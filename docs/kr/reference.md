# Workspace

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

**Workspace**를 이용해 엔티티, 스크립트, 이미지를 효율적으로 관리할 수 있습니다.

##### 참고 가이드

[Entity, Component, Property](/docs?postId=54) [Model](/docs?postId=55)

# Workspace 소개

**Workspace**는 폴더 형식의 리소스 관리 공간입니다. 필요한 것을 찾을 수 있는 **Workspace**는 효율적인 월드 제작을 위해 필요합니다. **Workspace** 패널의 기본 위치는 우측 중앙입니다. 크리에이터의 편의에 따라 원하는 위치로 바꿀 수 있습니다. **Workspace**는 메이커에서 제공하는 모델과 스크립트 등이 저장된 **BaseEnvironment**와 크리에이터가 만든 리소스를 보관하는 **MyDesk**로 구성되어 있습니다. 또한 작업의 편의를 위해 **DefaultPlayer**를 제공합니다.

> **Tip.** 메이커에서 **Workspace** 패널이 보이지 않을 때는 **Panels - Workspace**를 클릭하세요.

![Workspace](https://mod-file.dn.nexoncdn.co.kr/bbs/16970914230526448d81201d64b46ace8099e009114fc.png)

**Workspace**의 상위 폴더(엔트리)는 다음과 같습니다.

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) | DefaultPlayer | NativeModel에 있는 Player의 정보를 참조하고 있습니다. 실제 생성한 플레이어 아바타 엔티티는 World 안에 속합니다.<br>시작 시 스타트 포인트에 플레이어 아바타를 생성합니다. |
| ![workspace_NativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634598960433b8c2accd227347b29b0efb94f1320156.png) | BaseEnviroment | 메이커에서 제공하는 기본 Component, Service, Logic, Event가 저장되어 있습니다. |
| ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png) | MyDesk | **크리에이터가 추가한 리소스, BaseEnvironment에서 확장, 복제한 모델, 컴포넌트 등이 추가됩니다.**<br> WorldConfig에서 월드의 설정을 변경할 수 있습니다. <br> 새롭게 추가한 리소스는 MyDesk 폴더 하위에 저장됩니다. 필요할 때 폴더를 추가하여 효율적으로 리소스를 관리할 수 있습니다. |

# Workspace 검색

![Common_search01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634538429925640e864de1094ea8a4df3109e38dbb7d.png)검색 창에 검색어를 입력해 빠르게 원하는 리소스나 모델을 찾을 수 있습니다.

- 검색 기준은 이름입니다.
- 검색 범위는 **Workspace** 전체입니다.
- 검색어를 입력하면 조건에 맞는 결과만 나타납니다. ![workspace007](https://mod-file.dn.nexoncdn.co.kr/bbs/16607022459523d659807533b45bd80d145f3d879a9fe.png)

# WorldConfig

월드의 설정을 변경할 수 있습니다. WorldConfig의 설정은 추가될 수 있습니다. WorldConfig를 누르면, 프로퍼티 에디터 창에 변경할 수 있는 설정이 나타납니다. WorldConfig의 자세한 기능은 [WorldConfig](/docs?postId=1101) 가이드를 참고하세요.

- **LegacyAnimation**: 캐릭터에 이전 메이플스토리 월드 움직임과 애니메이션을 적용합니다.
- **PlayerEntityAuthorityCheck**: 플레이어 엔티티에 속한 Component들의 Server 함수들을 로컬 Client 이외의 Client에서 호출하지 못하도록 변경합니다. 이 설정을 활성화 함으로써 좀 더 높은 보안 수준을 제공합니다.
- **ServiceAuthorityCheck**: Native에서 동작하는 Service의 모든 Server 함수들을 ServerOnly 함수로 동작하도록 변경합니다. 이 설정을 활성화 함으로써 좀 더 높은 보안 수준을 제공합니다.
- **SourceLanguage**: 플레이어가 월드에서 자동 번역 기능을 사용한다면 SourceLanguage의 언어를 번역 대상으로 삼습니다. 현재 원문 언어로 설정할 수 있는 언어는 한국어, 영어입니다. 추후 언어가 추가될 수 있습니다.

# BaseEnvironment

메이커에서 기본 제공하는 기능을 모아 둔 폴더입니다. 총 2개의 폴더로 구성되어 있습니다.

- **NativeScripts**
- **NativeModel**

**BaseEnvironment**의 폴더 순서를 바꾸거나, 하위 목록을 옮길 수 없습니다. **NativeScripts**의 모든 계층은 복제/삭제할 수 없습니다. **NativeScripts**의 특성을 변경해 사용하려면 해당 스크립트를 확장(Extend)하여 사용해야 합니다. 또한 **NativeModel**은 복제하거나 확장해 활용할 수 있습니다.

**BaseEnvironment**의 주요 엔트리는 다음과 같습니다.

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | NativeScripts | Component, Service, Logic, Event, Misc가 하위 폴더로 저장되어 있습니다. <br>이 폴더에 속한 스크립트들은 삭제할 수 없습니다. <br>Component는 확장할 수 있으며 확장 컴포넌트는 MyDesk 폴더에 저장됩니다. |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | Component | 수정, 삭제할 수 없는 기본 컴포넌트가 저장된 폴더입니다. <br> Component는 확장해 사용할 수 있습니다. |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | Service | 수정, 삭제할 수 없는 기본 서비스가 저장된 폴더입니다. |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | Logic | 수정, 삭제할 수 없는 기본 로직이 저장된 폴더입니다. |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | Event | 수정, 삭제할 수 없는 기본 이벤트가 저장된 폴더입니다. |
| ![workspace_LockedNativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/163459994812299d7858eb2d142a9a57caaec1f0a09a7.png) | Misc | 기타 스크립트가 저장된 폴더입니다. |
| ![workspace_NativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634598960433b8c2accd227347b29b0efb94f1320156.png) | NativeModel | 메이커에서 제공하는 기본 모델들이 저장된 폴더입니다. 모델을 Scene으로 배치해 바로 사용합니다. <br>다른 폴더로 이동하거나, 모델을 만들 순 없으나, 필요에 따라 복제/확장 모델로 응용해 활용할 수 있습니다.<br>확장 모델은 MyDesk 폴더에 저장됩니다. |

# MyDesk

**MyDesk**는 크리에이터가 직접 추가한 음악, 스크립트, 이미지 파일과 확장 컴포넌트 등을 모아서 관리하는 곳입니다. **MyDesk**는 일종의 저장소이며, 어떤 것을 추가했을 때 동일한 계층으로 추가가 됩니다. 한 곳에 모아 관리하고 싶다면 **MyDesk** 내에 새 폴더를 생성해봅시다.

> **Tip.** **Workspace**는 저장소, **Hierarchy**는 작업 현황 개념입니다. **MyDesk**에 추가한 리소스를 월드에 배치하면, **Hierarchy**에 엔티티가 만들어집니다. **MyDesk**의 원본을 삭제했을 때 원본 정보를 참조하고 있는 엔티티에서 해당 정보는 지워지지만, 생성된 엔티티는 남습니다 만약 **MyDesk**에서 바로 배치했던 엔티티라면, 해당 엔티티(리소스)의 이름 옆에 **Missing**이 붙으며, 빨간색으로 변합니다. ![workspace002](https://mod-file.dn.nexoncdn.co.kr/bbs/16359122256435b2c3432bf4e40b69b2cfe2175942941.png)

**UIPopup**과 **UIToast**는 크리에이터가 자유롭게 수정하거나 삭제할 수 있는 로직입니다. 제작 배경에 따라 필요 없을 때 자유롭게 삭제할 수 있습니다. 필요에 따라 확장하거나, 복제할 수 있습니다.

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| ![workspace_logic](https://mod-file.dn.nexoncdn.co.kr/bbs/163459925288465e2645e5e334c0e96f20e740f8d8e5d.png) | UIPopup | 팝업 메시지 로직입니다. 필요에 따라 원 로직을 수정하거나 삭제할 수 있습니다. |
| ![workspace_logic](https://mod-file.dn.nexoncdn.co.kr/bbs/163459925288465e2645e5e334c0e96f20e740f8d8e5d.png) | UIToast | 토스트 메시지 로직입니다. 필요에 따라 원 로직을 수정하거나 삭제할 수 있습니다. |

#### MyDesk에 리소스 추가하기

1. 검색 창 왼쪽의 **[+]** 버튼을 클릭해 콘텍스트 메뉴를 엽니다.
2. 원하는 항목을 선택합니다.
3. **Workspace**의 **MyDesk** 하위에 새로운 항목이 추가됩니다.

> **Tip.** 크리에이터가 직접 추가하는 리소스는 모두 변경할 수 있기 때문에 모두 **MyDesk** 안에 생성됩니다.

![workspace05](https://mod-file.dn.nexoncdn.co.kr/bbs/16874792631302293c55974c04671a6aa795ca68ae9d2.png)

#### MyDesk 폴더 삭제

비어있는 폴더는 바로 삭제할 수 있습니다. 리소스가 들어있는 폴더를 삭제하면, 폴더 안의 모든 리소스가 함께 삭제됩니다. 실수를 방지하기 위해 리소스가 든 폴더를 삭제할 때는 **Delete**를 누른 뒤, 경고 창에서 **[예]** 버튼을 눌러 삭제합니다.

![workspace04](https://mod-file.dn.nexoncdn.co.kr/bbs/168264614543834918ce5a518478baf8537f9938d42e8.png)

# Workspace 콘텍스트 메뉴

콘텍스트 메뉴 목록은 다음과 같습니다.

#### DefaultPlayer 주요 콘텍스트 메뉴

| 목록 | 설명 |
| --- | --- |
| Duplicate | DefaultPlayer를 복제한 모델을 생성합니다. |
| Open | Player의 상태 혹은 변경 점을 확인하기 위해 사용합니다. |
| Add Component | DefaultPlayer에 컴포넌트를 추가합니다. |
| Add New Component | 새로운 컴포넌트를 생성한 후 DefaultPlayer에 추가합니다. |
| Extend | DefaultPlayer의 확장 모델을 생성합니다. |
| Copy Entry ID | DefaultPlayer의 ModelID를 복사합니다. |

#### BaseEnvironment 주요 콘텍스트 메뉴

잠겨 있는 폴더에서는 콘텍스트 메뉴가 열리지 않습니다.

| 목록 | 설명 |
| --- | --- |
| Duplicate | NativeModel을 복제합니다. |
| Open | 선택한 항목을 엽니다. |
| Add Component | NativeModel에 컴포넌트를 추가합니다. |
| Add New Component | NativeModel에 새로운 컴포넌트를 추가합니다. |
| Place to Hierarchy | 선택한 모델을 Scene에 배치합니다. |
| Extend | 선택한 모델의 확장 모델을 생성합니다. |
| Copy Entry ID | 선택한 모델의 ID를 복사합니다. |

#### MyDesk 콘텍스트 메뉴

| 목록 | 하위 목록 | 설명 |
| --- | --- | --- |
| Create Folder | - | 새로운 폴더를 생성합니다. |
| Create Scripts | Create Component | 새로운 스크립트 컴포넌트를 생성합니다. |
| Create EventType | 새로운 이벤트 타입을 생성합니다. |
| Create ItemType | 새로운 아이템 타입을 생성합니다. |
| Create BTNodeType | 새로운 BTNode타입을 생성합니다. |
| Create StateType | 새로운 StateType타입을 생성합니다. |
| Create StructType | 새로운 StructType타입을 생성합니다. |
| Create Logic | 새로운 로직을 생성합니다 |
| Create Script | 처음부터 스크립트를 입력할 수 있는 탑 레벨 스크립트를 생성합니다. |
| Create DataSet | - | 새로운 DataSet을 생성합니다. |
| Create TileDataSet | - | 새로운 TileDataSet을 생성합니다. |
| Create AtlasBlueprint | - | 새로운 AtlasBlueprint를 생성합니다. |
| Create Material | - | 새로운 머티리얼을 생성합니다. |
| Create Model | - | 비어있는 새로운 모델을 생성합니다. 직접 컴포넌트를 추가합니다. |
| Copy Entry ID | - | 선택한 엔트리의 ID를 복사합니다. |
| Import From | Import Scripts | PC에서 스크립트를 불러옵니다. |
| Import Image | PC에서 이미지 파일을 불러옵니다. |
| Import Sound | PC에서 사운드 파일을 불러옵니다. |
| Import Package | PC에서 패키지를 불러옵니다. |

Update 2025-11-20 PM 02:03


# WorldConfig

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드는 WorldConfig에서 다양한 월드 설정 기능을 제공합니다. WorldConfig의 기능은 제작 중인 월드에 전반적인 영향을 끼칩니다.

##### 참고 가이드

- [실행 제어](/docs/?postId=210)
- [Effective MSW 2](/docs/?postId=560)
- [패킷 변조 대비하기](/docs?postId=1102)
- [예시로 알아보는 서버 검증](/docs?postId=1084)

# WorldConfig 소개

WorldConfig는 크리에이터가 제작하는 월드의 다양한 설정을 변경할 수 있습니다.

- **Edit - WorldConfig**를 누릅니다.
- **Workspace - WorldConfig**를 누르면 세부 설정 항목이 **프로퍼티 에디터 창**에 나타납니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17114447139367ac91d0b1e984ea3bba1d2ee1e30882e.png)

# LegacyAnimation

메이플스토리 월드의 아바타 움직임과 애니메이션은 2023년 3월 23일에 원작 메이플스토리과 유사하게 동작하도록 변경되었습니다. 만약 크리에이터의 월드가 변경일 이전에 제작되었다면, LegacyAnimation을 활성화해 이전의 메이플스토리 월드의 아바타 움직임과 애니메이션을 적용합니다. 다만, 현재의 아바타 움직임이 원작과 유사하므로 변경일 이후에 제작된 월드라면 LegacyAnimation 적용을 권장하지 않습니다. 이전 움직임과 현재의 움직임은 아래와 같습니다.

| true | false |
| --- | --- |
| ![legacy](https://mod-file.dn.nexoncdn.co.kr/bbs/16957010690636f2b8b04e7494501a3765817083d211d.gif) | ![animation](https://mod-file.dn.nexoncdn.co.kr/bbs/1695701089240b13b2ad54232422582e9fd9f8b9c8e04.gif) |

# PlayerEntityAuthorityCheck

플레이어 엔티티에 속한 컴포넌트의 서버 함수를 **로컬 클라이언트**에만 호출하도록 합니다. 이 설정을 활성화하면 월드의 보안을 강화할 수 있습니다. 예를 들어 DefaultPlayer에 속한 컴포넌트 중 실행 공간이 server인 `MoveToMapPosition()` 함수는 로컬 클라이언트 외 다른 클라이언트에서 호출할 수 없습니다. 함수를 실행 시 콘솔창에 에러 메시지가 나타납니다.

```
Method:
[client only]
void NewFunction()
{
    local targetEntity = nil
    for key, value in pairs(_UserService.UserEntities) do
    	if key ~= _UserService.LocalPlayer.Name then
    		targetEntity = value
    		break
    	end
    end
    
    if targetEntity ~= nil then
    	targetEntity.PlayerComponent:MoveToMapPosition("map01", Vector2(0, 3))
    end
}
```

![PlayerEntity](https://mod-file.dn.nexoncdn.co.kr/bbs/169571933009917b0b6c1d9994fe9a9e71fa7ff2dacbd.png)

# ServiceAuthorityCheck

Service의 모든 서버 함수를 **ServerOnly 함수**로 동작하도록 변경합니다. 이 설정을 활성화해 월드의 보안을 강화할 수 있습니다. 예를 들어 아래와 같이 client only 함수에서 실행 공간이 server인 함수를 실행하면 실행 시 콘솔창에 에러 메시지가 나타납니다.

```
Method:
[client only]
void OnMapEnter(Entity enteredMap)
{
    _TeleportService:TeleportToMapPosition(me, currentPosition + Vector3(0, 2, 0), currentMapName)
}
```

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/169570858853819399808907c4a219ad5a93aa6dcab19.png)

# RestrictedPlayerEntitySync

플레이어 엔티티에 속한 네이티브 컴포넌트의 **Sync** 프로퍼티가 클라이언트에서 변경된 값을 서버로 동기화하지 않도록 설정합니다. 이 설정을 활성화하면 월드의 보안을 강화할 수 있습니다. 예를 들어 클라이언트에서 `ChatBalloonComponent.Message`에 메시지를 입력하면 서버로 동기화하지 않기 때문에 다른 플레이어들의 화면에서는 말풍선이 나타나지 않습니다.

```
[client only]
void ShowChatBalloon()
{
    local chatBalloon = self.Entity.ChatBalloonComponent
    chatBalloon.ChatModeEnabled = false
    chatBalloon.AutoShowEnabled = true
    chatBalloon.Message = "메이플스토리 월드"
}
```

예외적으로 다음 컴포넌트들은 RestrictedPlayerEntitySync에 영향을 받지 않습니다. 플레이어 엔티티에 속해 있으면 항상 클라이언트에서 서버로 동기화가 이루어지므로 주의해야 합니다.

- MovementComponent
- PlayerControllerComponent
- StateComponent
- TransformComponent

# SourceLanguage

플레이어가 월드에서 [자동 번역](/docs/?postId=1072) 기능을 사용한다면 SourceLanguage의 언어를 번역 대상으로 삼습니다. 현재 원문 언어로 설정할 수 있는 언어는 한국어, 영어입니다. 추후 언어가 추가될 수 있습니다.

# LocalWorkspace

월드 데이터를 크리에이터의 컴퓨터(Local)로 내려받을 수 있는 기능입니다. 월드의 다양한 엔트리와 데이터를 크리에이터의 컴퓨터에 파일 형태로 저장합니다. 자세한 내용은 [LocalWorkspace](/docs/?postId=1165) 가이드를 참고하세요.

Update 2025-11-17 PM 06:29


# Hierarchy

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

**Hierarchy** 탭을 이용해 제작 현황을 확인하고, 제작 능률을 높일 수 있습니다.

# Hierarchy 소개

**Hierarchy** 탭은 제작 중인 게임 현황을 **계층 구조(부모-자식)**로 볼 수 있는 패널입니다. 복잡하게 구성한 맵에서 원하는 엔티티를 빠르게 찾을 때 사용하거나, 체계적으로 엔티티를 관리할 때 사용합니다. 가장 상위인 **World** 계층 아래에 **common**, **maps**, **ui** 엔트리가 있으며 **maps**와 **ui** 엔트리는 각자 기본 하위 엔트리를 가지고 있습니다.

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| ![workspace_world](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520188174b448bb50e5c64320bb3c882a5b438d6d.png) | World | 실제로 제작에 사용한 엔티티들이 모여있으며 가장 상위 계층입니다.<br>common, maps, ui가 기본 하위 엔트리로 속해 있습니다.<br> 제작 중인 게임의 구성 방식을 확인하고 수정할 수 있습니다. |
| ![icon_asset](https://mod-file.dn.nexoncdn.co.kr/bbs/163451962580666b43144ad504f8e9e4a7cc01771207a.png) | common | 게임 전체에 적용되는 룰을 만들 수 있습니다.<br>컴포넌트를 추가해 사용합니다. |
| ![workspace_maps](https://mod-file.dn.nexoncdn.co.kr/bbs/16345995071559181085e7c2544278d4418375d12ca2e.png) | maps | 맵에 배치한 엔티티들은 맵 엔트리 하위에 위치합니다.<br>map01은 기본 하위 엔트리로 속해있습니다. |
| ![workspace_ui](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520137460bf156bbec2ef452c9a5a31d9cbec5a61.png) | ui | UI 편집기에서 추가하는 엔티티들이 하위에 위치합니다.<br>DefaultGroup, PopupGroup, ToastGroup이 기본 하위 엔트리로 속해있습니다. |

# 계층 구조

계층 구조에서는 가장 위의 목록(엔트리)이 부모가 되고, 하위 목록은 자식이 됩니다. **부모-자식** 구조는 '부모'가 큰 범위이며, 부모에 속한 것들이 '자식'으로 분류됩니다. 계층 분류는 여러 엔티티가 동일한 속성을 가지고 있을 때 사용하거나, 여러 엔티티를 묶어 하나의 그룹으로 관리하고 싶을 때 사용합니다. 특히 많은 양의 엔티티를 사용할 때 일정한 기준으로 분류한다면 엔티티를 체계적으로 관리할 수 있습니다. 부모-자식 구조는 **드래그 앤 드롭**을 사용해 만들 수 있습니다. 하나의 엔티티 아래에 자식으로 만들고 싶은 엔티티를 끌어 놓으면 자식으로 편입됩니다. 자식 엔티티들은 부모 엔티티의 영향을 받습니다. 예를 들어, 부모 엔티티의 **TransformComponent**를 변경하면 자식 엔티티는 자동으로 변경됩니다.

> **Tip.** 단방향으로 영향을 끼칩니다. (부모 → 자식)

드래그 앤 드롭을 사용해 하나의 부모-자식 구조를 만든 뒤, 그 안에 또 다른 부모-자식 구조를 만들 수 있습니다. 동일한 계층으로 있던, 같은 모양의 오브젝트를 부모-자식 구조로 만드는 예시를 살펴보겠습니다. Box1의 자식으로 만든 Box2 아래에 Box3을 자식으로 만들어 이중 계층 구조(부모-자식)를 만들었습니다.

![scenemaker03](https://mod-file.dn.nexoncdn.co.kr/bbs/16595015512015162cbdf29594207ad7fb9c0f51c75b2.gif)

구조의 특성을 이용해 엔티티를 한 번에 이동하거나, 상위 부모에 안에 속해 있는 부모 만을 골라 형태를 변경할 수 있습니다. 아래의 예시에서는 3가지 동작을 보여주고 있습니다.

- 예시에서는 Box1을 선택해 나머지 오브젝트까지 한꺼번에 움직인다.
- Box2를 선택해 Box3까지 함께 오브젝트를 돌리고, 확대한다.
- Box4만 선택해 따로 움직인다.

위 3가지 동작 모두 계층 구조의 특징을 활용한 것입니다. 부모를 선택했을 때는 자식이 영향을 받기 때문에 이중 구조 안에 있는 자식까지 모두 영향을 받지만, 자식은 부모 계층에 영향을 끼칠 수 없기 때문에 자식을 선택하면 자식만 상태를 변경할 수 있게 됩니다.

![box1](https://mod-file.dn.nexoncdn.co.kr/bbs/1661498040265eebb1ccae6574916b97afdfe7fb3a202.gif)

이런 구조는 여러 개의 엔티티를 이용해 특정 UI나, 구조물을 만들 때 유용하게 사용할 수 있습니다. 예를 들어, 확인 메시지 창을 만든다고 했을 때 전체 배경을 부모로 만들고, 버튼 배경과 텍스트를 부모-자식 구조로 만든다면, 하나의 버튼을 옮기거나 바꾸고 싶을 때 다른 메시지 창 엔티티들은 영향을 받지 않습니다.

# Hierarchy 검색 기능

검색 창은 탭 타이틀 바로 아래에 위치합니다. 검색 기준에 따라 다른 결괏값이 나오기에 필요에 따라 선택해 검색합니다.검색 기준은 **Name**과 **Component** 두 가지이며, 다음과 같이 사용합니다.

- **Name** : **Workspace**의 전 영역에서 검색한 이름과 맞는 값을 찾을 때 사용합니다.
- **Component** : 엔티티 중 검색어에 해당하는 컴포넌트가 포함된 값을 찾을 때 사용합니다.

| Name "chat" 검색 | Component "chat" 검색 |
| --- | --- |
| ![hierachy01](https://mod-file.dn.nexoncdn.co.kr/bbs/166149753085952e43e90e24240fabe1c43f54d182c4a.png) | ![hierachy02](https://mod-file.dn.nexoncdn.co.kr/bbs/16614975572003bbd30ba3f0c45c19ec477a6e1e22b77.png) |

# 엔트리 별 콘텍스트 메뉴

**Hierarchy**의 상위 엔트리 별 콘텍스트 메뉴는 다음과 같습니다. 하위 엔티티는 특성에 따라 다른 목록이 추가로 활성화됩니다.

| 엔트리 이름 | 메뉴 목록 | 설명 |
| --- | --- | --- |
| World | Create Entity | 새로운 엔티티를 생성합니다. |
| Create Entity as Child | 하위에 새로운 엔티티를 생성합니다. |
| Property | World의 프로퍼티 에디터 창을 엽니다. |
| Go To Entity | 선택한 엔티티로 이동합니다. |
| Copy Entity ID | 엔티티 아이디를 복사합니다. |
| common | Create Entity | 새로운 엔티티를 생성합니다. |
| Create Entity as Child | 하위에 새로운 엔티티를 생성합니다. |
| Property | common의 프로퍼티 에디터 창을 엽니다. |
| Go To Entity | 선택한 엔티티로 이동합니다. |
| Add Component | common에 컴포넌트를 추가합니다. |
| Add New Component | common에 새로운 컴포넌트를 추가합니다 |
| Copy Entity Path | 엔티티 경로를 복사합니다. |
| Copy Entity ID | 엔티티 아이디를 복사합니다. |
| maps | Create New Map | 새로운 맵을 생성합니다. |
| Create Entity | 새로운 엔티티를 생성합니다. |
| Create Entity as Child | 하위에 새로운 엔티티를 생성합니다. |
| Property | maps의 프로퍼티 에디터 창을 엽니다. |
| Go To Entity | 선택한 엔티티로 이동합니다. |
| Copy Entity Path | 엔티티 경로를 복사합니다. |
| Copy Entity ID | 엔티티 아이디를 복사합니다. |
| map01 | Create New Map | 새로운 맵을 생성합니다. |
| Create Entity | 새로운 엔티티를 생성합니다. |
| Create Entity as Child | 하위에 새로운 엔티티를 생성합니다. |
| Switch To RectTileMap | RectTileMape으로 전환합니다. |
| Switch To SideViewRectTileMap | SideViewRectTileMap으로 전환합니다. |
| Duplicate | 맵을 복사합니다. |
| Rename | map01의 이름을 변경할 수 있습니다. |
| Property | map01의 프로퍼티 에디터 창을 엽니다. |
| Go To Entity | 선택한 엔티티로 이동합니다. |
| Add Component | map01에 컴포넌트를 추가합니다. |
| Add New Component | map01에 새로운 컴포넌트를 추가합니다. |
| Copy Entity Path | 엔티티 경로를 복사합니다. |
| Copy Entity ID | 엔티티 아이디를 복사합니다. |
| ui | Create Entity | 새로운 엔티티를 생성합니다. |
| Create Entity as Child | 하위에 새로운 엔티티를 생성합니다. |
| Property | ui의 프로퍼티 에디터 창을 엽니다. |
| Go To Entity | 선택한 엔티티로 이동합니다. |
| Copy Entity Path | 엔티티 경로를 복사합니다. |
| Copy Entity ID | 엔티티 아이디를 복사합니다. |

Update 2025-11-17 PM 08:14


# Scene

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

Scene은 월드와 UI 제작 및 테스트에 사용하는 필수 창입니다. Scene을 구성하는 다양한 기능을 살펴봅시다.

##### 참고 가이드

- [Workspace](/docs/?postId=121)
- [Hierarchy](/docs/?postId=453)
- [프로퍼티 에디터](/docs/?postId=1087)
- [UI 에디터 활용과 제어](/docs/?postId=120)

# Scene

Scene은 UI 화면, 맵, 테스트 중인 월드의 상태를 모두 볼 수 있는 창입니다. 크리에이터의 선택에 맞는 모습으로 UI 에디터, 테스트 화면으로 전환됩니다.

- 맵은 **Hierarchy**에서 선택한 맵이 보여집니다.
- **[UI]** 버튼을 눌러 UI 편집 창으로 진입하면, Scene 창이 에디터로 전환됩니다.
- **[시작]** 버튼을 눌러 제작한 월드를 테스트하면 Scene 화면이 월드 테스트 편집 화면으로 변경됩니다. 테스트를 종료 시 제작 중인 Scene 화면으로 다시 전환됩니다. 월드 테스트 중 편집한 엔티티 정보는 테스트 중에만 유효합니다.

#### Scene의 기능

Scene의 상태에 따라 다양한 기능을 사용할 수 있습니다. 상단 메뉴에 아이콘이 노출됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1737097069972da535f8e4e944afdb42c571b35b73088.png)

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| - | Scale | Scene을 확대, 축소할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_reset.png) | 초기화 | 조정한 확대/축소 값을 기본 값으로 되돌립니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_grid.png) | 그리드 정보 | 그리드 신 위에 격자선을 보여줍니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_foothold.png) | 발판 정보 | FootholdComponent가 있는 엔티티의 발판을 보여줍니다. 발판은 빨간선으로 표시됩니다. |
| ![StartingMap](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_starting_map.png) | 시작 맵에서 플레이 | 제작한 월드 테스트 시 시작 맵에서 테스트를 시작합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_plus.png) | 커서 위치 | Scene에서의 커서 위치를 나타냅니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_scene_maximize.png) | Scene 최대화 | Scene을 전체 화면으로 전환합니다. [축소] 버튼을 누르면 이전 크기로 돌아갑니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_ui_snap.png) | UI Snap | UI 정렬에 도움을 주는 기능입니다. UI의 외곽선끼리 겹치지 않고 정렬되도록 합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_play_here.png) | Play Here | 테스트를 시작할 위치를 크리에이터가 지정할 수 있습니다. |

#### 테스트 시 Scene의 기능

테스트 시 Scene에서 사용할 수 있는 기능이 변경됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/173745185491329d2287c7cbd4506bdbbc1c9144c56db.png)

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| - | Scale | Scene을 확대, 축소할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_reset.png) | 초기화 | 조정한 확대/축소 값을 기본 값으로 되돌립니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_plus.png) | 커서 위치 | Scene에서의 커서 위치를 나타냅니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_scene_maximize.png) | Scene 최대화 | Scene을 전체 화면으로 전환합니다. [축소] 버튼을 누르면 이전 크기로 돌아갑니다. |

Update 2025-11-17 PM 08:14


# Play

# 학습 과정 소개

제작한 월드를 테스트할 수 있는 Play 창에 대해 알아봅시다.

#### 참고 가이드

- [Scene](/docs/?postId=1152)
- [Workspace](/docs/?postId=121)
- [Hierarchy](/docs/?postId=453)
- [프로퍼티 에디터](/docs/?postId=1087)
- [UI 에디터 활용과 제어](/docs/?postId=120)

# Play

Play 창은 만든 월드를 테스트할 때 사용합니다. **[시작]** 버튼을 눌러 플레이 테스트를 실행했을 때만 활성화됩니다. 월드를 편집하는 Scene 창과 별개의 카메라로 동작하므로 테스트 시에 화면 이동이 동기화되지 않습니다. 하지만 Scene에서 클라이언트 부분을 변경하면, Play 창에도 반영됩니다. 테스트 플레이 전 테스트 화면비를 설정할 수 있으며, 테스트 중 가상의 클라이언트를 추가해 멀티 테스트를 진행할 수 있습니다.

#### Play의 기능

Play의 상태에 맞는 다양한 기능을 사용할 수 있습니다. 상단에 아이콘이 노출됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17370970458165d802f305fde434d9020a4eac96ab265.png)

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| - | 시뮬레이터 | 테스트 화면비를 설정할 수 있습니다. 기본값은 PC입니다.<ul><li>PC: FHD 해상도(1920x1080)를 기준으로 동작합니다. 화면 비율은 16:9로 고정되어 있습니다.</li><li>Mobile: 다양한 모바일 기기의 화면비로 Scene과 Play의 크기를 조정합니다. 테스트 시에도 화면비가 유지됩니다. Safe Area를 활성화할 수 있습니다.</li><li>Free: 자유롭게 시뮬레이터의 화면비를 설정할 수 있습니다. Play의 창 크기를 기준으로 화면비가 결정됩니다.</li></ul> |
| - | 테스트 플레이 언어 | 테스트할 언어를 지정할 수 있습니다. 테스트 중에는 언어 변경은 불가능합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_latency_01.png) | 성능 통계 | 플레이 중인 월드의 FPS, 메모리 정보를 실시간으로 보여줍니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_scene_maximize.png) | 창 최대화 | Play 창을 전체 화면으로 전환합니다. **[축소]** 버튼을 누르면 이전 크기로 돌아갑니다. |

#### 테스트 시의 Play

테스트 시 Play 창에서 사용할 수 있는 기능이 변경됩니다. ![play01](https://mod-file.dn.nexoncdn.co.kr/bbs/1737452078994c0fb1a6973394aa4b20d64ba20768447.png)

| 아이콘 | 이름 | 설명 |
| --- | --- | --- |
| - | 시뮬레이터 | 테스트 중인 화면비 정보를 나타냅니다. |
| - | 테스트 플레이 언어 | 테스트 중인 언어 설정을 나타냅니다. 테스트 중에는 언어 변경은 불가능합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_latency_01.png) | 성능 통계 | 플레이 중인 월드의 FPS, 메모리 정보를 실시간으로 보여줍니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_scene_maximize.png) | 창 최대화 | Play 창을 전체 화면으로 전환합니다. [축소] 버튼을 누르면 이전 크기로 돌아갑니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_multiplayer.png) | 가상의 플레이어 추가 | 테스트 시 활성화되며, 가상의 클라이언트를 여러개 띄울 수 있습니다. |
| - | 가상의 플레이어 수 | 추가할 가상 플레이어 수를 설정해 여러 개의 클라이언트를 한꺼번에 열 수 있습니다. 최대 10개의 가상의 클라이어트를 열 수 있습니다. 테스트를 종료하면 모두 사라집니다. |

Update 2025-11-17 PM 08:14


# 배경 설정하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

**Preset List**와 **BackgroundComponent**를 활용하여 맵의 배경을 설정해봅시다.

# 템플릿 배경 설정

**Preset List - Background**에서 메이플스토리의 다양한 배경을 선택할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1660872151969aea4b5e0f90c4c2ab1c556a2ea900127.png)

이와 같이 배경 템플릿을 선택하면 배경이 움직이는 속도, 즉 **ScrollRate**를 조절할 수 있습니다. ![1a](https://mod-file.dn.nexoncdn.co.kr/bbs/1676524214491fd465cd70f484b7baa55a9c7cceb1a78.png)

**ScrollRate** 값이 커지면 배경이 움직이는 속도가 빨라지며, 음수를 입력하면 반대 방향으로 이동합니다.

| ScrollRate | Image |
| :---: | :---: |
| 1 | ![s1](https://mod-file.dn.nexoncdn.co.kr/bbs/1676524614371f682d76a305e4987aa04507430a3f891.gif) |
| 10 | ![s2](https://mod-file.dn.nexoncdn.co.kr/bbs/1676524628557d5e56dce60f74ab59a962793a594b408.gif) |
| -10 | ![s3](https://mod-file.dn.nexoncdn.co.kr/bbs/16765246400798c2f36ddf63a47bc92883f9d493b22d6.gif) |

# 단색 배경 설정

**Preset List - Solid Background**에서 단색 배경을 설정할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1660872533050bd027ce1934b47669a0f3d3f82994180.png)

프리셋으로 제공되는 것 외의 다른 색상을 설정하고 싶다면 **[+]** 버튼을 눌러 컬러 팔레트를 연 뒤 원하는 색상을 설정할 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1660872694830338c5a59114a46aa9d41eeecbfae1203.png)

# 그라데이션 배경 설정

**Hierarchy - 현재 맵 - Background** 선택 후 프로퍼티 에디터의 **BackgroundComponent**에서 **Type**을 **Gradient**로 변경하면 그라데이션 배경을 설정할 수 있습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1675686701848d25aebc9b2b645519a894cb17489b07a.png) 그라데이션의 최상단, 중상단, 중하단, 최하단 색상을 컬러 팔레트에서 선택합니다. 또한 **MiddleTopRatio, MiddleBottomRatio** 프로퍼티로 중상단, 중하단 색상의 위치를 설정합니다. 이처럼 **Gradient** 타입을 활용하면 손쉽게 크리에이터가 원하는 형태의 그라데이션 배경을 만들 수 있습니다.

# 이미지 배경 설정

## 저장된 이미지로 배경 설정

**Preset List - Image Background**에서 크리에이터가 저장하고 있던 이미지를 배경으로 설정할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1660874114096e52157d7c9fa444c8c5b1c3173ee0d7d.png)

## 웹 이미지로 배경 설정

웹상의 이미지를 배경으로 설정할 수 있습니다.

1. 배경으로 설정하려는 이미지 링크를 복사합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1662419003792c23005e9e1de42d4972dd217aacb1bae.png)
2. BackgroundComponent의 Type을 Web으로 설정한 뒤, WebURL에 복사한 주소를 붙여 넣습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1662419129189d4b5d5fb2028458baa10f740ecfbac45.png)
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해 봅시다. 아래와 같이 웹상의 이미지가 배경으로 설정된 것을 확인할 수 있습니다. ![bg](https://mod-file.dn.nexoncdn.co.kr/bbs/166241921017719b68e8cb4674133892283180eb6a3e2.gif)

Update 2025-11-17 PM 08:14


# 프로퍼티 에디터

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

프로퍼티 에디터 창을 이용해 컴포넌트의 프로퍼티를 확인하고, 수정할 수 있습니다.

#### 참고 가이드

- [Entity, Component, Property](/docs/?postId=54)
- [Workspace](/docs/?postId=121)
- [Hierarchy](/docs/?postId=453)
- [모델의 활용](/docs?/postId=461)
- [컴포넌트 추가와 삭제](/docs/?postId=58)

# 프로퍼티 에디터 소개

Property 패널은 엔티티, 모델에 포함된 컴포넌트의 프로퍼티를 확인, 변경할 수 있는 에디터입니다. MSW에서 제공하는 컴포넌트 중 Attribute가 HideFromInspector인 프로퍼티는 에디터에 나타나지 않고, 스크립트에서만 접근이 가능합니다. 크리에이터가 생성한 프로퍼티를 에디터에서 숨기고 싶다면 Attribute Setting의 '표시 안 함' 옵션을 선택합니다. 프로퍼티 에디터 창에서 모델, 엔티티에 컴포넌트를 추가, 삭제, 비활성화할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1722919835240d375b04a5ca8460aa0b70afe977333b8.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 컴포넌트 추가 | 검색창 옆의 **+** 버튼을 눌러 컴포넌트를 추가할 수 있습니다. [컴포넌트 추가와 삭제](docs/?postId=58)를 참고하세요. 또한 프로퍼티 에디터 하단의 Add Component 버튼을 눌러 추가할 수 있습니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 검색창 | 검색 창은 탭 타이틀 바로 아래에 위치합니다. 검색 기준에 따라 다른 결괏값이 나오기에 필요에 따라 선택해 검색합니다. 검색 기준은 **Component**와 **Property** 두 가지이며, 다음과 같이 사용합니다.<ul><li>Component: 검색어에 해당하는 컴포넌트를 찾을 때 사용합니다.</li><li>Property: 검색어에 해당하는 프로퍼티가 포함된 컴포넌트를 찾을 때 사용합니다.</li></ul> |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 모델 프로퍼티 | 각 엔티티, 모델에 포함된 컴포넌트의 일부 프로퍼티를 즐겨찾기처럼 모아놓은 것입니다. 크리에이터가 생성한 엔티티, 모델의 경우 이름 영역을 눌러 이름을 변경할 수 있습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | Model Extension Info | 참조하고 있는 모델 정보 혹은 모델을 확장한 모델의 계층 정보를 확인할 수 있습니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 컴포넌트의 프로퍼티 | 컴포넌트의 프로퍼티 정보를 보여줍니다. 컴포넌트가 추가된 순서대로 정렬됩니다. |
| ![[6]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 햄버거 메뉴 | 엔티티에 포함된 컴포넌트 목록 전체를 접거나 펼칩니다. |

# 프로퍼티 에디터 기능

#### 체크박스 활성, 비활성

컴포넌트 이름 왼쪽에 위치한 체크박스를 눌러 컴포넌트 자체를 활성/비활성화할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1692601186919c8ee674ef7054b5b88e3325a085e3853.png)

#### Edit 버튼

충돌 영역을 설정할 때는 Edit 버튼을 누르면 Scene에서 충돌 영역을 수정할 수 있습니다. [엔티티의 충돌](docs/?postId=175) 가이드를 참고하세요.

#### 증감 커서

Vector, Number, integer 타입의 값을 변경할 때 마우스를 사용해 값을 변경할 수 있습니다. 커서가 값 근처로 다가가면 ![cursor](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Cursor/cursor_scale_02.png) 모양으로 변하고, 값을 변경할 수 있습니다. ![PlusMinus](https://mod-file.dn.nexoncdn.co.kr/bbs/16956247765542533d53ec25841009cb68f6d39ab1b8f.gif)

#### 수식 입력

프로퍼티 에디터에서 Vector, number 타입의 값을 입력하는 항목은 수식을 사용할 수 있습니다.

- `+`,`-`,`/`,`*` 연산이 가능합니다.
- 연산 실패 시 이전 값이 적용됩니다.
- 정수형만 가능한 타입의 경우 결괏값의 소수점은 버려집니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1692583022446085bd548f1af4126b5e9e64653081457.gif)

#### 복수의 엔티티 선택

여러 개의 엔티티를 동시에 선택하면, 공통으로 가지고 있는 컴포넌트의 프로퍼티들만 걸러 보여집니다. 특정 값을 변경할 때, 그 값이 선택한 모든 엔티티에게 적용됩니다. 이때 선택한 엔티티들의 리스트 개수가 같으면 공통 편집이 가능합니다. 예를 들어 CustomFootholdComponent의 edgeLists와 같은 list 타입의 값은 Size의 개수가 같다면 동일한 값으로 값을 변경할 수 있습니다.

![4](https://mod-file.dn.nexoncdn.co.kr/bbs/169260611101535f49fc4f0084a35a65869a08f4548ab.gif)

Update 2025-11-20 PM 03:53


# 모델 에디터

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

모델의 특성을 활용하면 월드를 보다 효율적으로 제작할 수 있습니다. 모델을 편집할 수 있는 모델 에디터에 대해 알아봅시다.

# 모델 에디터 소개

모델 에디터를 활용해 모델을 더욱 효율적으로 생성하고, 편집할 수 있습니다. 모델 에디터로 진입하면 맵이나 UIGroup에서 편집하던 내용과는 독립된 공간에서 모델만을 자유롭게 편집할 수 있습니다. 모델 에디터를 사용하는 동안 맵 편집과 테스트 플레이는 불가능해집니다.

#### 모델 에디터 진입하기

모델 에디터로 진입하게 되면 Scene 패널이 변경되고, Hierarchy 창은 편집 중인 모델의 계층 구조를 나타내는 용도로 변경됩니다.  모델 에디터로 진입하는 방법은 두 가지입니다.

1. **Workspace에서 진입**
  1. **Workspace**에서 새로운 모델을 만듭니다.
  2. 더블 클릭해 모델 에디터를 엽니다.
2. **Hierarchy에서 진입**
  1. **Hierarchy**에서 엔티티를 생성하고, 콘텍스트 메뉴를 열어 **Create Model From Entity**을 선택해 엔티티를 모델화합니다..
  2. 생성한 모델을 선택하고 **콘텍스트 메뉴 - Edit Model**을 선택합니다.

#### 화면 소개

모델 에디터를 활성화하면 Scene 패널이 모델 편집 화면으로 변경되며, 주요 버튼의 기능이 변경됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/175211224021236c5261d9da34c7d8f44febbb48c0e14.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | Scene | 제작 중인 모델을 저장하고, Scene으로 돌아갑니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | NewModel | 편집 중인 모델의 이름입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | Discard | 저장하기 전의 모든 편집 내용을 버립니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | Save | 편집한 모델을 저장합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | UI 버튼 | UI 모델을 만들 때 사용할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | Property 창 | 편집 중인 모델에 컴포넌트를 추가/삭제 하고, 프로퍼티 값을 변경할 수 있습니다. 확장한 모델인 경우 모델의 확장 정보를 확인할 수 있습니다.<br><ul><li>**Model Extension Info**: 모델의 확장 구조를 한 눈에 확인할 수 있습니다. 작업 중인 모델 외의 다른 계층의 모델을 편집해야 할 경우 **콘텍스트 메뉴 - Find Model**을 선택해 진입할 수 있습니다.</li></ul> |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | Hierarchy 창 | 모델의 계층 구조를 확인할 수 있는 창입니다. 새로운 자식 엔티티를 추가하거나, 계층 구조를 변경할 수 있습니다. |

# 모델 편집하기

모델 에디터에서 편집할 수 있는 모델은 세 가지입니다.

1. 크리에이터가 직접 생성한 모델
2. native 모델을 확장한 모델
3. DefaultPlayer

#### 컴포넌트 추가/삭제

프로퍼티 창에서 모델에 새로운 컴포넌트를 추가하거나, 삭제할 수 있습니다.

#### 자식 엔티티 추가/ 계층 구조 변경 가능

모델 에디터에서도 계층 구조를 가진 모델을 만들 수 있습니다. **Hierarchy** 창에서 부모-자식 관계를 드래그해 설정할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17521081010150fea6ccf5f314ccea8df8b2181341c3e.png)

> **더 알아보기** 편집 중인 씬에서도 계층 구조를 변경하고, Create Model From Entity를 활용해 계층 구조를 가진 모델을 생성할 수 있습니다. Hierarchy에서 확인하세요.

#### 편집 시 유의사항

Scene에 배치한 모델은 개별 엔티티로 취급됩니다. 배치된 엔티티는 모델에 종속되어 있지 않으므로 이점을 유의해야 합니다. 그러므로 맵에 배치한 엔티티는, 원모델을 편집해 내용이 변경되었더라도 영향을 받지 않습니다. 만약, 배치된 모델 기반 엔티티에도 수정된 모델을 적용하고 싶은 경우 해당 엔티티를 **Revert** 해 동일하게 적용할 수 있습니다.

만든 모델을 배치한 후 해당 모델을 수정하는 경우, 배치된 모델 기반 엔티티에는 추가한 새로운 엔티티, 변경된 계층 구조가 반영되지 않습니다. 모델 에디터에서 추가/삭제한 컴포넌트와 프로퍼티 값만 변경됩니다.

> **Tip.** Scene에 배치한 모델의 컴포넌트를 삭제하거나, 계층 구조를 변경하는 것은 모델 에디터에서만 가능합니다.

Update 2025-11-17 PM 08:14


# 컴포넌트 추가와 삭제

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

엔티티에 정체성을 불어넣는 방법은 컴포넌트를 이용하는 것입니다. 컴포넌트와 프로퍼티 에디터 창 이용 방법을 알아보겠습니다.

# 컴포넌트 구분

컴포넌트는 엔티티의 정체성을 결정하는 역할을 합니다. 컴포넌트는 크리에이터가 제작한 모델에서 몇 가지 컴포넌트를 추가하거나, 삭제해 겉모습은 같지만 다르게 동작하는 엔티티를 제작할 수 있습니다.

프로퍼티 에디터 창에서 컴포넌트는 **Map, UI, Player, Etc** 4가지 항목으로 분류하고 있습니다.각 항목에 맞는 컴포넌트가 들어 있으며, 컴포넌트의 특징은 아이콘으로 구분할 수 있습니다. 컴포넌트 각각의 설명은 [API Reference](/apiReference?postId=317)를 참고하세요.

| 아이콘 | 컴포넌트 |
| --- | --- |
| ![avatar](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357080473d55d20344b90435a823e542b11829a0e.png) | 아바타 관련 컴포넌트 |
| ![ui](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357498603c3f1666fb49d43f2a8a35ab4921b118b.png) | UI 관련 컴포넌트 |
| ![AI](https://mod-file.dn.nexoncdn.co.kr/bbs/16363570539712866386877bf4ee885533554c4398352.png) | AI 관련 컴포넌트 |
| ![etc](https://mod-file.dn.nexoncdn.co.kr/bbs/163635714752051801c9ae8b24113a2a0cbe18dd96bb6.png) | 기타 컴포넌트<br>크리에이터 제작 컴포넌트 |
| ![camera](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357093244b60a272cb7fb490eb5770df741becff3.png) | 카메라 관련 컴포넌트 |
| ![player](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357430620486e701f5b2d4d1599e7c72705e23f50.png) | 플레이어 관련 컴포넌트 |
| ![sprite](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357473313e6e6178c7e9f4a10a65949eb0b391541.png) | 스프라이트 관련 컴포넌트 |
| ![move](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357387379505d66dc8dbf4770a32b9817b213ea39.png) | 이동 관련 컴포넌트 |
| ![map](https://mod-file.dn.nexoncdn.co.kr/bbs/16363573741458fe0e51a246b4ae5898d1c2fefe92710.png) | 맵에 영향을 끼치는 관련 컴포넌트 |
| ![sound](https://mod-file.dn.nexoncdn.co.kr/bbs/16363574605286d5c7249c6344b829d3efe1b34d9eb51.png) | 소리 관련 컴포넌트 |
| ![item](https://mod-file.dn.nexoncdn.co.kr/bbs/16363571792923152ba595bf340ed9f87583aeb7d3868.png) | 아이템 관련 컴포넌트 |
| ![control](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357117698b48ce0db38bc432e97e40269c8545180.png) | 조작 관련 컴포넌트 |
| ![collision](https://mod-file.dn.nexoncdn.co.kr/bbs/163635710557194c1304e88c34552b0a68d2b30eb3568.png) | 충돌 관련 컴포넌트 |

# 컴포넌트 추가

1. 프로퍼티 에디터 하단의 **Add component**를 누릅니다. ![component10](https://mod-file.dn.nexoncdn.co.kr/bbs/1634619180422b0c8ea84e18648749cd9d6642ff0b8d1.png)
2. 추가할 컴포넌트를 검색, 선택합니다. ![component11](https://mod-file.dn.nexoncdn.co.kr/bbs/1634619277305f8cc364cb0b7421eb3bad22bfdbbd4c6.png)
3. 프로퍼티 에디터 창에 선택한 컴포넌트가 추가되었는지 확인합니다. ![component12](https://mod-file.dn.nexoncdn.co.kr/bbs/1634619296245c4904b69ee43474b9ec416bd7e652521.png)

# 컴포넌트 초기화

설정한 컴포넌트 값을 초깃값으로 되돌립니다.

- 콘텍스트 메뉴를 열고, **Reset All Properties**를 선택해 컴포넌트의 프로퍼티 값을 초기화합니다. ![component13](https://mod-file.dn.nexoncdn.co.kr/bbs/1634619750943da28f727fc4548fa859cb322bf88dbe7.png)

# 컴포넌트 상태 변경

컴포넌트는 추가와 동시에 자동으로 활성화됩니다. 필요할 때 체크박스를 이용해 간단하게 활성 혹은 비활성 상태로 변경이 가능합니다.

- 아이콘과 컴포넌트 이름 사이의 체크박스를 선택해 상태를 변경합니다. ![Editbox_Check](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176407708cb3de01eaaf48a68ab2dd6fe1b1183f.png) : 컴포넌트 활성 상태 ![Editbox_Visible](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176985962dcc6fd403f34978b50521f0a8329013.png) : 컴포넌트 비활성 상태

![component14](https://mod-file.dn.nexoncdn.co.kr/bbs/1634619923114e5669c9d06f14fbba2355f32e99f00a1.png)

- 컴포넌트명 옆 콘텍스트 메뉴를 열고, **Disable Component**를 선택해 비활성화 할 수 있습니다.

# 컴포넌트 삭제

콘텍스트 메뉴를 열고, **Remove Component**를 선택해 컴포넌트를 삭제합니다. ![component15](https://mod-file.dn.nexoncdn.co.kr/bbs/16346199801992f5684c3b2e44bf194317e3efda34a18.png)

Update 2025-11-17 PM 08:14


# 캐릭터 초기 속성 편집

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

동시에 출발해 목표 지점까지 오르는 게임을 시작할 때 누군가는 한 번에 4칸을 오르고, 다른 누구는 2칸을 오른다면 함께 게임을 즐길 수 없을 것입니다. 게임을 처음 시작할 때 만큼은 동일한 환경에서 시작하는 게 중요합니다. 모델 프로퍼티를 이용해 속성을 편집하는 방법을 알아봅니다.

# 플레이어 기본 속성 변경

**Player** 모델에서 기본 속성을 변경할 수 있습니다.

1. **Workspace - BaseEnvironment - NativeModel - Player**를 선택합니다.
2. **Player**의 프로퍼티 값을 변경합니다.
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 변경 사항을 확인합니다.

**Player** 모델 프로퍼티는 다음과 같습니다. 여러 프로퍼티를 참조할 경우 정확한 구분을 위해 모델 프로퍼티 명칭이 변경된 경우가 있습니다.

![player](https://mod-file.dn.nexoncdn.co.kr/bbs/16357503109659b1496c0a9e84d899b57ed7a46c12439.png)

| 모델 프로퍼티 명 | 원 컴포넌트  원 프로퍼티 명 | 설명 |
| --- | --- | --- |
| speed | MovementComponent<ul><li>InputSpeed</li></ul> | 플레이어의 기본 이동 속도 값을 정합니다. 값이 클수록 빠르게 움직입니다.<br>기본값은 1.2입니다. |
| jumpForce | MovementComponent<ul><li>JumpForce</li></ul> | 플레이어의 기본 점프 높이를 설정합니다. 값이 클수록 높이 점프합니다.<br>기본값은 1입니다 |
| walkAcceleration | RIgidbodyComponent<ul><li>WalkAcc</li></ul> | 이동 가감속 값을 설정합니다. 값이 클수록 최대 속도에 빠르게 도달합니다.<br>기본값은 1입니다. |
| gravity | RIgidbodyComponent<ul><li>Gravity</li></ul> | 플레이어가 받는 중력 값입니다. 값이 클수록 빠르게 떨어집니다.<br>기본값은 1입니다. |
| cameraDeadZone | CameraComponent<ul><li>DeadZone</li></ul> | 입력한 범위까진 플레이어 아바타가 움직이더라도 카메라는 고정됩니다.<br>X, Y값이 0일 경우 플레이어 아바타의 모든 움직임에 카메라가 반응합니다. |
| cameraSoftZone | CameraComponent<ul><li>SoftZone</li></ul> | SoftZone 영역을 설정합니다. 대상이 프레임의 영역에 들어오면 카메라가 방향을 바꾸어 DeadZone으로 되돌립니다. |
| cameraDamping | CameraComponent<ul><li>Damping</li></ul> | 플레이어 아바타가 DeadZone을 벗어나 이동할 때 카메라가 쫓아가게 됩니다.<br>이때 화면을 급격하게 틀지 않고, 자연스럽게 플레이어 아바타를 따라가게 합니다.<br>값이 클수록 움직이는 플레이어 아바타를 부드럽게 따라갑니다. |
| cameraScreen | CameraComponent<ul><li>ScreenOffset</li></ul> | 화면에서 DeadZone의 중심점 위치를 지정합니다.<br>X, Y값은 (0,0)부터 (1,1)까지 입력할 수 있습니다.. |
| cameraDutch | CameraComponent<ul><li>DutchAngle</li></ul> | 카메라 회전 각도를 설정합니다.<br>큰 값을 입력할수록 화면이 시계 방향으로 회전합니다.<br>카메라는 입력한 값에 따라 반시계 방향으로 회전합니다. |
| cameraOffset | CameraComponent<ul><li>CameraOffset</li></ul> | 카메라 위치를 입력 받은 값만큼 보정합니다.<br>X, Y 좌표값은 절댓값입니다. 입력한 값만큼 카메라가 이동해 플레이어 아바타를 추적합니다. |
| message | ChatBalloonComponent<ul><li>Message</li></ul> | 플레이어 아바타의 말풍선 안에 들어갈 내용을 입력합니다. |
| chatModeEnabled | ChatBalloonComponent<ul><li>ChatModeEnaled</li></ul> | 채팅창에 입력한 대화가 말풍선으로 동시에 나타납니다. <br>활성 상태가 기본입니다. |
| nameTag | NameTagComponent<ul><li>Name</li></ul> | 플레이어의 이름표를 붙이거나 뗄 수 있습니다.<br>NameTagComponent의 Enable 체크박스를 해제해 비활성화합니다. |
| damageSkinId | DamageSkinSettingComponent<ul><li>DamageSkinld</li></ul> | ID값을 입력해 대미지 스킨 종류를 정합니다. |
| damageDelayPerAttack | DamageSkinSettingComponent<ul><li>DelayPerAttack</li></ul> | 대미지 값이 여러 번 화면에 보일 때 대미지 값 사이의 지연 속도(초)를 입력합니다. |
| triggerBodyBoxsize | TriggerComponent<ul><li>BoxSize</li></ul> | 플레이어가 충격 감지하는 범위를 박스 크기 좌표 값으로 정합니다. |
| triggerbodyBoxOffset | TriggerComponent<ul><li>Offset</li></ul> | 플레이어가 충격을 감지하는 박스의 위치를 좌표 값으로 정합니다. |
| maxHp | PlayerComponent<ul><li>MaxHP</li></ul> | 플레이어의 최대 체력을 설정합니다.<br>기본값은 1000입니다. |

# 모델 프로퍼티 비활성화하기

크리에이터의 의도에 따라 필요 없는 모델 프로퍼티를 비활성화 할 수 있습니다. 예를 들어, **NameTag**을 사용하고 싶지 않다면, 프로퍼티 에디터에서 **NameTagComponent**의 **Enable** 체크를 해제합니다.

![player01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634115527034a6cafbd8f68a4de49a827121df6f7a9c.png)

# DefaultPlayer의 기본 컴포넌트 삭제하기

기본 컴포넌트를 확장한 컴포넌트를 제작해 사용한다면, **DefaultPlayer**의 기본 컴포넌트를 삭제해야 합니다. 근본이 같은 컴포넌트가 여러 개 있으면 오동작 가능성이 커지기 때문에 기본적으로 하나의 컴포넌트만 사용하는 것을 권장합니다.

> **Tip.** 컴포넌트 특성에 따라 확장한 컴포넌트 여러 개를 함께 활용할 수도 있습니다.
> **Tip.** 컴포넌트의 동작 방식이 각각 다르므로 비활성화만 하는 것은 권장하지 않습니다. 오동작 가능성은 낮지만, 스크립트 작성 중 컴포넌트 명이 헷갈리거나 작성한 대로 동작하지 않고 오류가 날 가능성이 있기 때문입니다.

1. **Workspace - BaseEnvironment - NativeModel - Player**를 선택합니다.
2. 모델 프로퍼티 창에서 삭제하고 싶은 컴포넌트를 선택합니다.
3. 콘텍스트 메뉴를 열어 **Remove Component**를 클릭합니다.

![player09](https://mod-file.dn.nexoncdn.co.kr/bbs/1659574418759c11cbf083bd3472893c15be435fbe1f5.png)

# 마무리

모델 프로퍼티 값을 조금 바꿔 색다른 재미를 만들 수 있습니다. 기본 설정과 나만의 설정을 비교해 게임에 어울리는 플레이어 속성을 만들어보세요.

Update 2025-11-20 PM 02:03


# 게임 시작 위치 설정

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

**플레이어 아바타**의 등장 위치 설정 방법을 소개합니다. 게임 시작 위치, 재등장(리스폰), 게임 제작 중 테스트 위치 설정에 대해 알아보겠습니다.

# 플레이어 아바타의 기본 위치

플레이어 아바타의 기본 위치는 화면 중간입니다. X, Y 좌표상 X값 0, Y값 0인 위치입니다. 기본적으로 게임 시작과 리스폰 위치가 이 설정을 따릅니다. 플레이어 아바타의 기본 위치는 ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png)**DefaultPlayer의 TransformComponent**에서 확인할 수 있습니다. ![transformcomponent](https://mod-file.dn.nexoncdn.co.kr/bbs/163515895824953612927a52740079e54f5fff52a4db3.png)

# SpawnLocation을 이용한 시작 위치 설정

배치한 맵이 시작 맵이라면, 배치한 'SpawnLocation' 위치에 플레이어 아바타가 처음 등장하게 됩니다. 타 맵에 배치한 'SpawnLocation'은 맵에 진입했을 때 혹은 리스폰 위치로 이용할 수 있습니다.

1. Preset List에서**Special Model**을 클릭합니다.
2. **SpawnLocation 모델**을 ![TabScene](https://mod-file.dn.nexoncdn.co.kr/bbs/163452458863504f49c7a23aa4a41af56b5b4611a6daf.png)Scene에 배치합니다.![spawn80](https://mod-file.dn.nexoncdn.co.kr/bbs/1656036546711155b8385c0fb4001bda8ec16387d412e.png)

# 플레이 중 리스폰 위치

'SpawnLocation'은 맵마다 필요한 만큼 배치할 수 있습니다. 여러 'SpawnLocation'이 한 맵에 있으면**'SpawnLocation'과 플레이어 아바타 사이의 거리가**재등장 위치 선택 기준이 됩니다. 아래와 같이 플레이어 아바타가 두 개의 스폰 로케이션 사이에서 죽었을 경우, 아바타의 진행 방향이 왼쪽이라 할지라도 오른쪽의 'SpawnLocation'이 더 가깝기에 오른쪽에서 재등장하게 됩니다. ![spawn01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634957591109e98512448cae4044ae9a75e96b22221a.png) 'SpawnLocation'을 적절히 배치한다면 게임 중간의 체크포인트처럼 이용할 수 있습니다. 게임을 처음부터 다시 하지 않아도 되기 때문에 유저가 다시 도전할 수 있는 동기가 될 것입니다.

# 테스트 시작 위치 설정

게임 제작 중 특정 구간을 반복 확인하고 싶을 때가 있습니다. 이때 처음부터 테스트를 진행하는 것보다 원하는 위치에서 시작해 일정 구간을 테스트 하는 것이 훨씬 효율적입니다. ![Common_PlayHere](https://mod-file.dn.nexoncdn.co.kr/bbs/1634538307569eec2919eb0d84163aa7be63651bd165d.png) **여기서 시작**을 이용해 테스트 시작 위치를 설정할 수 있습니다.

1. ![TabScene](https://mod-file.dn.nexoncdn.co.kr/bbs/163452458863504f49c7a23aa4a41af56b5b4611a6daf.png)Scene 탭 아래에 위치한 ![Common_PlayHere](https://mod-file.dn.nexoncdn.co.kr/bbs/1634538307569eec2919eb0d84163aa7be63651bd165d.png)**여기서 시작** 버튼을 선택합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17617248549680bd501dfcee840dbb7eb05c1fed935eb.png)
2. 테스트를 시작하고 싶은 위치(타일 혹은 발판 위)로 움직여 배치합니다.![spawn9](https://mod-file.dn.nexoncdn.co.kr/bbs/1740551251453a53f6916f5d6499e86c8c453f7304fdc.png)
3. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트를 시작합니다.
4. 설정한 곳에서 플레이어 아바타가 등장합니다.

> **Tip.** 이미 배치한 SpawnLocation이 있더라도, 테스트 시에는 배치한 '여기서 시작' 위치가 우선입니다.
> **Tip.** 맵에 발판/타일을 배치하지 않고 시작 위치를 지정하게 되면, 테스트가 시작될 때 캐릭터가 임의로 화면 중앙에 배치됩니다. 의도한 곳에 캐릭터가 나타나길 원한다면 캐릭터가 설 수 있는 발판 영역 위에 두어야 합니다.

##### 참고 가이드

[캐릭터 초기 속성 편집](/docs?postId=48)

Update 2025-11-17 PM 08:14


# 게임 섬네일 변경하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임 섬네일은 유저의 흥미와 플레이 욕구를 자극할 수 있는 중요한 요소입니다. 이번 과정에서는 게임의 섬네일을 등록, 삭제하는 방법에 대해 알아보겠습니다.

# 섬네일 등록하기

1. **만들기** 메뉴에 있는 월드 목록에서 섬네일을 변경하려는 월드를 선택합니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1676443855396688088e04cbc4c62b50493b19961143a.png)
2. **이미지** 탭에서 **[이미지 첨부]** 버튼을 클릭해 내 컴퓨터에 있는 이미지를 섬네일로 등록합니다. 섬네일은 최대 5장까지 등록 가능합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1652839494394ff1412b0e0244ea3a4c697f3f5e7db92.png)
3. 아래와 같이 등록한 이미지를 확인할 수 있습니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/165283951204852807e7f27b2417eaa4028eb5e7faabc.png)

# YouTube 영상 등록하기

1. **동영상** 탭을 선택한 후, **[YouTube URL]** 버튼을 클릭합니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1652839530338f5a40da71f894b9e917430d3dc7ad8e1.png)
2. **YouTube URL**을 입력하고 **[확인]** 버튼을 클릭합니다. ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/165283955093915a273db892549bfb137981c2fa1a4c9.png)
3. 영상이 재생되는 것을 확인할 수 있습니다. ![06](https://mod-file.dn.nexoncdn.co.kr/bbs/16826484276740be95079568d40a2923208683e270854.png)

# 섬네일과 영상 삭제하기

섬네일을 삭제하려면 이미지 탭을 선택한 후, 삭제하고 싶은 섬네일이 보이는 상태에서 **[삭제]** 버튼을 클릭합니다. ![07](https://mod-file.dn.nexoncdn.co.kr/bbs/1652839587302e1550d9505a04191a1db7139751c5344.png)

영상을 삭제하려면 동영상 탭을 선택한 후, **[삭제]** 버튼을 클릭합니다. ![08](https://mod-file.dn.nexoncdn.co.kr/bbs/1682648463267027a1a3db3e64061ad133eed0eb6fe06.png)

# 게임을 출시하면서 섬네일과 영상 변경하기

제작한 게임을 출시할 때도 섬네일이나 영상을 등록, 변경, 삭제할 수 있습니다. 먼저 **File - Release**를 클릭합니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/16841147126563e8e10fa3cbf402fb4a4a2cdb1a338d1.png)

**Release** 창에서 섬네일이나 영상을 관리할 수 있습니다. 섬네일을 등록하는 방법은 3가지가 있습니다.

| 이미지 | 스크린샷 | AI |
| :---: | :---: | :---: |
| ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/168411475173752829596e4f64ea48cc41c7daf35880b.png)<br>내 컴퓨터에 있는 이미지를 섬네일로 등록 | ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/168411478437899133237b6484489a110e1284a2a85ca.png)<br>현재 메이커 상의 화면을 섬네일로 등록 | ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1684114892964a1cd84432cdf42a2b75e270a2e5ddf0e.png)<br>AI 자동 생성 섬네일 추가 |

동영상을 등록하려면 동영상 탭을 선택한 뒤, **[YouTube URL]** 버튼을 클릭해 영상 주소를 넣으면 됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16528396661683c6d848466eb4b4d8f076607777ad517.png)

지금까지 게임 섬네일과 영상 등록 방법을 알아보았습니다. 멋진 섬네일과 영상으로 본인이 제작한 게임을 돋보이게 만들어봅시다.

Update 2025-11-17 PM 08:14


# 제작한 월드 불러오기 및 관리

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

제작한 월드를 불러오고 관리하는 방법을 알아봅니다.

# 제작 중인 월드 불러오기

1. 메뉴에서 **[만들기]** 버튼을 클릭합니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16654666396025c27dfec219f44d4855305b5b5bbb3fd.png)
2. 월드 목록에서 불러올 월드를 선택합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1697688993495dab3281a7ede406f835f4373d835b71a.png)
3. 월드 정보에서 **[이어서 만들기]** 버튼을 클릭하면 제작 중인 월드를 불러옵니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/169761419461164f8c0c53c4c49a8920f32be1fe8670d.png)

# 리비전 관리

월드를 제작할 때는 리비전을 기록하고 관리하는 과정이 필요합니다. 중요한 변경점이 발생했을 때마다 리비전을 기록해두면 필요한 순간에 예전 리비전으로 월드를 되돌릴 수 있어 안전합니다. 또한 이전 버전을 추적하고 관리할 때 편리합니다.

##### 리비전 기록하기

**File - Revisions** 메뉴로 들어가면 리비전을 기록할 수 있습니다. ![revision](https://mod-file.dn.nexoncdn.co.kr/bbs/16892261674937e4332ad952c4bfba92ca79c12271eb4.png)

**Revisions** 창에서 **[지금 기록하기]** 버튼을 누르면 간단한 메모와 함께 리비전을 저장할 수 있습니다. ![revision](https://mod-file.dn.nexoncdn.co.kr/bbs/1689227369728d4ea35ebfb104ac48448359ff18c8f36.png)

##### 리비전 관리 기능

**Revisions** 창에서는 아래의 기능을 사용할 수 있습니다. ![revision](https://mod-file.dn.nexoncdn.co.kr/bbs/16892318009566f218c41f5bc4e98aa8c8db8d22b4971.png)

| 번호 | 기능 | 설명 |
| --- | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg) | 메모 수정 | 리비전 메모를 수정합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg) | 다운로드 | 해당 리비전의 mod 파일을 다운로드합니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg) | 되돌리기 | 해당 리비전으로 되돌립니다. <br>개인 월드는 바로 리비전을 되돌릴 수 있지만 그룹 월드는 복구 모드를 켠 뒤 리비전을 되돌릴 수 있습니다. 자세한 내용은 [공동 제작](/docs/?postId=670) 가이드의 **복구 모드** 내용을 참고합니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541326353d8628c1473944497bf376acb7a65ca45.jpg) | 제거 | 리비전을 제거합니다. |

> **더 알아보기** 월드 정보에서 **[⋯] - [리비전]** 버튼을 클릭해도 리비전 관리를 할 수 있습니다. ![Revision](https://mod-file.dn.nexoncdn.co.kr/bbs/16982844687277d91f57257414627911fa276d4652ea6.png) ![revision2](https://mod-file.dn.nexoncdn.co.kr/bbs/1697614268934a9692437551e43f49f5f383a8ccf5139.png)

# 월드 삭제

출시하지 않은 월드만 삭제가 가능합니다. 출시한 월드는 삭제가 불가능합니다.

1. 월드 목록에서 삭제할 월드를 선택합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1697688993495dab3281a7ede406f835f4373d835b71a.png)
2. **[⋯]** 버튼을 클릭합니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1697614389339483bb4702a3b4b1597707aa6fecd1595.png)
3. **월드 관리** 팝업 창에서 **[월드 삭제]** 버튼을 누릅니다. ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/16976144114251253358153f8432e862cc4fce67c4100.png)

> **더 알아보기** 이미 출시된 월드는 삭제할 수 없습니다. 출시된 월드의 **월드 관리** 팝업 창에는 **[리비전], [크리티컬 리포트]** 버튼만 보입니다.

Update 2025-11-17 PM 08:14


# 월드 출시하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드 출시를 위해 준비해야 할 항목들을 알아봅시다.

# 월드 출시

월드 출시의 최종 목표는 모든 유저에게 월드를 공개하는 것입니다. 그러나 제작 중인 월드를 곧바로 모두에게 공개하는 것은 위험하므로 단계별로 출시를 진행하기를 권장합니다. 메이플스토리 월드에서의 출시는 3단계로 나눌 수 있습니다. 먼저 제작 중인 월드를 **비공개**로 출시해 데이터 저장, 월드 워프 등의 구현한 기능이 정상 동작하는지 확인합니다. 여러 번의 비공개 출시와 테스트를 거쳐 월드를 완성했다면, 두 번째 단계로 **공개 예정** 출시를 합니다. 이 공개 예정 출시 단계는 월드에 따라 건너뛰어도 좋습니다. 마지막으로 모든 준비가 되었다면 메이플스토리 월드 유저들에게 **공개**로 월드를 출시합니다.

월드는 용량에 따라 출시 완료까지 걸리는 시간이 다릅니다. 출시가 완료되면 오른쪽 아래에 출시 완료 메시지가 나타납니다. 출시 이후의 월드 수정은 크리에이터가 다시 월드를 출시하기 전까지 출시된 월드에 반영되지 않습니다. 이 점을 유의하여 순차적으로 공개되어야 하거나, 특정 일자에 공개되어야 하는 수정점이 있는 경우 월드 출시를 유의해야 합니다. 효과적인 월드 관리를 위해 제작용으로 다른 월드를 사용해 수정된 내용이 반영되지 않도록 합니다.

# 월드 출시하기

월드 출시 전 월드를 반드시 저장해야 합니다. 월드를 저장한 후 아래 순서를 따라 월드를 출시합니다.

1. **File - Release**를 누릅니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1749445127392c3d69f1deb444fc3a58b3cb40a00fbeb.png)
2. 월드의 **기본 정보, 공지사항, 소셜, 출시 지역**을 작성합니다.
3. **출시** 버튼을 누릅니다. 월드 출시가 완료되면 알림창이 나타납니다.

# 필수 입력 사항

아래 사항을 필수로 입력해야 월드를 출시할 수 있습니다.

## 기본 정보

월드의 기본적인 정보를 제공할 수 있습니다.

#### 이미지, 동영상

이미지와 동영상은 유저에게 월드를 미리 소개할 수 있는 기능입니다. 이미지는 5개, 동영상은 1개 등록할 수 있습니다.

- **이미지**: 크리에이터가 준비한 이미지를 업로드합니다.
- **스크린샷**: 현재 Scene에 보이는 상태를 캡쳐해 보여줍니다.
- **AI**: 메이플스토리 월드에서 제공하는 이미지와 크리에이터가 입력한 제목을 합쳐 새로운 이미지를 만듭니다. AI 버튼을 누를 때마다 새로운 이미지가 생성됩니다.
- **YouTube URL**: YouTube에 업로드한 영상의 URL을 입력합니다.

![2](https://mod-file.dn.nexoncdn.co.kr/bbs/17494451432855f88ae7f0dc744b2a7d344072d252c8e.png)

#### 제목, 설명, 장르

- **제목**: 제작한 월드 제목을 작성합니다. 최대 50자까지 작성할 수 있습니다.
- **설명**: 월드에 관한 정보를 작성합니다. 최대 1,000자까지 작성할 수 있습니다.
- **장르**: 만든 월드의 주요 장르를 선택합니다. 액션, 어드벤처, 캐주얼, 시뮬레이션, 퀴즈, 퍼즐, 전략, 레이싱, 스포츠, 소셜, 교육, 타이쿤 중 선택할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174909874880630f9882bd5fe47ac9534c7d472ff08c3.png)

#### 최대 플레이어 수, 플레이 가능 기기

- **플레이 가능 기기**: 기본값은 PC와 모바일이 모두 선택된 상태입니다. 특정 기기만 고려하고 만들었다면 고려한 기기만 선택합니다.
- **최대 플레이어 수**: 최소 1명부터 최대 100명까지 하나의 월드 인스턴스에 입장할 수 있는 플레이어 수를 정합니다. 최대 플레이어 수는 월드의 규모와 설계에 따라 달라집니다. 월드 실행에 부담이 되지 않는 선에서 최대 플레이어 수를 설정하기를 권장합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1750764172878a52446a929e44288b6017e0f592c9e0c.png)

#### 플레이 가능 범위

월드의 성격에 따라 플레이 가능 범위를 설정할 수 있습니다. 월드 제작 중 출시 환경에서 제작한 의도대로 동작하는지 확인이 필요할 경우 **비공개**로 출시해 그룹원끼리 테스트할 수 있습니다. 실제 유저들 중 일부 테스트 지원자를 포함해 월드를 플레이 해보고 싶다면, **공개 예정**으로 출시해 월드가 매끄럽게 동작하는지 확인할 수 있습니다. 월드의 플레이 가능 범위는 비공개, 공개 예정, 공개 총 3가지로 구분됩니다.

- **비공개**: 크리에이터 혹은 크리에이터 그룹원만 플레이할 수 있습니다.
- **공개 예정**: 플레이 화면에서 노출되지만, 크리에이터와 그룹원만 플레이할 수 있습니다. 점검 중일 경우 점검 중 표시가 노출됩니다.
- **공개**: 모든 플레이어가 월드를 플레이할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1749098823710d6644e1475514b14903c0fe91df6de99.png)

# 선택 입력 사항

월드를 출시할 때 아래 항목은 선택적으로 입력할 수 있습니다. 크리에이터가 제작한 월드의 특성에 따라 필요한 항목을 입력하고, 월드를 출시합니다. 만약 월드를**공개**로 출시한다면 [제작 시 준수 사항](/docs/?postId=665)의 내용을 읽고 크리에이터의 월드가 문제 없이 출시될 수 있는 상태인지 최종 점검할 것을 권장합니다.

## 기본 정보

#### 권장 연령과 월드 설문지

월드의 권장 연령은 크리에이터가 임의로 설정할 수 없습니다. 권장 연령은 월드 출시 후 **월드 설문지** 응답을 통해 결정됩니다. 월드 설문지 응답을 진행하지 않은 경우 최고 연령 등급으로 자동 책정됩니다. 월드의 권장 연령에 따라 기준 연령 미만인 플레이어에게는 월드가 노출되지 않습니다.

- **전체 이용가**: 모든 연령의 플레이어에게 적합한 월드입니다.
- **9세 이상**: 9세 이상 플레이어에게 적합한 월드입니다.
- **13세 이상**: 13세 이상 플레이어에게 적합한 월드입니다. 월드 설문지에 응답하지 않은 경우 13세 연령으로 자동 배정됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17491002805601b9a9c3093694e02b57d6eca5924559d.png)

#### 언어와 원문 언어 설정

월드에서 제공하는 언어를 설정하세요. 영어, 한국어, 스페인어, 중국어 간체, 중국어 번체를 설정할 수 있습니다. 원문 언어 설정은 **WorldConfig - SourceLanguage**에서 설정합니다. 원문 언어 설정에 관한 내용은 [자동 번역](/docs?postId=1072)을 참고합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17491003710998205aa29fbf6416e9ffa7d3e2a23e3e2.png)

#### 리메이크 허용 여부

리메이크와 댓글 허용 여부는 월드의 상황에 따라 언제든지 변경 가능합니다. 리메이크를 허용하면 다른 크리에이터들이 해당 월드를 리메이크하여 월드 제작에 활용할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174962398396121b5b7c1fdfc4bb9b68769662222bb8c.png)

#### 댓글 허용 여부

월드 댓글 허용 여부를 결정합니다. 댓글을 허용하던 월드를 '허용 안 함'으로 변경할 경우 기존 댓글은 숨겨집니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174962397318505fe84606b194addade01ff00a5d5788.png)

#### 대표 리소스 IP

메이플스토리 월드에서는 다양한 리소스를 제공하고 있습니다. 월드에서 가장 많이 사용한 게임 리소스 IP를 설정할 수 있습니다.

- **리소스 IP 종류**: 메이플스토리, 바람의나라, 큐플레이, 듀랑고

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1749103470496667114d3e3cc42c98e8fcbb938d980e9.png)

#### 레이블

레이블은 크리에이터가 직접 설정하는 항목입니다. 레이블은 추후 크리에이터가 제작한 여러 월드에 하나의 레이블로 종합적인 지표를 확인할 수 있도록 제공될 예정입니다. 레이블은 공백 없이 2 - 20자의 영문 대소문자와 숫자 조합으로 작성합니다. 레이블은 월드를 제작한 크리에이터만 확인할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1750818528527347f577a6a704a9ebaa1c0cad8aab020.png)

## 공지사항과 업데이트

공지사항과 업데이트는 클라이언트와 공식 홈페이지에서 모두 수정할 수 있습니다. **메이플스토리 월드 공식 홈페이지 - 월드 만들기 - 제작 중인 월드 - 월드 정보 관리** 에서 두 항목을 수정할 수 있습니다. 공지사항과 업데이트는 확인 버튼을 누르면 즉시 반영되므로 주의가 필요합니다.

- **공지사항**: 플레이어에게 알려야 할 공지 관해 작성하거나, 확률 관련 안내를 하는 용도로 사용할 수 있습니다.
- **업데이트**: 업데이트를 통해 플레이어에게 새롭게 제공하는 기능이나, 수정된 버그 관련 정보를 작성합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174909886716594015be6defc4c908d849dc0ce539a3e.png)

## 소셜 미디어 등록

월드의 공식 소셜 미디어를 등록해 제공할 수 있습니다. **페이스북, 유튜브, 트위치, 디스코드** 등의 URL을 입력하고 소개글을 작성합니다. 소개글은 30자까지 작성 가능합니다. **메이플스토리 월드 공식 홈페이지 - 월드 만들기 - 제작 중인 월드 - 월드 정보 관리**에서도 수정할 수 있습니다. 확인 버튼을 누르면 즉시 반영되므로 주의가 필요합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1749693246976915c5733fcdf4123b81582df27fcecca.png)

## 출시 지역

월드를 출시할 지역을 선택합니다. 출시 지역으로 선택하지 않은 지역에서는 월드가 노출되지 않으며, 접속도 할 수 없습니다. 만약, 월드 설문지의 결과에서 일부 지역의 출시 기준과 맞지 않다면 출시 국가에서 제외하는 것을 권장합니다. **메이플스토리 월드 공식 홈페이지 - 월드 만들기 - 제작 중인 월드 - 월드 정보 관리**에서도 수정할 수 있습니다. 확인 버튼을 누르면 즉시 반영되므로 주의가 필요합니다.

![9](https://mod-file.dn.nexoncdn.co.kr/bbs/17491036297776e5b57b4ccd94fc29857cc029c5d0f7b.png)

Update 2025-11-17 PM 08:14


# 유저 피드백 설정하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터는 유저 피드백 알림을 통해 주기적으로 본인이 제작한 월드의 긍정적인 피드백을 전달받을 수 있습니다. 이번 과정에서는 유저 피드백 알림 설정 방법을 알아보겠습니다.

# 유저 피드백 알림

## 알림 설정

유저 피드백 알림은 프로 모드, 디자인 모드에서 모두 설정할 수 있습니다.

| 프로 모드 | 디자인 모드 |
| :---: | :---: |
| **File - User Feedback Setting**<br>![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1684311904185def4420d2f0e48c18facb47c8e4771b3.png) | **메뉴 - 유저 피드백 설정**<br>![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1684312020039e61a7feb1cba49ab9426f57c6e30016f.png) |

유저 피드백 알림 설정 창은 아래와 같이 구성되어 있습니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16843123885594cb3963439af4913a08f45b4814029c1.png)

| 항목 | 설명 |
| --- | --- |
| 플레이 | 플레이한 유저 및 인원수를 보여줍니다. |
| 좋아요 | "좋아요"를 누른 유저 및 인원수를 보여줍니다 |
| 즐겨찾기 | 즐겨찾기를 누른 유저 및 인원수를 보여줍니다. |
| 알림 발송 주기 | 알림 주기를 설정합니다.<br>알림 발송 주기는 적용 버튼을 누른 시점부터 계산됩니다. |

## 알림 출력

유저 피드백 알림은 PC 및 모바일 환경에서 모두 출력됩니다. 예를 들어 모바일에서 메이플스토리 월드 실행 중일 때 알림은 아래와 같이 출력됩니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16843874714860fd65aedc9fb425ca6d030881d8b0d72.gif)

> **더 알아보기** 모바일에서 메이플스토리 월드 앱을 비활성화한 상태일 때 발생한 유저 피드백 알림은 백그라운드 푸시로 전달됩니다.

Update 2025-11-17 PM 08:14


# 리소스 찾기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

방대한 리소스 속에서 크리에이터에게 필요한 리소스만 골라 활용할 수 있습니다. 또한 크리에이터가 제작한 리소스를 추가해 제작에 활용할 수도 있습니다.

# 맵 테마별 리소스 찾기

메이플스토리 월드에서는 크리에이터들의 원활한 월드 제작을 돕기 위해 **Preset List**를 제공합니다. **Preset List**에서 스크롤을 내려가며 마음에 드는 리소스를 찾거나 직접 검색어를 입력할 수도 있지만 제공되는 **Preset**이 많기 때문에 원하는 리소스를 찾기 어려울 수도 있습니다.  메이플스토리의 특정 지역 테마별 리소스만 추려 보고 싶다면 맵 필터 기능을 사용해봅시다. **Preset List** 검색창 옆의 **[필터]** 버튼을 누르면 원하는 맵 테마만 선택할 수 있습니다. 예를 들어, **헤네시스** 체크박스만 선택하면 메이플스토리의 헤네시스 맵에서 사용된 리소스만 골라볼 수 있습니다. ![09](https://mod-file.dn.nexoncdn.co.kr/bbs/1667265926167bf24a1e8116d46aa99cff4d05b798321.png)  **[필터]** 검색창에 맵 이름으로 검색하면 원하는 맵을 더 빠르게 찾을 수 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1667266173872fe1a8c94f10740d89a8b80eaee579886.png)

오브젝트뿐만 아니라 몬스터, NPC, 타일, BGM 등 다른 리소스도 마찬가지 방법으로 찾을 수 있습니다. 특정 지역 테마로 맵을 꾸밀 때 유용하게 활용해 봅시다.

# 리소스 스토리지 소개

메이플스토리 월드에서는 많은 리소스를 **Preset List**로 제공하지만, 모든 리소스가 **Preset List**에 있는 것은 아닙니다. 보다 방대한 데이터에서 원하는 리소스를 검색할 때는 **Resource Storage**를 활용해 봅시다. **Resource Storage**의 기본 위치는 **Scene** 탭 옆입니다.

창을 닫았을 때는 상단 내비게이션 메뉴의 **Panels - Resource Storage**를 클릭해 열 수 있습니다. ![resource01](https://mod-file.dn.nexoncdn.co.kr/bbs/1659526566918ff053800d1c4414e97be1069f5a27e5d.png)

**Resource Storage**는 **내 리소스, MSW 리소스, 즐겨찾기**로 나뉘어 있습니다.

- **내 리소스**
  - 외부에서 불러온 리소스 파일을 저장할 수 있습니다.
  - 검색창 왼쪽의 ![Common_plus](https://mod-file.dn.nexoncdn.co.kr/bbs/16345383307314ccbb85e4ebd48cf92648ca740ae490a.png) 를 눌러 리소스를 추가합니다. 추가한 리소스는 자동으로 RUID 값을 부여받습니다.![resource05](https://mod-file.dn.nexoncdn.co.kr/bbs/1636364332540dc322ca03197488eb39d1f4fe58c7463.png)
- **MSW 리소스**
  - 메이플스토리 월드에서 제공하는 리소스가 카테고리별로 저장되어 있습니다.
  - 메이플스토리 월드 리소스 자체를 저장할 수는 없으며, RUID 값을 제작에 활용합니다.![resource06](https://mod-file.dn.nexoncdn.co.kr/bbs/16635907926480b23f6c1f7324fcf8cf4768b90fb5b5d.png)
- **즐겨찾기**
  - 검색한 리소스를 즐겨찾기에 등록해 편리하게 RUID를 찾을 수 있습니다.
  - 별 모양 버튼을 누르면 즐겨찾기에 저장됩니다.
  - 최대 5,000개의 리소스를 즐겨찾기에 저장할 수 있습니다.![bookmark](https://mod-file.dn.nexoncdn.co.kr/bbs/1663576170291cee2171bf56b4c46ab42c00f27dec95e.png)

#### 리소스 카테고리 구분

리소스는 4개의 상위 카테고리 **Sprite, AnimationClip, AudioClip, AvatarItem** 아래에 하위 카테고리로 분류되어 있습니다. 4개의 카테고리 중 찾으려는 분류를 선택해 검색합니다.

| 카테고리 | 설명 |
| --- | --- |
| Sprite | 다양하게 활용할 수 있는 스프라이트가 카테고리별로 분류되어 있습니다.<br>하위 카테고리: object, foothold, monster, npc, trap, item, skill, ladder, rope, portal, etc |
| Animation Clip | 움직임이 포함된 애니메이션 스프라이트가 카테고리별로 분류되어 있습니다.<br>하위 카테고리: object, monster, npc, trap, item, skill, background, portal, etc |
| Audio Clip | 다양하게 이용할 수 있는 음원이 카테고리별로 분류되어 있습니다.<br>하위 카테고리: monster, item, skill, bgm, etc |
| Avatar Item | 아바타에 장착할 수 있는 아이템들이 카테고리별로 분류되어 있습니다.<br>하위 카테고리: hair, face, cap, cape, coat, glove, longcoat, pants, shoes, faceaccessory, eyeaccessory, onehandweapon, twohandweapon, subweapon, ear, body |

# 리소스 스토리지 사용

#### 텍스트 검색

1. **MSW 리소스**에서 검색어를 입력합니다. 검색어 예: 병아리![resource03](https://mod-file.dn.nexoncdn.co.kr/bbs/166737559837948f0e485931d4845b429ef6c25db8981.png)
2. 카테고리를 확장하여 원하는 리소스를 찾습니다. **[RUID 복사]** 버튼을 클릭해 값을 복사한 후, 필요한 곳에 사용합니다. 이미지를 더블 클릭하면 세부 정보가 나타납니다. ![resource04](https://mod-file.dn.nexoncdn.co.kr/bbs/1660714310363d5a4524261594dea8290a03f40ddb4d6.png)

#### 이미지 검색

이미지 검색은 sprite만 가능합니다. 이미지로 검색하면 유사한 이미지를 찾아 보여줍니다. 원하는 리소스를 지칭하는 용어가 생각나지 않을 때 이용하면 편리합니다.

1. 이미지 선택을 눌러 검색하려는 이미지를 추가합니다.  ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1660719540488c535b33c016d4baeaeb906591c2e5a00.png)
2. 카테고리를 확장하여 원하는 리소스를 찾습니다. **[RUID 복사]** 버튼을 선택해 값을 복사한 후, 필요한 곳에 사용합니다. 이미지를 더블 클릭하면 세부 정보가 나타납니다.  ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1660719223493f4f3801dbdd046d7bd85d41f8de80b0c.png)

> **Tip.** [메이플스토리 월드](https://maplestoryworlds.nexon.com/) 공식 홈페이지에서도 동일하게 검색할 수 있습니다. ![200](https://mod-file.dn.nexoncdn.co.kr/bbs/1667375842722439880381a5146a38d5c30b4caf8fc4a.png)
> **더 알아보기** **Resource Picker**는 특정 카테고리에 해당하는 리소스만을 프로퍼티 에디터 창에서 보고, 고를 수 있습니다. RUID 값 입력 창 옆의 버튼을 선택해 사용합니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/16808611104777a306de2baa344efa28ca04d30782612.png)

# 리소스 버전 관리

크리에이터는 **Resource Storage**나, **Workspace - MyDesk** 폴더에 리소스를 직접 추가할 수 있습니다. 제작한 월드를 출시할 때 리메이크 허용을 염두에 두고 있다면, 리소스를 둘 중 어느 공간에 추가할지도 함께 고려해야 합니다. 리소스가 추가된 위치에 따라 리소스 업데이트와 리메이크의 영향을 받는 범위가 결정됩니다.

**Workspace - MyDesk**에 추가한 리소스는 월드를 출시한 뒤 해당 리소스를 변경하더라도, 리메이크된 월드는 영향을 받지 않습니다. 리소스 저장소에 추가한 리소스를 변경하게 되면 리메이크된 모든 월드가 영향을 받습니다. 리메이크를 허용할 때 리소스를 변경할 계획이 없다면 어느 곳에 리소스를 추가해 제작해도 좋지만, 반대의 경우라면 워크스페이스에만 리소스를 추가해 제작하는 방법을 권장합니다.

Update 2025-11-17 PM 08:14


# 리소스 관리

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

유저가 메이커에 등록한 리소스를 관리하는 방법에 대해 알아봅시다.

# 리소스 구분

메이플스토리 월드에서의 리소스는 프로퍼티 에디터 혹은 스크립트 등에서 사용할 수 있습니다. 그리고 각각의 리소스마다 RUID가 존재합니다. 리소스는 제공자에 따라 **메이플스토리 월드 리소스**와 **유저 리소스**로 나눌 수 있습니다. ![resource](https://mod-file.dn.nexoncdn.co.kr/bbs/165629249068116a4d90cc59547e7acf937a4382a9e93.png)

## 메이플스토리 월드 리소스

메이플스토리 월드 리소스는 말 그대로 메이플스토리 월드에서 제공하는 리소스를 말합니다. 메이커의 **Resource Storage** 및 [메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/)의 **MSW 리소스** 페이지에서 확인할 수 있습니다.

| 메이커 | 공식 홈페이지 |
| :---: | :---: |
| ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16635723190184a5ae4b2c64a43d09a0c86875eddb1f7.png) | ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1665577523337a9933b9eb4e54e20a80ba17c6a829a9c.png) |

## 유저 리소스

유저가 소유하고 있던 이미지, 오디오 파일 등을 메이커에 등록한 것을 말합니다. 유저 리소스는 메이커 상에 등록되는 위치에 따라 **Workspace 리소스**와 **Resource Storage 리소스**로 구분할 수 있습니다.

### Workspace 리소스

유저는 **Workspace**에 이미지 파일(Sprite)과 사운드 파일(Audio Clip)을 등록(Import)할 수 있습니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/1687485897578727af760113a444395d417a01539f4c5.png) **Workspace**에 등록된 리소스는 **월드에 귀속**되어 해당 월드 내에서는 자유롭게 사용할 수 있습니다. 어떤 리소스를 현재 제작 중인 월드에서만 사용할 예정이라면 **Workspace**에 등록하여 사용하면 됩니다.

### Resource Storage 리소스

유저는 **Resource Storage**에 직접 리소스를 등록하거나 MSW 리소스를 내 리소스로 복제한 뒤 메타 정보를 편집하여 사용할 수 있습니다.

#### 직접 등록

**Resource Storage**에는 **Sprite, Animation Clip, Audio Clip, Avatar Item**을 등록할 수 있습니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1678782615037da2f7e4bb8f94673aa6449cd5171a761.png)

**Sprite, Audio Clip**은 유저가 소유한 파일을 등록할 수 있습니다. **Animation Clip과 Avatar Item**은 전용 에디터로 제작하여 등록할 수 있습니다.

> **더 알아보기** Animation Clip 등록 방법에 대해 더 알아보고 싶다면 아래 가이드를 참고하세요! [애니메이션 만들기](/docs/?postId=595) Avatar Item 등록 방법에 대해 더 알아보고 싶다면 아래 가이드를 참고하세요! [아바타 아이템 등록하기](/docs/?postId=590)

#### MSW 리소스 복제

MSW 리소스를 복제한 뒤 메타 정보(이름, 설명, 피봇 등)를 편집하여 사용할 수 있습니다. 원하는 MSW 리소스의 콘텍스트 메뉴에서 **Duplicate**를 선택하면 내 리소스 탭 하단의 **duplicated sprite** 폴더에 복제본이 생성됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1678781904414feca1160b30f47f9a4ff6f5aa60a55a2.png)

복제본의 세부 정보 창에서 이름, 설명 등의 정보를 편집할 수 있습니다. 또한 스프라이트 슬라이스의 **[편집]** 버튼을 눌러 피봇 등의 정보를 변경할 수 있습니다. ![34](https://mod-file.dn.nexoncdn.co.kr/bbs/16787821964358229060c44f4487c817834e517a48b4f.png)

**개인 월드**의 **Resource Storage**에 등록한 리소스들은 **계정에 귀속**됩니다. 같은 계정으로 제작한 여러 월드에서는 그 계정에서 등록한 리소스를 자유롭게 사용할 수 있습니다. **그룹 월드**의 **Resource Storage**에 등록한 리소스는 **그룹에 귀속**되어 해당 그룹이 제작한 여러 월드에서 자유롭게 사용할 수 있습니다. 그러므로 제작하는 여러 월드에서 공통적으로 사용할 리소스라면 **Resource Storage**에 등록하여 사용하는 것이 편리합니다.

# 리소스 사용 권한

리소스 종류에 따라 사용 권한이 달라집니다.

| 리소스 구분 | 사용 권한 |
| :---: | --- |
| 메이플스토리 월드 리소스 | 모든 크리에이터가 자유롭게 사용할 수 있습니다. |
| Workspace 리소스 | 해당 월드에서만 사용할 수 있습니다. |
| Resource Storage 리소스 | 월드 제작자와 Resource Storage의 소유자가 같아야 사용할 수 있습니다. <br>다만 Resource Storage에서 공유 기능을 설정하면 모든 유저가 자유롭게 사용할 수 있게 됩니다. |

## 개인 리소스 - 그룹 리소스 이전

Resource Storage 리소스는 그룹 리소스로 이전하여 사용할 수 있습니다.

| 세부 정보에서 이전하기 | 콘텍스트 메뉴로 이전하기 |
| :---: | --- |
| ![transfer](https://mod-file.dn.nexoncdn.co.kr/bbs/16635730280498ee9bce2a62645d88bb200e8b3401f49.png) | ![transfer2](https://mod-file.dn.nexoncdn.co.kr/bbs/16635731424338eea6c824d134c30808a14fbfd0a24c6.png) |

위와 같이 선택하면 어떤 그룹으로 소유권을 이전할 것인지 결정할 수 있습니다. ![transfer3](https://mod-file.dn.nexoncdn.co.kr/bbs/16563171740870115df1b2d294a21880a554493daf7bf.png)

> **더 알아보기** 그룹을 만들어 공동 제작하는 방법에 대해 더 알아보고 싶다면 아래 가이드를 참고하세요! [공동 제작](/docs/?postId=670)

## 리소스 공유

Resource Storage 리소스에 아래와 같이 공유 기능을 설정할 수 있습니다. ![resourcesharing](https://mod-file.dn.nexoncdn.co.kr/bbs/166357327058272ffb6a6e6314fd9856618c631d82521.png) 원작자가 리메이크를 허용한 **월드 A**를 출시했다고 가정해봅시다. **월드 A**에는 공유 기능을 설정한 **리소스 a**가 사용되었습니다. 다른 크리에이터가 **월드 A**를 리메이크하면 리메이크 월드에서도 **리소스 a**를 자유롭게 사용할 수 있습니다. 하지만 추후에라도 원작자가 **리소스 a**의 공유 기능을 해제한다면 리메이크 월드에서도 **리소스 a**를 사용할 수 없게 되므로 주의해야 합니다.

# 리소스 버전

Workspace 리소스인지, Resource Storage 리소스인지에 따라 리소스 업데이트와 리메이크의 영향을 받는 범위가 달라집니다. 그러므로 제작한 월드를 출시할 때 리메이크 허용을 염두에 두고 있다면 리소스를 **Workspace**와 **Resource Storage**와 중 어느 공간에 추가할지도 함께 고려해야 합니다.

## Workspace 리소스 버전

**Workspace**에는 동일한 이름의 파일을 import 하면 해당 리소스의 버전이 올라가게 됩니다. 원본에서 파생된 월드의 Workspace 리소스는 원본에서 복제된 것이기에 각 월드별로 최신화됩니다. 따라서 원본 월드의 리소스가 변경되더라도 파생된 월드의 Workspace 리소스는 바뀌지 않습니다.

> **더 알아보기** '원본에서 파생된 월드'란 아래와 같은 월드를 말합니다. - 리메이크 월드 - 원본 월드를 Export 한 뒤, 새로 Import 하여 생성한 월드

## Resource Storage 리소스 버전

Resource Storage 리소스가 교체되면 리소스 버전이 올라갑니다. ![details](https://mod-file.dn.nexoncdn.co.kr/bbs/16643345214154e11a0d35f614cb5a837c212fbc3b766.png) Resource Storage 리소스가 교체될 경우, 파생된 월드에서도 해당 리소스가 교체됩니다. 따라서 리메이크를 허용할 때 원본 리소스를 변경할 계획이 없다면 어느 곳에 리소스를 추가해도 상관없지만, 변경 가능성이 있다면 **Workspace**에만 리소스를 추가해 사용하는 것을 권장합니다.

Update 2025-11-17 PM 08:14


# 원하는 이펙트 찾기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 리소스 검색

리소스 검색은 현재 웹과 메이커에서 이용할 수 있습니다.

- [MSW 리소스](https://maplestoryworlds.nexon.com/resource)![resource02](https://mod-file.dn.nexoncdn.co.kr/bbs/1666080948482bbe25c0b28bd464fa06c89790f7e2954.png)
- 메이커의 **Resource Storage** 패널 ![resource01](https://mod-file.dn.nexoncdn.co.kr/bbs/165957603963230101d3cac97480285f5496cd808cd84.png)

# 스킬 고유 명칭으로 리소스 찾기

제작 리소스 조회 페이지에서는 여러 태그를 제공하고 있지만 아직 정확도가 높지 않습니다. 검색 시 가장 정확도가 높은 키워드는 **스킬의 고유 명칭**입니다.

예로 스킬 고유 명칭인 **워리어리프**로 검색하면 원하는 검색 결과를 확인하실 수 있습니다. ![skill](https://mod-file.dn.nexoncdn.co.kr/bbs/16747823215038f1d75c4c5514fe6b6a36bba1e7ddcac.png)

> 만약 정확한 스킬 명칭을 모른다면 [링크](https://maplestory.nexon.com/Guide/GameInformation/Skill/4thPromotionAndHyperSkill)에서 도움을 받을 수 있습니다. 참고용으로 사용 부탁드립니다. 크리에이터가 이용하는 커뮤니티 혹은 메이플스토리를 플레이하며 확인할 수도 있습니다.

스프라이트 카테고리에서 원하는 리소스를 찾을 때는 애니메이션 카테고리보다 많은 결괏값이 검색되므로, 의도하는 리소스를 찾기 어려울 수 있습니다. 그러므로 고유 명칭으로 검색해 스프라이트 리소스를 바로 찾기보다는, 태그로 먼저 애니메이션을 찾아 검색 범위를 좁히는 방법을 추천합니다.

# 태그로 리소스 찾기

대부분의 리소스는 태그로 찾을 수 있습니다. 예시로 메이플스토리의 신궁 스킬인 **피어싱** 관련 리소스를 찾아보며, 태그로 리소스를 찾는 방법을 살펴봅시다.

1. 먼저 **피어싱**으로 1차 검색을 하고, 리소스를 찾습니다. ![tag01](https://mod-file.dn.nexoncdn.co.kr/bbs/167478238596993c8ff12e50c46ba870a8f39d40c1048.png)
2. 원하는 리소스를 찾았다면, 클릭해 상세 보기 창을 열고, 관련 태그 중에 **#리소스타입#고유 ID(#skillname#3221017)**를 확인합니다. ![tag02](https://mod-file.dn.nexoncdn.co.kr/bbs/1674782493166fa37020638ce4fed87618c1bd65b97c1.png) 이 태그를 클릭해 검색하면 고유 ID와 연관된 결과만 나오기 때문에 수월하게 리소스를 찾을 수 있습니다.
3. 스킬 고유 ID 태그로 2차 검색을 하고 원하는 리소스를 찾아봅니다. ![tag03](https://mod-file.dn.nexoncdn.co.kr/bbs/1674783583003e107777d03b94cd883ba81dfb2259202.png)

# 스킬 리소스를 사용하는 방법

메이플스토리 월드에서 제공하는 모든 리소스는 고유한 **32자리의 RUID**를 갖고 있습니다. 크리에이터는 컴포넌트나 스크립트에서 RUID로 리소스를 활용할 수 있습니다. ![ruid](https://mod-file.dn.nexoncdn.co.kr/bbs/16747827559611f8ac1d95fae42b6a7a600846407408a.png)

RUID는 대표적으로 **SpriteRendererComponent, SpriteGUIRendererComponent, EffectService**에서 사용합니다. RUID 옆의 ![copy](https://mod-file.dn.nexoncdn.co.kr/bbs/16747829119867539c98fe77f4fabba798c44bc837130.png) **[복사]** 버튼을 누르면 RUID를 쉽게 복사할 수 있습니다.

#### SpriteRendererComponent

월드에 배치되고 이미지를 가진 대부분의 엔티티는 **SpriteRendererComponent**를 갖고 있습니다. 검색한 리소스 RUID를 **SpriteRendererComponent**의 **SpriteRUID** 프로퍼티 값으로 넣으면, 입력한 RUID의 이미지로 변경됩니다. 만약 입력한 **RUID**가 애니메이션이라면, **PlayRate** 프로퍼티의 속도로 **EndFrameIndex**까지 재생한 후 처음 프레임으로 돌아가기를 반복합니다. [SpriteRendererComponent](/apiReference?postId=385)에서 상세한 정보를 확인할 수 있습니다.

![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1637746312852d02d7530fb0e4a4496989389875caa14.png)

#### SpriteGUIRendererComponent

UI에 배치되고 이미지를 가진 대부분의 엔티티는 **SpriteGUIRendererComponent**를 갖고 있습니다. 검색한 리소스 RUID를 **SpriteGUIRendererComponent**의 **ImageRUID** 프로퍼티에 할당하면 이미지가 변경됩니다. **SpriteRendererComponent**와 유사한 방식으로 사용할 수 있으나 원본 사이즈와 비율로 사용하기 위해서는 **PreserveSprite** 프로퍼티의 값을 **NativeSize**로 변경해야 합니다. 만약 **PreserveSprite** 프로퍼티의 값을 **NativeSize**로 설정하면 이펙트의 사이즈와 오프셋은 **LocalScale**, **LocalPosition** 프로퍼티로 조정할 수 있습니다. [SpriteGUIRendererComponent](/apiReference?postId=387)에서 상세한 정보를 확인할 수 있습니다.

![8](https://mod-file.dn.nexoncdn.co.kr/bbs/163774632551686f93d4782234199ae25cd8b6b55a4a8.png)

#### EffectService

**EffectService**를 활용하면 스크립트로 리소스를 호출할 수 있습니다. 자세한 예시는 [EffectService의 Examples](/apiReference?postId=304)에서 살펴봅시다.

사용 예시는 아래와 같습니다.

```
_EffectService:PlayEffect("f396262ddb6e4d5581360496bb4e9f86",self.Entity,Vector3(x,y,0), 0, Vector3(1,1,1))
```

##### 원하는 애니메이션 프레임을 체크해서 사용하는 방법

애니메이션 이펙트를 사용할 때 특정 타이밍에 공격 판정을 하도록 구현하려면 `SpriteAnimPlayerChangeFrameEvent`를 사용합니다.

사용 예시는 아래와 같습니다.

```
Event Handler:
[self]
HandleSpriteAnimPlayerChangeFrameEvent(SpriteAnimPlayerChangeFrameEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ClimbableSpriteRendererComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Sender: SpriteRendererComponent
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local FrameIndex = event.FrameIndex
    -- local ReversePlaying = event.ReversePlaying
    -- local TotalFrameCount = event.TotalFrameCount
    -- local AnimPlayer = event.AnimPlayer
    ---------------------------------------------------------
    
    if FrameIndex == 7 then
        log("7프레임에 공격 판정을 발생시킵니다.")
    end
}
```

##### 참고 가이드

[스킬 이펙트를 뿌려보자!](/docs?postId=70)

Update 2025-11-20 PM 02:03


# 범용 리소스 모음

메이플스토리 월드에서는 원작의 풍부한 리소스를 제공하고 있습니다. 크리에이터는 **Preset List**와 **리소스 스토리지**, **MSW 리소스 조회 페이지**에서 다양한 리소스를 사용할 수 있습니다. 원작 리소스의 양이 워낙 방대하기 때문에 원하는 리소스를 찾기 어려울 때가 종종 있습니다. 크리에이터들이 자주 찾을 만한 리소스를 소개합니다.

> **더 알아보기** 메이플스토리 월드 팀은 보다 편리한 리소스 이용 환경을 만들기 위해 꾸준히 노력하고 있습니다. 여기서 소개되는 리소스는 앞으로 손쉽게 검색할 수 있도록 개선될 예정입니다. 개선 전까지 본 가이드를 참고하시기 바랍니다.

# 스프라이트

### 일반

| 항목 | 이미지 | RUID |
| --- | --- | --- |
| 레벨 업 | ![lvup](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646215203e3c07f2cf18a43f5a742377ef739fa3b.gif) | 486a0ba11a6c474a81d13641876f8808 |
| 동색 메소 | ![meso1](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646291147076c767c53de4a868d7e37da81a134cd.gif) | a724200c454c4fcf878b0a3cdbb706d6 |
| 은색 메소 | ![meso5](https://mod-file.dn.nexoncdn.co.kr/bbs/1675821760863b3d9738df32b41349bd9f79ab5c50770.gif) | 7b417b1a1b0b40469077a4a261b00cbf |
| 금색 메소 | ![meso2](https://mod-file.dn.nexoncdn.co.kr/bbs/16756463753016df288e4ea5844e6bbde89758406e362.gif) | b60c3cbbf52c40709f2fd886d98fe2d9 |
| 지폐 | ![meso3](https://mod-file.dn.nexoncdn.co.kr/bbs/167564643296447042df3012846e7b4c99f060bccff4d.gif) | c3fe3ffa606f41069ce8b36278e9e7e8 |
| 돈주머니 | ![meso4](https://mod-file.dn.nexoncdn.co.kr/bbs/16756464700154c6b1db7f41a4125b9d371b685e486c9.gif) | f0aa7764ff5344848d59accafa2dbf6e |
| 퀘스트 | ![quest](https://mod-file.dn.nexoncdn.co.kr/bbs/1675919811873e0712b9bad70458f8ebd3cec068113ca.gif) | 0f945fc42f6d41548f9a62570e5307df |
| ![quest2](https://mod-file.dn.nexoncdn.co.kr/bbs/16759199274378ca68916aab544bda8a449b6cb99a45d.png) | a4f20dac165944faa255198e9f0b7064 |
| ![bulb1](https://mod-file.dn.nexoncdn.co.kr/bbs/167564728648033530577f62847d694c450882a8dd00a.png) | 002246ff6e3f4a20832ceae8c908dc47 |
| 전구 | ![bulb2](https://mod-file.dn.nexoncdn.co.kr/bbs/1675647317292d3e3e3e1837840dcb8ee2d31e6e751b0.gif) | 4b1bb95e5da64a3a898401e653acea2f |

### 화살표 및 안내

| 항목 | 이미지 | RUID |
| --- | --- | --- |
| 위 화살표 | ![a1](https://mod-file.dn.nexoncdn.co.kr/bbs/167564650741316c0558cba1e47ca8aeb41cdff1318d3.gif) | 621d0abe16e84a79a4e2cd3df1fad1a0 |
| 아래 화살표 | ![a2](https://mod-file.dn.nexoncdn.co.kr/bbs/16756465428386f48e7cbd791474580fc43d6a3b83b4c.gif) | 69701c2acf63415ea922119c25f40982 |
| 왼쪽 화살표 | ![a3](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646578167db8c1f1ff41a4667915898ce00609841.gif) | cdfde5ae11d34639b727210bac3ec56f |
| 아래쪽 화살표 | ![a4](https://mod-file.dn.nexoncdn.co.kr/bbs/167564661312775de2609ccce4493b9ced016548a0afd.gif) | 13266cc409e645ba8502c8e467eefdb5 |
| 포탈 안내 | ![portal](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646655538d8028bcc8c5b4adfab27a081a9c7dd22.gif) | d6811607f46c42f892bbf9fc4944f3d0 |
| 점프 안내 | ![jump](https://mod-file.dn.nexoncdn.co.kr/bbs/16756466929657f5d51bf59494f09850ac62f623f3862.gif) | 9bf47489799f4ccd8fe25ae10800a347 |
| 하향 점프 안내 | ![jump2](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646736426b31c6f751b85440890e5c6db13a8dd48.gif) | 2a3efcde699842d791a52c7894df0134 |
| 스페이스바 안내 | ![space](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646770950b6d2a969799c487d9c1ecb5b6ee90d7e.gif) | 89db1177f546474791bc98f294c71edb |
| 공격 안내 | ![ctrl](https://mod-file.dn.nexoncdn.co.kr/bbs/16756468130729bc19ada914b46f6a6c2a0e758af1d5d.gif) | 4ba7043bf2b545939dffb80aca529f2e |
| X 안내 | ![x](https://mod-file.dn.nexoncdn.co.kr/bbs/1675646845045ef54696149ef4c8495950c2683e98397.gif) | 5b4ba503367b4bdf88f956d75df5fe1f |
| 클릭 | ![click](https://mod-file.dn.nexoncdn.co.kr/bbs/167564688906825e70a64164049c3ab8e675b38f5eba0.gif) | 52e1bebc009f471aa2760e7fb41c552c |
| ![c2](https://mod-file.dn.nexoncdn.co.kr/bbs/16756469352683449caba111843fcafe26df482292689.gif) | d8a422e1d9084f75af9387e26943b62f |
| ![c3](https://mod-file.dn.nexoncdn.co.kr/bbs/167564697108930a0308ef6184f3ca047b5be406545b6.gif) | 71e3d860dfab47f5a0fc929e2c318c23 |
| 메이플스토리 커서 | ![c1](https://mod-file.dn.nexoncdn.co.kr/bbs/16756470769279d546931328847cc828d7223b1941ddc.png) | 3930c5d2e85b4bff8467aada64fda7f5 |
| ![c2](https://mod-file.dn.nexoncdn.co.kr/bbs/16756471255777e7532a3e1ec4ee4abb7247edbcaad2d.png) | 093dd313030e48a28371b68227ba280c |
| ![c3](https://mod-file.dn.nexoncdn.co.kr/bbs/1675647164035baed7724152a4254b15fc4bdea19fa9a.png) | 0783db1be0e54f74ba7824b3a7685fad |
| ![c4](https://mod-file.dn.nexoncdn.co.kr/bbs/16756471943681c565e1f07324c8ba6be637d0cda43a7.png) | 1188b31c01db4af18b269dcd02020d88 |
| ![c5](https://mod-file.dn.nexoncdn.co.kr/bbs/167564722561430c5b54f807b445a84fa96714bd38480.png) | 444a6c0115fd4703a83ad50f31661154 |

### 기타

| 항목 | 이미지 | RUID |
| --- | --- | --- |
| Perfect | ![perfect](https://mod-file.dn.nexoncdn.co.kr/bbs/1675909921375a5bbb49032a84dc080bede7206bbafc1.gif) | 5765fbb4eeaa4d7d89b66d42b22b729c |
| Miss | ![miss](https://mod-file.dn.nexoncdn.co.kr/bbs/167591001450402e9713523344827a42d57290b9ffc56.gif) | 5076d53f3a7441779d9f50ba5d47339d |
| Great | ![great](https://mod-file.dn.nexoncdn.co.kr/bbs/16759100278990ab49e0786224ec39f76204e390a5bce.gif) | 45aa7a057bb4458590b6196796b98817 |
| HIT | ![hit](https://mod-file.dn.nexoncdn.co.kr/bbs/1675648835475a3826ddd5470438db09f3208c01323ba.png) | 12c848efca964eaf953022d13c1c365b |
| 보호막 | ![s](https://mod-file.dn.nexoncdn.co.kr/bbs/1675648890434ff9695de378041bfb26a5cf08818a204.gif) | bb9087a155c048af9fd2833352c6604a |

# 오디오

| 항목 | 설명 | RUID |
| --- | --- | --- |
| 점프 효과음 | 기본 점프 효과음 | d881a73a0700404a91bcf753474274c3 |
| 귀여운 기본 점프 효과음 | dfca55f443464fd5801952efeb50d819 |
| 버튼 효과음 | 기본 버튼 효과음 | 7eda004ded944e459f1fbb16c7f0f3f4 |
| 기본 버튼 효과음2 | cd0bd46d7f454640b82c9dfff0c6677b |
| 버튼 클릭 효과음 | 972843e759204d3e9ad84e7d3fa94f83 |
| 키보드 입력 효과음 | de344b5f1bb444189d57dc52fca2bb14 |
| 카운트다운 효과음 | 기본 카운트다운 | 7ca9fa1a7b384c1caae2449eee77d3ba |
| 째깍째깍 효과음 | d2aa7ffc04c64c97be26de31dcf3cb2c |
| 레벨업 효과음 | 메이플스토리 레벨업 | c198d87b06b24707864b1ac73345cca8 |
| 레벨업 효과음1 | 85009f4dcc7d4536b732aa54b76d05c9 |
| 레벨업 효과음2 | dd47946756f341538f6874dbfc4ce340 |
| 레벨업 효과음3 | 4b0b169b519a42e8803e596911d9f96f |
| Win 효과음 | - | 713eb3fa83e14498b012d6466977989a |
| Lose 효과음 | - | e64a2dfc09f6447a947652d68eaeb047 |
| Draw 효과음 | - | 3a3e72a1b5fa422490f529bbbb6e07bc |
| Start 효과음 | - | 04ca8c287bad49e286bc0feb17cb8824 |
| Game Over 효과음 | - | 27d957fce5214fc5ba7f948661361887 |
| 획득 효과음 | - | 205510b33adf4509b1565ccd4c77d98b |
| 동전 효과음 | - | 21600ec9d3a04cfeb69c6fe0c50e197c |
| 사망 효과음 | - | 8727e134756141c58bf2f525a1598eee |
| 로그인 BGM | - | 877280f8701844378acfa6cee83dfede |

# 아바타

| 항목 | 이미지 | RUID |
| --- | --- | --- |
| 기본 대미지 스킨 | ![d](https://mod-file.dn.nexoncdn.co.kr/bbs/167565054213232e3bf7b4e614706bd834fd7a4db36d1.gif) | 3271c3e79bf04ecba9a107d55495970d |

Update 2025-11-17 PM 08:14


# 패키지의 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 Workspace의 모델, 스크립트 컴포넌트, 데이터 셋과 같은 엔트리를 하나의 파일로 묶어 외부로 공유할 수 있는 패키지 기능을 제공하고 있습니다. Workspace의 엔트리를 패키지 파일로 내보내거나, 패키지 파일을 월드에 불러오는 방법에 대해 알아봅니다.

# 패키지 소개

패키지는 특정 엔트리를 묶은 파일입니다. 패키지 파일을 이용해 제작한 월드의 일부를 외부와 공유하거나, 타인이 공유한 패키지를 내 월드에 사용할 수 있습니다. 패키지 내보내기, 불러오기 창에서는 폴더 구조와 계층 구조 형태로 내용을 확인할 수 있습니다.

- 폴더 구조: Workspace의 구조 대로 엔트리를 보여줍니다.
- 계층 구조: 엔트리를 타입별로 구별해 보여줍니다.

| 폴더 구조 | 계층 구조 |
| --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/171031359711989a5bc8dd99c4e40b4c0298413a26f33.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17103136145179dda4111bd25414698ef8fc0c99a3b7a.png) |

# 패키지 내보내기

1. **Workspace - MyDesk**에서 패키지로 내보낼 엔트리들을 선택합니다.
2. 콘텍스트 메뉴에서 **Export To Package**를 눌러 내보내기 창을 엽니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1710308131839b0ccc1f6757d4c8497b97b6558157c70.png)
3. 엔트리 선택이 완료되면 하단 **[Export]** 버튼을 클릭합니다. 필요한 경우 이름을 변경하고 **[저장]** 버튼을 클릭합니다. ![export](https://mod-file.dn.nexoncdn.co.kr/bbs/1710313472618c2be293f9d514ad5b85ac749245baf1a.png)

# 내보내기 관련 규칙

#### 리소스 내보내기

이미지, 사운드 같은 리소스 엔트리를 패키지에 포함하기 위해서는 월드를 저장해야 합니다. 리소스 엔트리에 포함된 리소스가 월드 저장 시 서버에 업로드되며, 서버에 업로드된 리소스 엔트리들만 패키지로 정상 동작합니다. 리소스 엔트리에는 RUID가 저장되며, 다른 월드에서 해당 패키지를 불러오면 RUID를 통해 서버에 저장된 리소스를 가져오기 때문입니다.

#### 엔트리 상속 관계

부모 - 자식 관계에 있는 엔트리를 패키지로 내보내면 부모 - 자식 관계를 유지합니다. 확장한 엔트리만 선택해 패키지로 내보내면 부모 엔트리를 자동으로 패키지에 포함됩니다. 예를 들어 부모인 Model_EmptyEntity를 확장한 Model_EmptyEntity_child 자식을 만들었다고 생각해 봅시다. Model_EmptyEntity_child만 선택해 패키지로 내보내면, 부모가 함께 포함된 것을 확인할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1711441490696cf0346c49cc348d7abd73a5fff97de99.png)

#### 네이티브 엔트리 제한 사항

메이플스토리 월드에서 제공하는 **네이티브 스크립트와 네이티브 모델**은 패키지로 내보낼 수 없습니다. 네이티브 모델 자체에 새로운 컴포넌트를 추가한 경우, 그 네이티브 모델을 확장한 경우 또한 패키지로 내보낼 수 없습니다. 패키지를 불러올 때 모든 정보를 불러올 수 없기 때문입니다. 예를 들어 네이티브 모델에 ComponentA를 추가하고 이를 확장한 모델을 만들었다고 생각해 봅시다. 이 확장한 모델은 ComponentA를 상속받게 됩니다. 모델B를 다른 월드에서 불러올 때 새로운 월드에는 ComponentA가 포함된 네이티브 모델이 없기 때문에 모델B가 크리에이터의 의도와 다르게 추가될 수 있으므로 패키지로 내보내기가 불가능합니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1711520919542cc7ecbdb36ed4388a710eccb0248ac79.png)

확장한 네이티브 엔트리의 경우 패키지로 내보낼 수 있습니다. 확장한 엔트리가 네이티브 엔트리의 정보를 갖고 있기 때문에 새로운 월드에서 상속받을 네이티브 모델을 자동으로 찾습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17115264454698f2775b2d21349e2adf74871b0d2cda5.png)

네이티브 모델을 상속받은 모델에 새로운 기능을 넣어서 패키지로 만들고 싶다면 확장한 모델에 컴포넌트를 추가하거나, 네이티브 모델 씬에 배치해 편집한 뒤 Create Model From Entity로 만들어 사용하는 것을 권장합니다.

![3](https://mod-file.dn.nexoncdn.co.kr/bbs/171152096321699e779d3b6e14078be21089b366ed7f3.png)

# 패키지 가져오기

1. **Import Package**를 선택한 후 불러올 패키지를 선택합니다. 패키지를 불러오는 방법은 두 가지입니다.
  - **Create - Import Package**를 눌러 불러올 패키지를 선택합니다.
  - **Workspace - Import From - Import Package**를 눌러 불러올 패키지를 선택합니다.
2. 불러올 엔트리를 선택한 후 **[Import]** 버튼을 누릅니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/176164724148389e267f1087f479291a389c266bfb9a0.png)
  > **Tip.** 패키지를 불러올 때 월드는 자동으로 직전 월드 상태를 저장합니다. **File - Rivisions**에서 자동으로 저장된 월드를 확인할 수 있습니다. ![revisions](https://mod-file.dn.nexoncdn.co.kr/bbs/17049588104003484bdc4e4024c41a5a7b513f02ea217.png)

# 가져오기 관련 규칙

패키지를 월드로 가져올 때 엔트리의 변경점에 따라 상태 아이콘이 나타납니다. 기존 월드의 엔트리 내용이 달라질 수 있으니 패키지의 엔트리 상태를 확인하고 패키지를 가져와야 합니다.

| 아이콘 | 설명 |
| --- | --- |
| ![equal](https://mod-file.dn.nexoncdn.co.kr/bbs/17049520316499abe1ca8a9944aafa17e610f838fd71c.png) | 변경된 내용이 없는 엔트리입니다. |
| ![update](https://mod-file.dn.nexoncdn.co.kr/bbs/170495172860025bc9882ab1844618b4839224af7afb5.png) | 내용이 다른 엔트리입니다. 가져올 때 내용을 덮어씌웁니다. |
| ![moved](https://mod-file.dn.nexoncdn.co.kr/bbs/1704952016010a8122bcebacc4831a18be2b30c2f6e21.png) | 현재 월드와 경로가 다른 엔트리입니다. 현재 월드의 경로가 유지됩니다. |
| ![rename](https://mod-file.dn.nexoncdn.co.kr/bbs/1704951745392fd9a4eef1a2a44beb5a7e7f811782655.png) | 이름이 변경된 엔트리입니다. 가져올 때 기존의 엔트리 이름을 변경합니다. |
| ![NameConflict](https://mod-file.dn.nexoncdn.co.kr/bbs/17049517636351f8489cf0bdc424a8066cf85f6207987.png) | 엔트리의 이름은 동일하지만, 유형이 다르거나 다른 크리에이터가 제작해 내용이 다른 엔트리일 수 있습니다. 엔트리를 가져올 수 없습니다. |
| ![IdConflict](https://mod-file.dn.nexoncdn.co.kr/bbs/170495199953619842ee2757d465faee85fa3e285b1c3.png) | 엔트리의 Id는 동일하지만, 타입이 다른 엔트리이거나 다른 크리에이터가 제작해 내용이 다른 엔트리일 수 있습니다. 가져올 수 없습니다. |

Update 2025-11-17 PM 08:14


# 패키지 스토리지

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서 제공하는 패키지와 크리에이터가 생성한 패키지를 저장하고, 관리할 수 있는 패키지 스토리지에 대해 알아봅시다.

##### 참고 가이드

- [패키지의 활용](/docs?postId=647)

# 패키지 카테고리

패키지 스토리지란 개인, 그룹, 메이플스토리 월드가 만든 패키지를 저장하는 보관소입니다. 패키지는 총 두 종류로 나뉩니다.

- **내 패키지**: 개인 제작 월드인 경우 개인이 만든 패키지만 보입니다. 그룹 제작 월드인 경우 그룹에서 만든 패키지만 보입니다.
- **MSW 패키지**: 메이플스토리 월드에서 제공하는 공식 패키지입니다. 패키지를 다운로드받아, 내용을 월드에 맞게 자유롭게 수정할 수 있습니다. 공식 패키지는 지속적으로 추가될 예정입니다.

![[1]](https://mod-file.dn.nexoncdn.co.kr/bbs/custom/1328/Docs_1328_1_ko.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 카테고리 | 패키지 종류를 구분합니다. 내 패키지와 MSW 패키지로 분류됩니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 업로드 버튼 | 패키지를 패키지 스토리지에 새롭게 올릴 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 검색창 | 패키지 이름을 검색할 수 있는 창입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 패키지 정보 | <ul><li>상태 아이콘: 패키지의 상태를 나타내는 아이콘입니다.</li><li>상세 정보: 패키지의 상세 정보를 확인하고, 수정할 수 있습니다.</li><li>적용 버튼: 패키지를 월드에 내려받거나, 패키지 내용을 업데이트할 수 있습니다.</li></ul> |

# 패키지 관리하기

패키지의 내용은 편집 화면에서 관리할 수 있습니다.

![[2]](https://mod-file.dn.nexoncdn.co.kr/bbs/custom/1328/Docs_1328_3_ko.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 이미지 추가 | 섬네일로 사용할 이미지를 추가할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 패키지 정보 | 패키지 이름과 설명을 입력합니다. 이름은 최대 50자, 설명은 최대 1000자까지 입력할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 코어 버전 | 패키지를 업로드하거나 마지막으로 업그레이드할 때의 메이플스토리 월드의 코어 버전입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 등록일 | 마지막으로 패키지를 업그레이드한 일자입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 업그레이드 로그 | 패키지의 업그레이드 기록입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 설치 제거 | 패키지를 설치하거나 제거할 수 있습니다. |

# 코어 버전

코어 버전이란 메이플스토리 월드 메이커의 버전을 의미합니다. 패키지를 저장할 때 코어 버전이 함께 저장됩니다. 코어 버전은 **Edit - Preferences - 만들기 - Version**에서 확인할 수 있습니다. 패키지의 코어 버전과 제작 중인 월드의 코어 버전이 동일하지 않은 경우 메이커가 정상적으로 동작하지 않을 수 있습니다.

# 패키지 등록

1. **Panels - Package Storage**를 선택합니다.
2. **[+]** 버튼을 눌러 **Package Uploader**을 엽니다.
3. 패키지에 포함시킬 엔트리를 선택하고, 이름과 설명을 작성합니다. ![[2]](https://mod-file.dn.nexoncdn.co.kr/bbs/custom/1328/Docs_1328_2_ko.png)
4. 패키지 버전을 입력합니다. 패키지 내용을 수정할 때마다 버전도 함께 변경해 패키지가 수정되었음을 인식할 수 있게 합니다.

# 패키지 설치

1. 패키지를 선택하고, **[업데이트]** 버튼을 누릅니다.
2. **Import Package** 창에서 제작 중인 월드에 적용할 패키지의 엔트리를 선택합니다.
3. **Workspace - MyDesk**에 패키지가 정상적으로 적용되었는지 확인합니다.

# 패키지 업데이트

업데이트는 수정된 패키지를 월드로 가져오는 기능입니다. 다운받았던 패키지의 내용이 변경된 경우 업데이트를 통해 수정된 내용을 가져올 수 있습니다. 패키지 내용과 월드의 엔트리 내용이 다른 엔트리들만 선택해 업데이트할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1761566355082f5d996c6d87e4334895c2b3880ac1993.png)

# 패키지 업그레이드

패키지 스토리지에 추가한 패키지를 수정하고 싶을 때 **업그레이드**를 사용할 수 있습니다. 패키지를 업그레이드할 때는 패키지 버전을 함께 수정하기를 권장합니다. 만약 1.0 버전으로 시작한 경우 1.1 버전, 2.0 버전 등으로 표기해 다른 사용자가 패키지 내용이 변경되었음을 인식할 수 있게 합니다.

1. Package Storage에서 업그레이드할 패키지를 선택하고, **콘텍스트 메뉴 - Upgrade Package**를 선택합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17615660365688a967a6de44f48edaa10038960ef6ff4.png)
2. **Import Package** 창에서 업그레이드할 엔트리를 선택합니다.
3. **업그레이드 로그**와 **패키지 버전**을 입력합니다.
4. [Upgrade] 버튼을 누릅니다.

# 패키지 설치 제거

더 이상 필요하지 않은 경우 패키지 스토리지에서 패키지를 활용해 패키지에 포함된 엔트리를 한 번에 삭제할 수 있습니다. 한 번 삭제된 패키지는 복원할 수 없습니다. 이때 패키지의 엔트리를 기반으로 하는 항목이 남아있는 경우 월드가 정상적으로 동작하지 않을 수 있으므로 삭제 후 월드에 문제가 발생하지 않는지 확인해보아야 합니다.

1. 삭제할 패키지의 섬네일에서 **편집 화면 ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_info_02.png)** 창 버튼을 누릅니다.
2. **설치 제거** 버튼을 누릅니다.
3. **Workspace - MyDesk**에서 패키지의 엔트리들이 제거된 것을 확인합니다.

Update 2025-11-17 PM 08:14


# 그룹 생성과 멤버 관리

# 학습 과정 소개

월드를 함께 만들기 위해서는 그룹에 가입해야 합니다. 그룹을 만들어 팀원들과 함께 월드를 만들 수 있습니다. 협동한다면 내가 잘하는 것에 집중할 수 있고, 새로운 영감이나 번뜩이는 아이디어를 떠올릴 수도 있습니다. 세상에 선보이고 싶은, 아름답고 재미있는 월드를 **함께 만들 사람**을 찾아 그룹에 초대해 봅시다.

# 그룹 관리 소개

메이플스토리 월드 클라이언트와 [공식 홈페이지](https://maplestoryworlds.nexon.com/)에서 그룹을 생성하고, 멤버를 관리할 수 있습니다.

#### 그룹 생성

그룹장은 그룹을 10개까지 만들 수 있고, 그룹마다 인원 제한은 없습니다. 한번 생성된 그룹은 삭제할 수 없습니다.

1. **[월드 만들기] - [+그룹]** 버튼을 클릭합니다.
2. **그룹 이름**을 입력하고 **[다음]** 버튼을 누릅니다. ![Group](https://mod-file.dn.nexoncdn.co.kr/bbs/1682650366279afe2a5bd22dc49cd85b1d4f485fdc2b4.png)

#### 멤버 등급 관리

1. 그룹을 선택하고, **[멤버관리]** 메뉴로 들어갑니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1689813631553716bdb65929d493e8d5db006b48843a5.png)
2. 원하는 멤버의 등급을 조정합니다. 등급을 변경하면 상단의 멤버 현황에 반영됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/175308342240534475ca3483a4f9694dcc8b9e831a4af.png)

> **더 알아보기** 멤버 등급 구분 및 권한에 대한 자세한 내용은 [공동 제작 그룹 멤버의 등급과 권한](/docs/?postId=1077) 가이드를 참고합니다.

#### 그룹장 양도

1. **[멤버관리]** 메뉴에서 원하는 멤버를 선택하고 **[⋮]** 메뉴를 클릭합니다.
2. **[그룹장 양도]** 버튼을 클릭합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1689814837844a0ba1949e5424ecebdc1ad82546c8bf0.png)
3. 팝업 창의 내용을 확인한 후 **[양도]** 버튼을 클릭하면 그룹장 권한 양도가 완료됩니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/168981495670313bf8553e0c9446ca92284f80265d316.png)

#### 멤버 내보내기

그룹장은 멤버를 그룹에서 탈퇴시킬 수 있습니다. 탈퇴 멤버는 그룹의 모든 월드에서 편집 권한을 박탈당합니다.

1. **[멤버관리]** 메뉴에서 삭제할 멤버를 선택하고 **[⋮]** 메뉴를 클릭합니다.
2. **[내보내기]** 버튼을 클릭합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/168981578441839ce171ee1274aecb99ec61e54291fb8.png)

# 그룹 가입 신청

가입하고 싶은 그룹을 발견했다면 먼저 그룹 가입 신청을 할 수도 있습니다. 가입 신청을 하면 그룹장이나 매니저가 가입 허가 여부를 결정할 수 있습니다.

1. 가입을 원하는 그룹 이름을 클릭합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1689826803097e6c4deea9be145f5a5ae56a7e0ca96b0.png)
2. 그룹 정보 페이지에서 **[가입 신청]** 버튼을 클릭합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1689821977348304ef0c631114129b13e0a84b86e08e6.png)

# 접속 중인 멤버 확인

함께 제작하는 그룹 월드에서 **Panels - Cooperation**을 누릅니다. 해당 월드에 함께 접속 중인 사람들의 닉네임과 메이커 아이디가 보입니다. ![CooperationPanel](https://mod-file.dn.nexoncdn.co.kr/bbs/1656652152957d88e3a917e4a44b984a825324ca881f1.png)

Update 2025-10-14 AM 11:47


# 공동 제작

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

다양한 사람들이 함께 모여 월드를 제작할 수 있는 방법에 대해 알아봅시다.

##### 참고 가이드

- [그룹 생성과 멤버 관리](/docs/?postId=1325%22target%22:%22_self%22%7D)
- [공동 제작 그룹 멤버의 등급과 권한](/docs/?postId=1077)
- [LocalWorkspace](/docs/?postId=1165)
- [ExtendedScriptFormat](/docs/?postId=1166)

# 공동 제작

함께 월드를 제작하기 위해서는 우선 그룹을 형성하고, 멤버 권한을 설정해야 합니다. 그룹을 생성하는 방법은 [그룹 생성과 멤버 관리](/docs/?postId=1325)을 참고하세요. 그룹을 생성한 뒤 제작하는 월드의 성격에 따라 크리에이터가 공동 제작 방식을 두 가지 중에 선택해 사용합니다.

1. 월드의 크기가 크거나 작업자의 수가 많은 경우 로컬에서의 공동 제작 방식을 활용해 외부에서 스크립트를 작성하고, 다시 메이플스토리 월드로 싱크 시키는 방법을 사용할 수 있습니다.
2. 월드의 규모가 크지 않거나, 멤버의 작업 현황을 확인하고 싶다면 메이커의 Cooperation 기능을 활용해 메이커에서 월드를 제작할 수 있습니다. 이 방식을 선택하면 메이커에서 다른 사람들이 어떤 작업을 하고 있는지 확인할 수 있습니다.

# LocalWorkspace로 공동 제작

LocalWorkspace를 활용하는 공동 제작 방법은 [LocalWorkspace](/docs/?postId=1165)를 참고하시기를 바랍니다.

# Cooperation으로 공동 제작

Cooperation을 활용한 공동 제작은 월드에 접속 중인 멤버와 함께 메이커에서 동시에 월드를 제작할 수 있습니다.

## 편집 방법

Cooperation을 활용해 엔트리와 엔티티를 편집하는 흐름은 아래와 같습니다.

1. 엔트리 편집 방법
  1. 편집하고자 하는 엔트리를 **Workspace**에서 선택합니다.
  2. 콘텍스트 메뉴에서 **Check Out**을 선택합니다.
  3. 편집을 마쳤으면 **Check In**을 클릭합니다.
  4. 편집한 내용이 월드에 저장됩니다.
2. 엔티티 편집 방법
  1. 편집하고자 하는 엔티티를 **Hierarchy**에서 선택합니다.
  2. 콘텍스트 메뉴에서 **Check Out**을 선택합니다.
  3. 편집을 마쳤으면 **Check In**을 클릭합니다.
  4. 편집한 내용이 월드에 저장됩니다.

### Check Out

Check Out은 편집 권한을 획득하고, 다른 이의 편집 권한을 편집하는 시간 동안 차단하는 기능입니다. 다른 이에게는 **Locked by 닉네임** 상태로 보입니다.

#### 자동 Check Out

Check Out을 선택하지 않고 편집을 시작할 경우, 자동으로 Check Out 되며 편집할 수 있습니다. 반대로 Check Out 된 상태라면 다른 이로부터 Check In 되기 전까지 편집할 수 없습니다.

![FailureMessage](https://mod-file.dn.nexoncdn.co.kr/bbs/1729131999459b6b08a1cae6348bd96a71037cf2e110a.png)

> **Tip.** 단, 엔티티의 경우 편집 단위가 map, ui그룹 단위입니다. 자식 엔티티 편집을 시작하면 부모가 Check Out 됩니다. 예를 들어 map01의 Entity01 편집을 시작하면 Map01이 Check Out 됩니다.

Check Out을 하면 Hierarchy, Workspace에 아래 아이콘이 표시됩니다.

- ![my](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Cooperation/icon_checkout_my.png): 내가 작업 중인 엔트리에 표시됩니다. 작업을 마친 후 **Check In**해야 다른 멤버가 해당 엔트리에 접근할 수 있습니다.![MyCheckIn](https://mod-file.dn.nexoncdn.co.kr/bbs/165951264937121b4736a686643cdb826e73f0ee16ad7.png)
- ![others](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Cooperation/icon_checkout_others.png): 다른 멤버가 해당 엔트리에 영향받는 작업을 진행 중이며, 나에게 반영되지 않은 상태입니다. **작업 중인 멤버가 Check In** 할 때까지 접근할 수 없습니다. ![OthersCheckOut](https://mod-file.dn.nexoncdn.co.kr/bbs/16595126827450aa46fce85ec4a80a07b1c04ae7471d3.png)
  > **Tip** 변경한 사항을 체크인하지 않은 상태에서 다른 맵을 불러온다면 안내 창이 노출됩니다. ![PopUpMessage](https://mod-file.dn.nexoncdn.co.kr/bbs/1705909718818892e96abc9d94a859a5b305ca8641b91.png)

### Check In

Check In은 편집한 내용을 저장하고 다른 멤버들에게 내용을 업데이트시키는 기능입니다. Check In 하면 멤버들의 편집이 허용됩니다. Check In 되지 않은 항목은 폐기되니 주기적으로 Check In 하는 습관을 들이기를 권장합니다.

## 접속 중인 멤버 확인

함께 제작하는 그룹 월드에서 **Panels - Cooperation**을 누릅니다. 해당 월드에 함께 접속 중인 사람들의 닉네임과 메이커 아이디가 보입니다. ![CooperationPanel](https://mod-file.dn.nexoncdn.co.kr/bbs/1656652152957d88e3a917e4a44b984a825324ca881f1.png)

## Local Changes

그룹 월드에서 작업자가 Check Out한 항목을 모아 볼 수 있는 창입니다. Hierarchy, Workspace에서 내가 변경한 항목을 확인하고, 한 번에 **Check In**할 수 있습니다. **Panels - Cooperation - Local Changes**를 눌러 창을 엽니다. ![LocalCheckIn](https://mod-file.dn.nexoncdn.co.kr/bbs/1705907944580466f84660f7043cfa4aad482c7887ac3.png)

## 복구 모드

그룹 월드의 리비전을 되돌리기나 **Import from File** 기능 사용은 월드 전체에 큰 영향을 미칩니다. 이러한 작업은 다른 멤버들이 모두 메이커를 종료한 상태에서 진행하는 것이 안전합니다. 따라서 리비전을 되돌리기나 mod 파일을 Import 하는 것은 복구 모드를 켠 이후에만 진행할 수 있습니다.

#### 복구 모드 켜기

복구 모드는 그룹장 또는 매니저만 켤 수 있습니다. 복구 모드를 켜는 방법은 두 가지입니다.

| 월드 관리 창에서 복구 모드 켜기 | Cooperation 창에서 복구 모드 켜기 |
| --- | --- |
| 로비 - 만들기 - [⋯] 버튼 클릭 - 월드 관리 - 복구 모드 켜기 <br>![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/172717835081730ba5431ab3b4ecbb9a19f42ae76ea84.png) | 메이커 - Panels - Cooperation - Members - 복구 모드 켜기 <br>![2](https://mod-file.dn.nexoncdn.co.kr/bbs/17643101741302a074d63c64f4e4ebc07b85a6a9f543f.png) |

복구 모드를 켜면 체크인하지 않은 작업 내용은 모두 폐기되며, 복구 모드가 해제될 때까지 그룹 월드를 편집할 수 없습니다. 아직 멤버가 메이커에 접속 중일 때 복구 모드를 켜면, 멤버는 아직 Check In 하지 못한 수정 내역을 버리고 로비로 나가야 합니다. 그러므로 되도록 메이커에 접속 중인 멤버가 없는지 확인한 후 복구 모드를 켜는 것이 좋습니다.

> **더 알아보기** 리비전을 기록하고 되돌리는 방법은 [제작한 월드 불러오기 및 관리](/docs/?postId=213) 가이드의 **리비전 관리** 항목을 참고합니다.

Update 2025-11-28 PM 03:09


# 공동 제작 그룹 멤버의 등급과 권한

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

공동 제작의 그룹장은 함께 하는 그룹 멤버를 관리하고 등급을 세분화할 수 있습니다. 그룹 멤버 등급 분류와 등급별 권한을 자세히 살펴봅시다.

##### 참고 가이드

[공동 제작](/docs/?postId=670) [공동 제작 팁](/docs/?postId=766)

# 그룹 멤버 등급

그룹 내 멤버 등급은 아래와 같이 나뉩니다.

| 등급 | 설명 |
| --- | --- |
| 그룹장 | <ul><li>그룹을 최초로 만든 사람에게 부여되는 등급입니다.</li><li>그룹 내 1명만 존재합니다.</li><li>그룹 관리를 위한 모든 권한을 보유합니다. 단, 그룹 탈퇴를 할 수는 없습니다.</li><li>다른 멤버에게 그룹장을 이전할 수 있으며, 다른 멤버가 그룹장이 되면 기존 그룹장은 자동으로 매니저 등급이 됩니다.</li></ul> |
| 매니저 | <ul><li>그룹의 부운영자입니다.</li><li>그룹장 전용 관리 권한 이외의 전반적인 권한을 사용할 수 있습니다.</li></ul> |
| 개발자 | <ul><li>해당 그룹의 월드 제작과 관련된 메이커 기능 대부분을 사용할 수 있습니다.</li></ul> |
| 운영자 | <ul><li>월드 이용자들의 문의사항을 확인하고, 대응할 수 있습니다.</li></ul> |
| 일반 멤버 | <ul><li>그룹에 최초 가입 시 부여되는 등급입니다.</li><li>그룹에서 제작 중인 비공개 월드를 플레이할 수 있습니다. 클로즈드 베타 테스터 역할을 수행할 수 있습니다.</li></ul> |

멤버 등급을 설정하는 방법은 [공동 제작](/docs/?postId=670) 가이드의 **"멤버 등급 관리"** 항목을 참고해 봅시다.

# 등급별 권한

그룹 멤버 등급별로 주어지는 권한은 아래와 같습니다. 그룹장은 아래 내용을 참고하여 각 멤버의 등급을 적절하게 설정할 수 있습니다.

| 기능 설명 | 그룹장 | 매니저 | 개발자 | 운영자 | 일반 | 참고 가이드 |
| --- | :---: | :---: | :---: | :---: | :---: | :---: |
| 멤버 내보내기 | O | O | X | X | X | [공동 제작](/docs/?postId=670) |
| 가입 신청 승인 / 거절 | O | O | X | X | X |
| 매니저 미만 그룹원의 등급 조절 | O | O | X | X | X |
| 매니저 권한 설정 / 삭제 | O | X | X | X | X |
| 그룹 탈퇴 | X | O | O | O | O |
| 그룹의 신규 월드 생성 | O | O | X | X | X |
| 그룹 소속의 출시 전 월드 삭제 | O | O | X | X | X |
| 그룹의 비출시 / 비공개 월드 열람, 플레이 | O | O | O | O | O |
| 그룹 월드를 메이커로 편집 | O | O | O | X | X |
| 리소스 스토리지에서 그룹 소유 리소스 열람, 추가, 수정 | O | O | O | X | X | [리소스 관리](/docs/?postId=690) |
| 그룹 소유 리소스 공유 설정 변경 | O | O | X | X | X |
| 그룹 소유 리소스 제거 | O | O | X | X | X |
| 월드 출시 / 출시 해제, <br>공개 / 비공개 상태 수정 | O | O | X | X | X | - |
| 월드 이름, 설명, 공지사항 추가 및 수정 | O | O | X | X | X |
| 엔트리와 엔티티 생성, 편집, 삭제, 체크아웃, 체크인 | O | O | O | X | X |
| 월드 복구 모드 켜기 | O | O | X | X | X | [공동 제작](/docs/?postId=670) |
| (내가 켜지 않은) <br>월드 복구 모드 해제 | O | X | X | X | X |
| MOD 파일 Import/Export | O | O | X | X | X | [공동 제작 팁](/docs/?postId=766) |
| 리비전 수동으로 남기거나 메모 편집 | O | O | O | X | X | [제작한 월드 불러오기 및 관리](/docs/?postId=213) |
| 리비전 목록 열람 | O | O | O | X | X |
| 리비전 삭제 | O | O | X | X | X |
| 특정 리비전으로 롤백 | O | O | X | X | X |
| 월드 번역 페이지 접근 | O | O | O | X | X | [월드 정보와 배지, 상품 번역하기](/docs/?postId=971) |
| LocaleDataSet 동기화 권한 | O | O | O | X | X | [LocaleDataSet](/docs/?postId=1120) |
| 월드 전용 상품 목록 열람 | O | O | O | X | X | [상품 등록하기](/docs/?postId=581) <br>[상품 관리하기](/docs/?postId=658) |
| 월드 전용 상품 등록 / 수정 | O | O | X | X | X |
| 월드 배지 목록 보기 | O | O | O | X | X | [배지 등록하기](/docs/?postId=656) <br>[배지 관리하기](/docs/?postId=663) |
| 월드 배지 등록 | O | O | X | X | X |
| 월드 마이그레이션 | O | O | X | X | X | - |
| 로컬 워크스페이스 활성화 | O | O | X | X | X | [LocalWorkspace](/docs/?postId=1165) |
| 로컬 워크스페이스 비활성화 | O | O | X | X | X |
| 리모트 워크스페이스로 동기화 | O | O | X | X | X |
| 로컬 워크스페이스 출시 | O | O | X | X | X |
| 월드 CS 문의 목록 조회 | O | O | X | O | X | - |
| 월드 CS 문의 읽기/답변 | O | O | X | O | X |
| 월드 성과 지표 열람 | O | O | X | X | X |

Update 2025-11-17 PM 08:14


# LocalWorkspace

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

##### **LocalWorkspace는 프리뷰 기능으로 정식 출시 시 기능이 변경될 수 있습니다.**

# 학습 과정 소개

로컬 워크스페이스는 크리에이터가 제작하는 월드 데이터를 내 컴퓨터로 내려받을 수 있는 기능입니다. 로컬 워크스페이스를 사용하고, 메이커와 동기화해 월드를 제작하는 방법을 알아봅시다.

##### 참고 가이드

- [공동제작](/docs/?postId=670)
- [공동 제작 그룹 멤버의 등급과 권한](/docs/?postId=1077)
- [WorldConfig](/docs/?postId=1101)
- [LocalWorkspace 활용](/docs/?postId=1166)

# 로컬 워크스페이스 소개

**로컬 워크스페이스**란 월드 데이터를 크리에이터의 컴퓨터(Local)로 내려받을 수 있는 기능입니다. 월드의 다양한 엔트리와 데이터를 크리에이터의 컴퓨터에 파일 형태로 저장합니다. 로컬 워크스페이스 기능을 활용해 컴퓨터에 저장한 파일은 크리에이터의 제작 방식에 따라 다양하게 활용할 수 있습니다. 비상시를 대비한 백업 파일용으로 저장하거나, 그룹에서 공용으로 파일을 관리하거나, 형상 관리 도구와 함께 사용해 파일을 관리할 수도 있습니다.

> **주의!** **LocalWorkspace는 preview 기능으로 안정성을 보장하지 않습니다. 사용 중 버그가 발생할 수 있으며, 추후 정식 버전 도입 시 기능이 정지될 수도 있습니다. 그러므로 LocalWorkspace를 비활성화한 상태로 월드를 제작할 수 있도록 백업 파일, 백업 월드를 만들어 두는 것을 권장합니다.**

# 개인의 로컬 워크스페이스 활성화

1. **Workspace - WorldConfig - LocalWorkspace**를 활성화합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1718943333689397acd2763cb44bba91abfa9a163d1e4.png)
2. 폴더 선택 창에서 파일을 저장할 위치를 선택합니다.
3. 지정한 폴더를 열어 월드의 파일이 다운로드되었는지 확인합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17189433493352cf95e72a7db436d89fbd2a87eb093c2.png)
4. 메이커에서 월드를 수정하거나, 새로운 스크립트 엔트리를 추가하면 지정한 폴더에 저장됩니다.

# 그룹의 로컬 워크스페이스 활성화

로컬 워크스페이스 기능을 최초로 활성화할 수 있는 권한은 **그룹장과 매니저**에게 있습니다. 그룹원은 로컬 워크스페이스의 path만 지정할 수 있습니다.

#### 그룹장, 매니저

로컬 워크스페이스는 공동 제작 월드에서 활성화할 수 있으며, 그룹장과 매니저만 활성화할 수 있습니다. LocalWorkspace를 활성화하면, 크리에이터가 지정한 위치에 월드의 데이터가 다운로드 됩니다. LocalWorkspace를 활성화하는 방법은 다음과 같습니다.

1. **Panels - Cooperation - Members**에서 복구 모드를 활성화합니다. 복구 모드를 활성화하면 그룹원은 월드를 수정할 수 없습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1718943320876d4fdf86c67f2483e974e5e0cef47768a.png)
  > **Tip** 복구 모드를 활성화하기 전에 그룹원 모두는 작업물을 모두 체크인해야 합니다. 작업 내용이 사라지지 않도록 별도 파일로 저장해 두는 것을 권장합니다.
2. **Workspace - WorldConfig - LocalWorkspace**를 활성화합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1718943333689397acd2763cb44bba91abfa9a163d1e4.png)
3. 폴더 선택 창에서 파일을 저장할 위치를 선택합니다. 다운로드가 완료되면 공동 제작 상태가 해제됩니다.
4. 지정한 폴더를 열어 월드의 파일이 다운로드되었는지 확인합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17189433493352cf95e72a7db436d89fbd2a87eb093c2.png)
5. 월드 파일을 함께 제작할 수 있도록 그룹원에게 공유합니다.
6. 메이커에서 월드를 수정하거나, 새로운 스크립트 엔트리를 추가하면 지정한 폴더에 저장됩니다.

#### 그룹원

그룹원은 그룹장 혹은 매니저가 공유한 월드 파일을 자신의 컴퓨터에 내려받습니다. 그 후 로컬 워크스페이스가 활성화된 월드에 그룹원이 최초 입장하면, 폴더 선택창이 나타납니다. 그룹원은 자신의 컴퓨터에서 로컬 워크스페이스로 사용할 위치를 지정하고, 메이커에서 월드를 수정할 수 있습니다.

1. 그룹에서 공유하는 월드 데이터를 다운 받습니다.
2. 폴더 선택창에서 다운 받은 월드 데이터 폴더 위치를 지정합니다.

# 로컬 워크스페이스 사용

#### 로컬 워크스페이스 폴더

LocalWorkspace를 활성화하면 월드 데이터는 4개의 폴더에 구분되어 다운로드됩니다.

| 이름 | 설명 |
| --- | --- |
| Global | 월드의 다양한 엔트리가 포함된 폴더입니다. |
| map | Hierarchy의 maps 엔트리 폴더입니다. |
| RootDesk | Workspace - MyDesk의 엔트리들이 포함된 폴더입니다. |
| ui | Hierarchy의 ui 엔티티 폴더입니다. |

#### 로컬 워크스페이스와 리모트 워크스페이스

로컬 워크스페이스를 사용하게 되면 로컬 워크스페이스와 리모트 워크스페이스로 저장소가 구분됩니다. 크리에이터는 기본적으로 로컬 워크스페이스와 메이커를 필요에 따라 동기화하며 월드를 제작합니다. Revision 기록, 월드 출시가 필요할 때 리모트 워크스페이스와 로컬 워크스페이스를 동기화합니다.

#### 메이커를 로컬로 동기화

월드를 저장하면 크리에이터가 지정한 위치에 메이커에서 저장한 내용이 로컬 파일로 동기화됩니다.

> **주의!** 워크스페이스의 엔트리나 폴더 이름이 OS에서 허용하지 않는 규칙으로 설정된 경우, 로컬로 저장할 때 문제가 발생할 수 있습니다. 로컬워크스페이스를 활성화하기 전에 아래 조건에 해당하는 이름이 있는지 점검하고 문제를 수정해야 합니다. - **`<` (작음 기호), `>` (큼 기호), `:` (콜론), `"` (큰따옴표), `/` (슬래시), `\` (역슬래시), `|` (수직선), `?` (물음표), `*` (별표)**- 예약어 **CON, PRN, AUX, NUL, COM1~COM9, LPT1~LPT9** 사용 - 파일, 폴더 이름의 시작 혹은 끝에 **마침표, 공백**- 전체 경로를 포함해 **255자 초과**

#### 로컬을 메이커로 동기화

Hierarchy, Workspace의 콘텍스트 메뉴에서 **Refresh, Reimport, ReimportAll**을 상황에 맞게 선택해 사용할 수 있습니다. 메이플스토리 월드를 종료한 상태에서 월드 파일을 다운로드 받은 뒤, 메이커에서 월드를 불러오면 자동으로 로컬의 파일을 불러와 동기화합니다. 메이커를 실행 중인 상황에서 형상 관리 도구로부터 월드 메타데이터 파일을 다운로드 받은 경우라면, 상황에 따라 크리에이터가 직접 로컬 폴더의 데이터를 메이커로 동기화시켜야 합니다.

| 이름 | 설명 |
| --- | --- |
| Refresh | 로컬 워크스페이스에서 변경점이 있는 파일만 메이커에서 새로고침하고 불러옵니다. |
| Reimport | 개별 스크립트 또는 Dataset 엔트리의 로컬 변경점을 메이커에 반영합니다. |
| Reimport All | 로컬 워크스페이스의 Hierarchy, Workspace의 모든 파일을 반영합니다. 개별 파일만 불러왔으나 오류가 발생했다면 Reimport All을 시도해 해결할 수 있습니다. 모든 파일을 불러온 후 월드를 재로딩합니다. |

> **주의!** **로컬 워크스페이스에 다운로드한 파일은 고유한 정보를 가지고 있으므로 특정 파일을 로컬에서 직접 복사하거나 편집하는 것은 지양해야 합니다. 임의로 수정된 파일로 인해 동기화 오류가 발생할 수 있습니다.** **단, mLua 파일의 경우 mlua VS Code Extension을 사용하면 안정적으로 편집할 수 있으며, CSV 파일은 자유로운 수정이 가능합니다.**

#### 리모트 워크스페이스로 동기화

크리에이터는 LocalDataset 동기화, Revisions 기록 등을 위해 메이플스토리 월드의 DB에 월드 데이터를 저장할 수 있습니다. **File - Sync to Remote Workspace**를 선택하면 로컬 파일이 리모트 워크스페이스로 동기화됩니다. Revision에는 동기화 직전의 메이커 데이터가 기록됩니다. 그룹 월드의 경우 리모트 워크스페이스로 동기화는 **그룹장과 매니저**만 가능합니다.

#### 월드 출시

월드를 출시할 때는 출시 시점의 최신 로컬 워크스페이스 내용을 리모트 워크스페이스에 동기화시킵니다. 메이커의 수정 파일이 로컬에 저장되지 않은 경우 메이커를 로컬로 동기화한 뒤, 로컬을 리모트 워크스페이스로 동기화하고 월드를 출시합니다. 로컬 워크스페이스를 사용하는 그룹 월드의 경우 **그룹장과 매니저**만 출시가 가능합니다.

# 개인의 로컬 워크스페이스 비활성화

로컬 워크스페이스를 더는 사용하지 않거나, 실수로 로컬 워크스페이스를 활성화했을 경우 이를 해제할 수 있습니다. 이때 로컬 워크스페이스의 데이터를 리모트 워크스페이스로 모두 저장한 후 로컬 워크스페이스를 비활성화합니다.

- **Workspace - WorldConfig - LocalWorkspace**를 비활성화합니다.

# 그룹의 로컬 워크스페이스 비활성화

그룹의 로컬 워크스페이스를 비활성화할 경우 메이커는 다시 공동 제작 상태로 변경됩니다.

1. **Workspace - WorldConfig - LocalWorkspace**를 비활성화합니다.
2. 메이커가 공동 제작 상태로 변경되었는지 확인합니다.

# 로컬 워크스페이스와 파일 공유 도구

로컬 워크스페이스와 함께 별도의 파일 공유 도구를 활용하면 보다 효율적으로 월드를 제작할 수 있습니다. 그룹 월드의 경우 로컬 워크스페이스를 활성화한 뒤에는 더 이상 공동 제작 기능을 사용하는 월드가 아니므로 메이커 안에서 그룹원끼리 변경점을 동기화할 수 없습니다. 그러므로 별도로 파일을 공유하고, 내려받을 수 있는 공용 저장소가 필요합니다. 클라우드 저장소, 형상 관리 도구(svn, git)를 활용하면 공동으로 월드 데이터의 변경점을 기록하고, 관리할 수 있을 뿐만 아니라 필요한 파일만 메이커에 별도로 반영해 개별 테스트할 수 있습니다.

# 로컬워크스페이스와 VS Code 연동

VS Code 연동 기능을 활성화하면 메이커에서 선택한 항목의 mLua 파일이 자동으로 VS Code에서 열리게 됩니다. **LocalWorkspace**와 **UseExtendedScriptFormat**을 모두 활성화하면, **File - Setting - 만들기**에 **LocalWorkspace** 항목이 추가됩니다. 이 항목의 활성화해 VS Code를 연동할 수 있습니다. VS Code 연동 옵션은 **Windows**에서만 지원합니다. VS Code를 연동하면, `.vscode` 폴더, `.code-workspace` 파일, `launch.json` 파일을 로컬워크스페이스 폴더 하위에 생성할 수 있습니다.

> **Tip.** 연동된 상태에서 발생하는 **Console, Build Console**의 **로그 메시지**의 줄 번호는 VS Code의 줄 번호로 표시됩니다.
> **Tip.** `launch.json` 파일은 VS Code Debugger 사용 시 필요한 파일입니다. 자세한 내용은 [Debugger for mLua](/docs?postId=1323)에서 확인할 수 있습니다.

#### VS Code 연동 활성화

1. **File - Setting - 만들기 - LocalWorkspace**에서 VS Code 연동을 활성화합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1749630358982ac6b8c65696741b28a12ad2428ad56f7.png)
2. VS Code가 연동되면 VS Code의 `Code.exe` 경로가 자동으로 설정됩니다. 만약 경로가 설정되지 않았다면 **[경로 설정]** 버튼을 눌러 직접 설정합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/17496303719117441164073524d468e5e7ae84208dbd5.png)

#### 스크립트 메이커에서 확인

VS Code와 연동된 월드는 메이커에서 모든 항목이 **읽기 전용**으로 변경되어 메이커에서 직접적으로 스크립트를 수정할 수 없게 됩니다. 만약 메이커에서 스크립트를 확인하고 싶은 경우 **콘텍스트 메뉴 - Open In Script Editor(Read Only)를** 눌러 메이커에서 읽을 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17496310661647421ad7e3f2b40c799cbfbb98ca75a0d.png)

Update 2025-11-19 AM 09:35


# ExtendedScriptFormat

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

##### **ExtendedScriptFormat은 프리뷰 기능으로 정식 출시 시 기능이 변경될 수 있습니다.**

# 학습 과정 소개

확장된 스크립트 포맷을 사용하는 방법과 mlua 파일 형식 정의를 알아봅시다.

##### 참고 가이드

- [공동제작](/docs/?postId=670)
- [공동 제작 그룹 멤버의 등급과 권한](/docs/?postId=1077)
- [WorldConfig](/docs/?postId=1101)
- [LocaWorkspace](/docs/?postId=1165)

# 확장된 스크립트 포맷 소개

로컬 워크스페이스의 **확장된 스크립트 포맷**(UseExtendedScriptFormat)을 활성화하면 메타데이터 파일과 쌍을 이루는 **mlua 파일**을 생성합니다. 확장된 스크립트 포맷은 Plain Text 형식이므로 파일 공유 도구에서 파일 병합 시 충돌이 발생하더라도 문제 지점을 더욱 수월하게 발견할 수 있습니다.

> **주의!** **UseExtendedScriptFormat은 preview 기능으로 안정성을 보장하지 않습니다. 사용 중 버그가 발생할 수 있으며, 추후 정식 버전 도입 시 preview 기능이 정지될 수도 있습니다. 백업 파일 혹은 백업 월드를 만들어 두는 것을 권장합니다.**

# 확장된 스크립트 포맷 활성화

1. **WorldConfig - LocalWorkspace - UseExtendedScriptFormat**를 활성화합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1718965223446aece1d91f1aa4b5289f10318668c8d55.png)
2. LocalWorkspace로 지정한 경로의 폴더에 Environment 폴더와 mlua 파일이 생성된 것을 확인할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/171896527924681d2c04cdc794423bfbf09033535d3b1.png)

# 확장된 스크립트 포맷 비활성화

UseExtendedScriptFormat는 한 번 활성화되면 비활성화 상태로 되돌릴 수 없습니다. 로컬 워크스페이스 자체를 비활성화 해야합니다. 로컬 워크스페이스를 비활성화하는 방법은 다음과 같습니다.

1. 로컬 파일을 문제점 이전의 상태로 변경합니다.
2. 메이플스토리 월드 메이커에서 **ReimportAll**을 선택합니다.
3. **File - Sync To Remote Workspace**를 선택해 현재 로컬 파일을 리모트 워크스페이스에 동기화합니다.
4. 로컬 폴더에서 **Global - WorldConfig.config** 파일을 엽니다.
5. 내용 중 **"UseExtendedScriptFormat": true**를 **"UseExtendedScriptFormat": false**로 변경하고, 저장합니다.
6. 메이플스토리 월드 메이커에서 **ReimportAll**을 다시 선택합니다.
7. 메이커에서 UseExtendedScriptFormat이 비활성화 상태인 것을 확인합니다.
8. **LocalWorkspace**를 비활성화합니다.
9. **File - Revisions**에서 문제 발생 이전 버전을 선택해 되돌립니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1718965862199daceebf0e47e4de2a75198f96ca02477.png)

# mlua 파일 소개

mlua 파일은 일정한 형식으로 정의되어 있습니다.

> **주의! 메이커에서 지원하지 않는 기능을 mlua에서 임의로 사용하는 것은 권장하지 않습니다. 현재는 정상 동작하는 것처럼 보일 지라도 추후에 동작하지 않도록 변경될 수 있으니 주의 바랍니다.**

#### 스크립트 엔트리 정의

스크립트 엔트리는 하나의 부모로부터 상속받을 수 있으며, 같은 종류의 스크립트 엔트리끼리만 상속이 가능합니다. 스크립트 엔트리 중 **Component, Item, BTNode, State, Logic**은 상속 받은 부모의 정보가 필수적입니다. 스크립트 엔트리에서 정의 가능한 스크립트 종류는 아래와 같습니다.

- Component
- Item
- BTNode
- State
- Logic
- Event
- Struct

```
@스크립트 종류
script 이름 extends 상속
end
```

스크립트 엔트리 정의 예시입니다.

```
@Component
script NewComponent extends Component
end
```

#### 프로퍼티 정의

프로퍼티 정의 구성은 다음과 같습니다.

```
Property 타입 프로퍼티이름 = 기본값
```

프로퍼티 정의 예시입니다.

```
Property number NewProperty = 5
```

#### 메소드 정의

메소드는 정의 구성은 다음과 같습니다.

```
method 반환타입 메소드이름 (매개변수타입 매개변수이름)
```

메소드 정의 예시입니다.

```
method void TestMethod(float parameter)
```

#### 이벤트 핸들러 정의

이벤트 핸들러는 EventSender Attribute를 필수로 사용합니다.

```
@EventSender("Self")
handler 핸들러이름(이벤트타입 event)
```

이벤트 핸들러 정의 예시입니다.

```
@EventSender("Self")
handler HandleButtonClickEvent(ButtonClickEvent event)
```

#### 어트리뷰트 정의

어트리뷰트의 매개변수가 필요하지 않은 경우 생략할 수 있습니다.

```
@이름()
@이름(매개변수)
```

어트리뷰트 정의 예시입니다.

```
@EventSender()
@EventSender("Self")
```

Update 2025-12-01 PM 04:21


# mLua

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

##### **mLua는 프리뷰 기능으로 정식 출시 시 기능이 변경될 수 있습니다.**

# 학습 과정 소개

메이플스토리 월드 메이커를 벗어나 외부 편집기에서 스크립트를 작성하기 위해서는 mLua 문법에 맞게 작성해야 합니다. mLua의 문법에 대해 알아봅시다.

##### 참고 가이드

[LocalWorkspace](/docs/?postId=1165) [ExtendedScriptFormat](/docs/?postId=1166) [mLua Extension](/docs?postId=1209) [공동 제작](/docs/?postId=670)

# mLua

MSW 메이커의 스크립트 엔트리를 표현하기 위한 프로그래밍 언어입니다.

# 정의문

## 스크립트 정의문

스크립트 정의문을 사용하여 스크립트를 정의할 수 있습니다. 스크립트 정의문의 문법은 다음과 같습니다.

```
script 타입이름

end
```

상속 관계가 있다면 extends를 붙여 어떤 타입으로부터 상속받았는지 명시할 수 있습니다. extends가 있는 스크립트 정의문의 문법은 다음과 같습니다.

```
script 타입명 extends 타입명
 
end
```

## 프로퍼티 정의문

프로퍼티 정의문을 통해 스크립트의 프로퍼티를 정의할 수 있습니다. 프로퍼티 정의문에서 우측 식은 일부 타입을 제외하고 반드시 작성해야 합니다. SyncTable 타입은 할당이 불가능한 타입이므로 우측 식 작성을 생략합니다.

```
property 타입명 이름 = 식
```

## 메소드 정의문

메소드 정의문을 통해 스크립트의 메소드를 정의할 수 있습니다. 메소드 정의문의 문법은 다음과 같습니다.

```
method 빈환타입명 메소드이름(파라미터타입명 파라미터이름)

end
```

**사용 예시**

```
method string NewMethod(number num)
    return ""
end
```

## 이벤트 핸들러 정의문

이벤트 핸들러 정의문을 통해 스크립트의 이벤트 핸들러를 정의할 수 있습니다. 이벤트 핸들러 정의문 문법은 다음과 같습니다.

```
handler 핸들러이름(이벤트타입명 파라미터이름)

end
```

**사용 예시**

```
handler HandleEvent(KeyDownEvent event)

end
```

## Attribute문

Attribute문을 사용해 스크립트, 멤버에 다양한 기능을 지정할 수 있습니다. 하나의 멤버에 복수의 Attribute문을 사용할 수 있습니다. Attribute문 문법은 다음과 같습니다.

```
@AttributeName
```

**사용 예시**

```
@Sync
property string NewValue = nil
```

Attribute는 파라미터가 있을 수 있습니다. 파라미터가 있는 Attribute문의 문법은 다음과 같습니다.

```
@AttributeName(인수)
```

**사용 예시**

```
@ExecSpace("Server")
method void OnBeginPlay()

end
```

# Attribute

mLua에서 스크립트 멤버에 동기화, 실행제어, 최솟값, 최댓값과 같은 기능을 적용하려면 Attribute를 사용해야 합니다. 하나의 멤버에 복수의 Attribute를 지정할 수 있습니다.

#### Sync Attribute

프로퍼티에 동기화 여부를 지정합니다. 적용 대상은 **프로퍼티**입니다. 적용 대상은 **동기화 가능한 Property 타입의 프로퍼티**입니다. 적용 가능 타입은 **Component, Logic, BTNode**입니다.

- 매개 변수: **없음**

```
@Sync
Property string NewValue = nil
```

#### TargetUserSync Attribute

특정 타겟에 대한 동기화 여부를 지정합니다. 적용 대상은 **동기화 가능한 Property 타입의 프로퍼티, 컴포넌트**입니다.

- 매개 변수: **없음**

```
@TargetUsrSync
```

#### ExecSpace Attribute

메소드와 이벤트 핸들러의 실행제어 공간을 지정합니다. 파라미터는 string으로 지정된 문자열로만 사용이 가능합니다. 적용 대상은 **메소드, 이벤트 핸들러**입니다. 적용 가능 타입은 **Component, Logic**입니다.

- 매개 변수: **string** ("Server", "Client", "ServerOnly", "ClientOnly", "Multicast")

```
@ExecSpace("Client")
@ExecSpace("Server")
@ExecSpace("ServerOnly")
@ExecSpace("ClientOnly")
@ExecSpace("Multicast")
```

#### EventSender Attribute

이벤트 핸들러의 이벤트 발송 객체를 지정합니다. 적용 대상은 **이벤트 핸들러**이며 반드시 EventSender Attribute를 사용해야 합니다. 파라미터는 string으로 지정된 문자열로만 사용이 가능합니다.

- 매개 변수: **string** ("Self", "Entity", "Model", "LocalPlayer", "Service", "Logic"), **string**(optional)

> **Tip** 첫 번째 매개변수로 사용하는 string에 따라 두 번째 매개변수로 사용할 수 있는 값이 달라집니다. - "Entity", "Model": 두 번째 파라미터로는 **Entity Id**를 입력해야 합니다. - "Service", "Logic": 두 번째 파라미터로는 **타입명**을 입력해야 합니다. - "Self", "LocalPlayer": 두 번째 파라미터를 사용하지 않습니다.

```
@EventSender("Service", "InputService")
handler handleEvent(keyDownEvent event)

end
```

#### DisplayName Attribute

MSW 메이커의 프로퍼티 에디터에 표시되는 이름을 지정합니다. 적용 대상은 **프로퍼티**입니다.

- 매개 변수: **string**

```
@DisplayName("Test Value")
property string NewValue = nil
```

#### Description Attribute

MSW 메이커의 프로퍼티 에디터에 툴팁으로 표시되는 설명입니다. 적용 대상은 **프로퍼티**입니다.

- 매개 변수: **string**

```
@Description("Property Description")
property string NewValue = nil
```

#### HideFromInspector Attribute

MSW 메이커의 프로퍼티 에디터에 표시할 것인지 여부를 지정합니다. 적용 대상은 **프로퍼티**입니다.

- 매개 변수: **string**

```
@HideFromInspector
property string NewValue = nil
```

#### MinValue Attribute

MSW 메이커의 프로퍼티 에디터에 최솟값을 지정합니다. 적용 대상은 **number, integer 타입의 프로퍼티**입니다.

- 매개 변수: **number**

```
@MinValue(2)
property number NewValue = 3
```

#### MaxValue Attribute

MSW 메이커의 프로퍼티 에디터에 최댓값을 지정합니다. 적용 대상은 **number, integer 타입의 프로퍼티**입니다.

- 매개 변수: **number**

```
@MaxValue(10)
property number NewValue = 3
```

#### Delta Attribute

MSW 메이커의 모바일 프로퍼티 에디터에서 좌우 버튼을 눌렀을 때의 변화량을 지정합니다. 적용 대상은 **number, integer 타입의 프로퍼티**입니다.

- 매개 변수: **number**

```
@Delta(1)
property number NewValue =3
```

#### MaxLength Attribute

MSW 메이커의 프로퍼티 에디터에 최대 길이를 지정합니다. 적용 대상은 **string 타입의 프로퍼티**입니다.

- 매개 변수: **integer**

```
@MaxLength(5)
property string NewVlaue = "test"
```

#### Component Attribute

스크립트를 Component로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@Component
script NewComponent extends Component
```

#### Event Attribute

스크립트를 EventType으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@Event
script NewEvent extends EventType

end
```

#### Item Attribute

스크립트를 ItemType으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@Item
script NewItem extends Item

end
```

#### BTNode Attribute

스크립트를 BTNodeType으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@BTNode
script NewBTNode extends BTNode

end
```

#### State Attribute

스크립트를 StateType으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@State
script NewState extends StateType

end
```

#### Struct Attribute

스크립트를 StructType으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@Struct
script NewStruct

end
```

#### Logic Attribute

스크립트를 Logic으로 지정합니다. 적용 대상은 **스크립트**입니다.

- 매개 변수: **없음**

```
@Logic
script NewLogic extends Logic

end
```

# Annotation

어노테이션은 코드에 추가하여 사용하는 일종의 메타데이터입니다. `---@` 형태로 어노테이션을 작성하면 실제 코드를 작성할 때 다양한 도움을 줄 수 있습니다.

#### Type Annotation

Type Annotation은 타입을 명시적으로 지정할 수 있습니다. 할당문과 프로퍼티 정의문에 사용할 수 있습니다.

```
---@type TYPE
```

**사용 예시**

```
---@type string
local testValue = "test"
```

```
---@type string, integer
local strValue, intValue = "str", 5
```

#### Param Annotation

Param Annotation은 대상이 되는 함수의 매개 변수 타입을 지정할 수 있습니다. 함수 정의문에 사용합니다.

```
---@param param_name PARAM_TYPE
```

**사용 예시**

```
---@param testParamA Entity
local function TestFunction(testParamA)
end
```

```
---@param testParamA Entity
---@param testParamB integer
local function TestFunction(testParamA, testParamB)

end
```

#### Return Annotation

Return Annotation은 대상 함수의 반환 타입을 지정할 수 있습니다. 함수 정의문, 메소드 정의문에 사용할 수 있습니다. Return Annotation은 대상 함수의 반환 타입을 지정하여 스크립트 어시스트의 도움을 받을 수 있습니다.

```
---@return TYPE
```

**사용 예시**

```
---@return Entity
local function TestFunction(testParamA, testParamB)
    return self.Entity
end
```

```
---@return Entity, string
local function TestFunction(testParamA, testParamB)
    return self.Entity, "strValue"
end
```

#### Deprecated Annotation

Deprecated Annotation을 사용해 더 이상 사용하지 않음을 명시할 수 있습니다. 스크립트 정의문, 프로퍼티 정의문, 메소드 정의문, 이벤트 핸들러 정의문에 사용할 수 있습니다.

```
---@deprecated
```

**사용 예시**

```
---@deprecated
property any NewValue = nil
```

#### Sealed Annotation

Sealed Annotation은 해당 멤버가 더이상 오버라이드되지 않음을 명시합니다. 프로퍼티 정의문, 메소드 정의문, 이벤트 핸들러 정의문에 사용할 수 있습니다.

```
---@sealed
```

**사용 예시**

```
---@sealed
property any NewValue = nil
```

#### Description Annotation

Description Annotation은 툴팁에 표시할 설명을 작성할 수 있습니다. 스크립트 정의문, 프로퍼티 정의문, 메소드 정의문, 이벤트 핸들러 정의문에 사용할 수 있습니다.

```
---@description "Test"
```

**사용 예시**

```
---@description "Test Value"
property any NewValue = nil
```

Update 2025-11-19 AM 11:33


# VS Code: mLua Extension

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

##### **VS Code: mLua Extension은 프리뷰 기능으로 정식 출시 시 기능이 변경될 수 있습니다.**

# 학습 과정 소개

LocalWorkspace와 ExtendedScriptFormat을 사용하는 크리에이터는 메이플스토리 월드에서 제공하는 mLua VS Code Extension을 활용하여 스크립트를 효율적으로 작성할 수 있습니다.

##### 참고 가이드

[LocalWorkspace](/docs/?postId=1165) [ExtendedScriptFormat](/docs/?postId=1166) [mLua](/docs?postId=1287) [공동 제작](/docs/?postId=670)

# mLua VS Code Extension

mLua Extension은 VS Code에서 mLua를 편리하게 사용할 수 있도록 지원하는 확장 프로그램입니다.

> 더 알아보기 mLua Extension은 글로벌 변수 선언이 가능하며, MSW 메이커의 스크립트 에디터와 달리 경고가 표시되지 않습니다.
> 더 알아보기 디버깅 기능이 추후 추가될 예정입니다.

# mLua VS Code Extension 사용

mLua Extension을 사용하기 위해서는 [VS Code](https://code.visualstudio.com/)를 설치해야 합니다. VS Code는 소스 코드 편집기로 구문 강조 기능을 제공해 코드 작성의 편리성을 높여줍니다.

1. [VS Code](https://code.visualstudio.com/)를 설치합니다.
2. **Extensions**를 선택하고 mLua를 검색합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1739257075188099842c84703431fae9f1dfe782c5b3b.png)
3. 설치가 완료되면 Extension은 자동으로 활성화됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17392575481988bb9dee8ad324ddea22bef398b4421c7.png)
4. **VS Code - File - Open Folder**를 선택한 뒤, 로컬에 내려 받은 월드 폴더를 선택해 전체 파일을 불러옵니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1739257564610278a1b7b1ff143d0a498a01e8a3c6134.png)
5. 작성한 코드를 메이플스토리 월드의 메이커에 동기화해 출시할 수 있습니다. 동기화 방법은 [LocalWorkspace](/docs/?postId=1165)을 참고합니다.

# mLua VS Code Extension 기능

## Hover

심볼에 마우스를 올리면, 해당 심볼의 정보가 나타납니다. ![hover](https://mod-file.dn.nexoncdn.co.kr/bbs/1739258236378407788513cc141c2af1b550be5154b6d.png)

## Inlay Hint

멤버의 오버라이딩 여부, Entity Id에 해당하는 Entity Name와 같이 코드 작성을 돕는 정보를 표시합니다. ![Inlay](https://mod-file.dn.nexoncdn.co.kr/bbs/1739258296092c63e04f5db6a443585eb781342cc51b3.png)

## Document Symbol

문서에 존재하는 심볼을 표시합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1739259663469d2a0a54c39c44d87942b78154ea70269.png)

## Rename Symbol

참조된 심볼들의 이름을 한 번에 변경할 수 있습니다.

## Signature Helper

함수 호출 식을 작성할 때 함수 시그니처를 표시하여 파라미터 작성에 도움을 줍니다. 오버로딩된 경우 방향키를 사용하여 원하는 시그니처를 찾아 함수 시그니처를 표시할 수 있습니다. ![signature helper](https://mod-file.dn.nexoncdn.co.kr/bbs/1739258358762a37066f5d9284e27a5d031f086aedb78.png)

## Go to Reference

선택한 심볼의 참조로 이동합니다.

## Find All Reference

선택한 심볼의 모든 참조를 찾습니다.

## Go to Definition

선택한 심볼이 정의된 위치로 이동합니다.

## Go to Type Definition

선택한 심볼의 타입이 정의된 위치로 이동합니다. ![gototype](https://mod-file.dn.nexoncdn.co.kr/bbs/1739259625673c71ae233e5f2446daee2749b11cfbbd4.png)

## Completion

#### Code Completion

스크립트 작성 시 특정 스크립트에 사용 가능한 심볼을 추론하고, 자동 완성을 제공합니다. 인덱싱할 때도 해당 심볼로부터 접근 가능한 멤버를 추론하고, 자동 완성을 제공합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/173925981885800cc64e8e22a4c6bab618d241f270495.png)

#### Entity Id Completion

엔티티 경로를 이용해서 엔티티의 Id를 쉽게 찾을 수 있습니다. Completion에서 제공한 엔티티 후보 중 하나를 선택하면, Entity Id로 자동으로 치환됩니다. 엔티티 Id를 쉽게 식별할 수 있도록 인레이 힌트로 엔티티의 이름을 확인할 수 있습니다. 예를 들어 프로퍼티 타입이 BackgroundComponent인 경우, Completion은 Background가 있는 엔티티의 Id만 추려서 보여줍니다. ![entityId](https://mod-file.dn.nexoncdn.co.kr/bbs/173926657423897107b00ec1c4dc7a66a7c5907914b2c.png)

## Code Snippet

사용자가 자주 사용하는 코드를 템플릿으로 제공합니다. Snippet을 선택하여 코드 조각을 자동으로 완성하고, Tab 키를 눌러 템플릿이 의도하는 다음 위치로 이동할 수 있습니다.

## Diagnostic

크리에이터가 작성한 코드를 진단해 문제가 될 수 있는 부분을 알려주는 기능입니다. 문제 해결의 중요도에 따라 분류되고, 진단 결과는 PROBLEMS에서 확인할 수 있습니다. ![Problems](https://mod-file.dn.nexoncdn.co.kr/bbs/17392600764315daec26eb5b148fe90c9134258b65d7d.png)

## Commit Character Support

`.(dot)`, `,(comma)`, `:(colon)`을 입력하는 시점에 자동으로 제안된 항목을 선택해주는 기능입니다. ![CommitCharacterSupport](https://mod-file.dn.nexoncdn.co.kr/bbs/1739259976957319c89b93a604bba81366707a91b93f2.gif)

# Code Folding

`--region`, `--endregion`을 사용해 작성한 코드의 특정 구간을 접는 기능입니다. 코드를 접고 싶은 시작 구간에 `--region`을, 끝 구간에 `--endregion`을 입력합니다.

![CodeFolding](https://mod-file.dn.nexoncdn.co.kr/bbs/17483232121567e4c7bf533d5448d9a8a8b143410a237.png)

# Symbol Color Customization

**Inspect Editor Tokens and Scopes**의 **foreground scope**값을 변경해 특정 심볼의 색상을 변경할 수 있습니다. 로컬 워크스페이스를 통해 로컬로 **다운 받은 프로젝트 폴더 - .vscode폴더** 하위에 **settings.json**파일을 생성해야만 색상 변경 기능을 사용할 수 있습니다. **settings.json** 파일 생성 방법은 [LocalWorkspace](/docs?postId=1165)가이드를 참고합니다.

1. VS Code에서 **Ctrl + Shift + P**를 입력합니다.
2. **Developer:Inspect Editor Tokens and Scopes**를 선택합니다.
3. 색상을 변경할 심볼을 마우스로 클릭해 **foreground scope** 값을 확인합니다.
4. 생성한 **settings.json** 파일에 아래와 같은 형식으로 작성합니다.```
{
    "editor.tokenColorCustomizations": {
        "textMateRules": [
            {
                "scope": "entity.name.class",
                "settings": {
                    "foreground": "#daed30", 
                    "fontStyle": "bold"
                }
            },
            {
                "scope": "keyword.control",
                "settings": {
                    "foreground": "#daed35",
                    "fontStyle": "bold"
                }
            }
        ]
    }
}
```
5. **settings.json** 파일을 저장하고, 색상이 변경되었는지 확인합니다.

> **Tip.** .**vscode** 폴더 내부의 파일 이름이 반드시 **settings.json**이어야 합니다. 이름이 정확하지 않으면 기능이 적용되지 않습니다.

# 단축키

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| Ctrl + Space | Completion | Completion을 활성화합니다. |
| Ctrl + Shift + Space | Signature Helper | Signature Helper를 활성화 합니다. |
| Shift + F12 | Go to Reference | 선택한 심볼의 참조로 이동합니다. |
| Shift + Alt + F12 | Find All Reference | 선택한 심볼의 모든 참조를 찾습니다. |
| F2 | Rename | 이름을 변경합니다. |
| F12 | Go to Definition | Definition으로 이동합니다. |

Update 2025-11-19 AM 11:33


# VS Code: Debugger for mLua

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

mLua Debugger VS Code Extension을 설치해 제작 중인 월드를 VS Code에서 디버깅해봅시다.

##### 참고 가이드

- [스크립트 디버그](/docs?postId=202)
- [LocalWorkspace](/docs?postId=1165)
- [mLua VS Code Extension](/docs/?postId=1209)

# Debugger for mLua Extension

**Debugger for mLua**는 로컬워크스페이스를 사용하는 월드의 mLua 파일을 VS Code에서 디버그할 수 있도록 지원하는 확장 프로그램입니다. mLua Extension 설치와 메이플스토리 월드의 LocalWorkspace 연동 기능이 활성화되어 있어야 Debugger for mLua를 사용할 수 있습니다.

# Debugger for mLua Extension 설치

1. Extensions를 선택하고 **Debugger for mLua**를 검색해 설치합니다.
2. 월드의 로컬 폴더에서 `.vscode` 폴더와 `launch.json` 파일이 있는지 확인합니다.
3. `launch.json` 파일을 열어 아래와 같이 입력합니다. configurations이 아래와 같이 작성되어야 VS Code의 **Run and Debug** 탭이 활성화됩니다.```
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "MSW Attach",
            "type": "msw",
            "request": "attach"
        }
    ]
}
```

# 디버그하기

Debugger for mLua는 MSW에 VS Code Debugger를 연결하는 방식입니다. 그러므로 메이커에서 먼저 디버그 플레이를 실행한 뒤 VS Code Debugger를 연결해 사용해야 합니다. 디버그 연결 상태는 메이커의 Console에서 확인할 수 있습니다.

1. 디버깅할 월드를 메이커에서 엽니다.
2. 메이커의 디버깅 시작 버튼을 눌러 플레이합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752493246769c727f80f4b834db49badc10dfa1d87ae.png)
3. VS Code에서 **Run and Debug**를 선택합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752493465533de5e5b193b0a4b64918698ba153abef7.png)
4. 이전에 정의한 구성 정보의 이름을 선택한 뒤 실행 버튼을 누릅니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752491257751ada9a353952a4373a9a58c419aabec9f.png)
5. VS Code Debugger 연결이 완료되면 메이커의 Console에서 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/175249314149585250a3fb9e242ae91545127d221d059.png)

# Run and Debug

## 중단점

중단점은 디버그 실행을 일시 중단할 지점입니다. 중단점은 여러 곳에 설정할 수 있고, 자유롭게 제거할 수도 있습니다. 중단점이 설정된 파일과 라인을 **BREAKPOINTS**에서 확인할 수 있습니다.

#### 중단점 지정, 해제

중단점을 지정하거나 해제하는 방법은 두 가지입니다.

1. 중단점을 지정할 라인을 선택하고 `F9` 키를 눌러 중단점을 추가하거나 해제합니다.
2. 코드 라인 영역을 눌러 중단점을 추가하거나 해제합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752491279590042be7bd2233426b8df2b4ff76b99d7e.png)

#### VARIABLES

Scope에 따른 변수 정보를 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17524936153840d09d5ea89904d80ae2099bb38b014ec.png)

#### WATCH

직접 Expression을 작성하고 값을 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752557620746239370f899b8440d963337db331828e9.png)

#### CALL STACK

호출 스택을 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17525480355440cc7b232d4fa498881987f2cb470a7f5.png)

#### BREAKPOINTS

중단점이 설정된 파일의 경로와 라인을 확인할 수 있습니다. 목록에서 중단점을 선택하면 해당하는 중단점으로 이동합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1752491237685ab378074ca044f6e98ee50bc36320133.png)

#### ENVIRONMENT

현재 실행 공간을 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/175249399198781822bddc5f947eca0d193fcc7905448.png)

#### 심볼에 할당된 값 확인

심볼에 할당된 값은 해당 심볼에 마우스를 올렸을 때 나타나는 툴팁으로 확인할 수 있습니다.

# 디버그 툴바

디버그를 시작하면, 툴바가 VS Code 상단에 나타납니다. 월드 디버그 실행 중 중단점에서 플레이가 멈추면 툴바의 실행 버튼들이 활성화됩니다. 디버그를 위해 코드를 계속 실행하고 싶다면 버튼을 눌러 코드를 계속 실행할 수 있습니다. 코드 실행을 통해 프로시저 단위로 코드의 상태나 흐름을 파악해 월드의 문제를 찾고 해결할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17524912237671bfee3141dde43fb80b778e12dfef002.png)

| 번호 | 기능 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 계속 실행 | 현재의 중단점에서 다음 중단점이 있는 코드 라인까지 실행합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 프로시저 단위 실행 | 코드를 한 줄씩 실행합니다. 포커싱된 라인에 함수가 있을 때, 그 함수를 실행한 것으로 간주하고 다음 줄로 넘어갑니다 |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 아래로 코드 실행 | 포커싱 된 라인에 함수가 있을 때 해당 함수 내부로 들어가 함수 내 코드를 한 줄씩 실행합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 위로 코드 실행 | 현재 실행 중인 함수 호출을 완료하고, 해당 함수를 호출한 위치로 이동합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 재시작 | 현재 디버그 실행을 중단하고, 디버그 시작점으로 돌아가 디버그를 다시 실행합니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 중단 | 디버거 실행을 중단합니다. |

Update 2025-11-17 PM 08:14


# Command Console

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

Command Console의 다양한 명령어를 사용해 특정한 동작을 바로 수행할 수 있습니다. 특정 프로퍼티를 사용하고 있는 모든 엔티티를 찾을 수도 있고, 디버그에 활용할 수도 있습니다. Command Console 활용법을 알아봅시다.

# Command Console 소개

Panel - Command Console을 눌러 Command Console 창을 열 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17307099056193c94fbbdb3df4c6fb3c5047b65b20282.png)

#### 화면 소개

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1730788005872cf5bfbc44751472087b21b2871280fc4.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 결과 창 | 실행한 명령어의 결과를 보여줍니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 입력 창 | 명령어를 입력하는 공간입니다. 명령어를 입력한 후 `Enter` 키를 입력하면 실행됩니다. |

# 명령어 사용하기

명령어를 입력하면 실행한 결괏값이 Command Console 결과 창 혹은 콘솔 창에 로그로 출력됩니다.

#### 명령어 종류

MSW에서 사전에 지정한 명령어만 사용할 수 있습니다. 명령어를 사용할 때는 명령어와 매개 변수는 반드시 입력해야 합니다. 매개 변수를 입력할 때는 지정된 순서를 지켜야 합니다. 콘솔에서 사용할 수 있는 명령어는 아래와 같습니다. 명령어의 매개 변수와 옵션은 [Console 명령어](/docs?postId=1195)에서 확인할 수 있습니다.

| 명령어 이름 | 설명 |
| --- | --- |
| help | 사용할 수 있는 명령어와 설명을 출력합니다. |
| echo | 입력된 메시지를 결과 창에 그대로 출력합니다. |
| export | 지정한 경로로 원하는 파일을 내보냅니다. 스크립트, 코드 블록, 데이터셋, 유저 데이터셋 엔트리만 내보낼 수 있습니다. |
| import | 지정한 경로로 파일을 불러옵니다. |
| findentity | 하이어라키에서 특정 엔티티를 찾습니다. 모든 맵의 엔티티를 대상으로 찾을 수 있습니다. |
| findcomponent | 하이어라키에 있는 특정 컴포넌트를 찾습니다. 모든 맵을 대상으로 찾을 수 있습니다. |
| findproperty | 하이어라키에 있는 특정 프로퍼티를 찾습니다. 모든 맵을 대상으로 찾을 수 있습니다. |
| play | 월드를 플레이합니다. 디버그 모드로 실행하거나 가상 플레이어를 추가할 수 있습니다. |

> **Tip** Command Console에서 바로 확인하고 싶을 경우 `help 명령어 이름`을 실행해 확인할 수 있습니다. - 명령어 목록 찾기 예시: help all, help findentity

# 기본 구문

기본 구문은 명령어, 매개 변수, 옵션으로 구분됩니다. 세 가지를 구분할 때는 **띄어쓰기**로만 구분합니다. `,`이나 다른 기호를 사용할 경우 에러가 발생합니다. `[]`는 크리에이터가 선택적으로 사용하면 되는 매개 변수 혹은 옵션을 의미합니다. 명령어 구문은 일반적으로 아래와 같이 구성됩니다.

```
명령어 매개변수 -옵션1 -옵션2
```

### 매개 변수

명령어의 매개 변수는 필수로 입력해야 하며, 지정된 순서를 반드시 지켜 입력해야 합니다. 예를 들어, export의 매개 변수는 src_path, dest_path로 export를 사용하기 위해선 export "MyDesk/NewComponent" "C:\Test" 이렇게 입력해야 합니다.

### 옵션

명령어마다 다양한 옵션을 제공합니다. 옵션은 크리에이터의 명령어 사용 의도에 따라 자유롭게 선택해 사용하면 됩니다. 옵션 작성 순서에는 규칙이 없으므로, 크리에이터가 순서를 자유롭게 변경해 작성해도 무방합니다. 옵션을 사용할 때는 `-`을 옵션명 앞에 붙여야 합니다. 옵션 또한 매개 변수를 가질 수 있습니다. 이때 옵션의 매개 변수는 정해진 순서대로 작성해 사용해야 합니다. 예를 들어, 명령어 play의 - debug의 경우 매개 변수가 없기 때문에 `play -debug`만을 입력해 debug 모드를 실행할 수 있습니다. 그러나 -virtual을 사용하려면 매개 변수가 필요하므로 `play -virtual_player 5`와 같이 작성해 가상의 플레이어를 5명 추가합니다.

# stream

옵션의 매개 변수 중 하나로 stream을 활용할 수 있습니다. stream은 특정 파일로부터 값을 가져오거나 내보낼 때 사용합니다. 또한 결과를 파일 형태로 출력할 수도 있습니다. `-out`, `-err` 옵션의 매개 변수로 stream을 넘기면 명령어의 결과 로그와 에러 로그를 파일로 출력합니다. 파일로 출력하기 위해서는 경로 앞에 `$`를 붙여 사용해야 합니다. 예를 들어 `echo $"C:\Test/file.txt"`로 입력하게 되면 파일 경로의 값이 인수로 넘어가게 됩니다. 반면 `echo "C:\Test/file.txt"`로 입력하면, 입력한 내용 자체가 인수로 넘어가게 됩니다. 아래와 같이 명령어를 작성하게 되면 결과 로그와 에러 로그 파일이 매개 변수로 지정한 파일 경로에, 파일로 생성되어 출력됩니다.

```
echo "test" -out $"C:\Test/resultLog.txt" -err $"C:\Test/errorLog.txt"
```

# 경로

명령어 사용 시 파일 경로, 메이커의 엔트리 경로는 아래의 규칙에 따라 작성해야 합니다.

- **파일 경로**: 운영체제의 파일 경로 표기법을 따릅니다.
- **Workspace 경로** : MyDesk부터 차례대로 입력합니니다.
  - 예시: MyDesk/Images/Test_Sound_01.ogg
- **Hierarchy 경로**: World부터 차례대로 구분합니다.
  - 예시: World/ui/UIGroup/UIEmpty

# 로그

크리에이터가 작성한 명령어를 실행하면, 실행 결과는 콘솔 창에 로그 형태로 나타납니다. 명령어 사용 결과에 따라 나타나는 로그는 일반 로그, 명령어 결과 로그, 에러 로그로 총 3종류입니다.

#### 일반 로그

일반 로그는 명령어 수행 상황과 같이 크리에이터에게 정보를 전달하는 로그입니다. 예를 들어 import 명령어를 사용하면, 파일 불러오기가 완료되었을 때 완료를 알리는 로그가 나타납니다.

#### 결과 로그

명령어를 통해 얻을 수 있는 결과들은 결과 로그로 분류합니다. 예를 들어 findentity 명령어를 사용하면, 찾은 엔티티들이 결과 로그로 나타납니다.

#### 에러 로그

명령어 수행 중에 문제가 발생할 경우 나타나는 로그를 에러 로그로 분류합니다. 예를 들어 명령어의 매개 변수가 유효하지 않을 경우 에러 로그가 발생합니다.

Update 2025-11-17 PM 08:14


# Command Console 명령어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

Command Console 창에서 사용할 수 있는 명령어들을 알아봅시다.

# help

사용할 수 있는 명령어와 설명을 출력합니다.

```
help [command=all] [-out stream] [-err stream]
```

#### 매개 변수

- **command**: 설명을 출력할 명령어의 이름입니다. all을 입력하면 모든 명령어의 설명이 출력됩니다.

#### 옵션

- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
help findentity
```

# echo

입력된 메시지를 결과창에 그대로 출력합니다.

```
echo message [-out stream] [-err stream]
```

#### 매개 변수

- **message**: 출력할 메시지입니다.

#### 옵션

- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다. #### 예제

```
echo "test"
```

# export

지정한 경로로 원하는 파일을 내보냅니다. 스크립트, 코드블럭, 데이터셋, 유저 데이터셋 엔트리만 내보낼 수 있습니다.

```
export src_path dest_path [-out stream] [-err stream]
```

#### 매개 변수

- **src_path**: 내보낼 엔트리의 워크스페이스 경로입니다. 경로는 MyDesk부터 시작합니다.
- **dest_path**: 내보낸 엔트리를 저장할 경로입니다.

#### 옵션

- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
export "MyDesk/NewComponent" "C:\TestFolder"
```

# import

지정한 경로로 파일을 불러옵니다.

```
import src_path [dest_path=MyDesk] [-overwrite] [-out stream] [-err stream]
```

#### 매개 변수

- **src_path**: 가져올 엔트리의 경로입니다.
- **dest_path**: 가져온 파일을 저장할 워크스페이스 경로입니다. 경로는 MyDesk부터 시작합니다.

#### 옵션

- **-overwrite**: 덮어쓰기를 허용합니다.
- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
import "C:\TestFolder/NewComponent.xml" "MyDesk/NewFolder"
```

# findentity

하이어라키에서 특정 엔티티를 찾습니다. 모든 맵의 엔티티를 대상으로 찾을 수 있습니다.

```
findentity [-path path] [-name name [match_type=contains] [comparison_type=ordinal]] [-visibleonly] [-enableonly] [-modelonly] [-model_name name [match_type=contains] [comparison_type=ordinal]] [-model_id id] [-out stream] [-err stream]
```

#### 옵션

- **-path**: 엔티티를 찾을 경로로 지정합니다
  - path: 엔티티를 찾을 경로입니다.
- **-visibleonly**: Visible인 엔티티만 찾습니다.
- **-enableonly**: Enable인 엔티티만 찾습니다.
- **-modelonly**: 모델을 확장한 엔티티만 찾습니다.
- **-name**: 지정한 이름이 포함된 엔티티를 찾습니다.
  - name: 찾을 이름입니다.
  - match_type: 이름을 찾는 방식입니다. contains, equals, regex 중 하나를 사용합니다.
    - contains: 지정한 이름이 포함된 모델을 확장한 엔티티를 찾습니다.
    - equals: 지정한 이름과 동일한 모델을 확장한 엔티티를 찾습니다.
    - regex: 정규식을 사용하여 일치하는 엔티티를 찾습니다.
  - comparison_type: 이름을 비교하는 방식입니다. ordinal, ordinal_ignorecase 중 하나를 사용할 수 있습니다.
    - ordinal 바이트 비교를 수행합니다.
    - ordinal_ignorecase: 바이트 비교를 수행하고 대소문자 비교를 무시합니다.
- **-model_name**: 지정한 이름이 포함된 모델을 확장한 엔티티를 찾습니다.
  - name: 찾을 이름입니다.
  - match_type: 이름을 찾는 방식입니다. contains, equals, regex 중 하나를 사용할 수 있습니다.
    - contains: 지정한 이름이 포함된 모델을 확장한 엔티티를 찾습니다.
    - equals: 지정한 이름과 동일한 모델을 확장한 엔티티를 찾습니다.
    - regex: 정규식을 사용하여 일치하는 엔티티를 찾습니다.
  - comparison_type: 이름을 비교하는 방식입니다. ordinal, ordinal_ignorecase 중 하나를 사용할 수 있습니다.
    - ordinal: 바이트 비교를 수행합니다.
    - ordinal_ignorecase: 바이트 비교를 수행하며 대소문자 비교를 무시합니다.
- **-model_id**: 모델 id가 일치하는 모델을 찾습니다.
  - id : 찾을 모델의 id입니다.
- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
findentity -path "World/ui/DefaultGroup" -enableonly -name "Button" contains ordinal_ignorecase -out $"C:\TestFolder/result.txt"
```

# findcomponent

하이어라키에 있는 특정 컴포넌트를 찾습니다. 모든 맵을 대상으로 찾을 수 있습니다.

```
findcomponent [-path path] [-enableonly] [-name name [match_type=contains] [comparison_type=ordinal]] [-out stream] [-err stream]
```

#### 옵션

- **-path** 컴포넌트를 찾을 경로를 지정합니다.
  - path : 컴포넌트를 찾을 경로입니다.
- **-enableonly**: Enable이 켜져있는 컴포넌트만 찾습니다.
- **-name**: 지정한 이름이 포함된 컴포넌트를 찾습니다.
  - name: 찾을 이름입니다.
  - match_type: 이름을 찾는 방식입니다. contains, equals, regex 중 하나를 사용할 수 있습니다.
    - contains: 지정한 이름이 포함된 이름의 컴포넌트를 찾습니다.
    - equals: 지정한 이름과 동일한 이름의 컴포넌트를 찾습니다.
    - regex: 정규식을 사용하여 일치하는 이름의 컴포넌트를 찾습니다.
  - comparison_type: 이름을 비교하는 방식입니다. ordinal, ordinal_ignorecase 중 하나를 사용할 수 있습니다.
    - ordinal: 바이트 비교를 수행합니다.
    - ordinal_ignorecase: 바이트 비교를 수행하며 대소문자 비교를 무시합니다.
- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
findcomponent -path "World/ui/DefaultGroup" -name "ButtonComponent" equals ordinal_ignorecase -out $"C:\TestFolder/result.txt"
```

# findproperty

하이어라키에 있는 특정 프로퍼티를 찾습니다. 모든 맵을 대상으로 찾을 수 있습니다.

```
findproperty [-path path] [-name name [match_type=contains] [comparison_type=ordinal]] [-component_name name [match_type=contains] [comparison_type=ordinal]] [-out stream] [-err stream]
```

#### 옵션

- **-path**: 프로퍼티를 찾을 경로를 지정합니다.
  - path: 프로퍼티를 찾을 경로입니다.
- **-name**: 지정한 이름이 포함된 프로퍼티를 찾습니다.
  - name: 찾을 이름입니다.
  - match_type: 이름을 찾는 방식입니다. contains, equals, regex 중 하나를 사용할 수 있습니다.
    - contains: 지정한 이름이 포함된 이름의 프로퍼티를 찾습니다.
    - equals: 지정한 이름과 동일한 이름의 프로퍼티를 찾습니다.
    - regex: 정규식을 사용하여 일치하는 이름의 프로퍼티를 찾습니다.
  - comparison_type: 이름을 비교하는 방식입니다. ordinal, ordinal_ignorecase 중 하나를 사용할 수 있습니다.
    - ordinal: 바이트 비교를 수행합니다.
    - ordinal_ignorecase: 바이트 비교를 수행하며 대소문자 비교를 무시합니다.
- **-component_name**: 지정한 이름이 포함된 컴포넌트의 프로퍼티를 찾습니다.
  - name: 찾을 이름입니다.
  - match_type: 이름을 찾는 방식입니다. contains, equals, regex 중 하나를 사용할 수 있습니다.
    - contains: 지정한 이름이 포함된 이름의 컴포넌트를 찾습니다.
    - equals: 지정한 이름과 동일한 이름의 컴포넌트를 찾습니다.
    - regex: 정규식을 사용하여 일치하는 이름의 컴포넌트를 찾습니다.
  - comparison_type: 이름을 비교하는 방식입니다. ordinal, ordinal_ignorecase 중 하나를 사용할 수 있습니다.
    - ordinal: 바이트 비교를 수행합니다.
    - ordinal_ignorecase: 바이트 비교를 수행하며 대소문자 비교를 무시합니다.
- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
findproperty -name "Color" -component_name "SpriteGUIRendererComponent"
```

# play

월드를 플레이합니다. 디버그 모드로 실행하거나 가상 플레이어를 추가할 수 있습니다.

```
play [-debug] [-virtual_player player_number] [-out stream] [-err stream]
```

#### 옵션

- **-debug**: 디버그 모드로 플레이합니다.
- **-virtual_player**: 가상 플레이어를 추가합니다.
  - player_number: 추가할 가상 플레이어 수 입니다.
- **-out**: 결과를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.
- **-err**: 에러를 출력할 스트림을 설정합니다.
  - stream: 출력할 스트림입니다.

#### 예제

```
play -debug -virtual_player 3
```

Update 2025-11-17 PM 08:14


# Lua Executor

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이커에서 제작한 월드를 테스트할 때 다양한 컴포넌트, 프로퍼티 값을 변경해 실시간으로 의도한 바가 맞는지 확인하거나, 서버 또는 클라이언트 환경에서 각각 만든 스크립트가 문제없이 작동하는지 확인하고 싶을 수 있습니다. Lua Executor로 이러한 내용을 쉽게 확인할 수 있습니다. 몇 가지 활용 예시와 함께 Lua Executor에 대해 알아봅시다.

# Lua Excutor

Lua Executor를 사용하면 메이커에서 플레이 중에 실시간으로 스크립트를 실행하고 즉시 월드에 반영됩니다. 크리에이터의 필요에 따라 플레이 중에 다양한 스크립트를 실행하며 월드를 확인할 수 있습니다. 작성한 스크립트는 서버, 클라이언트, 인스턴스 룸에서 각각 실행할 수 있으며, 실행한 값은 Console 창에서 확인할 수 있습니다.

#### 화면 소개

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17314026977102d66cc962e73441caee4eb403cf02d5b.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 실행 공간 설정 | 실행 공간을 설정할 수 있습니다. 서버, 클라이언트, 인스턴스 룸을 설정할 수 있습니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 실행 | 작성한 스크립트를 실행하는 버튼입니다. |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 스크립트 작성 공간 | 실행할 스크립트를 작성하는 공간입니다. 메이커에서 테스트 플레이 중에만 동작합니다. |

# 활용 예시

Lua Executor를 활용한 예시들입니다. 예시를 참고해 크리에이터의 월드에 필요한 스크립트를 작성해 응용할 수 있습니다.

#### Tween 값 확인

TweenLogic은 UI 연출에 많이 사용되지만 작성한 스크립트의 값만으로는 최종 모습을 상상하기 어렵습니다. 이때 Lua Executor를 활용해 Tween 값을 변경하고, 결과물을 확인하며 원하는 연출값을 찾을 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1730979504422b4960734f4c449f9b2ddcbbd63f1cbf2.gif)

1. **Hierarchy - World - ui**에 새로운 **TestGroup**을 추가합니다.
2. 콘텍스트 메뉴를 눌러 **Create Entity - Create UISprite**를 선택해 새로운 UISprite를 생성합니다. ![UISprtie](https://mod-file.dn.nexoncdn.co.kr/bbs/1732151013045fb775efde16f4c0480caab166a5a357f.png)
3. 제작한 UISprite에서 Tween 결과를 확인할 수 있도록 Lua Executor에 아래와 같이 작성합니다.```
local entity = _EntityService:GetEntityByPath("/ui/TestGroup/UISprite")
local startY = 90
local goalY = 0
_TweenLogic:PlayTween(startY, goalY, 2, EaseType.ElasticEaseOut, function(y) entity.UITransformComponent.Position.y = y end)
```
4. Lua Executor의 실행 공간을 **Client**로 변경한 뒤 [실행]을 누릅니다.
5. startY, goalY 값과 EaseType을 변경해 원하는 UI 연출을 찾을 수 있습니다.

#### 카메라 이동

커다란 맵을 만들었을 때는 맵 전체를 돌아보며 월드의 구성이 크리에이터가 생각한 바와 동일하게 만들어졌는지 확인이 필요합니다. Lua Executor를 활용해 테스트 플레이 중에 CameraComponent를 추가해 맵 전경을 확인할 수 있습니다.

![camera2](https://mod-file.dn.nexoncdn.co.kr/bbs/173098108808006c95dfa943e47a0ae3e8896635c4631.gif)

1. **Workspace - MyDesk - Create Model**을 눌러 새로운 **transformonly** 모델을 생성합니다.
2. **TransformComponent**를 추가합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17314992738388e253d7a07024b2eb33e070a74e78933.png)
3. Lua Executor에 아래와 같이 작성합니다.```
local mapEntity = _EntityService:GetEntityByPath("/maps/map01")

local debugCamera = _SpawnService:SpawnByModelId("model://transformonly", "DebugCamera", Vector3(0,0,0), mapEntity)

local camera = debugCamera:AddComponent("CameraComponent")
_CameraService:SwitchCameraTo(camera)
```
4. 테스트 플레이를 시작한 뒤 Lua Executor의 **Client**로 실행 공간을 변경합니다.
5. **Hierarchy - World - Maps - Map01**에 추가된 **DebugCamera**를 선택합니다. ![DebugCamera](https://mod-file.dn.nexoncdn.co.kr/bbs/1731499807402c81daf4e1a71486b827c3e25a48c88d0.png)
6. Property 창에서 CameraComponent의 **CameraOffset**값을 변경하며 맵 전체를 둘러볼 수 있습니다. ![CameraOffset](https://mod-file.dn.nexoncdn.co.kr/bbs/17314999391660155bbac855f4eda83d60e5568b67e54.png)

#### 서버 값 확인

버그 원인을 찾기 위해 서버 값을 재현된 상황에서 확인할 수 있습니다. 예를 들어 플레이어가 몬스터를 공격했으나 몬스터의 체력 값이 변하지 않을 때 몬스터의 상태 변화에 따라 서버 값이 변하는지 확인할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17314825147714ec3aa415d38416d8b22e58fa4d56499.gif)

1. 확인이 필요한 엔티티의 path를 `EntityService`를 활용해 얻어옵니다. 아래와 같이 작성합니다.```
local monster = _EntityService:GetEntityByPath("/maps/map01/monster-2419_2")
log(monster.Monster.Hp)
```
2. [실행]을 누르고, 몬스터 근처로 이동하면, Console 창에서 값을 확인할 수 있습니다.

#### 몬스터 소환

특정 몬스터를 서버에서 소환해 테스트해 볼 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17314820984397187de91e0444333991781e9ca6925e2.gif)

1. **PresetList - Monster**에서 프리셋을 선택한 뒤 콘텍스트 메뉴를 열고 **Add to Workspace**를 선택합니다. ![AddToWorkspace](https://mod-file.dn.nexoncdn.co.kr/bbs/1731501190648856620b0912a40d481ef115741a2309c.png)
2. Workspace에 추가한 몬스터 모델의 **Entry ID**를 복사해, 몬스터를 소환할 수 있도록 아래와 같이 작성합니다.```
local mapEntity = _EntityService:GetEntityByPath("/maps/map01")
for i=1, 10 do
    _SpawnService:SpawnByModelId("model://000000", "TestMonster", Vector3(-7,0,0), mapEntity)
    wait(0.1)
end
```
3. Lua Executor의 실행 공간을 **Server**로 변경하고, [실행]을 누릅니다.
4. 10마리의 몬스터가 소환되는지 확인합니다.

#### 인스턴스 룸 생성 및 테스트

Lua Executor에서 인스턴스 룸을 생성하고, 인스턴스 룸에서 특정 엔티티의 위치를 디버깅해볼 수 있습니다.

1. map02를 생성하고, 프로퍼티 창에서 MapComponent의 **InstanceMap**을 활성화합니다.
2. 맵에 디버깅 대상인 새로운 TestTarget 엔티티를 추가합니다.
3. 테스트 플레이를 시작합니다.
4. `CreateInstanceRoom()`을 활용해 임시로 인스턴스 룸을 만듭니다. 아래와 같이 작성하고 [실행]을 누릅니다.```
_RoomService:CreateInstanceRoom("Test", {"map02"}, 200)
```
5. 실행 환경에서 **Server_Instance_Test**를 선택합니다. ![Instance Test](https://mod-file.dn.nexoncdn.co.kr/bbs/1731501337385b5fafa8f5d674b41afe2280eeef9215e.png)
6. `EntityService`를 활용해 디버깅 대상인 엔티티의 위치를 알 수 있습니다. 아래와 같이 작성하고 [실행]을 누릅니다.```
local debug = _EntityService:GetEntityByPath("/maps/map02/TestTarget")
log(debug.TransformComponent.Position)
```
7. **Console 창**에서 로그를 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17314885251115e78f866636b457f86abbc6b4ddf7460.png)

Update 2025-11-17 PM 08:14


# MSW 단축키

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드 메이커에는 월드를 더 빠르고 쉽게 만들 수 있는 단축키가 있습니다. 단축키를 활용하여 편리하게 월드를 제작해 봅시다.

# 일반 단축키

메이커 내 각종 에디터와 텍스트 입력 필드에서 활용할 수 있는 단축키입니다.

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `Z` | 실행 취소 | 실행을 취소합니다. |
| `Ctrl(L)` + `Shift(L)` + `Z` , <br>`Ctrl(L)` + `Y` | 다시 하기 | 취소했던 실행을 다시 합니다. |
| `Ctrl(L)` + `C` | 복사하기 | 선택한 텍스트나 객체를 복사합니다. |
| `Ctrl(L)` + `V` | 붙여넣기 | 복사한 텍스트나 객체를 붙여넣습니다. |
| `Ctrl(L)` + `D` | 복제하기 | 선택한 텍스트나 객체를 복제합니다. |
| `Ctrl(L)` + `X` | 잘라내기 | 선택한 텍스트나 객체를 잘라냅니다. |
| `Delete` | 삭제 | 선택한 텍스트나 객체를 삭제합니다. |
| `Ctrl(L)` + `S` | 저장하기 | 파일을 저장합니다. |
| `Ctrl(L)` + `F5` | 플레이 시작 / 종료 | 플레이를 시작합니다. <br>플레이 상태에서 해당 단축키를 누르면 플레이를 종료합니다. |
| `Ctrl(L)` + `A` | 모두 선택 | 캐럿이 위치한 텍스트 필드의 내용을 모두 선택합니다. |

# 맵 에디터, UI 에디터

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `KeypadPlus` , <br>`Ctrl(L)` + `=` | 줌인 | **Scene**을 줌인합니다. |
| `Ctrl(L)` + `KeypadMinus` , <br>`Ctrl(L)` + `-` | 줌아웃 | **Scene**을 줌아웃합니다. |
| `Left Arrow` | 왼쪽 | 선택한 엔티티를 왼쪽으로 움직입니다. |
| `Right Arrow` | 오른쪽 | 선택한 엔티티를 오른쪽으로 움직입니다. |
| `Up Arrow` | 위 | 선택한 엔티티를 위로 움직입니다. |
| `Down Arrow` | 아래 | 선택한 엔티티를 아래로 움직입니다. |

# 맵 레이어 에디터

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `]` | 위로 이동 | 선택한 레이어를 하나 위로 이동합니다. |
| `Ctrl(L)` + `Shift(L)` + `]` | 최상단으로 이동 | 선택한 레이어를 최상단으로 이동합니다. |
| `Ctrl(L)` + `[` | 아래로 이동 | 선택한 레이어를 하나 아래로 이동합니다. |
| `Ctrl(L)` + `Shift(L)` + `[` | 최하단으로 이동 | 선택한 레이어를 최하단으로 이동합니다. |

# 스크립트 에디터

### 기본 편집

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Tab` | 들여쓰기 | 캐럿 위치에서 들여쓰기 합니다. |
| `Shift` + `Tab` | 내어 쓰기 | 캐럿 위치에서 내어 쓰기 합니다. |
| `Home` | 앞 | 선택한 줄의 맨 앞으로 캐럿을 이동합니다. |
| `End` | 뒤 | 선택한 줄의 맨 뒤로 캐럿을 이동합니다. |
| `PageUp` | 코드 블록 최상단 | 선택한 코드 블록의 최상단으로 이동합니다. |
| `PageDown` | 코드 블록 최하단 | 선택한 코드 블록의 최하단으로 이동합니다. |
| `Ctrl(L)` + `Up Arrow` | 위 스코프로 이동(Move Scope Up) | 현재 캐럿이 위치한 줄의 스코프 기준으로 위 스코프로 이동합니다. |
| `Ctrl(L)` + `Down Arrow` | 아래 스코프로 이동(Move Scope Down) | 현재 캐럿이 위치한 줄의 스코프 기준으로 아래 스코프로 이동합니다. |
| `Ctrl(L)` | 투명화 | 코드 컴플리션, 퀵 인포, 시그니처 헬퍼를 투명화합니다. |
| `Ctrl(L)` + `Space` | 코드 컴플리션 | 코드 컴플리션을 엽니다. |
| `Ctrl(L)` + `Shift(L)` + `Space` | 시그니처 헬퍼 | 시그니처 헬퍼를 엽니다. |
| `Ctrl(L)` + `/` | 주석 처리 | '캐럿이 있는 줄' 또는 '드래그하여 선택한 여러 줄'의 코드를 주석 처리합니다. |
| `Ctrl(L)` + `Shift(L)` + `/` | 블록 주석 처리 | 선택한 영역의 코드를 블록 주석 처리합니다. |
| `Ctrl(L)` + `D` | 코드 복제 | 선택한 줄 또는 선택 영역을 복제합니다. |
| `Ctrl(L)` + `L` | 현재 줄 삭제 | 캐럿이 위치한 줄 전체를 삭제합니다. |
| `Ctrl(L)` + `W` | 현재 단어 선택 | 캐럿이 위치한 단어를 선택합니다. |
| `Ctrl(L)` + `LeftArrow` | 왼쪽으로 이동 | 캐럿 기준 왼쪽으로 이동합니다. |
| `Ctrl(L)` + `RightArrow` | 오른쪽으로 이동 | 캐럿 기준 오른쪽으로 이동합니다. |
| `Ctrl(L)` + `Shift(L)` +`LeftArrow` | 왼쪽 선택 | 캐럿 기준 왼쪽을 선택합니다. `LeftArrow`를 여러번 눌러 복수 선택할 수 있습니다. |
| `Ctrl(L)` + `Shift(L)` +`RightArrow` | 오른쪽 선택 | 캐럿 기준 오른쪽을 선택합니다. `RightArrow`를 여러번 눌러 복수 선택할 수 있습니다. |
| `Ctrl(L)` + `Backspace` | 캐럿 기준 왼쪽 삭제 | 캐럿이 기준 왼쪽을 삭제합니다. |
| `Ctrl(L)` + `Delete` | 캐럿 기준 오른쪽 삭제 | 캐럿이 기준 오른쪽을 삭제합니다. |
| `Ctrl(L)` + `M` | 함수 펼치기 | 함수를 모두 펼칩니다. |
| `Ctrl(L)` + `Shift(L)` + `M` | 함수 접기 | 함수를 모두 접습니다. |
| `Alt(L)` + `Up Arrow` | 줄을 위로 이동 | 선택한 줄 또는 현재 캐럿이 위치한 줄 전체를 위로 이동합니다. |
| `Alt(L)` + `Down Arrow` | 줄을 아래로 이동 | 선택한 줄 또는 현재 캐럿이 위치한 줄 전체를 아래로 이동합니다. |

### 탐색

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `-` | Navigate back | 기록된 이전 위치로 이동합니다. |
| `Ctrl(L)` + `=` | Navigate forward | 이전 위치에서 다시 최근 위치로 이동합니다. |

### 찾기와 바꾸기

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `F` | 검색 | 현재 스크립트에서 원하는 텍스트를 검색합니다. |
| `Ctrl(L)` + `Shift(L)` + `F` | 전체 프로젝트에서 검색 | 현재 프로젝트의 모든 스크립트에서 원하는 텍스트를 검색합니다. |
| `Ctrl(L)` + `H` | 바꾸기 | 현재 스크립트에서 원하는 텍스트를 찾아 대체 텍스트로 바꿉니다. |
| `Ctrl(L)` + `Shift(L)` + `H` | 전체 프로젝트에서 바꾸기 | 현재 프로젝트의 모든 스크립트에서 원하는 텍스트를 찾아 대체 텍스트로 바꿉니다. |

# 디버그 모드

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `F5` | 디버그 모드 / 다음 중단점까지 이동 | 디버그 모드를 실행합니다. <br> 디버그 모드가 실행되어 있다면 다음 중단점이 있는 코드 라인까지 실행합니다. |
| `F9` | 중단점 | 선택한 코드 라인에 중단점을 설정합니다. |
| `F10` | 프로시저 단위 실행(Step Over) | 코드를 한 줄씩 실행합니다.<br>포커싱 된 라인에 함수가 있을 때, 함수를 실행한 것으로 간주하고 다음 줄로 넘어갑니다. |
| `F11` | 한 단계씩 코드 실행(Step Into) | 프로시저 단위 실행과 같이 코드를 한 줄씩 실행하지만, 포커싱 된 라인에 함수가 있을 때, 해당 함수 내부로 들어가 함수 내 코드를 한 줄씩 실행합니다. |
| `Shift(L)` + `F11` | 프로시저 나가기(Step Out) | 현재 실행 중인 함수 호출을 완료하고, 해당 함수를 호출한 위치로 이동합니다. |
| `F12` | 정의로 이동 | 선택한 변수의 선언으로 이동합니다. |
| `Ctrl(L)` + `Shift(L)` + `F9` | 모든 중단점 해제 | 모든 중단점 설정을 해제합니다. |

# 내비게이션 메뉴

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Alt(L)` + `F` | File | **File** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `E` | Edit | **Edit** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `W` | Create | **Create** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `I` | Window | **Window** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `P` | Panel | **Panel** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `D` | Debug | **Debug** 항목의 콘텍스트 메뉴가 나옵니다. |
| `Alt(L)` + `H` | Help | **Help** 항목의 콘텍스트 메뉴가 나옵니다. |

# 커서 그룹

![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1666834632280605cea59f8f242cfa946de73ce148fc7.png)

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Q` | ![NO01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg)기본 커서 | 기본 이동 커서입니다. |
| `W` | ![NO_02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg)화면 이동 커서 | 화면 이동 커서입니다. |
| `Shift` + `E` | ![NO_03](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg)지우개 커서 | 지우개 커서입니다. |

# 패널

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `1` | Scene | **Scene** 패널로 포커스가 이동합니다. |
| `Ctrl(L)` + `2` | Property | **Property** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `3` | Hierarchy | **Hierarchy** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `4` | Workspace | **Workspace** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `5` | Preset List | **Preset List** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `6` | History | **History** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `7` | Map Layer | **Map Layer** 패널 생성 확인 후 포커스가 이동합니다. |
| `Ctrl(L)` + `8` | Resource Storage | **Resource Storage** 패널 생성 확인 후 포커스가 이동합니다. |
| `Shift(L)` + `Ctrl(L)` + `C` | Console | **Console** 패널 생성 확인 후 포커스가 이동합니다. |
| `Alt(L)` + `1` | Debug - Watcher | **Watcher** 패널 생성 확인 후 포커스가 이동합니다. |
| `Alt(L)` + `2` | Debug - Call Stack | **Call Stack** 패널 생성 확인 후 포커스가 이동합니다. |
| `Alt(L)` + `3` | Debug - Breakpoints | **Breakpoints** 패널 생성 확인 후 포커스가 이동합니다. |
| `Alt(L)` + `4` | Debug - Watch Expression | **Watch Expression** 패널 생성 확인 후 포커스가 이동합니다. |

# Workspace, Hierarchy

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `F2` | 이름 변경 | 선택한 객체의 이름을 변경합니다. |
| `Left Arrow` | 왼쪽 | 상위 계층으로 이동하거나 계층을 접습니다. |
| `Right Arrow` | 오른쪽 | 하위 계층으로 이동하거나 계층을 펼칩니다. |
| `Up Arrow` | 위 | 위 항목으로 이동합니다. |
| `Down Arrow` | 아래 | 아래 항목으로 이동합니다. |
| `Home` | 최상단 | 최상단 항목으로 이동합니다. |
| `End` | 최하단 | 최하단 항목으로 이동합니다. |
| `PageUp` | 현재 보이는 목록의 최상단 | 현재 패널에 보이는 최상단 엔티티로 이동합니다. |
| `PageDown` | 현재 보이는 목록의 최하단 | 현재 패널에 보이는 최하단 엔티티로 이동합니다. |

# 팝업

메이커의 프로 모드에서 특정 팝업 창을 여는 단축키입니다.

| 단축키 | 액션 | 설명 |
| --- | --- | --- |
| `Ctrl(L)` + `Alt(L)` + `1` | Map List | **Map List** 창을 엽니다. |
| `Ctrl(L)` + `Alt(L)` + `2` | MapleStory Map | **MapleStory Map** 창을 엽니다. |
| `Ctrl(L)` + `Alt(L)` + `3` | Script Manager | **Script Manager** 창을 엽니다. |

Update 2025-11-17 PM 08:14


# Entity, Component, Property

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

Entity와 Component 그리고 Property에 대해서 개념을 이해합니다.

# Entity

엔티티는 메이플스토리 월드 내에서 존재하는 객체입니다. 아래의 그림에서 Entity는 어떤 것들일까요? ![Entity_Component_Propoerty_1](https://mod-file.dn.nexoncdn.co.kr/bbs/1634523787794b80552669cd948a59e89f799d0a016fe.png)  빨간색을 칠한 부분이 Entity입니다. 그뿐만 아니라 보이지는 않지만 돌아가고 있는 모든 것들이 Entity입니다. ![Entity_Component_Propoerty_2](https://mod-file.dn.nexoncdn.co.kr/bbs/16345239132331e370f40d8cb452aa323567c080660a0.png)  메이플스토리 월드에서는 실제로 수많은 Entity가 배치되어 있고 실시간으로 생성, 변경, 삭제됩니다. Entity들이 실제 게임상에서 활동함으로써 시각적으로 보이며, 내부적으로 로직이 돌아가게 됩니다.  그럼 Entity는 뭐로 구성이 되어 있을까요?

# Component

Entity는 Component들로 구성되어 있으며 Component들의 집합체로 볼 수 있습니다. Component는 각각의 요소를 담당하고 있으며 각각의 기능을 담당합니다.  피자를 예로 들어볼까요? ![pizza](https://mod-file.dn.nexoncdn.co.kr/bbs/163547555559905a1c30c66a24b689e06baf34fc3a750.png)  내 앞에 완성된 피자가 있다고 생각해봅시다. 이 피자는 향기도 나며 먹을 수 있습니다. 이 피자는 Entity에 해당합니다.  위 피자를 구성하고 있는 것은 토마토, 도우, 소스 등이 있습니다. 그리고 보이지는 않지만 조리 방법 같은 것도 있습니다. 이것들이 모두 Component입니다.

- 토마토 Component
- 도우 Component
- 소스 Component
- 조리법 Component  Component는 각각의 기능을 담당하며 때로는 다른 Component와 결합하여 다른 효과가 날 수도 있습니다. 이렇게 각각을 Component로 분리하는 이유는 재사용성이 높기 때문입니다. 예를 들어서 다른 피자를 만들고 싶다고 할 때
- 치즈 피자 = 도우 + 소스 + 치즈 + 오븐 조리
- 파인애플 피자 = 도우 + 소스 + 치즈 + 파인애플 + 오븐 조리
- 냉동 불고기 피자 = 도우 + 소스 + 치즈 + 불고기 + 전자레인지 조리  이렇게 이미 만들어진 Component를 가지고 잘 조합을 한다면 다른 형태가 나오기 때문이죠  메이플스토리 월드에서는 프로퍼티 에디터에서 Component를 관리합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1635475521115072c13f11f5e4c49abea1035b8234c82.png)  앞서 말한 대로 Entity는 Component들로 구성이 되어 있고, Entity Editor를 열면 위 그림과 같이 Component들로 구성이 되었습니다. 따라서 기능이 잘 분리된 Component들을 잘 조합 한다면 내가 원하는 형태로 원하는 동작을 할 수 있는 Entity를 제작할 수 있습니다.  그렇다면 정해진 Component만을 조합하면 내가 원하는 Entity를 생성할 수 있는 걸까요?

# Property

Property는 각 Component의 세부사항을 설정합니다. Component에서 예시를 든 피자로 다시 돌아와 볼까요?  세 명의 아이가 페퍼로니 피자를 먹고 싶어 합니다. 철수는 페퍼로니가 2배들어 있는 피자를 원하고, 영희는 들어 있는 치즈가 체다가 아닌 모짜렐라 치즈를 원합니다. 윤후는 사이즈를 조금 더 크게 먹고 싶습니다.  기존에 도우 Component, 페퍼로니 Component, 치즈 Component 가 있습니다. 자, 어떻게 하면 될까요?

철수는 페퍼로니 2배 Component를 추가하고 영희는 모짜렐라 치즈 Component를 추가하고 윤후는 도우 2배 Component, 페퍼로니 2배 Component, 치즈 2배 Component를 추가합니다.  이렇게 하면 원하는 형태의 피자(Entity)를 만들 수 있습니다. 하지만 Component의 재사용성이 떨어지는군요. 앞서서는 Component가 재사용성이 높다고 하였는데 결국 다 따로 만들어 줘야 하는군요.  그럼 어떻게 하면 될까요?  바로 Property를 이용하는 겁니다. Property는 Component에서 주요 설정이 필요한 항목들을 의미합니다. 그렇기에 같은 Entity가 같은 Component를 사용하더라도 Property 값이 다르면 다르게 동작하게 할 수 있는 거죠.  예를 들어서 도우 Component에는 "Size"라는 Property가 있습니다. 치즈 Component에는 "Size"와 "치즈 Type" 이라는 Property가 있고 페퍼로니 Component에는 "Size"라는 Property가 있다고 한다면, 세 친구 모두 같은 Component를 사용한 피자(Entity)를 만들 수 있습니다. 물론 각각의 Property는 다르지만요.  다시 메이플스토리 월드로 돌아와서 이처럼 각각의 Component는 Property들로 세부 속성을 정할 수 있습니다. 말풍선을 뿌릴 수 있는 ChatBalloonComponent에 대해서 살펴볼까요?

| BalloonScale | FontSize |
| --- | --- |
| ![Entity_Component_Propoerty_5](https://mod-file.dn.nexoncdn.co.kr/bbs/16345465139383799f3fe0d2a45f694d9126878968370.png)<br>말풍선의 크기를 설정합니다. <br>값이 커질수록 말풍선의 크기도 커집니다. | ![Entity_Component_Propoerty_6](https://mod-file.dn.nexoncdn.co.kr/bbs/1634546537630dd90d539b29b4f15bf01cdb6eec31a1a.png)<br>말풍선 텍스트의 크기를 설정합니다. <br>값이 커질수록 텍스트 크기도 커집니다. |

이 ChatBalloonComponent는 Scale과 FontSize라는 Property를 가지고 있습니다. 각각의 속성에 따라 Entity별로 다르게 설정할 수 있으며, 각각 다르게 동작합니다.

Update 2025-11-17 PM 08:14


# 로컬화된 Entity

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

클라이언트에서만 생성되는 로컬화된 엔티티에 대해 알아봅시다.

##### 참고 가이드

[서버와 클라이언트](/docs?postId=207) [예시로 알아보는 서버 검증](/docs?postId=1084) [패킷 변조 대비하기](/docs?postId=1102) [Effective MSW 2](/docs/?postId=560)

# 로컬화된 엔티티

**로컬화된 엔티티(Localized Entity)**란 클라이언트에서만 생성되는 엔티티를 의미합니다. Hierarchy 창에서는 ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1744353390721e6e7eb37353d4042aabf7d24c432ba27.png)가 표시된 엔티티로 구분되어 표시됩니다. 메이플스토리 월드의 엔티티는 기본적으로 서버와 클라이언트에서 각각 생성됩니다. 이는 쉬운 멀티 플레이 월드 제작을 돕기 위함입니다. 그러나 서버에 생성되는 엔티티가 많아질수록 서버의 부담이 늘어나게 됩니다. 만약 서버에서 관리할 필요가 없는 엔티티라면 클라이언트에서만 생성되도록 로컬화된 엔티티로 제작할 수 있습니다. 월드의 꾸미기 요소로 사용하는 엔티티나 데이터를 저장하지 않아도 되는 엔티티를 로컬화하면, 서버-클라이언트 간의 동기화와 통신을 적게 사용함으로써 더욱 효율적으로 월드를 만들 수 있습니다.

로컬화된 엔티티를 사용할 때는 4가지 유의 사항을 염두에 두고 사용해야 합니다.

1. **부모-자식** 관계에 영향을 받습니다. 부모 엔티티를 로컬화된 엔티티로 변경하면 자식 엔티티 모두 동일하게 변경됩니다.
2. **서버 실행제어 함수**를 사용할 수 없습니다.
3. 서버에서 검증 작업을 할 수 없으므로 변조, 해킹에 취약합니다. 월드 생태계에서 중요한 역할을 하는 엔티티의 경우 로컬화된 엔티티로 사용하지 않도록 주의해야 합니다.
4. **PortalComponent**의 경우 로컬화된 엔티티에서 사용할 수 없습니다. 또한 서버 기능을 사용하는 컴포넌트의 경우 일부 기능이 정상적으로 동작하지 않을 수 있습니다.

# 로컬화된 엔티티 만들기

서버와 동기화되는 기본 엔티티를 로컬화된 엔티티로 사용하는 방법은 3가지입니다.

#### Localize 프로퍼티 활성화

**Localize** 프로퍼티를 활용해 엔티티를 로컬화할 수 있습니다. 이 프로퍼티는 World 하위에 생성하는 엔티티에서만 활성화됩니다. 이 기능을 활성화하면 Scene에 직접 엔티티를 배치했더라도 클라이언트에서만 생성됩니다. **Hierarchy - World - maps** 하위에 배치한 엔티티를 **프로퍼티 창 - 모델 프로퍼티**에서 `Localize` 활성화합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174433695073900c80e0cc0604735bd090b707991c89b.png)

#### UI 엔티티로 생성

**ui - UI Group**에 생성되는 **UI엔티티**는 클라이언트에서만 생성이 됩니다. UI 엔티티의 경우 기본값이 로컬화된 상태이므로 프로퍼티 에디터 창에 Localize 프로퍼티가 없습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1744354007080d2ad5568bf8c4085889573254f82f4ea.png)

#### SpawnService 활용한 동적 생성

클라이언트 공간에서 `SpawnService`를 호출해 로컬화된 엔티티를 동적으로 생성할 수 있습니다. 동적으로 엔티티를 생성할 때는 생성할 엔티티의 수만큼 SpawnService를 호출해야 합니다. 이는 월드 제작 효율성을 저하시킬 수 있으므로 필요할 때만 사용하는 것이 좋습니다.

Update 2025-11-17 PM 08:14


# 모델

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

자주 사용했던 모델의 개념을 정확히 이해합니다.

# 원하는 Entity 만들기

원하는 엔티티를 만들려면, 엔티티에 컴포넌트를 추가하고 프로퍼티를 수정해야 합니다.

다음과 같은 나무를 만들어봅시다. ![Model_1](https://mod-file.dn.nexoncdn.co.kr/bbs/1634553528053ca48e93975e04ccaa843244bbcde7219.png)  엔티티를 만들고 컴포넌트를 추가하고 프로퍼티를 알맞게 수정했습니다. 완성이군요!  이렇게 여러 개의 나무를 모아서 숲을 만들고 싶습니다. 어떻게 하면 될까요? ![Model_2](https://mod-file.dn.nexoncdn.co.kr/bbs/16345535759657d1c01e5106d4d939c547586dae942b3.png)  엔티티를 만들고 컴포넌트를 추가하고 프로퍼티를 4번 수정하면 되겠군요. 나무가 100개가 있다면 어떻게 하면 될까요? 그렇습니다. 100번을 해야 합니다. 이 행위는 너무나 피곤합니다. 어떻게 하면 좋을까요?

# 모델

잠시 일상생활로 돌아가서, 우리가 어떤 그림을 그린다고 생각해 봅시다. ![star_circle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480499353135233e3daf946998fda9453abc5312b.png)  이런 별을 한 개 그려봅시다. 별을 여러 개 그린다고 가정할 때 쉽게 할 수 있는 방법은 무엇일까요? 많은 방법이 있겠지만 대표적인 예시로 이런 도장을 만들면 됩니다. ![stamp_starcircle](https://mod-file.dn.nexoncdn.co.kr/bbs/163548052969636561321444d4686876e3d3b69442c8f.png)  이 도장을 찍으면 별이 나올 테니까요, 그냥 단순히 3번만 찍어도 별이 3개 나옵니다. ![star_circle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480499353135233e3daf946998fda9453abc5312b.png) ![star_circle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480499353135233e3daf946998fda9453abc5312b.png) ![star_circle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480499353135233e3daf946998fda9453abc5312b.png)  메이플스토리 월드로 돌아가 봅시다. 메이플스토리 월드에도 이런 "도장" 이 있으면 편리할 것입니다. 그것이 바로 **모델**입니다.  **모델**은 어떤 엔티티의 컴포넌트와 프로퍼티 정보를 가지고 있는 판본입니다. 여러분들은 이미 이 모델을 매우 친숙하게 사용하고 있습니다. ![Model_3](https://mod-file.dn.nexoncdn.co.kr/bbs/165993039740743e32904b0f442ebbd627968576bb02a.png)  **Preset List**에서는 메이플스토리 데이터를 바탕으로 기본적인 프리셋을 제공하고 있습니다. 그렇다면 메이플스토리 리소스에서 컴포넌트와 프로퍼티를 변경한 뒤 이것을 자주 사용해야 한다면 어떻게 해야 할까요? 혹은 제작 중인 월드에서 완전히 새로운 나만의 엔티티를 만들어 빈번하게 사용해야 한다면 어떻게 해야 할까요?

# 모델화

잠시 일상생활로 돌아가 봅시다. ![star_circle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480499353135233e3daf946998fda9453abc5312b.png)  이런 도장을 찍었지만 동그란 테두리가 마음에 들지 않습니다. 네모난 테두리로 바꾸고 싶습니다. 그래서 동그란 원을 쓱쓱 지우고 네모난 사각형을 그립니다. ![star_quadangle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480621736d7207f056a4945c0bf13a531fb8a5e3f.png)  마음에 듭니다. 이 별을 여러 개 나열하려면 어떻게 하면 될까요? 도장을 찍고 → 동그란 원을 지우고 → 사각형을 그리는 과정을 별 개수만큼 하면 됩니다. 이것은 너무 번거로운 방법입니다. 쉬운 방법은 없을까요?  바로 도장을 새로 만드는 것입니다. ![stamp_starQuadangle](https://mod-file.dn.nexoncdn.co.kr/bbs/1635480687931bb4a27c2a1154b239d9256faec98820f.png)  이렇게 말입니다. 하지만 도장 하나 만드는 건 쉬운 일이 아닙니다. 그렇다면 어떻게 하면 될까요? 별 도장 따로, 원 테두리 도장 따로, 사각형 테두리 도장 따로 만들면 되겠군요.

- 별 도장 + 원 테두리 = 원 별
- 별 도장 + 사각형 테두리 = 사각형 별

하지만 삼각형 테두리가 생기면? 별이 아닌 하트를 만든다면? 조합은 가능하나 잘 나눠야 하고 전혀 새로운 타입이 나온다면 처음부터 다시 만들어야 합니다. 이런 고민의 근본적인 문제는 도장을 하나 만들기가 쉽지 않기 때문입니다.  다시 메이플스토리 월드로 돌아와 볼까요? 메이플스토리 월드에서는 모델(예: 도장)을 만들기가 매우 쉽습니다. 그림 자체를 바로 도장으로 만들 수 있기 때문입니다.  즉, 엔티티를 모델로 변환하는 것, 그것이 바로 **모델화**입니다. 예시를 통해 살펴봅시다.  기존에 나무 모델에 **ChatBalloonComponent**를 추가해서 "말하는 나무"를 만들었습니다. ![Model_4](https://mod-file.dn.nexoncdn.co.kr/bbs/16345560690347d9b46707db345c8abf5b57f0cca67e9.png)  "말하는 나무" 100개를 만들려면 나무 오브젝트를 배치하고 **ChatBalloonComponent** 추가 작업을 수없이 반복해야 합니다. 이러한 단순 반복을 피하는 아주 쉬운 방법이 있습니다. 바로 처음 만든 "말하는 나무"를 **모델화** 하는 것입니다. "말하는 나무"의 콘텍스트 메뉴에서 **Create Model From Entity**를 클릭하면 엔티티를 모델로 만들 수 있습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1659932995539100fa46c3c824656b22c4ad30f184791.png)  이렇게 만든 모델은 **Workspace - MyDesk**에서 확인할 수 있습니다. 나만의 "말하는 나무" 도장을 마음껏 활용해 봅시다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1659933437521b3f0c8b795714806b51ec2ca7d38689f.png)

Update 2025-11-17 PM 08:14


# 모델의 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 모델 확장과 모델 생성 방법, 그리고 모델 프로퍼티의 편집 방법을 알아봅니다. 본 과정을 진행하기 전에 [모델](https://mod-developers.nexon.com/docs?postId=55) 가이드를 먼저 살펴보면 도움이 됩니다.

# 모델 확장

**모델**은 자신이 갖고 있던 속성, 즉 같은 컴포넌트와 프로퍼티 값을 물려받은 확장 모델을 생성할 수 있습니다. 얼핏 복사와 개념이 비슷한 것 같지만 복사와는 다릅니다.

- **복사**
  - 원본 모델과 복사된 모델이 독립적으로 존재하기 때문에 속성을 수정하면 서로에게 영향을 주지 않습니다.
- **확장**
  - 기반 모델과 확장 모델의 관계가 유지됩니다.
  - 기반 모델의 속성을 변경하면 확장 모델에도 적용됩니다.
  - 확장 모델이 물려받은 속성은 삭제하지 못하는 등의 편집 제한이 있습니다.

## 모델 확장 방법

**Workspace**에서 원하는 모델을 선택한 뒤, 콘텍스트 메뉴에서 **Extend**를 클릭해 확장 모델을 만듭니다. 일반적으로 **NativeModel**을 확장하거나, 이미 생성된 모델을 확장합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/168748927574808ba5739c2514974927e404e117fb58a.png)

**Scene**에 배치된 엔티티에서 확장 모델을 만들 수도 있습니다. 엔티티의 콘텍스트 메뉴에서 **Create Extended Model From Entity**를 클릭하면 확장 모델이 생성됩니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1659699619694576dc357b7da4990b5690ff856b3ca3e.png)

확장 모델은 **MyDesk**에 생성됩니다. 확장 모델의 컴포넌트와 프로퍼티를 살펴보면 기반 모델과 같은 것을 확인할 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16596999700401c39926d07ac4d4c96e15f28690ad8a4.png)

## 모델 확장의 특징

확장 모델은 기반 모델로부터 컴포넌트와 프로퍼티 초깃값을 물려받습니다. 예를 들어 **Model A**에 **컴포넌트 A, B, C**가 포함되어 있다면, A의 확장 모델인 **A1**도 **컴포넌트 A, B, C**를 포함하고 있고, 프로퍼티 값도 **기반 모델과 같은 초깃값**으로 설정되어 있습니다.

![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1659937910290f4135be616534e058a42ea11f624d982.png)

> **Tip.** 확장한 이후에 확장 모델의 프로퍼티 값은 기반 모델의 초깃값과 다르게 설정할 수 있습니다.

만일 기반 모델에 새로운 컴포넌트를 추가하거나, 혹은 이미 있던 컴포넌트를 삭제하면, 해당 기반 모델에서 확장된 모든 모델에도 같은 변화가 적용됩니다.  예를 들어 봅시다.

- **Model A**에 컴포넌트 A, B가 포함된 상태로 확장 모델 **A1**을 만든 뒤,
  - **Model A**에 컴포넌트 C를 추가하면 **A1**에도 컴포넌트 C가 추가됩니다.
  - 반대로 **Model A**의 컴포넌트 A를 삭제하면, **A1**에도 컴포넌트 A가 삭제됩니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16599385674172dc29b11c0d34513b9f9d68582466546.png)

단, 확장 모델은 기반 모델로부터 받은 컴포넌트를 삭제할 수 없습니다. 예를 들어, **Model A**에서 **컴포넌트 A, B, C**를 물려받은 확장 모델 **A1**은 **컴포넌트 A, B, C**를 삭제할 수 없습니다. 물려받은 컴포넌트를 삭제하려면 **A1**이 아닌 **Model A**에서 삭제해야 합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16599392579591f653ee65ab24429960ab8db9df69f1d.png)

기반 모델에 추가한 컴포넌트가 확장 모델에도 추가되는 것과 달리, 확장 모델에 추가한 컴포넌트는 기반 모델에 추가되지 않습니다. 즉, **Model A**의 확장 모델 **A1**에 컴포넌트 C를 추가하면 **A1**에는 포함되지만, **Model A**에는 포함되지 않습니다. 이를 활용하면 확장 모델만이 가질 수 있는 컴포넌트를 추가하여 기반 모델과는 다른 특성을 부여할 수 있습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1659939801137ef0cf58931c24d0d8a8faff04f187d68.png)

## 모델 계층 구조 확인하기

모델 간의 관계는 프로퍼티 에디터의 **Model Extension Info**에서 확인할 수 있습니다. 선택한 모델의 모든 기반 모델과 바로 아래 단계의 확장 모델을 계층 구조로 보여줍니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/165970035134839cc60633a0e497a91bb193aee9266b2.png)

계층 구조에 나타난 모델의 콘텍스트 메뉴에서 **Find Model**을 클릭하면 **Workspace**에서 해당 모델이 선택됩니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16599220988603cbb965fd0cf49898454e6c0b7fb2657.png)

# 신규 모델 생성

엔티티를 생성할 때는 주로 **Preset List**의 모델을 활용합니다. **Preset List**의 모델은 기본적으로 **NativeModel**의 특성을 물려받습니다. 그래서 **Preset List**의 모델 속성을 변경하려면 **NativeModel**을 수정해야 합니다. 하지만 **NativeModel**의 속성을 변경하면 해당 **NativeModel**에서 확장된 **Preset List**의 모델 속성이 모두 변경되어 버립니다. 작업 과정에서 원래 모델의 특성이 필요할 때는 또다시 수정해야 하므로 불편합니다.  **NativeModel**을 수정하지 않고도 **Preset List**에서 제공하지 않는 신규 모델을 생성할 수 있다면 편리할 것입니다. 신규 모델은 **NativeModel**에서 독립적이므로 수정과 변형이 자유롭습니다. 신규 모델을 만드는 방법은 다음과 같습니다.

- **방법 1**
  - **Workspace**에서 **[+]** 버튼 - **Create Model**을 클릭합니다.
- **방법 2**
  - **Workspace**의 콘텍스트 메뉴에서 **Create Model**을 클릭합니다.

![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1687494524198d8a118789c98467984663edb5051443b.png)

생성한 신규 모델에는 아무 컴포넌트도 없기 때문에 해당 모델을 엔티티로 배치해도 의미가 없습니다. 생성한 신규 모델의 용도에 따라 기본 컴포넌트를 추가해 사용해야 합니다. 생성한 신규 모델로 월드 엔티티를 생성할지, UI 엔티티를 생성할지에 따라 아래의 기본 컴포넌트를 추가해 봅시다.

| 월드 엔티티 | UI 엔티티 |
| --- | --- |
| <ul><li>TransformComponent</li><li>SpriteRendererComponent</li></ul> | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li></ul> |

**Workspace**에 빈 모델을 만든 뒤 원하는 컴포넌트를 추가할 수도 있지만, 이미 **Scene**에 배치한 엔티티를 신규 모델로 만들 수도 있습니다. 컴포넌트와 프로퍼티 값을 눈으로 보며 수정한 엔티티를 모델로 만들기 때문에 추가 편집을 할 필요가 없어 편리합니다. 배치한 엔티티의 콘텍스트 메뉴에서 **Create Model From Entity**를 클릭하면 엔티티를 모델로 만들 수 있습니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1659922427878a28dedc49ae74672b7c707d7cde5d520.png)

# UI 엔티티로 모델 생성

UI 엔티티도 모델로 만들 수 있습니다. 예를 들어, 아래와 같이 **NewUIGroup**에 있는 **Button01**과 **Button02**를 모델로 만든다고 가정해 봅시다. ![uimodel01](https://mod-file.dn.nexoncdn.co.kr/bbs/1667281846129e4eac692fe634d5f94367e7eb8c080ff.png)

**Button01**과 **Button02**의 상위 엔티티인 **UISprite**의 콘텍스트 메뉴에서 **Create Model From Entity**를 클릭하면 **Workspace - MyDesk**에 **Model_UISprite**가 생성됩니다. ![uimodel02](https://mod-file.dn.nexoncdn.co.kr/bbs/1667281948281b5607277f7cd42eaa18987580c9e546a.png)

이처럼 UI를 모델화하면 MSW 패키지에 포함할 수 있기 때문에 UI를 다른 월드로 옮길 때 활용할 수도 있습니다.

> **더 알아보기** 패키지 활용 방법은 [MSW 패키지의 활용](/docs/?postId=647) 가이드를 참고합시다.

단, UI 엔티티를 모델화할 때는 몇 가지 제약이 존재하므로 주의해야 합니다.

- 모든 **UIGroup** 엔티티는 모델화할 수 없습니다.
- **Default Group** 내 **Native** 상태로 구현된 **UIChat**과 **UIJoystick**은 모델화할 수 없습니다.
- **Extension Info**에서 **Break** 되는 등 일부 확장 불가능한 모델은 모델 확장 기능을 사용할 수 없습니다.

# 모델의 엔티티 생성

신규 모델이나 확장 모델을 엔티티로 생성하려면 **Workspace**에서 원하는 모델을 **Scene**에 드래그합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1656034659249381775e32b3b4809aacebc9675b6a737.png)

# 모델 편집

## NativeModel과 Preset List

모델을 통해 엔티티를 생성할 수 있으며, **Preset List**에서 제공하는 **Preset**도 결국 모델이라는 것을 [Model](/docs?postId=55) 가이드를 통해 배웠습니다. **Preset List**의 모델은 **NativeModel**에서 확장되었기 때문에 **Preset List** 카테고리 단위로 **NativeModel**의 속성을 물려받습니다. 따라서 각 카테고리에 해당하는 **NativeModel**을 변경하면 **Preset List**의 모델에도 변화가 생깁니다. 예를 들어 **Preset List - Object** 카테고리의 모델 속성을 변경하려면 **NativeModel - MapObject** 속성을 변경하면 됩니다. 만일 **Object** 모델을 엔티티로 생성할 때 2배 크게 생성하고 싶다면 **MapObject** 모델의 **Scale** 값을 **2**로 설정하면 됩니다.

![14](https://mod-file.dn.nexoncdn.co.kr/bbs/166026562910074f2778c33374262853f0e05fa39d5bb.png)

## 모델 프로퍼티

모델이나 엔티티의 프로퍼티 에디터 최상단에는 어떠한 컴포넌트에도 속하지 않은 프로퍼티가 있습니다. 이것이 **모델 프로퍼티**입니다. 모델 프로퍼티는 각 모델 또는 엔티티에 포함된 컴포넌트의 일부 프로퍼티를 즐겨찾기처럼 모아놓은 것입니다. 모델 프로퍼티는 컴포넌트의 프로퍼티가 투영된 것이기 때문에 모델 프로퍼티의 값이 변경되면 이에 해당하는 컴포넌트의 프로퍼티 값도 함께 변경됩니다. 예를 들어 **Object-1** 엔티티의 모델 프로퍼티 중 하나인 **Scale** 값을 **x = 10, y = 10, z = 10**으로 변경하면 **TransformComponent**의 **Scale**도 같은 값으로 바뀝니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1660265944245a95af2dcab5a4f26b5a3dc3b8793ec81.png)

모델 프로퍼티는 크리에이터의 편의에 맞춰 편집할 수 있습니다.

1. 편집하고자 하는 모델을 선택한 뒤, 모델 프로퍼티 상단의 ≡ 버튼을 클릭합니다.
2. 메뉴에서 **View Model Property**를 선택하여 모델 프로퍼티 편집 모드로 전환합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/166026617550958db5ba62369422292141e0fe5384465.png)
3. 각 프로퍼티 우측의 체크박스에 체크하면, 해당 프로퍼티를 모델 프로퍼티로 지정할 수 있습니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16393866635475d8a437cbd164248828822fe5ece17a3.png)
4. 모델 설정 메뉴에서 View Component Property를 선택하여 체크한 프로퍼티가 모델 프로퍼티에 표시되는 것을 확인합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16602672025747fe01c63b5fb40a19a5b048aaab4dfee.png)

Update 2025-11-20 PM 02:03


# 맵 레이어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

맵 레이어를 사용해 더욱 입체적으로 게임 화면을 디자인할 수 있습니다. 맵 레이어 창 구성을 살펴보고 활용하는 방법을 알아봅니다. 레이어 순서를 이해하고 레이어를 크리에이터의 게임에 맞게 활용할 수 있습니다.

# 맵 레이어 위치

맵 레이어 창은 기본 패널 설정 기준, 중앙 하단에 위치합니다. 작업 편의를 위해 탭을 닫은 후 다시 불러올 때는 **Panels - Map Layer**을 선택해 불러올 수 있습니다.

| 메이커 화면 기본 위치 | Panels - Map Layer |
| --- | --- |
| ![maplayer00](https://mod-file.dn.nexoncdn.co.kr/bbs/1661140579188d3b512992aad4a18bbc9411950f72d74.png) | ![maplayer](https://mod-file.dn.nexoncdn.co.kr/bbs/16595798309379692d0ca050848bea645debe9cb9286c.png) |

> **Tip** **Panels - Reset Panels**를 선택해 패널 상태를 초기화 할 수 있습니다. ![maplayer01](https://mod-file.dn.nexoncdn.co.kr/bbs/1682665165619440c6c5225ce4744b4e76a8245f1401a.png)

# 맵 레이어 창 구성

![MapLayer01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634540764998600230c000ac4c658b69d24a38131f32.png)

| 번호 | 아이콘 | 설명 |
| --- | --- | --- |
| ![NO01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg) | ![Common_FocusOn](https://mod-file.dn.nexoncdn.co.kr/bbs/16345366745866d71bbf1f9f3454786e3f3477e268b01.png) | 선택한 단일 레이어만 확인할 수 있습니다.<ul><li>None: 모든 레이어가 활성화된 상태입니다.</li></ul><ul><li>Focus: 선택한 레이어 하나만 활성화된 상태입니다. 다른 레이어는 반투명하고 어둡게 보여 활성 상태가 다름을 알 수 있습니다. 비활성 된 레이어는 씬에서 선택할 수 없습니다.</li></ul> |
| ![NO_02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg) | ![Common_show_black](https://mod-file.dn.nexoncdn.co.kr/bbs/1634538484615e92129425be84676a7af1ba82a8c1510.png) | 비활성화하면 해당 레이어에 배치된 엔티티가 숨겨지며 보이지 않습니다.<br>제작 중에만 보이지 않으며 테스트 실행, 게임 출시 시 비활성화 된 레이어가 모두 활성화됩니다 |
| ![NO_03](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg) | Layer | 총 10개의 Layer를 만들 수 있습니다. |
| ![NO_04](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541326353d8628c1473944497bf376acb7a65ca45.jpg) | ![Common_lock](https://mod-file.dn.nexoncdn.co.kr/bbs/1634537017666e283f66030444da08eddef99819b2b07.png) | 선택한 레이어를 잠급니다. 잠겨진 레이어에 속한 모든 엔티티를 선택하거나, 변경할 수 없습니다. |
| ![NO_05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541338689678f574f21e54a6ca533737924124d7e.jpg) | ![Common_layer_add](https://mod-file.dn.nexoncdn.co.kr/bbs/16345369150225f875c8c218444c58189ffac05201631.png) | 빈 레이어를 추가할 수 있습니다. 레이어를 추가하면 직전에 만든 엔티티 바로 위로 LayerN(숫자) 이름으로 새롭게 생성됩니다. |
| ![NO_06](https://mod-file.dn.nexoncdn.co.kr/bbs/163454135201207284554a25b498380fff224cd767f6b.jpg) | ![Common_LayerDelete](https://mod-file.dn.nexoncdn.co.kr/bbs/1634536995484055ff8f9ba99415486f815f599c0702d.png) | 레이어를 삭제합니다. 복구가 불가능하므로 신중하게 삭제하길 바랍니다. |

# 맵 레이어 이해하기

레이어란 맵 화면 위에 올리는 투명한 판과 같습니다. 판 위에 여러 엔티티를 올리고, 또 다른 투명한 판을 올리면 새로운 엔티티를 배치할 수 있습니다. 레이어 창 가장 아래에 깔린 레이어가 맵 화면에서 가장 뒤에 위치하게 되고, 맨 위에 있는 레이어가 가장 앞에 배치됩니다. 레이어에 배치된 엔티티들은 레이어 순서에 일괄적으로 영향을 받습니다. 가장 아래 있던 레이어를 위로 올리는 순간, 엔티티의 순서가 함께 변경됩니다. ![maplayer01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634601877817d0b37c6d8fbb4f668d37ea25d1783418.png) ![maplayer02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634601899530a6e1a61208ba414ba15bb4a138e038de.png)

#### 레이어 우선순위 적용 규칙

메이커에서 엔티티 순서는 아래 순서에 따라 결정됩니다.

1. **Map Layer** (SpriteRendererComponent의 SortingLayer)
2. **SpriteRendererComponent의 OrderInLayer 프로퍼티**
3. **TransformComponent의 Position Z값** [엔티티의 위치, 크기, 회전 조정](/docs?postId=82)을 참고하세요.

#### 모델의 레이어 순서

모델은 배치 편의를 위해 유형 별로 **OrderInLayer** 기본값이 정해져 있습니다.

![maplayer09](https://mod-file.dn.nexoncdn.co.kr/bbs/1682664093514566667bb5ccc473ca19732e72f275630.png)

**모델 유형별 OrderInLayer 기본값**

| OrderInLayer 값 | 모델 유형 |
| --- | --- |
| 0 | 오브젝트 |
| 1 | 타일 |
| 2 | 몬스터, NPC, 발판, 사다리, 로프, 포탈, 트랩, 아이템 |
| 3 | 타 이용자의 아바타 |
| 4 | 나의 아바타 |

분류된 값을 임의로 변경해 배치 순서를 바꿀 수 있으나, "3 이상의 값"을 입력하는 것은 지양합니다. 월드를 플레이할 때 아바타가 가려질 수 있기 때문입니다.

> **더 알아보기** 단일 레이어에서 같은 분류의 엔티티를 여러 개 배치하면, 마지막에 배치한 엔티티가 앞에 옵니다.

# 맵 레이어와 플레이어 아바타 관계

플레이어 아바타는 엔티티이지만, 다른 엔티티와 몇 가지 차이가 있습니다.

- 플레이어 아바타는 편집 상태에서 맵에 배치할 수 없고, 특정 레이어에 귀속되지 않습니다.
- 다른 엔티티는 움직임과 관계 없이 처음 배치된 맵 레이어에만 속합니다. 하지만 플레이어 아바타는 현재 밟고 있는 엔티티(타일, 발판 등)의 맵 레이어로 소속이 계속 바뀝니다. 두 개의 활용 예시를 보며 맵 레이어와 플레이어 아바타의 관계를 살펴보시길 바랍니다.

#### 활용 예시 1

초록 타일은 Layer1에, 연두 타일은 Layer2에 배치했습니다. 초록 타일을 밟고 있는 플레이어 아바타는 점프할 때까지는 Layer1에 머물러 있지만, 노란 타일에 착지하는 순간 Layer2에 있는 상태가 됩니다. ![maplayer04](https://mod-file.dn.nexoncdn.co.kr/bbs/16346025247675038e0d2fd854f5e80a5359fe45d2df8.gif)

#### 활용 예시 2

4개의 레이어에 각각 타일과 오브젝트를 배치했습니다.(OrderInLayer는 기본값입니다.) 플레이어 아바타는 밟고 있는 엔티티 레이어가 귀속 기준이므로 가장 아래 있는 layer1에서 움직이기 시작합니다. 초록 타일 위 나무 오브젝트들은 Layer4에 배치되어 있습니다. 그러므로 초록 타일을 밟으며 이동하는 아바타는 나무 오브젝트 뒤로 이동합니다.

플레이어 아바타가 연두 타일로 이동하면, 플레이어 아바타는 Layer3에 속합니다. 연두 타일 위의 장난감 오브젝트들은 Layer2에 배치되어 있습니다. 연두 타일이 Layer2보다 위에 있는 레이어에 속해있기 때문에 아바타는 장난감 오브젝트 앞으로 지나갑니다.

레이어 특성과 오브젝트를 적절히 이용해 불구덩이를 뚫고 가거나, 수풀을 헤쳐나가는 듯한 연출을 만들 수 있습니다. ![maplayer05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634602745986d158da5858dc44be9481dbd8b21ef50e.gif) ![maplayer07](https://mod-file.dn.nexoncdn.co.kr/bbs/1634620453053bba58d9571604df192a0ce5d56451b6d.png)

# 마무리

맵 레이어를 활용하면 엔티티를 특징 별로 묶어 관리할 수 있습니다. 이는 커다랗고 복잡한 맵을 만들수록 힘을 발휘합니다. 처음 월드를 제작한다면, 첫 기획과 다른 방향으로 흘러갈 수 있으니 처음부터 레이어 활용 규칙을 익혀 변동에 유연하게 대처하며 게임을 제작해보세요.

Update 2025-11-19 PM 05:04


# 월드 좌표와 스크린 좌표

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드의 월드 공간과 스크린 공간이 존재합니다. 각 공간에서는 서로 다른 좌표계를 사용합니다. 두 공간에서 사용하는 좌표계에 대해 알아봅시다.

# 월드 공간

월드 공간이란 Hierarchy - world - map의 공간을 의미합니다.

## 월드 좌표

월드 좌표는 맵에서의 특정 위치 값입니다. 맵에 배치된 엔티티의`TransformComponent.WorldPosition` 값이 월드 좌표입니다. 월드 좌표의 원점은 맵의 중앙입니다. 예를 들어 아래 이미지와 같이 **분수 Entity**는 월드에서 X = 23.91, Y = -3.37, Z = 999.953에 위치한다는 것을 **WorldPosition** 값으로 알 수 있습니다.

![fountain](https://mod-file.dn.nexoncdn.co.kr/bbs/16560451065876f02eae1080d46618432600ef68e44ec.png)

# 스크린 공간

스크린 공간에서 사용되는 좌표는 **Screen 좌표**와 **UI 좌표**로 나눌 수 있습니다. 두 가지 좌표 모두 화면 상의 위치 값을 말하지만, 좌표를 계산하는 방식이 다릅니다.

## Screen 좌표

Screen 좌표는 기기의 디스플레이 해상도 픽셀 수와 동일합니다. Screen 좌표의 원점은 좌측 하단이고, 기기마다 액정의 해상도가 다르므로 Screen 좌표의 최댓값 또한 다릅니다. 예를 들어 아이폰 16의 경우 최댓값은 2556 x 1179이고, 갤럭시 S25의 최댓값은 2340 x 1080입니다. Screen 좌표의 값은 `ScreenTouchEvent`, `ScreenTouchHoldEvent`, `UILogic.ScreenWidth`, `UILogic.ScreenHeight`를 활용해 확인할 수 있습니다.

아래는 Samsung Galaxy S10+의 Screen 좌표 원점과 최댓값 좌표입니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17515098580721c29bc7c83a24474bf1b38fb72f3a236.png)

## UI 좌표

UI 좌표는 기기에 따라 원점과 최댓값이 달라집니다. UI 좌표의 기본 원점은 보이는 화면의 중앙이고, UI 좌표의 최댓값은 1920 x 1080에 가깝게 맞춰집니다.

#### 기기별 UI 좌표 원점

- **PC**: 보이는 캔버스의 중앙이 원점(0,0)입니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751510074818eedf66599ea54950bd381b1b30a3f6bf.png)
- **Mobile**: Safe Area의 중앙이 원점(0,0)입니다. **Safe Area**란 모바일 기기에서 노치, 탭 막대 등에 영향을 받지 않고 안전하게 사용할 수 영역을 의미합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17515100532491f1477f2f58c44f088db81ab0ca34efe.png)

UI를 UIGroup에 배치하면 UI 엔티티는 UI 좌표를 사용하게 됩니다. UI 좌표의 원점과 최댓값은 기기마다 다르므로 PC에서 꽉차게 배치했을지라도 다른 기기에서는 화면을 다 채우지 못할 수도 있습니다.

| PC | Apple iPhone 12 Mini | Samsung Galaxy S10+ |
| --- | --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17514482389113061b375c5af442cbc1af9c27e6f984e.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751448252201c407bce361bb4d198816856516c7a183.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751448268722abd9bdd5be9b4e99839a6ded171432d5.png) |

# 해상도별 UI 좌표 영역 처리 방식

UI 좌표 영역의 기본 해상도는 1920 x 1080, 기본 비율은 16:9입니다. 기기 해상도에 따라 월드 화면이 확대/축소되어도 해상도에 관련 없이 항상 눈에 보이는 화면은 모습은 동일하게 유지되도록 처리됩니다.

#### PC

PC를 사용하는 메이플스토리 월드 유저는 창 크기를 변경할 수 있습니다. 그러나 창 크기를 변경해도 창의 화면 비율은 16:9로 유지됩니다. 비율이 유지되므로 화면의 보이는 영역이 비율에 비례해 확대/축소됩니다. 단, 창이 전체 화면인 경우 모니터의 화면 비율에 따라 가로 영역이 더 많이 보이거나 더 적게 보이게 됩니다. 예를 들어 창 크기가 1920x1080일 때와 3840x2160일 때 모두 화면은 동일하게 보입니다.

| 1920x1080 | 3840x2160 |
| --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751526293382a3747cbf4fa24976b52d4dc05e854b79.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1760355323385269cedca02f343a6ad9089315fa4c96d.png) |

#### Mobile

Mobile 기기에서 월드에 입장했을 때는 화면이 가로로 변경됩니다.

보이는 영역은 16:9 비율을 기준으로 세로 영역은 동일하게, 가로 영역은 기기의 해상도 비율에 따라 더 많이 보이거나 더 적게 보여집니다. 아래 그림과 같이 16:12 비율인 iPad Pro 12.9의 해상도는 2732 x 2048이지만, 좌표 영역 전체를 계산하면 1920 x 1439입니다. Screen 좌표와 비율 차이는 약 1.42배로, 16:9에 비해 16:12 비율은 세로가 더 긴 화면이기 때문에 1920을 기준으로 캔버스 크기를 조정한 결과입니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751526324699a520b57239974b27a5a253474d4f7549.png)

또 다른 예로 19:9 비율인 갤럭시 S10+의 해상도는 3040 x 1440이지만, 캔버스 전체 크기는 **2280 x 1080** 입니다. 스크린 좌표와 비율 차이는 약 1.3배로, 16:9에 비해 19:9 비율은 가로가 더 긴 비율이므로 1080을 기준으로 캔버스 크기를 조정한 결과입니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751526357807622abec3694e4ac9a02bc427a92e8ad9.png)

# UI 좌표 설정

UI는 `UITransformComponent`의 Anchor Presets 설정을 기준으로 **PosX, PosY** 값만큼 떨어진 곳에 배치됩니다. Anchor Presets 설정에 따라 필요한 Property가 달라집니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1754011712034b9838df4d63c4911a492903c6d88962f.png)

#### Anchor 설정

**Anchor**는 `UITransformComponent`의 격자 무늬 아이콘을 눌러 선택할 수 있습니다. 선택한 후 **PosX와** **PosY**를 입력하면 Anchor를 기준으로 입력한 값만큼 떨어진 위치에 UI가 배치됩니다. 이때 UI 앵커의 기준점은 Safe Area 영역입니다.

![anchorPresets](https://mod-file.dn.nexoncdn.co.kr/bbs/1652754058498d1bc17b4c1d04e75bc8000fde8722de1.png)

Anchor를 형태(Stretch)로 설정하면 UI가 설정에 맞게 늘어납니다. Anchor가 길게 늘어나는 경우, 종류에 따라 설정할 수 있는 프로퍼티가 달라집니다. 예를 들어, 팝업 메시지의 검은색 반투명 배경 이미지(PopupBack)는 정중앙을 기준으로 UI가 사방으로 늘어 화면을 덮도록 설정되어 있습니다. 어떤 해상도에서든 팝업 메시지가 떴을 때 검은색 배경 이미지가 화려한 색상의 맵을 덮어주어 유저가 팝업 메시지에만 집중하도록 합니다. ![anchorex02](https://mod-file.dn.nexoncdn.co.kr/bbs/165604560743653ab60032b284c4cb1fa149610be2b93.png)

#### Anchor Presets 종류

| Anchor | 설명 |
| --- | --- |
| ![anchor01](https://mod-file.dn.nexoncdn.co.kr/bbs/1652753675728c2aaf37b9f124af7893d195adcef175b.png) | 상단 왼쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor02](https://mod-file.dn.nexoncdn.co.kr/bbs/165275370174172181339e3834ca086504f0c535151ff.png) | 상단 중앙을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor03](https://mod-file.dn.nexoncdn.co.kr/bbs/1652753728860c87e3a1bb08b4b5580456a8cce00f406.png) | 상단 오른쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor04](https://mod-file.dn.nexoncdn.co.kr/bbs/16527537526160827153fdd254b85883a0b2034f68230.png) | 중앙 왼쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor05](https://mod-file.dn.nexoncdn.co.kr/bbs/1652753775316eb1fa9ba8c1b45b29705a7728b78db74.png) | 정중앙을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor06](https://mod-file.dn.nexoncdn.co.kr/bbs/1652753795158b1e8a296bbf44fddb88e77f0d9dd67bf.png) | 중앙 오른쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor07](https://mod-file.dn.nexoncdn.co.kr/bbs/165275381909396f89e4e066c4a9392fb67db882319e1.png) | 하단 왼쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor08](https://mod-file.dn.nexoncdn.co.kr/bbs/16527538405956b6dc7cc784f492cad18daaf2f449f22.png) | 하단 중앙을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor09](https://mod-file.dn.nexoncdn.co.kr/bbs/1652753858060d23fdebc0f4b4f9293594b55d52eacb1.png) | 하단 오른쪽 끝을 기준으로 PosX, PosY 만큼 떨어진 곳에 UI가 위치합니다. |
| ![anchor10](https://mod-file.dn.nexoncdn.co.kr/bbs/165276280240576b4802818d74cf095e74237cb57da69.png) | 상단 중앙을 기준으로 Left, Right 값만큼 남기고 UI가 가로로 늘어납니다. <br>상단 중앙을 기준으로 PosY 값만큼 떨어진 곳에 위치합니다. |
| ![anchor11](https://mod-file.dn.nexoncdn.co.kr/bbs/165276284856863a5c32a8f6c4e20b6261d44d2bda729.png) | 정중앙을 기준으로 Left, Right 값만큼 남기고 UI가 가로로 늘어납니다. <br>정중앙을 기준으로 PosY 값만큼 떨어진 곳에 위치합니다. |
| ![anchor12](https://mod-file.dn.nexoncdn.co.kr/bbs/16527628656822017ed5fcffc4ed7ac43bc57234b13f8.png) | 하단 중앙을 기준으로 Left, Right 값만큼 남기고 UI가 가로로 늘어납니다. <br>하단 중앙을 기준으로 PosY 값만큼 떨어진 곳에 위치합니다. |
| ![anchor13](https://mod-file.dn.nexoncdn.co.kr/bbs/165276288320119af691b47d54ee5a5f8f8cc841ba772.png) | 왼쪽 중앙을 기준으로 Top, Bottom 값만큼 남기고 UI가 세로로 늘어납니다. <br>왼쪽 중앙을 기준으로 PosX 값만큼 떨어진 곳에 위치합니다. |
| ![anchor14](https://mod-file.dn.nexoncdn.co.kr/bbs/1652762899845dbdb414c754049a5b95a6e0d3f7426b8.png) | 정중앙을 기준으로 Top, Bottom 값만큼 남기고 UI가 세로로 늘어납니다. <br>정중앙을 기준으로 PosX 값만큼 떨어진 곳에 위치합니다. |
| ![anchor15](https://mod-file.dn.nexoncdn.co.kr/bbs/1652762937587653a13ae666f45329c6afa9c618617e4.png) | 오른쪽 중앙을 기준으로 Top, Bottom 값만큼 남기고 UI가 세로로 늘어납니다. <br>오른쪽 중앙을 기준으로 PosX 값만큼 떨어진 곳에 위치합니다. |
| ![anchor16](https://mod-file.dn.nexoncdn.co.kr/bbs/1652762962358809eb3ba031f47f491b2a12900b0b324.png) | 정중앙을 기준으로 Left, Right, Top, Bottom 값만큼 남기고 UI가 사방으로 늘어납니다. |

# Anchor Presets 활용

기기마다 해상도와 Safe Area가 다르므로 UI 좌표로 UI 위치를 결정할 경우 기기에 따라 UI의 일부가 잘려 보이거나, 보이지 않을 수 있습니다. 모든 기기의 Safe Area를 확인해 UI 위치를 일일이 지정하는 것은 효율적인 제작 방식이 아니므로 UI의 특정 지점을 기준으로 얼마나 떨어져 있을 것인지와 같은 다른 기준으로 UI를 배치해야 합니다.

UI 좌표에 맞추어 UI를 배치했을 발생하는 문제를 살펴봅시다. UI는 **스크린 해상도**의 변화에 따라 위치가 달라지게 됩니다. 크리에이터가 버튼 하나를 Anchor를 정중앙으로 설정하고, 화면 우측 소셜 버튼 아래에 배치하려 한다고 생각해 봅시다. 크리에이터는 UI 좌표 800, 400 위치에 버튼을 배치했습니다. 1920 X 1084(16:9) 해상도의 스크린에서 월드를 플레이할 경우 크리에이터가 원하는 위치에 보입니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1761722356633567344378b9c4005b5c0d3ded1e480f8.png)

3040 X 1440(19:9) 해상도의 스크린으로 월드를 플레이할 경우 크리에이터가 의도하지 않은 곳에 UI 버튼이 위치하게 됩니다. 스크린 해상도의 비율이 다르기 때문입니다. 유저 디바이스 해상도가 어떻든 크리에이터가 원하는 곳에 UI 요소를 보여주려면 **Anchor Presets** 기능을 활용해야 합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17617232008259055a237bce9451fb3ea92694455b9cd.png)

이처럼 다양한 해상도에 대응하기 위해 `UITransformComponent`에서 **Anchor**를 설정해 UI의 거리를 계산할 수 있습니다. Anchor는 **원점으로부터 PosX, PosY 값만큼 떨어진 곳**에 배치됩니다. 예를 들어 메이플스토리 월드에서 제공하는 기본 채팅 UI는 Anchor Point가 좌상단 끝으로 설정되어 있습니다. 이렇게 설정되어 있다면 채팅 UI는 어떤 기기든 좌상단 끝을 기준으로 368.9725, -251.8051 만큼 떨어진 곳에 위치하게 됩니다.

![anchorex01](https://mod-file.dn.nexoncdn.co.kr/bbs/165604514596759c47da1127745c2b9207457e3d9bbe9.png)

# UI 좌표와 Screen 좌표 차이

UI 좌표와 Screen 좌표는 비율과 원점의 위치가 다르기 때문에 같은 위치에서도 다른 좌표값을 가지고 있습니다. 그러므로 Screen 좌표값을 `UITransformComponent.Position` 값에 그대로 넣어 사용할 경우 예상하는 위치와 다른 곳에 UI 엔티티가 위치하게 됩니다. 모바일의 경우 기기의 화면 비율을 반영해 UI 좌표의 최댓값이 결정됩니다.

Galaxy S10+로 시뮬레이터를 설정해두고 **UI TransformComponent의 Anchor Preset**을 이용해 봅시다. UI 엔티티를 생성하고, **UITransformComponent - Anchor Preset**을 사방 스트레치를 선택해 **Left, Right, Top, Bottom**값을 모두 **0**으로 만들어 화면 전체를 덮도록 만들어봅시다. 화면을 덮도록 만들었지만, Safe Area 영역만 채워지는 것을 확인할 수 있습니다. 덮어진 Saf Area의 UI 좌표 값은 **2173.5 x 1080**이고, 원점은 Safe Area의 중앙입니다. 그러나 Screen 좌표에서는 `UILogic.ScreenWidth`은 **3040** , `UILogic.ScreenHeight` **1440**이고, 이 좌표는 Screen 좌표이므로 원점이 좌측 하단입니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1751526243746915bec31023144ad83bb3513bbee6799.png)

Update 2025-11-17 PM 08:14


# 타입의 이해

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

타입(Type)의 개념과 활용 방법을 소개합니다.

# 타입이란?

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1687940593248ba72058dee8e4fb58ec8a1964a2a6663.png)메이플스토리 월드에서 **타입**이란 여러 가지 프로퍼티 및 함수를 조합하여 하나의 새로운 데이터 유형을 만드는 사용자 정의 자료형을 말합니다. 타입을 활용하면 유사한 성격의 데이터를 한 번에 묶어서 제어하고 관리할 수 있어 코드를 재사용하기 좋습니다. 또한 코드를 유지 보수할 때 유용합니다.

## 타입과 컴포넌트의 차이

타입은 컴포넌트와 비슷하지만 다음과 같은 차이점이 있습니다.

- 타입은 컴포넌트가 아니므로 엔티티에 추가할 수 없습니다.
- 타입은 실행 제어 기능을 지원하지 않습니다.
- 타입에는 이벤트 핸들러가 없습니다.
- 각 타입의 용도에 맞는 **기본 이벤트 함수**가 제공되기도 합니다.

# 타입의 특징과 종류

각 타입은 사용처가 정해져 있습니다. 그리고 사용처에 맞는 Native 기능과 연동되어 있습니다. 또한 각 타입의 용도에 맞는 **기본 이벤트 함수**가 제공되는 타입도 있습니다. 기본 이벤트 함수가 어떻게 작동할지는 Native에서 이미 정의되어 있습니다. 그러므로 크리에이터는 이러한 기본 이벤트 함수를 가져다가 본인의 월드에 맞게 필요한 부분만 구현하면 됩니다.

이제 타입의 종류와 특징, 그리고 활용법을 알아봅시다.

## EventType

Native에서 정의되지 않은, 새로운 **EventType**을 정의할 때 사용합니다. **EventType**은 **Event System**과 연동됩니다. **EventType**의 자세한 활용 예시는 [Entity Event System](/docs/?postId=176) 가이드를 참고해 봅시다.

## ItemType

**ItemType**은 말 그대로 아이템을 분류하고, 분류된 아이템의 성격을 정의할 때 사용합니다. **ItemType**은 [ItemService](/apiReference/Services/ItemService)와 연동됩니다. **ItemType**은 개별 아이템 단위로 생성할 수도 있지만 일반적으로는 기능이 동일한 유형 별로 묶어서 생성하는 것이 좋습니다. 예를 들어, 크리에이터가 만드는 월드에는 여러 아이템이 존재할 것입니다. 이 아이템의 종류를 크게 아래와 같이 나눌 수 있다고 가정해 봅시다.

- 무기 : 공격력을 가짐
- 포션 : 회복력을 가짐
- 방어구 : 방어력을 가짐
- 기타 : 특별한 기능 없음

이런 경우에는 아래와 같이 **ItemType**을 만들 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16806724849204180b61d083646ccae04f255217b72c2.png)

**ItemType** 스크립트에서는 기본 이벤트 함수인 `OnCreate()`를 사용할 수 있습니다. `OnCreate()`는 아이템이 생성될 때 자동으로 호출되며 아이템 테이블(UserItemDataSet)의 데이터가 아이템 객체로 넘어옵니다. 아이템 객체로 넘어온 데이터는 `self.ItemTableData:GetItem("컬럼명")` 형식으로 접근할 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1680672660749a9c4c02d07df4a938bb51c84d12a1b84.png)

**ItemType**의 자세한 활용 예시는 [아이템 생성 및 삭제](/docs/?postId=66) 가이드를 참고해 봅시다.

## BTNodeType

몬스터나 NPC 같은 엔티티에 AI를 적용할 때는 [AIComponent](/apiReference/Components/AIComponent)를 활용합니다. **AIComponent**로 행동 트리(Behaviour Tree)를 만들 수 있습니다. 이 행동 트리를 구성하는 노드 중 하나인 **Action 노드**를 생성할 때 **BTNodeType** 스크립트를 사용합니다.

**Action 노드**는 "엔티티의 행동" 또는 "행동에 대한 조건"을 정의합니다. 예를 들어, 몬스터가 "대기" 상태에 있을 때 어떤 행동을 할지를 정의하거나, "대기" 상태에서 "공격" 상태로 변환되는 조건을 정의합니다. **BTNodeType**으로 Action 노드를 만들어 두면 **AIComponent**의 `CreateNode()`로 손쉽게 노드 객체를 생성할 수 있습니다.

**BTNodeType** 스크립트에서는 기본 이벤트 함수인 `OnBehave()`, `OnInit()`를 사용할 수 있습니다.

| 함수 | 설명 |
| :---: | --- |
| `OnBehave(number delta)` | 해당 Action 노드가 실행될 때마다 1회씩 호출되는 함수입니다. AI의 행동이나 행동의 조건을 정의할 때 사용하는 함수이기 때문에 **BTNodeType**을 만들었다면 반드시 추가해야 합니다. |
| `OnInit()` | `OnBehave()`가 호출되기 전에 실행되는 함수입니다. |

![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1680766233591bda06f8923594e85abd6e71e451335bb.png)

각 함수에 대한 보다 자세한 설명 및 **BTNodeType** 활용 예시는 [행동 트리를 활용한 AI 만들기](/docs/?postId=562) 가이드를 참고해 봅시다.

## StateType

**StateType**은 사용자가 새로운 상태를 만들 때 사용합니다. 예를 들어 플레이어 캐릭터는 서 있는 상태, 엎드린 상태, 공격 상태, 점프하는 상태 등 여러 가지 상태를 갖고 있습니다. 이렇게 기본적으로 갖고 있는 상태 이외에 크리에이터가 추가하고 싶은 새로운 상태가 있을 때 **StateType**을 추가하면 됩니다. **StateType**은 [StateComponent](/apiReference/Components/StateComponent)와 연동됩니다.

**StateType**에서는 다음의 내용을 정의할 수 있습니다.

- 어떤 상태에 진입하거나 상태에서 퇴장할 때 사용자가 정의한 행동을 수행하게 할 수 있습니다.
- 상태가 종료되는 조건을 정의할 수 있습니다.

**StateType** 스크립트에서는 기본 이벤트 함수인 `OnEnter()`, `OnUpdate()`, `OnExit()`, `OnConditionCheck()`를 사용할 수 있습니다.

| 함수 | 설명 |
| :---: | --- |
| `OnEnter()` | 상태에 처음 진입할 때의 동작을 실행합니다. |
| `OnUpdate()` | 상태가 유지되는 동안의 동작을 실행합니다. |
| `OnExit()` | 상태가 변경될 때 실행됩니다. |
| `OnConditionCheck(string nextStateName)` | 상태 전이 조건을 지정합니다. <br>**nextStateName** 파라미터를 사용해 연결된 상태에 따라 다른 결괏값을 반환할 수 있습니다. |

![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16807662783116d11c7686e694f9197b6c6ab59f01ef0.png)

**StateType**에 대한 보다 자세한 설명은 [엔티티의 상태 제어하기](/docs/?postId=686) 가이드를 참고해 봅시다.

## StructType

**StructType**은 크리에이터가 직접 사용처를 정하고 그에 맞게 형태를 정의할 때 사용합니다. 일반적인 프로그래밍 언어의 Structure와 비슷한 기능을 한다고 이해할 수 있습니다. 다른 데이터를 담는 변수들을 묶어서 사용할 때 유용합니다. 예를 들어 "Student"라는 Type을 만들고 그 안에 "이름, 학번, 학과" 등의 변수들을 넣어 관리할 수 있습니다.

Update 2025-11-17 PM 08:14


# 스크립트 라이프 사이클

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

기본 이벤트 함수의 라이프 사이클과 플레이할 때의 전체 라이프 사이클을 알아봅시다. 라이프 사이클을 이해하면 특정 함수가 언제 불리는지 예상할 수 있고, 전체 월드의 동작을 고려하며 제작할 수 있습니다.

# 기본 이벤트 함수의 라이프 사이클

월드에 필요한 로직을 만들기 위해서는 컴포넌트 스크립트를 만들어야만 합니다. 필요한 컴포넌트 스크립트를 만들 때 호출되는 시점을 예상해 의도한 로직에 맞게 동작할 수 있도록 작성해야 합니다. 라이프 사이클의 개념을 익혀두면 전체 흐름을 파악할 수 있기에 스크립트를 작성할 때 도움이 됩니다. 실행 환경에 따라 라이프 사이클의 기본 차이가 있습니다. 실행 환경은 크게 **제작 중인 월드/출시된 월드**, **서버/클라이언트**로 구분됩니다.

함수 종류는 두 가지로 나눌 수 있습니다.

- **기본 이벤트 함수**: 메이플스토리 월드가 만든 함수들로 함수마다 특정 호출 시점이 정해져 있습니다. 크리에이터는 이 함수들의 호출 시점을 수정할 수 없고, 이 함수들의 시점을 기본으로 사용자 정의 함수를 만들어 호출해야 합니다.
- **사용자 정의 함수**: 사용자가 직접 정의하는 함수로 호출 시점을 기본 이벤트 함수와 엔티티 이벤트 함수에서 호출해 사용할 수 있습니다.  기본적으로 함수는 어디선가 호출을 해야 합니다. 기본 이벤트 함수는 크리에이터가 호출하지 않아도, 특정 조건이 되었을 때 자동으로 호출되는 함수를 의미합니다. 이 함수들은 기본적으로 서버 공간에서 호출합니다 기본 이벤트 함수는 스크립트 에디터 창에서 Function 옆의 ![plus](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_plus.png) 버튼을 눌러 추가할 수 있습니다. 기본 이벤트 종류로는 `OnInitialize`, `OnUpdate`, `OnBeginPlay`, `OnMapEnter`, `OnMapLeave`, `OnEndPlay`, `OnDestroy`, `OnSyncProperty` 가 있습니다. 각 함수에 대한 내용은 [MSW 기본 이벤트 함수](/docs/?postId=163)를 참고하세요.

기본 이벤트 함수의 흐름은 다음과 같습니다. 이 중 `OnUpdate`와 `OnSyncProperty`를 제외한 함수들의 흐름은 로그를 활용해 확인할 수 있습니다.

1. 새로운 **LIfeCycle** 컴포넌트를 생성하고 `OnInitialize` `OnBeginPlay` `OnMapEnter` `OnMapLeave` `OnEndPlay` `OnDestroy` 함수를 추가합니다.
2. 어떤 함수가 실행되었는지 알 수 있게 `log("함수 이름 실행")`을 작성합니다.
3. **LIfeCycle** 컴포넌트를 **DefaultPlayer**에 추가합니다.
4. `OnMapEnter` `OnMapLeave`를 확인하기 위해 맵을 추가하고, 포털을 사용해 연결합니다.
5. 월드를 실행하고, 포털로 맵을 이동한 뒤, 실행을 종료합니다.
6. 남겨진 로그의 순서는 아래와 같습니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1683859157721a85006486490435ba29d7b5deea1e2f7.gif)

먼저 `OnInitialize` `OnMapEnter` `OnBeginPlay`로그가 찍힙니다. 실행을 눌러 월드를 시작하면 시작 맵에 플레이어가 입장하기 때문에 월드 진입 시 최초 한 번 불리는 다른 두 함수와 불리게 됩니다. 포털을 이용해 맵을 이동하게 되면 시작 맵에서 떠나, 새로운 맵으로 진입하기 때문에 `OnMapLeave`, `OnMapEnter` 로그가 순차적으로 남습니다.

> **더 알아보기.** **사용자 정의 함수**는 시스템에서 자동으로 호출할 수 없기 때문에 기본 이벤트 함수로부터 호출을 받아야 실행됩니다. 만약, 크리에이터가 NewComponent에 MyNewFunction 함수를 만들었다면, 이 함수는 어디선가 호출을 해야합니다. 이때 호출하는 곳은 크리에이터가 만든 함수가 실행되길 원하는 시점(타이밍)과 같아야 합니다.
> **더 알아보기.** 엔티티 이벤트(Entity Event)는 Event를 쉽게 제어할 수 있으며 사용자 정의 함수를 호출할 수 있습니다. 기본 이벤트 함수와 달리 정의된 특정 이벤트가 발생하는 시점에만 호출되며 라이프 사이클에 포함되지 않습니다

# 전체 플레이 라이프 사이클

서버와 클라이언트가 호출되는 전체 흐름을 알아봅시다. 플레이 라이프 사이클은 **제작 중인 월드**와 **출시된 월드**에서 약간의 차이가 있습니다. 가장 큰 차이점은 맵을 불러오는 방식입니다.

- **제작 중인 월드**에서 플레이할 때는 10개의 맵을 만들었더라도 플레이어가 있는 맵만 불러옵니다.
- **출시된 월드**에서는 플레이어 유무와 상관없이 모든 맵을 불러옵니다.

이와 같은 차이를 알고 있다면 **제작 중인 월드** 또는 **출시된 월드**에서 크리에이터 의도대로 동작하지 않는 무언가가 있을 때, 그 원인이 잘못된 코드에 있는지 사이클을 고려하지 않은 호출 때문인지를 파악할 수 있습니다.

#### World 개념 이해하기

월드는 최상위 레벨의 엔티티로써 실행 환경에 따라 하나씩 생성됩니다. 동시에 여러 개의 월드가 존재할 수 있지만, 월드끼리는 상호작용하며 영향을 끼치진 못합니다. **제작 중인 월드**에서 테스트 플레이를 할 때는 편집용 월드와 테스트 플레이 월드가 공존하게 됩니다.

#### 제작 중인 월드에서 플레이 할 때

제작 중인 월드에서는 클라이언트 편집용 월드만 존재합니다. 편집용 엔티티는 `OnBeginPlay` `OnUpdate` `OnEndPlay`가 호출되지 않지만, 렌더링이 필요한 컴포넌트는 예외로 `OnUpdate`가 호출됩니다.

테스트를 위한 월드를 실행(플레이)하면 편집용 월드를 비활성화합니다. 그 후 로컬 서버 실행과 접속을 하고, 서버와 클라이언트에서 모두 테스트 플레이용 월드를 생성합니다. 이때 서버는 편집 중인 맵만 불러오는 것이 **출시된 월드**와의 차이점입니다. 그러나 제작 중인 월드에서 EntityService를 사용해 다른 맵의 엔티티를 얻거나, 플레이어가 포탈을 타고 다른 맵으로 이동하는 등 다른 맵에 접근한다면 해당 맵을 불러옵니다.

클라이언트는 플레이어의 엔티티가 있는 맵만 불러오며, 출시된 월드와 동일합니다. ![maker_life_cycle](https://mod-file.dn.nexoncdn.co.kr/bbs/1683859676106ae2fc05e6a434a63aa14a90883a59792.png)

#### 출시된 월드에서 플레이 시

출시한 게임의 서버는 시작 시 전체 맵을 불러오고, 클라이언트는 늘 플레이어 엔티티가 존재하는 맵만 불러옵니다.

![publishing_life_cycle](https://mod-file.dn.nexoncdn.co.kr/bbs/1683859725237548e1764d33b430ba798be79f395cf0d.png)

##### 참고 가이드

- [함수](/docs/?postId=172)
- [MSW 기본 이벤트 함수](/docs/?postId=163)
- [Effective MSW 1](/docs?postId=559)

Update 2025-11-20 PM 02:03


# 월드 인스턴스

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 안내

월드 인스턴스 개념과 생성, 파괴에 관해 알아봅시다. 월드 인스턴스를 이해하기 위해 [인스턴스 맵 만들기](/docs/?postId=540)의 룸 관련 내용을 먼저 학습하면 도움이 됩니다.

# 월드 인스턴스

월드 인스턴스란 크리에이터가 메이커에서 제작한 월드의 정보를 기반으로 생성한 실제 객체입니다. 월드 인스턴스는 독립적으로 실행되며, 크리에이터의 제작 방식에 따라 정적 룸과 인스턴스룸이 구성됩니다.

> **TIP.** 제작한 월드의 모든 월드 인스턴스는 하나의 DataStorage를 사용합니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1679291060113a0eff84f08214ed49d8a58ab3ba25664.png)

#### 월드 인스턴스끼리 통신

월드 인스턴스는 저마다 개별적으로 실행되고 있으므로 월드 인스턴스끼리의 통신이 필요하거나 이벤트 전달이 필요하다면 [RoomService](/apiReference/Services/RoomService)와 [WorldInstanceService](/apiReference/Services/WorldInstanceService)를 활용해야 합니다. 자세한 활용 방법은 [월드 인스턴스 통신](/docs?postId=999)을 참고하세요.

# 월드 인스턴스의 생성과 파괴

월드 출시 단계에서 크리에이터는 월드의 **최대 플레이어 수**를 설정합니다. 이 인원수가 새로운 월드 인스턴스를 생성하는 기준 중 하나입니다. 예를 들어 최대 플레이어 수를 10명으로 설정한 월드에 100명의 유저가 접속했다면, 월드 인스턴스가 10개 생성됩니다. 월드 인스턴스 파괴 기준은 **유저의 이탈**입니다. 모든 유저가 월드 플레이를 종료해 남아있는 유저가 없다면 월드 인스턴스는 자동으로 파괴됩니다. 월드 인스턴스는 생성된 후 일정 시간이 지나면 **은퇴 준비**를 합니다. 은퇴 준비란 새로운 유저의 접속을 허용하지 않는 것입니다. 월드 인스턴스는 기존에 접속해 있던 유저들만으로 월드 인스턴스를 운영하며 모든 유저가 떠나면서 자연스럽게 월드 인스턴스가 파괴되기를 기다립니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1679291087805feeafc80d6894e21bb6fa7acd50caf64.png)

#### 월드 인스턴스의 유저 할당

유저를 어떤 월드 인스턴스로 보낼지의 기준은 **월드 인스턴스의 인원수**입니다. 생성된 월드 인스턴스가 없을 때 새로운 월드 인스턴스를 하나 생성해 총원이 찰 때까지 해당 월드 인스턴스로 보냅니다. 이 월드 인스턴스에 정원이 모두 차면, 또 다른 새로운 월드 인스턴스를 생성해 유저를 보냅니다. 만약 여러 개의 월드 인스턴스를 운영 중인 상황에서 유저들이 월드를 떠나면 빈자리가 발생합니다. 그러면 새로운 유저가 접속했을 때 더 이상 새로운 월드 인스턴스를 생성하지 않습니다. 대신 빈자리가 있는 월드 인스턴스 중 유저가 가장 많은 곳으로 새로운 유저를 보냅니다. 이때 은퇴 준비를 시작한 월드 인스턴스는 유저 수가 가장 많더라도 대상에 포함되지 않습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/167929120294711f23765789448a4a0b99bacfb91db09.png)

Update 2025-11-17 PM 08:14


# 메이플스토리 월드 용어 사전

# ㄱ

##### 계층 구조 Hierarchy

제작 중인 월드의 현황을 계층 구조로 확인할 수 있는 창 복잡하게 구성한 맵의 엔티티를 체계적으로 관리할 때 사용 **World, common, maps, ui**를 포함함 **참고 |** [Hierarchy](/docs/?postId=453)

# ㄴ

##### 네이티브 API Native API

크리에이터는 생성할 수 없는 메이플스토리 월드 엔진 내의 API

# ㄷ

##### 데이터 에디터 Data Editor

메이커에서 데이터 셋을 편집할 수 있는 에디터 ![dataeditor](https://mod-file.dn.nexoncdn.co.kr/bbs/1672732832800533efc73a2a24fddbb4f8530a531e592.png) **참고 |** [데이터 편집](/docs/?postId=69)

##### 동기화 Synchronization

서버, 클라이언트 간 데이터 전송 방식의 일종으로, 각각의 실행 공간에 존재하는 같은 이름의 프로퍼티를 같은 값으로 맞춤 **참고 |** [프로퍼티 동기화](/docs/?postId=208)

##### 동적 스프라이트 Dynamic Sprite

메이플스토리 월드에서 플레이 도중 생성되는 이미지 **참고 |** [스크린샷과 동적 스프라이트](/docs/?postId=829)

# ㄹ

##### 로그 Log

월드 제작 중 발생하는 여러 가지 정보나 문제 상황에 대한 기록 **참고 |** [로그](/docs/?postId=719)

##### 로비 Lobby

메이플스토리 월드 홈 ![lobby](https://mod-file.dn.nexoncdn.co.kr/bbs/16727127637681e1c6345a31b4f2d9a08265b916e02e6.png)

##### 로컬 엔티티 Local Entity

서버에서는 없고 클라이언트에만 존재하는 개별 엔티티

##### 룸 Room

월드 인스턴스 하위에 구성된 맵들의 집합체 룸에는 정적 룸과 인스턴스 룸이 있으며 일반적으로 말하는 룸은 정적 룸을 지칭함

##### 리소스 고유 ID RUID

스프라이트, 애니메이션, 사운드 등 다양한 리소스가 가진 고유한 ID 값

##### 리워드코인 Reward Coin

이벤트를 통해 획득하는 코인

##### 릴리스 서버 Release Server

제작한 월드를 출시한 이후, 메이플스토리 월드의 **로비 - 플레이** 메뉴에서 월드로 들어갔을 때 뜨는 서버

# ㅁ

##### 매개 변수 Parameter

함수를 정의할 때 사용되는 변수

##### 머티리얼 Material

다양한 프로퍼티를 통해 엔티티가 렌더링 될 방법을 나타내는 객체

##### 모델 Model

메이커에서 어떤 엔티티의 컴포넌트와 프로퍼티 관련 정보를 가지고 있는 판본**Preset List**에서 제공하는 프리셋도 모델**참고 |** [모델](/docs/?postId=55)

##### 문법 강조 Syntax Highlighting

문법에 따라 글자 색을 강조하여 코드를 쉽게 인지할 수 있도록 돕는 기능

# ㅅ

##### 사용자 ID User ID

**설정 - 계정**에서 확인할 수 있는 ID![userid](https://mod-file.dn.nexoncdn.co.kr/bbs/16727215451210a07baf544cf4920a8e0a0cda7c66fac.png)

##### 셰이더 Shader

물체를 렌더링 할 때 사용할 코드 또는 스크립트

##### 스크립트 API Script API

크리에이터가 생성하는 API

##### 스크립트 아우트라인 Script Outline

스크립트 에디터에서 해당 스크립트의 프로퍼티, 함수, 이벤트 목록을 한눈에 확인하는 기능

##### 스크립트 어시스트 Script Assist

코드 작성 서포트 기능(시그니처 헬퍼, 퀵 인포, 코드 컴플리션 등)을 통칭하는 용어

##### 스크립트 에디터 Script Editor

메이플스토리 월드에서 스크립트를 코딩할 수 있는 에디터

##### 스프라이트 Sprite

2D 이미지를 뜻함메이커에서 위치, 크기, 회전 값 등을 변경할 수 있음

##### 시그니처 헬퍼 Signature Helper

함수의 파라미터를 채우는 데 도움을 주는 기능

##### 실행 공간 Execution Space

API의 함수가 실제 실행되는 공간으로 클라이언트 또는 서버에서 실행됨

##### 실행 공간 제어 Execution Space Setting

특정 함수가 클라이언트 또는 서버 중 어느 공간에서 실행되도록 할 것인지 설정하는 것

##### 심벌 Symbol

이름 또는 식이 참조하는 타입, 멤버, 변수 등의 식별자

##### 신 Scene

메이커에서 실제 월드 공간을 편집하는 영역

# ㅇ

##### 아틀라스 Atlas

한 장의 이미지에 여러 개의 스프라이트가 함께 있는 이미지

##### 아틀라스 언패커 Atlas Unpacker

아틀라스를 크리에이터가 개별의 스프라이트로 자르고 편집해 저장하는 툴

##### 어노테이션 Annotation

코드에 추가하여 사용하는 일종의 메타 데이터 **참고 |** [Annotation 활용하기](/docs/?postId=824)

##### 엔티티 Entity

메이플스토리 월드 내에 존재하는 객체로 여러 컴포넌트의 집합체 **참고 |** [엔티티](/docs/?postId=54)

##### 워크스페이스 Workspace

메이커에서 사용하는 폴더 형식의 리소스 관리 공간 메이플스토리 월드에서 제공하는 **NativeScripts**와 **NativeModel**이 모여 있는 **BaseEnvironment**와 크리에이터가 만든 리소스를 보관하는 **MyDesk**, 그리고 작업 편의를 위해 **DefaultPlayer**가 여기에 포함됨 **참고 |** [Workspace](/docs/?postId=121)

##### 월드 인스턴스 World Instance

서버 정보를 기반으로 실제 생성된 하나의 인스턴스

##### 월드코인 World Coin

결제를 통해 구매할 수 있는 코인

##### UI 에디터 UI Editor

메이커에서 UI 요소를 편집할 수 있는 에디터![uieditor02](https://mod-file.dn.nexoncdn.co.kr/bbs/1657678708992678df357225c4a71a7b01f9bba955ef5.png)

##### 이벤트 Event

로직 상에서 어떤 사건의 발생을 의미함 이벤트 종류의 식별 정보 및 추가 정보를 갖고 있는 자료형 **참고 |** [이벤트](/docs/?postId=73)

##### 이벤트 센더 Event Sender

이벤트를 발송하는 객체 Emitter, Dispatcher 등의 유사 용어가 있음

##### 이벤트 핸들러 Event Handler

이벤트를 받았을 때 처리하는 행동의 주체 Listener, Subscriber 등의 유사 용어가 있음

##### 인수 Argument

함수가 호출될 때 매개 변수에 실제로 담기는 값

##### 인스턴스 룸 Instance Room

서버 인스턴스에서 동적으로 생성하는 룸 인스턴스 룸에는 인스턴스 맵만 포함될 수 있음

##### 인스턴스 맵 Instance Map

인스턴스 룸에 생성되는 맵 **MapComponent**에서 **InstanceMap**을 체크하면 인스턴스 맵으로 설정됨

##### 일반 엔티티 Common Entity

**Hierarchy - World** 하위에 포함된 특수 엔티티 ![common](https://mod-file.dn.nexoncdn.co.kr/bbs/1672721691997704cb622be8647b783f3fcd1c1ab382d.png)

##### 임베디드 서버 Embedded Server

메이커에서 테스트 용으로 띄우는 로컬 서버

# ㅈ

##### 정적 룸 Static Room

월드 인스턴스가 생성되면 무조건 생성되는 룸 정적 룸에는 정적 맵만 포함됨

##### 정적 맵 Static Map

정적 룸에 생성되는 맵 월드에 존재하는 맵은 기본적으로 정적 맵으로 설정되어 있음 **MapComponent**에서 **InstanceMap**을 체크하지 않으면 정적 맵

# ㅊ

##### 최적화 Optimization

월드 처리 속도에서 부하가 걸리는 병목 지점(Bottle Neck)을 찾아 수정하는 것

# ㅋ

##### 컴포넌트 Component

특정 엔티티의 구성 요소로 각각의 기능을 담당 **참고 |** [컴포넌트](/docs/?postId=54)

##### 코드 검사 Code Inspection

코드에서 잠재적으로 버그가 발생할 수 있는 부분이나 사용자가 실수한 부분을 검사하여 사용자에게 알려주는 기능

##### 코드 컴플리션 Code Completion

문맥을 분석하여 현재 캐럿 위치에서 작성할 수 있는 심벌을 제안함 코드 입력 시 구문을 완성하는 방법을 제안하여 손쉽게 코드를 작성할 수 있도록 돕는 기능

##### 퀵 인포 Quick Info

함수, 변수, 파라미터 등에 마우스 오버하면 관련 정보를 보여주는 툴팁

# ㅌ

##### 타일 에디터 Tile Editor

맵 타일을 편집할 수 있는 에디터 타일 모드를 선택한 뒤, 선 칠하기 또는 박스 칠하기를 선택해 지형을 그릴 수 있음 ![tile](https://mod-file.dn.nexoncdn.co.kr/bbs/1672722909781b00c5ade293a45819a3487184089a20d.png)

##### 토큰 Token

일련의 문자열을 구분하는 최소 단위. 스크립트에서 의미를 갖는 최소한의 문자 덩어리

# ㅍ

##### 파티클 Particle

눈이나 비, 먼지 같은 다수의 작은 입자 **참고 |** [파티클](/docs/?postId=764)

##### 프로파일러 Profiler

최적화 작업을 손쉽게 진행할 수 있도록 돕는 툴

##### 프로퍼티 Property

각 컴포넌트의 세부 사항을 설정하는 요소 엔티티별로 다른 값을 가질 수 있음 **참고 |** [프로퍼티](/docs/?postId=205)

##### 프로필 ID Profile ID

#으로 시작하는 ID로 계정 별로 고유함 ![profileid](https://mod-file.dn.nexoncdn.co.kr/bbs/167272638409586f756d334234067a6903f605d877654.png)

##### 프로필 이름 Profile Name

프로필 이름은 변경할 수 있으며 다른 유저와 중복될 수 있음 ![profile](https://mod-file.dn.nexoncdn.co.kr/bbs/16727264545168cdbcea596eb4d1cb56f5a00026f0e13.png)

##### 프리셋 Preset

**Preset List**에 있는 개별 프리셋

##### 플레인 스크립트 Plain Script

**Create Scipt** 메뉴를 클릭해 크리에이터가 생성하는 스크립트

##### 플레인 텍스트 모드 Plain Text Mode

스크립트 에디터에서 Script API를 메타 데이터까지 모두 텍스트 형태로 보는 모드

Update 2025-11-17 PM 08:14


# 스크립트 에디터 오리엔테이션

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 스크립트 에디터를 사용해 크리에이터가 원하는 컴포넌트나 로직을 만들 수 있습니다. 스크립트 문법은 **Lua Script**를 사용하며 다양한 **API**를 지원합니다. 월드를 만들다 보면, 메이플스토리 월드에서 제공하는 스크립트나 다른 크리에이터가 작성한 스크립트를 수정해야 할 일이 생깁니다. 스크립트를 수정하기 위해서라도 스크립트 에디터 기본 사용법을 익혀두는 것이 좋습니다.

이번 과정에서는 간단하게 스크립트로 로그를 출력하는 방법을 알아보고, 스크립트 에디터의 다양한 편의 기능도 살펴보겠습니다.아래는 스크립트를 이용한 제작 예시입니다.

# 스크립트로 로그 출력하기

먼저 스크립트를 이용해 "Hello Maple World"라는 로그를 출력해 보겠습니다.

## 스크립트 컴포넌트 생성

스크립트 컴포넌트를 생성해 봅시다.

1. 메이커에 **Workspace** 탭이 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/165603680025521f2b8ff66cd4e838b0a5f5bf9899a0e.png)
2. **Workspace - MyDesk - Create Scripts - Create Component**를 클릭해 새로운 컴포넌트를 만듭니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1687496291799b05a128af08748b8bc69f2956c9de929.png)
3. 새 컴포넌트의 이름으로 **HelloMapleWorld**를 입력합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1635422307109859acba010394878982655abfaa83495.png)
4. **HelloMapleWorld** 스크립트 컴포넌트를 더블 클릭합니다. 스크립트 에디터에서 **HelloMapleWorld** 스크립트를 편집할 수 있습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1669634831972d857555921b0402db47a71d9d780f633.png)

## 스크립트 작성

**Function**의 **[+]** 버튼을 클릭하면 함수 목록이 나옵니다. 여기서 `OnBeginPlay` 함수를 선택합니다. 이 함수는 스크립트 컴포넌트가 실행될 때 최초 한 번 호출됩니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16696348590924e768b248a29402fa18c03f247ac65c7.png)  `OnBeginPlay()` 옆에 있는 **[+]** 버튼을 누르면 함수를 펼칠 수 있습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1669634880878d85c73c4caf1455fa8eebf7ad14f55ed.png)  다음과 같이 함수를 작성합니다.

```
[server only]
void OnBeginPlay()
{
    log("Hello Maple World")
}
```

> **더 알아보기** `log` 함수는 스크립트를 작성할 때 가장 기본적이면서도 가장 자주 사용되는 함수입니다. `log` 함수의 매개 변수로 넘겨진 값을 콘솔 창에 출력합니다. 변수나 프로퍼티 값, 또는 함수의 반환 값을 콘솔 창에 출력하여 확인할 수 있습니다. 자세한 내용은 [로그](/docs/?postId=719) 가이드를 참고합니다.

## 엔티티에 스크립트 컴포넌트 추가

스크립트 컴포넌트를 만든 후 엔티티에 추가해야 스크립트가 실행됩니다. 따라서 **HelloMapleWorld** 컴포넌트를 맵에 배치한 엔티티 중 하나에 추가해야 합니다. **DefaultPlayer**에 **HelloMapleWorld**를 추가해봅시다.

1. **Workspace - DefaultPlayer**를 클릭합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16354223715596e876b1f28734af39f0f4d3bd20cc2b0.png)
2. 프로퍼티 에디터에서 **[Add Component]** 버튼을 클릭합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/163693537008760bc035a3de447b6a17afb92232368f8.png)
3. 컴포넌트 검색창에서 **HelloMapleWorld**를 검색합니다. ![ScriptEditorOrientation_13](https://mod-file.dn.nexoncdn.co.kr/bbs/1663845838156754ed5aec49a4dce923c4b51d0ae0abd.png) 검색 결과에서 **HelloMapleWorld** 컴포넌트를 클릭합니다.
4. **Scene** 탭을 클릭합니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1669634932558359b1be73ec8433db07ef18d74a24620.png)
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트합니다. ![ScriptEditorOrientation_15](https://mod-file.dn.nexoncdn.co.kr/bbs/1634603292745976e230077b04ade8cffb42ffcd420e8.png)
6. 콘솔 창에 "Hello Maple World" 로그가 출력됩니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16638461874055a74dc917cc34d6e8421c897dcb9dc2f.png)

# 스크립트 어시스트

메이플스토리 월드의 스크립트 에디터는 코드를 보다 정확하고 빠르게 작성할 수 있도록 다양한 기능을 지원합니다. 기능에 대한 자세한 설명은 [스크립트 어시스트](/docs/?postId=952) 가이드를 참고합니다.

# 스크립트 아우트라인

스크립트를 작성하다 보면 내용이 길어지고 복잡해지는 경우가 많습니다. 스크립트의 전체적인 뼈대를 파악하거나 내용을 정리할 때 아우트라인 기능을 활용할 수 있습니다. 스크립트 아우트라인 기능을 활성화하면 프로퍼티, 함수, 이벤트 목록을 한눈에 확인할 수 있습니다. ![outline](https://mod-file.dn.nexoncdn.co.kr/bbs/1669705795169a6a7fc44da794355bc50b44303020f31.png)

아우트라인에서 목록을 드래그해 손쉽게 순서를 변경할 수 있습니다. ![outline2](https://mod-file.dn.nexoncdn.co.kr/bbs/1669706219051b8e968a98a314f348605e83adc5055e2.gif)

# 스크립트 에디터 확대/축소

스크립트 에디터에서 확대/축소 기능을 사용할 수 있습니다. 편집하려는 스크립트를 연 뒤, **Ctrl(L)** 키를 누른 채로 마우스 휠을 위로 올리면 스크립트 화면이 확대되고, 아래로 내리면 축소됩니다. ![scale1](https://mod-file.dn.nexoncdn.co.kr/bbs/1689130659090b30a483d52904d449052ea8bd44696a2.gif)  스크립트 에디터 왼쪽 하단에서 화면 배율을 선택할 수 있습니다. 20~400% 범위 내에서 원하는 배율을 직접 입력할 수도 있습니다. ![scale2](https://mod-file.dn.nexoncdn.co.kr/bbs/1689130753750642810ea2be447f387f7793ca44611ff.png)

Update 2025-11-20 PM 02:03


# 스크립트 어시스트

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드의 스크립트 에디터는 코드를 보다 정확하고 빠르게 작성할 수 있도록 다양한 기능을 지원합니다. 스크립트 어시스트는 이러한 기능을 총칭합니다. 본 과정에서는 스크립트 어시스트의 다양한 기능을 안내하겠습니다.

# 내비게이션

내비게이션(Navigation) 기능은 스크립트에서 원하는 위치로 빠르고 간편하게 이동할 수 있도록 지원합니다.

### 참조 찾기

참조 찾기(Find References) 기능은 단어 그대로 손쉽게 참조를 찾을 수 있게 도와줍니다. 심벌의 콘텍스트 메뉴에서 **Show References**를 클릭하면 **References** 창이 열립니다. 참조 찾기 기능을 사용하면 전체 프로젝트에서 현재 심벌에 대한 참조를 찾습니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/167297348163458165b0bcf8a4f80a73d2dbc09d0db98.png) ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/167297349998135042ccbd0024d048655782c225f2bd1.png)

### 정의로 이동

심벌의 콘텍스트 메뉴에서 **Go to Definition**을 클릭하면 해당 심벌의 정의부로 이동합니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16729741775763a6b33cef7374dbfae12640036d4eee6.png)

### 뒤로 이동 / 앞으로 이동

아래의 단축키를 활용하면 기록된 이전 위치로 이동하거나, 다시 최근 위치로 이동할 수 있습니다.

- Navigate Back : `Ctrl(L)` + `-` 키를 누르면 이전 위치로 이동합니다.
- Navigate Forward : `Ctrl(L)` + `=` 키를 누르면 이전 위치에서 최근 위치로 이동합니다. ![navigate](https://mod-file.dn.nexoncdn.co.kr/bbs/1678676733191965cd0d90c1c4abd81eea6cec1638e52.gif)

# 코드 검사

코드 검사(Code Inspection)는 코드를 점검하여 사용자가 인지하지 못한 실수를 잡아내어 잘못된 코드를 사전에 방지하는 기능입니다. 예를 들어 아래와 같이 오류가 발생했을 때 밑줄이 표시되고, 여기에 마우스 오버하면 퀵 인포로 자세한 정보가 안내됩니다. 이를 참고하여 오류를 빠르게 수정할 수 있습니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/167324776041075959c14f4d548f2920128aec2cb90be.png)

코드 검사에서는 대표적으로 아래와 같은 오류가 검출될 수 있습니다.

| 오류 | 설명 |
| :---: | --- |
| UnavailableMethodCall | 쌍점(Colon) 사용이 권장되는 함수에 점(Dot)을 사용했습니다. |
| TooManyParameter | 필요한 매개 변수 개수보다 많은 매개 변수를 작성했습니다. |
| ParameterTypeMismatch | 필요한 매개 변수 타입과 다른 매개 변수를 작성했습니다. |
| AssignTypeMismatch | 할당되는 변수의 타입과 일치하지 않는 타입의 값을 할당했습니다. |
| TableKeyTypeMismatch | 테이블의 키 타입이 일치하지 않습니다. |
| NotRecommendedAssignment | 권장하지 않는 할당문을 작성했습니다. |
| ReturnValueFromVoidFunction | 반환 값이 없는 함수에 반환문을 작성했습니다. |
| AssignToReadonlyProperty | 읽기 전용 프로퍼티에 할당했습니다. |
| IntroduceGlobalVariable | 글로벌 변수를 선언했습니다. |
| ObsoleteAPIUsed | 더는 사용하지 않는 API를 사용했습니다. 다른 API 사용을 권장합니다. |
| UnbalancedAssignment | 할당문의 왼쪽과 오른쪽의 길이가 다릅니다. |
| UnreachableCode | 도달할 수 없는 코드를 작성했습니다. |
| UnresolvedSymbol | 심벌을 찾을 수 없습니다. |
| UnresolvedMember | 멤버를 찾을 수 없습니다. |
| UnresolvedFunction | 함수를 찾을 수 없습니다. |
| DuplicateLocal | 로컬 변수를 중복 선언했습니다. |
| AnnotationNotFound | 어노테이션을 찾을 수 없습니다. |
| AnnotationTypeNotFound | 어노테이션에 사용된 타입을 찾을 수 없습니다. |
| ReturnTypeMismatch | 반환 타입이 일치하지 않습니다. |
| NotEnoughArgument | 필요한 것보다 적은 개수의 인수를 작성했습니다. |
| DuplicateFunction | 함수를 중복 정의했습니다. |

# 강조

코드의 글자색, 글자 배경색 등 다양한 방법으로 문법을 강조(Highliting)하여 코드를 쉽게 인지할 수 있도록 돕는 기능입니다.

### 심벌 참조 강조

심벌 참조 강조(Symbol Reference Highlight)는 선택한 심벌을 참조하는 여러 심벌을 강조하는 기능입니다. 아래와 같이 특정 심벌을 선택하면 이를 참조하는 다른 심벌의 배경색도 강조해서 보여줍니다. ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/167323895521158cef8fc84a04a3cae102bbdbb564d69.png)

### 문법 강조

문법 강조(Syntax Highlight)는 문법을 강조하는 기능입니다. 예를 들어 코드를 분석하여 해당 심벌이 변수라면 #1F377F 색상으로, 스트링이라면 #F17D80 색상으로, 어노테이션 종류라면 #648064 색상으로 보여줍니다. ![07](https://mod-file.dn.nexoncdn.co.kr/bbs/167331313032494bf43f0f61f49d3a0258a84940b35f3.png)

예로 든 것 외에도 다양한 문법 강조가 제공됩니다.

### 연관 토큰 강조

연관 토큰 강조(Related Token Highlight)는 연관성이 있는 토큰을 강조하는 기능입니다. 예를 들어 **if**를 선택하면 **if 문**에서 함께 사용하는 키워드인 **then**과 **end**도 강조해서 보여줍니다. ![06](https://mod-file.dn.nexoncdn.co.kr/bbs/1673239167792975ab6338cd647329a2cc5e0b19a34e7.png)

# 퀵 인포

퀵 인포(Quick Info)는 함수, 변수, 매개 변수 등에 마우스 오버하면 코드의 부가적인 정보를 쉽고 빠르게 보여주는 기능입니다. ![quickinfo](https://mod-file.dn.nexoncdn.co.kr/bbs/1668055736021fa7608306c80416a92a25c5d3277718d.png)

# 코드 컴플리션

코드 컴플리션(Code Completion)은 문맥을 분석하여 현재 위치에서 작성할 수 있는 심벌을 제안해 주는 기능입니다. 위 화살표 키와 아래 화살표 키를 사용하여 제안을 찾은 다음, **Enter** 또는 **Tab** 키를 눌러 구문을 삽입합니다. ![code](https://mod-file.dn.nexoncdn.co.kr/bbs/16680557704632d17b97ae55d402ab873ed774fd19e92.png)

코드 컴플리션을 다시 띄우고 싶을 때는 심벌에서 `Ctrl` + `Space`를 누릅니다. ![code2](https://mod-file.dn.nexoncdn.co.kr/bbs/167867626381462b21a82b8e442b69c56c425c1b65957.gif)

코드 컴플리션에서는 사용자가 선언한 함수나 변수의 이름도 제공하므로 오타를 방지하고 코드를 재사용하기 쉽습니다.

# 시그니처 헬퍼

시그니처 헬퍼(Signature Helper)는 함수를 작성할 때 함수 시그니처를 표시하여 매개 변수 작성에 도움을 주는 기능입니다. 위 화살표 키와 아래 화살표 키를 사용하여 원하는 시그니처를 찾은 뒤 함수 작성에 도움을 받을 수 있습니다. ![signature](https://mod-file.dn.nexoncdn.co.kr/bbs/166963495531574f3fb62127b4fc99058e2630eb54577.png)

시그니처 헬퍼를 다시 띄우고 싶을 때는 `Ctrl` + `Shift` + `Space`를 누릅니다. ![signature2](https://mod-file.dn.nexoncdn.co.kr/bbs/16843976134234c31e23de23d48c58444e0b85cc6bdf2.gif)

# 어노테이션

어노테이션(Annotation)은 스크립트 어시스트 기능 개선에 도움을 주는 기능입니다.

> **더 알아보기** 자세한 내용은 [어노테이션 활용하기](/docs/?postId=824) 가이드를 참고합니다.

# 코드 생성

코드 생성(Code Generation)은 코드를 자동으로 추가하여 빠르게 코드를 작성할 수 있도록 하는 기능입니다.

### 괄호 자동 완성

괄호 자동 완성(AutoBracketCompletion)은 괄호를 자동으로 완성하는 기능입니다.

### 문(Statement) 쌍 자동 완성

문(Statement)의 쌍을 자동 완성해주는 기능(AutoStatementPair)은 문장 작성 중 엔터를 입력하면 자동으로 짝을 맞춰줍니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/168439212479329d2c516a9c44e54932c198c11f3fab7.gif)

# 주석 단축키

단축키를 사용해 코드를 주석 처리하거나 주석을 해제할 수 있습니다.

### 줄 전체 주석

`Ctrl(L)` + `/`를 눌러서 코드를 주석 처리할 수 있습니다. '커서가 있는 줄' 또는 '드래그하여 선택한 여러 줄'의 코드를 주석 처리할 수 있습니다. 주석 처리된 부분에서 다시 `Ctrl(L)` + `/`를 누르면 주석이 해제됩니다. ![t1](https://mod-file.dn.nexoncdn.co.kr/bbs/1676422686186f6925f46e5cf45dc993bb712979ba9be.gif)

### 블록 주석

`Ctrl(L)` + `Shift(L)` + `/`를 눌러서 선택한 영역의 코드를 블록 주석으로 처리할 수 있습니다. 줄 전체가 아니라 일부만 블록 주석으로 처리할 수도 있습니다. 블록 주석 처리된 부분에서 다시 `Ctrl(L)` + `Shift(L)` + `/`를 누르면 주석이 해제됩니다. ![t2](https://mod-file.dn.nexoncdn.co.kr/bbs/167642308489426b09acc998840a59ef5c097f9a0c5e4.gif)

# 그 외 편의 기능

위에 소개한 내용 이외의 편의 기능을 소개합니다.

## 주요 단축키

### 투명화

`Ctrl(L)` 키를 눌러서 코드 컴플리션, 퀵 인포, 시그니처 헬퍼를 투명화할 수 있습니다. 투명화 기능을 활용하면 UI가 기존에 작성된 코드를 가려서 불편한 상황을 해결할 수 있습니다. ![t3](https://mod-file.dn.nexoncdn.co.kr/bbs/16786770174103e1c8fd8108740a891fea3be0b0ac988.gif)

### 복제

`Ctrl(L)` + `D` 키를 눌러서 선택한 줄이나 영역을 복제할 수 있습니다.

- 줄을 복제하면 바로 아랫줄에 복제된 내용이 나옵니다.
- 영역을 복제하면 선택했던 영역 바로 뒤에 이어서 나옵니다. ![duplicate](https://mod-file.dn.nexoncdn.co.kr/bbs/1678676463146908e86c91d9a47559246ef5be0195b68.gif)

> **더 알아보기** [MSW 단축키](/docs/?postId=813)의 "스크립트 에디터" 항목에서 사용 가능한 전체 단축키 목록을 확인할 수 있습니다.

## 환경 설정

**Edit - Preferences**로 들어가서 스크립트 어시스트 환경 설정을 할 수 있습니다. ![002](https://mod-file.dn.nexoncdn.co.kr/bbs/168437690187617eb3133ef694b9f826d4ce89b6be5ac.png) 각 탭에서 설정을 변경했다면 **[Save]** 버튼을 눌러 변경 사항을 저장해야 합니다.

설정 항목은 다음과 같습니다.

| 항목 | 세부 항목 | 설명 |
| --- | --- | --- |
| Code Completion | Enable Code Completion | **코드 컴플리션 기능**을 사용합니다. |
| Signature Helper | Enable Signature Helper | **시그니처 헬퍼 기능**을 사용합니다. |
| Code Generation | Enable AutoBracketCompletion | **괄호 자동 완성 기능**을 사용합니다. |
| Enable AutoStatementPair | **문(Statement)의 쌍을 자동 완성해주는 기능**을 사용합니다. |
| Code Inspection | Enable Code Inspection | **코드 검사 기능**을 사용합니다. |
| Error Level | 각 Error 별로 활성화 여부를 설정합니다. |
| Warning Level | 각 Warning 별로 활성화 여부를 설정합니다. |
| Info Level | 각 Info 별로 활성화 여부를 설정합니다. |
| Highlighting | Syntax Highlighting | **문법 강조 기능**을 사용합니다.<br>항목별 강조색을 설정할 수 있습니다. |
| Symbol Highlighting | **심벌 강조 기능**을 사용합니다.<br>항목별 강조색을 설정할 수 있습니다. |
| Related Token Highlighting | **연관 토큰 강조 기능**을 사용합니다.<br>항목별 강조색을 설정할 수 있습니다. |

Update 2025-11-17 PM 08:14


# 어노테이션 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

**어노테이션**(Annotation)은 코드에 추가하여 사용하는 일종의 메타데이터입니다. 스크립트에 `--` 기호를 사용한 주석(Comment)은 스크립트 작성에 참고 역할만 하는 반면, `---@` 형태로 **어노테이션**을 작성하면 **퀵 인포**나 **시그니처 헬퍼**, **코드 컴플리션** 등 스크립트 어시스트의 도움을 받을 수 있습니다. 본 과정을 통해 메이플스토리 월드에서 제공하는 **어노테이션**의 종류와 활용 방법을 알아봅시다.

> **더 알아보기** 퀵 인포, 시그니처 헬퍼, 코드 컴플리션에 대해 자세히 알고 싶다면 [스크립트 에디터 오리엔테이션](/ko/docs/?postId=56) 가이드에서 **스크립트 어시스트** 항목을 살펴봅시다.

# 변수 타입 지정 : Type Annotation

**Type Annotation**으로 변수 타입을 명시적으로 지정하면 스크립트 에디터에서 스크립트 어시스트의 도움을 받을 수 있습니다. **Type Annotation**은 할당문에 사용합니다.

## 사용 방법

**Type Annotation**은 다음과 같이 사용합니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/166788442640966b092935ab7482d948c6fc39188d48c.png)

```
---@type string
local testValue = "test"
```

## 활용 예시

##### 반환 타입을 추론할 수 없는 루아 함수

다음과 같이 반환 타입을 추론할 수 없는 루아 함수의 결괏값을 받을 때도 **Type Annotation**을 활용합니다.

```
local function TestFunction()
    return "strValue"
end

local strValue = TestFunction()
```

| Type Annotation 적용 전 | Type Annotation 적용 후 |
| :---: | :---: |
| ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/166788677395339c9be52267845a1a38273071868699e.png) | ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1667886963732dbed1d6d12984f79bd1922548876854f.png) |

##### 여러 값을 할당받는 경우

다음과 같이 여러 값을 할당받을 때도 **Type Annotation**을 활용합니다.

```
local function TestFunction()
    return "strValue", 5
end

local strValue, intValue = TestFunction()
```

| Type Annotation 적용 전 | Type Annotation 적용 후 |
| :---: | :---: |
| ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1667887186926acb2c0f5eac64f118c480078c23b2ac4.png) | ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1667892117117387cdcbbe65e4aa08d76b2fc548d48ad.png) |

여러 값을 할당받을 때는 일부만 타입을 지정할 수도 있습니다. 지정한 타입은 앞의 값부터 적용되므로 뒤의 값만 따로 타입을 지정할 수는 없습니다.

| Type Annotation 적용 전 | Type Annotation 일부 적용 후 |
| :---: | :---: |
| ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1667887186926acb2c0f5eac64f118c480078c23b2ac4.png) | ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/166789228646766e78448a0794b3cb971c4492954f34f.png) |

## 일반 타입 지정

일반적인 타입 지정은 아래와 같은 문법으로 작성합니다.

```
---@type TYPE
```

##### 사용 예시

```
---@type string
local testValue = "test"
```

```
---@type string, integer
local strValue, intValue = "str", 5
```

단순한 원시 타입 외에도 이벤트, 컴포넌트, 엔티티, Enum 등 다양한 타입을 **Type Annotation**으로 지정할 수 있습니다.

## Table 타입 지정

Table은 아래와 같은 문법으로 타입을 지정합니다.

```
---@type table<KEY_TYPE, VALUE_TYPE>
```

##### 사용 예시

```
---@type table
local testTable = {}
```

```
---@type table<Entity>
local testTable = {}
```

```
---@type table<string, Entity>
local testTable = {}
```

예를 들어 아래와 같이 **Type Annotation**을 지정하면 퀵 인포에서 관련 정보를 확인할 수 있습니다.

```
local function TestFunction()
    local testTable = {}
    testTable[1] = "A"
    testTable[2] = "B"
    testTable[3] = "C"
end

---@type table<integer, string>
local tableValue = TestFunction()
```

![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1667895925609146ce9442a4f4e6da96fc1aa6932f744.png)

## Function 타입 지정

Function은 아래와 같은 문법으로 타입을 지정합니다.

```
---@type function(param_name: PARAM_TYPE):RETURN_TYPE
```

##### 사용 예시

```
---@type function()
local testFunction = function() end
```

```
---@type function(testParamA:string, testParamB:Entity)
local testFunction = function(testParamA, testParamB) end
```

```
---@type function(testParamA:string, testParamB:Entity):AttackComponent
local testFunction = function(testParamA, testParamB) return atkComponent end
```

```
---@type function(testParamA:string, testParamB:Entity):AttackComponent, string
local testFunction = function(testParamA, testParamB) return atkComponent, "strValue" end
```

```
---@type (function(testParamA:string, testParamB:Entity):AttackComponent, string), Entity
local testFunction, testEntity = function(testParamA, testParamB) return atkComponent, "strValue" end, self.Entity
```

예를 들어 아래와 같이 **Type Annotation**을 지정하면 시그니처 헬퍼의 도움을 받을 수 있습니다.

```
local function TestFunction()
    return function(paramA, paramB)
        return "strValue", false
    end
end

---@type function(paramA:string, paramB:AttackComponent):string, boolean
local test = TestFunction()
```

![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1669633527104fde7bdfed20d4bdb802bdec69d11e4fb.png)또한 퀵 인포에서도 지정한 타입을 확인할 수 있습니다.

```
---@type function(paramA:string, paramB:AttackComponent):string, boolean
local test = TestFunction()
local strValue, boolValue = test("param", self.Entity.AttackComponent)
```

![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1667893299258103b46b267b745f882a40a4cbb70c568.png)여러 값을 반환하는 함수와 함께 다른 값을 지정하고 싶을 때는 괄호를 통해 각각의 타입을 묶어서 구분합니다.

```
---@type (function(paramA:string, paramB:Entity):AttackComponent,string), Entity
local testFunction, testEntity = function(testParamA, testParamB) return atkComponent, "strValue" end, self.Entity
```

# 매개 변수 타입 지정 : Param Annotation

**Param Annotation**을 사용해 대상이 되는 함수의 매개 변수 타입을 지정하여 스크립트 어시스트의 도움을 받을 수 있습니다. **Param Annotation**은 함수 정의문에 사용합니다.

아래와 같은 문법으로 **Param Annotation**을 사용합니다.

```
---@param param_name PARAM_TYPE
```

##### 사용 예시

```
---@param testParamA Entity
local function TestFunction(testParamA)
end
```

```
---@param testParamA Entity
---@param testParamB integer
local function TestFunction(testParamA, testParamB)

end
```

기본적으로 루아 함수를 정의하면 매개 변수에 어떤 타입이 들어올지 알 수 없기 때문에 타입 추론을 할 수 없습니다. 이때 **Param Annotation**을 사용해 봅시다.

| Param Annotation 적용 전 | Param Annotation 적용 후 |
| :---: | :---: |
| ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/166789361996144188e4993ee4a6a8a4d0bddeb7229ae.png) | ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1667893634012f417287ece184076a6dae5259609f80e.png)<br>![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1668671082158866bdb58d8bf4710b2df2fab3d00ce47.png) |

# 반환 타입 지정 : Return Annotation

**Return Annotation**은 대상 함수의 반환 타입을 지정하여 스크립트 어시스트의 도움을 받을 수 있습니다. **Return Annotation**은 함수 정의문에 사용합니다.

아래와 같은 문법으로 **Return Annotation**을 사용합니다.

```
---@return TYPE
```

##### 사용 예시

```
---@return Entity
local function TestFnction(testParamA, testParamB)
    return self.Entity
end
```

```
---@return Entity, string
local function TestFunction(testParamA, testParamB)
    return self.Entity, "strValue"
end
```

| Return Annotation 적용 전 | Return Annotation 적용 후 |
| :---: | :---: |
| ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1667893987810443dd08fe02842e19a29e8d2b7d14b54.png) | ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1667894003787ca547259d8d0414294064f26fd6569ac.png) |

Update 2025-11-17 PM 08:14


# 스크립트 디버그

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

디버그 기능을 통해 스크립트를 디버깅하는 방법에 대해 알아봅니다.

# 중단점 (Breakpoints)

스크립트 디버깅의 시작은 중단점 설정에서 시작됩니다. 이상이 발생하거나, 오작동의 원인으로 의심되는 코드 라인에 중단점을 설정 또는 해제하는 방법을 알아봅니다.

#### 중단점 설정

스크립트 에디터에서 디버깅하려면 가장 먼저 중단점을 설정해야 합니다. 중단점은 원하는 코드 라인에 **F9** 키를 눌러 설정할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/163705967832018b0bcb305064e1ab0588a93b33ded86.png) <코드 라인을 선택한 후 F9 키를 누르면 좌측에 중단점 ![break_point](https://mod-file.dn.nexoncdn.co.kr/bbs/163452037264550d6cc9a394d421686b324e622531625.png)이 나타납니다.>

#### 중단점 해제

중단점이 설정된 코드 라인을 선택하고**다시 F9** 키를 누르면 중단점이 해제됩니다. 중단점이 해제되면 디버그 모드로 실행 시 해당 지점에서 게임이 멈추지 않습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1637059714014a97f7af47e9e448687ce6993a387d639.png)

#### 중단점 관리

중단점을 여러 라인, 여러 스크립트에 설정하다 보면 내가 어디에 중단점을 설정했는지, 불필요한 중단점이 아직 남아있는지 확인이 어려울 때가 있습니다. 이때 **Breakpoints** 패널을 통해 설정된 모든 중단점의 확인이 가능합니다. 내비게이션 메뉴의 **Panels - Debug - Breakpoints**를 클릭해 엽니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16875077319895fd3c24546fb466abb6f59901a6fd11d.png)  **Breakpoints** 패널에서는 스크립트 이름과 함수명, 라인 정보를 제공합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16370597948003bc1552ec1b4445ebb17f3c2e15f2989.png)

| 목록 | 설명 |
| --- | --- |
| Entry | 중단점이 설정된 스크립트 컴포넌트 또는 스크립트 로직과 같은 스크립트 이름 |
| Method | Entry 내 중단점이 설정된 Method 이름 |
| Line | Method 내 중단점이 설정된 라인 위치 |

**Breakpoints** 패널에서는 중단점이 설정된 위치를 조회하는 것뿐만 아니라 각 중단점의 삭제 또는 중단점이 설정된 위치로 이동할 수 있습니다.

#### 중단점으로 이동

중단점 목록을 더블 클릭하거나, 콘텍스트 메뉴에서 **Move**를 클릭해 해당 중단점 위치로 이동할 수 있습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1637059803373a398dd6a85c944c8bb9223a41618be5d.png)

#### 중단점 삭제

삭제하려는 중단점의 콘텍스트 메뉴에서 **Remove**를 클릭해 중단점을 삭제합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/163705981310639ae31b71811480d9462f92fd1c649dc.png)

# 디버그

스크립트에 중단점을 설정했으면, 디버그 모드로 월드를 실행해 코드를 파악합니다.

#### 디버그 시작

디버그는 **[디버그 시작/중지]** 버튼 ![Tool_Debug](https://mod-file.dn.nexoncdn.co.kr/bbs/163453034389022f3433c55154836a7b16c2f001ec1b2.png)을 눌러 시작할 수 있습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16353141412294342625aa5754de983403c8517115938.png)  디버그를 시작하면 게임 시작했을 때와 똑같이 플레이되지만, 중단점이 설정된 코드가 실행될 때 플레이가 정지되며 코드의 상태를 파악할 수 있습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16370598223453b36967cfad54068bffdf7debc0505f0.png)

#### 코드 파악

디버깅 중 각 변수나 프로퍼티에 할당된 값을 확인할 수 있습니다. ![TabWatcher](https://mod-file.dn.nexoncdn.co.kr/bbs/1634524682293d425b6b49f234132a341a80cdc17a080.png) **WatchExpress** 같은 툴을 활용해 할당된 값을 상세히 알아볼 수 있습니다. 간단하게는 실행된 코드 라인의 변수나 프로퍼티에 **마우스 오버**하면 **툴팁**으로 **할당된 값, 실행 공간, 타입** 등을 확인할 수 있습니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1637060082729c78d3fca6cb940dd81255e820ec4ea9f.png) (예: 매개 변수로 받은 delta의 값이 무엇인지 확인할 수 있습니다.)

#### 디버깅 중지

**[디버그 시작/중지]** 버튼 또는 **[시작]** 버튼을 눌러 중지할 수 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1637059841169be829952b87b4af59e11572af9bd3e3f.png)

#### 디버깅 중 코드 실행

중단점을 설정한 코드를 확인했을 때 문제가 없다면, 혹은 해당 코드 아래 줄의 상태도 함께 확인하고 싶다면 어떻게 해야 할까요? 확인하고자 하는 모든 코드 라인에 중단점을 설정할 수도 없고, 매번 디버그 시작/중지를 반복하며 중단점 설정 해제를 반복하는 것도 비효율적입니다. 디버깅 중 중단점에서 플레이가 멈춘 뒤, 중단점이 설정된 라인 이후로 코드를 실행하는 방법이 있습니다. **프로시저 단위 실행**, **한 단계씩 코드 실행** 등을 통해 단위별로 코드를 실행하며 코드의 상태나 흐름을 파악할 수 있습니다. 단위별 코드 실행은 디버그가 시작되면 디버그 시작/중지 버튼 옆에 각 버튼이 노출됩니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1637059903339201b8d7bc1c84a1c8aff5223d3546515.png)

| 버튼 | 기능 | 단축키 | 설명 |
| --- | --- | --- | --- |
| ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/163531428695222092623c5ee4bbdb6c765b0257765d4.png) | 다음 중단점까지 이동 | F5 | 현재까지 실행된 라인에서 다음 중단점이 있는 코드 라인까지 실행합니다. |
| ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16353142973766005f7a18f6241e0853fcdb4b117d794.png) | 프로시저 단위 실행 | F10 | 코드를 한 줄씩 실행합니다.<br>포커싱 된 라인에 함수가 있을 때, 함수를 실행한 것으로 간주하고 다음 줄로 넘어갑니다. |
| ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1635314349045496e747d90b649a7aa14b0fb1388f0af.png) | 한 단계씩 코드 실행 | F11 | 프로시저 단위 실행과 같이 코드를 한 줄씩 실행하지만, 포커싱 된 라인에 함수가 있을 때, 해당 함수 내부로 들어가 함수 내 코드를 한 줄씩 실행합니다. |
| ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/163531436027902cc8e8685d04d26a2a7d6659e0ed05d.png) | 프로시저 나가기 | Shift + F11 | 현재 실행 중인 함수 호출을 완료하고, 해당 함수를 호출한 위치로 이동합니다. |

# Watch Expression

마우스 오버를 이용해 변수나 프로퍼티의 값을 확인하는 방법은 간편하게 값을 하나씩 확인하기엔 편리하지만, 코드가 한 줄씩 실행될 때마다 특정 변숫값이 어떻게 변하는지 알고 싶을 때는 계속 마우스를 올려 확인해야 하므로 상당히 불편합니다. 프로퍼티/함수 내부나 선언된 변수를 **Watch Expression**에 등록한 후, 코드가 실행될 때마다 값을 추적하면 매우 편리합니다.  내비게이션 메뉴의 **Panels - Debug - Watch Expression**를 클릭해 엽니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16875080353841809a26bb9494dbc9cc9bf775f4ff075.png)  디버깅 중 값을 알고자 하는 변수나 프로퍼티 명을 **Add Expression**에 작성합니다.

> __Tip.__ 현재 포커싱 되어있는 함수에서 선언된 **변수의 경우 변수 이름**을, **프로퍼티의 경우에는 self.프로퍼티 명** 형식으로 등록합니다.

![17](https://mod-file.dn.nexoncdn.co.kr/bbs/163531441012044c1f499c222457c8428da2cff7ffeb4.png)**Watch Expression**에 변수나 프로퍼티가 등록되면, 코드를 한 줄씩 실행하며 다음과 같이 값의 변화를 추적할 수 있습니다.

| 함수 내 코드 실행 전 | 함수 내 코드 실행 후 |
| --- | --- |
| - 디버깅 시작해서 중단점이 설정된 NewMethod3함수의 첫 번째 라인에 포커싱.<br>- NewMethod3 함수의 매개 변수로 "Debug12"를 받음.<br>- 변수 text는 아직 선언되지 않음.<br>- Property는 초깃값 0이 할당. | - F11을 통해 4번째 줄까지 코드 실행.<br>- 변수 text 선언 및 "Debug123" 할당.<br>- Property 값에 1을 더함. |
| ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16370600155057ca13181b27649018ee5ba886944a710.png) | ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16370600271603294fb67b3024471b88820dda2b0b976.png) |
| ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/163531445300862c1a06ecc354207b15e5206b731a731.png) | ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1635314465563af8446e05b504689aa99b9ee139f7e54.png) |

# Call Stack

콜스택은 현재 디버깅 중인 함수가 어디서부터 호출되었는지를 확인하는 데 사용됩니다. 내비게이션 메뉴의 **Panels - Debug - Call Stack**를 클릭해 엽니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/168750821078566a306d100c6405e8845e38ba39689a8.png)

다음과 같이 `OnBeginPlay` 함수를 시작으로 `Method1`, `Method2`를 거쳐 `Method3`을 호출하는 스크립트에서 `Method3` 내부를 디버깅 중이라 했을 때, **Call Stack**을 이용해 `Method3`까지 호출된 순서와 실행 공간을 확인할 수 있습니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16353144857503a4fa032527a41bd85f26876272b25a1.png)

Update 2025-12-02 PM 03:52


# 프로퍼티

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=40%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 메이플스토리 월드의 프로퍼티가 무엇인지 알아봅니다. 또한 프로퍼티 선언 및 초깃값 설정, 프로퍼티 동기화 방법 등 프로퍼티 관련 정보를 살펴보겠습니다.

# MSW의 프로퍼티

프로퍼티는 컴포넌트의 멤버 변수로써, 엔티티 별로 다른 값을 가질 수 있습니다. 프로퍼티는 세 가지 특징이 있습니다.

- 루아 변수와 달리 메이플스토리 월드의 프로퍼티는 선언할 때 타입을 설정하고, 값을 대입하거나 참조할 수 있습니다.
- 컴포넌트 내 외부에서 프로퍼티에 접근할 수 있고, 각 함수에서 값을 읽거나 쓸 수 있습니다.
- 프로퍼티 동기화 설정으로 서버 - 클라이언트 간 동기화 여부를 설정할 수 있습니다.

# 프로퍼티 선언과 제거

프로퍼티 선언 및 삭제 방법을 알아봅시다.

#### 프로퍼티 선언

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭해 새 스크립트 컴포넌트를 생성합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1687496291799b05a128af08748b8bc69f2956c9de929.png)
2. 컴포넌트 이름을 입력합니다. 생성된 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1635329393515dacd9e3446ac472e92b77b2f787c160d.png)
3. **[+]** 버튼을 클릭해 새 프로퍼티를 추가합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1635329401326a69e30631ae4401784a4862c7711aada.png)
4. 프로퍼티 이름, 타입, 초깃값, 그리고 서버-클라이언트 간 동기화 여부를 설정합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1635329412870e2a6e47b832645ed89b9768119cc89bc.png)

#### 프로퍼티 삭제

**[⋮] 메뉴 - Remove**를 클릭해 프로퍼티를 삭제합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1635329420391af78791adc6e4e3e97380dea88d3b4ad.png)

# 프로퍼티 타입

프로퍼티는 타입을 설정해야 합니다. 루아 기본 문법과는 조금 다르지만, 프로퍼티 값 전달과 동기화를 위해 타입을 반드시 설정해야 합니다. 프로퍼티 이름 왼쪽의 타입을 클릭해 적절한 타입을 설정합니다. ![06](https://mod-file.dn.nexoncdn.co.kr/bbs/1673599399633ba4e45d5b2694a838e3454621f4b9d4c.png)

#### string

string 타입은 문자열 값을 받을 수 있습니다.

```
Property: 
[Sync]
string StringProperty = "Hello"

Method:
[Server Only]
void OnBeginPlay()
{
    self.StringProperty = self.StringProperty .. " World!!"
    log(self.StringProperty) --콘솔 창에 문자열 "Hello World!!" 출력
    self.StringProperty = "Hello MSW!!"
    log(self.StringProperty) --콘솔 창에 문자열 "Hello MSW!!" 출력
}
```

#### number

number 타입은 숫자 값을 받을 수 있습니다. 정수, 실수 상관없이 모든 숫자 값을 받습니다.

```
Property:
[Sync]
number NumberProperty = 100

Method:
[Server Only]
void OnBeginPlay()
{
    self.NumberProperty = self.NumberProperty + 83
    log(self.NumberProperty) --콘솔 창에 숫자 183 출력
    self.NumberProperty = 3.28
    log(self.NumberProperty) --콘솔 창에 숫자 3.28 출력
}
```

#### integer

integer 타입은 정숫값을 받을 수 있습니다. 실숫값을 받으면 소수부는 버립니다.

```
Property:
[Sync]
integer IntegerProperty = 100

Method:
[Server Only]
void OnBeginPlay()
{
    self.IntegerProperty = self.IntegerProperty + 83
    log(self.IntegerProperty) --콘솔 창에 숫자 183 출력
    self.IntegerProperty = 3.28
    log(self.IntegerProperty) --콘솔 창에 숫자 3 출력
}
```

#### boolean

프로퍼티에 true 또는 false 값을 할당할 수 있습니다.

```
Property: 
[Sync]
boolean BooleanProperty = false

Method:
[Server Only]
void OnBeginPlay()
{
    self.BooleanProperty = true
    
    if self.BooleanProperty == true then
    self.BooleanProperty = false
    log("Hello MSW!!")
    end
}
```

#### table

루아 테이블을 참조합니다. 동기화(Sync)는 되지 않습니다.

```
Property: 
[None]
table TableProperty = {1,2,3,4,5}

Method:
[Server Only]
void OnBeginPlay()
{
    local tmpTable = self.TableProperty
    self.TableProperty[1] = 10
    log("tmpTable : "..tmpTable[1]) --콘솔 창에 "tmpTable : 10" 출력
    log("TableProperty : "..self.TableProperty[1]) --콘솔 창에 "TableProperty : 10" 출력
    
    self.TableProperty = {100,200,300,400}
    log("tmpTable : "..tmpTable[1]) --콘솔 창에 "tmpTable : 10" 출력
    log("TableProperty : "..self.TableProperty[1]) --콘솔 창에 "tmpTable : 100" 출력
}
```

#### SyncTable< v >

루아의 table 형태지만 제약이 있는 타입으로 `next` 함수는 사용할 수 없습니다. 일반 table 프로퍼티와 다르게 정해진 타입 중 한 가지만 설정할 수 있으며 **동기화(Sync)**할 수 있습니다. 다만 일반 table 보다는 다소 느리다는 점을 참고하기 바랍니다. **v**는 타입입니다. 목록에서 원하는 타입을 선택할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/168610513116799d1be6022794e1582c2b9227100a178.png)

#### SyncTable< k, v >

루아의 table 형태지만 제약이 있는 타입으로 `next` 함수는 사용할 수 없습니다. 일반 table 프로퍼티와 다르게 key, value에 각각 정해진 타입만 설정할 수 있으며 **동기화(Sync)**할 수 있습니다. 다만 일반 table 보다는 다소 느리다는 점을 참고하기 바랍니다. **k, v**는 타입입니다. 목록에서 원하는 타입을 선택할 수 있습니다.

#### Vector2

2차원 벡터와 위치를 표현합니다. 테이블 형태로 제공되며 프로퍼티 또는 변수에 할당 시 참조됩니다. 주로 2차원 공간에서의 위치 좌표를 나타내는 데 사용하며, x좌표와 y좌표를 나타내는 멤버 변수 x와 y를 포함하고 있습니다. 값의 생성과 참조, 그리고 멤버 변수 x, y에 접근하는 방법은 아래를 참고합니다.

```
Property: 
[Sync]
Vector2 Vector2Property = Vector2(0,0)

Method:
[Server Only]
void OnBeginPlay()
{
    local tmpVector2 = Vector2(10,10) --벡터를 생성하여 지역변수 tmpVector2에 할당
    self.Vector2Property = tmpVector2 --tmpVector2의 값을 프로퍼티 Vector2Property에 할당
    log(tmpVector2) --콘솔 창에 (10.000, 10.000)으로 출력
    log(self.Vector2Property) --콘솔 창에 (10.000, 10.000)으로 출력
    
    local calcu = self.Vector2Property
    calcu.x = 20 --멤버 변수 x의 값을 설정
    calcu.y = 50 --멤버 변수 Y의 값을 설정
    log(calcu) --콘솔 창에 (20.000, 50.000)으로 출력
}
```

#### Vector3

3차원 벡터와 위치를 표현합니다. **Vector2**와 마찬가지로 프로퍼티 또는 변수에 할당 시 참조됩니다. **Vector2**에서 멤버 변수 z가 추가됩니다. **TransformComponent**의 **Position**에 할당할 때를 제외하곤 주로 **Vector2**를 사용합니다. 값의 생성과 참조, 그리고 멤버 변수 x, y, z에 접근하는 방법은 아래를 참고합니다.

```
Method:
[Server Only]
void OnBeginPlay()
{
    local tmpVector3 = Vector3(10,10,10)  --벡터를 생성하여 지역변수 tmpVector3에 할당
    local Vt1 = tmpVector3
    local Vt2 = tmpVector3
    log(Vt1)  --콘솔 창에 (10.000, 10.000, 10.000)으로 출력
    log(Vt2)  --콘솔 창에 (10.000, 10.000, 10.000)으로 출력  
    
    tmpVector3.x = 20
    tmpVector3.y = 20
    tmpVector3.z = 20
    
    log(tmpVector3)  --콘솔 창에 (20.000, 20.000, 20.000)으로 출력
    log(Vt1)  --콘솔 창에 (20.000, 20.000, 20.000)으로 출력
    log(Vt2)  --콘솔 창에 (20.000, 20.000, 20.000)으로 출력
}
```

#### Vector4

4차원 벡터와 위치를 표현하는 참조 타입입니다. **Vector3**에서 멤버 변수 w가 추가됩니다. 값의 생성과 참조, 그리고 멤버 변수 x, y, z, w에 접근하는 방법은 아래를 참고합니다.

```
Method:
[Server Only]
void OnBeginPlay()
{
    local tmpVector4 = Vector4(10,10,10,10)  --벡터를 생성하여 지역변수 tmpVector3에 할당
    local Vt1 = tmpVector4
    local Vt2 = tmpVector4
    log(Vt1)  --콘솔 창에 (10.000, 10.000, 10.000, 10.000)으로 출력
    log(Vt2)  --콘솔 창에 (10.000, 10.000, 10.000, 10.000)으로 출력  
    
    tmpVector4.x = 20
    tmpVector4.y = 20
    tmpVector4.z = 20
    tmpVector4.w = 20        

    log(tmpVector4)  --콘솔 창에 (20.000, 20.000, 20.000, 20.000)으로 출력
    log(Vt1)  --콘솔 창에 (20.000, 20.000, 20.000, 20.000)으로 출력
    log(Vt2)  --콘솔 창에 (20.000, 20.000, 20.000, 20.000)으로 출력
}
```

#### Entity / EntityRef

엔티티를 가리키는 프로퍼티입니다. Entity와 EntityRef의 기본 사용법은 동일하며, 참조 방식이 다릅니다.

- Entity: 엔티티를 직접 참조합니다. 다른 맵으로 이동했다가 다시 돌아온 경우 참조가 끊어져 프로퍼티를 사용할 수 없게 됩니다.
- EntityRef: 엔티티의 키 값을 가지고 있다가 실제 접근할 때 엔티티를 찾습니다. 다른 맵에 갔다 왔을 때 원래 가리키던 엔티티에 문제없이 접근할 수 있습니다. EntityRef는 엔티티에 접근할 때마다 엔티티를 찾기 때문에 Entity보다 느립니다.

```
Property:
[Sync]
Entity EntityProperty = EntityPath
[None]
EntityRef EntityRefProperty = EntityPath

Method: 
[Client Only]
void OnBeginPlay()
{
    log(self.EntityProperty.Name)
    log(self.EntityRefProperty.Name)
}
```

#### Component / ComponentRef

컴포넌트 가리키는 프로퍼티입니다. 프로퍼티 타입을 Component 선택 후, 버튼을 눌러 특정 컴포넌트를 타입으로 설정할 수 있습니다. Component와 ComponentRef의 기본 사용법은 동일하며, 참조 방식이 다릅니다.

- Component: 컴포넌트를 직접 참조합니다. 다른 맵에 갔다 오면 참조가 끊어지고 프로퍼티를 사용할 수 없게 됩니다.
- ComponentRef: 컴포넌트의 키 값을 가지고 있다가 실제 접근할 때 컴포넌트를 찾습니다. 다른 맵에 갔다 왔을 때 원래 가리키던 컴포넌트에 문제없이 접근할 수 있습니다. ComponentRef는 컴포넌트에 접근할 때마다 컴포넌트를 찾기 때문에 Component보다 느립니다.![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1635329448310478cc03be91a4882900e39683a801fd7.png)

```
Property:
[None]
TransformComponent ComponentProperty = EntityPath
[None]
TransformComponentRef ComponentRefProperty = EntityPath

Method:
[client only]
void OnBeginPlay()
{
    log(self.ComponentProperty.Position)
    log(self.ComponentRefProperty.Position)
}
```

#### any

어떤 타입이든 참조할 수 있는 타입입니다. 위 기본 타입들을 대신해서 쓰기보다는, **Entity**나 **Component**를 참조할 때 주로 활용합니다.

```
Property:
[None]
any EntityProperty = nil
any ComponentProperty = nil

Method:
[Server Only]
void OnBeginPlay()
{
    self.EntityProperty = _EntityService:GetEntityByPath("/maps/map01/entityA")
    self.ComponentProperty = self.EntityProperty.TransformComponent
    log(self.EntityProperty.Name) --콘솔 창에 해당 엔티티의 이름 출력
    log(self.ComponentProperty.Position) --콘솔 창에 컴포넌트의 프로퍼티 값 출력. (Position은 Vector3 타입이므로, (x, y, z) 형태로 출력)
}
```

# 프로퍼티 초깃값 설정

프로퍼티 초깃값은 기본적으로 스크립트에서 설정합니다. 예를 들면 아래와 같이 각 프로퍼티의 타입에 따라 "Hello"라는 문자열 값을 넣거나, 또는 100과 같은 숫자 값을 넣을 수 있습니다. Table 타입의 프로퍼티라면 테이블을 초깃값으로 설정할 수도 있습니다. 프로퍼티 초깃값은 해당 컴포넌트가 적용된 엔티티의 기본값이 되기도 합니다. 각 프로퍼티에 어떠한 값도 대입하거나 참조하지 않은 상태에서 각 함수에서 접근하면 프로퍼티의 초깃값을 읽어옵니다.

```
Property:
[None]
string StringProperty = "Hello!!"

Method:
[Server Only]
void OnBeginPlay()
{
    local getStringProperty = self.StringProperty 
    --self.StringProperty의 값인 "Hello!!"를 getStringProperty에 대입
    log(getStringProperty) 
    --콘솔 창에 "Hello!!" 출력
}
```

엔티티별로 다른 초깃값을 설정할 수도 있습니다. 엔티티 별로 다른 초깃값을 설정하려면 스크립트보다는 프로퍼티 에디터에서 설정하는 것이 효율적입니다. 프로퍼티 에디터에서 설정한 프로퍼티 값은 스크립트의 프로퍼티 초깃값보다 우선순위가 높기 때문입니다. 따라서 엔티티에 컴포넌트를 추가한 후 프로퍼티 에디터에서 초깃값을 설정하면, 엔티티별로 다른 프로퍼티 초깃값을 가지게 됩니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1683001932653498b70b84e0242c7a8b8902a8643b144.png)

# 프로퍼티 접근

함수에서 프로퍼티에 접근하는 방법을 알아봅시다. 먼저 같은 컴포넌트에서는 다음과 같이 접근할 수 있습니다.

```
Property:
[None]
string StringProperty = "Hello!!"

Method:
[Server Only]
void OnBeginPlay()
{
    local stringProperty = self.StringProperty 
    --"self.프로퍼티명"으로 해당 프로퍼티를 가져옴
}
```

다른 컴포넌트의 프로퍼티는 다음과 같이 접근할 수 있습니다. 아래 상황에서 접근하는 방법을 알아봅시다.

- 엔티티 "A"와 "B"가 존재하고, 각각 엔티티에 "ComponentA"와 "ComponentB"가 적용된 상황.
- "ComponentA"에는 "PropertyA"라는 이름의 프로퍼티가, "ComponentB"에는 "PropertyB"라는 이름의 프로퍼티가 선언되어 있다.
- 이때 "ComponentB"에서 "ComponentA"의 프로퍼티 "PropertyA"의 값을 읽어와서 "PropertyB"에 대입시킨다.

```
Property: 
[None]
string PropertyA = "HelloMSW!!"
```

```
Property:
[None]
string PropertyB = ""

Method:
[Server Only]
void OnBeginPlay()
{
    local entityA = _EntityService:GetEntityByPath("/maps/map01/A")
    local componentA = entityA.ComponentA
    self.PropertyB = componentA.PropertyA
    log(self.PropertyB) --콘솔 창에 HelloMSW!!로 출력되는 것을 확인합니다.
}
```

> **더 알아보기** 엔티티와 컴포넌트 참조에 대한 설명은 다음 가이드를 참고하세요. [엔티티와 컴포넌트 참조](https://mod-developers.nexon.com/docs?postId=164)

# _T 프로퍼티

프로퍼티는 컴포넌트 내 멤버 변수로, 함수에서 쓰고 읽어도 종료되지 않고 함수에서 설정한 값이 보존됩니다. 따라서 함수를 통해 어떤 값을 담아놓거나 함수를 반복 호출하여 값을 누적할 때 활용될 수 있습니다. 다음은 3초 간격으로 콘솔 창에 "HelloMSW"를 출력하는 예제입니다.

```
Property:
[Sync]
number AccTime = 0

Method:
[Server Only]
void OnUpdate(delta)
{
    self.AccTime = self.AccTime + delta  
    --OnUpdate가 호출될 때마다 AccTime 프로퍼티에 delta 값을 더합니다.
        
    if self.AccTime >= 3 then  
    -- AccTime 프로퍼티의 누적값이 3 이상인지 체크, 3 이상이면 콘솔 창에 "HelloMSW"를 출력
        self.AccTime = 0
        log("HelloMSW")
    end
}
```

위 예제처럼 컴포넌트 내부에서 누적된 값을 담아놓을 수 있습니다. 하지만 불필요한 프로퍼티 선언과 동기화를 계속하기 때문에 번거롭습니다. 이를 해결하기 위해 메이플스토리 월드에서는 **_T 프로퍼티**를 제공합니다. **_T 프로퍼티**의 특징은 다음과 같습니다.

- 일반 프로퍼티와 달리 함수 내에서 처음 쓴 시점에 생성됩니다.
- 내부 컴포넌트는 물론 외부 컴포넌트에서도 접근할 수 있습니다.
- 동기화를 할 수 없기 때문에 동일한 공간에서만 사용할 수 있습니다.

**_T 프로퍼티**는 **"_T.프로퍼티 명"** 형식으로 사용합니다. 정확한 사용법을 알아보기 위해 위의 예제를 _T 프로퍼티를 사용하여 다시 작성해 보겠습니다.

```
Property:
[Sync]
number AccTime = 0  -- 이 프로퍼티 대신 _T 프로퍼티를 사용
 
Method:
[Server Only]
void OnUpdate(delta)
{
    if self._T.accTime == nil then self._T.accTime = 0 end  
    --_T 프로퍼티는 쓰는 시점에 바로 선언됨. 내부 컴포넌트에서 선언되었기 때문에 앞에 self를 붙임
 
    self._T.accTime = self._T.accTime + delta  
    --OnUpdate가 호출될 때마다 _T.accTime에 delta 값을 더함
     
    if self._T.accTime >= 3 then  
    -- _T.accTime의 누적값이 3 이상인지를 체크하고, 3이상이면 콘솔 창에 "Hellow MSW"를 출력
        self._T.accTime = 0
        log("HelloMSW")
    end
}
```

Update 2025-12-02 PM 03:52


# 프로퍼티 동기화

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

서버, 클라이언트 간 데이터 전송 방식 중 하나인 프로퍼티 동기화에 대해 알아봅시다.

# 동기화

메이플스토리 월드에서의 동기화는 서버, 클라이언트 간 데이터 전송 방식의 일종으로,각각의 공간에 존재하는 같은 이름의 프로퍼티를 같은 값으로 맞춰주는 것을 의미합니다. 기본적으로 프로퍼티는 선언과 동시에 서버, 클라이언트 각각의 공간에 생성되지만, 만일 프로퍼티 동기화가 되지 않는다면 이름은 같지만 서로 다른 값으로 설정할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1656921110965fe5ba17e21f34900892bd58c08cd2059.png)  제작자의 의도에 따라서 같은 프로퍼티의 값을 각 공간에 따라 다르게 할당할 수 있지만, 일반적으로 관리 측면의 효율성을 위해 두 공간의 같은 프로퍼티를 똑같은 값으로 맞춰주게 됩니다. 그렇다면 프로퍼티 동기화는 어떻게 할 수 있을까요?  메이플스토리 월드에서는 프로퍼티를 자동으로 동기화해주는 기능을 제공해주고 있습니다. 프로퍼티 선언 후 동기화를 할지에 대한 여부만 설정해주면 되기 때문에 동기화를 위한 별도의 구현이 필요 없습니다.

> **더 알아보기** 만약 동기화가 제공되지 않는 상황에서 캐릭터의 스탯을 만든다고 가정해 봅시다. 스탯을 만든다면 먼저 Stat이라는 컴포넌트를 만들고, 그 안에 HP 프로퍼티와 MP 프로퍼티 등등을 만들게 됩니다. 그리고 여기에 더해 캐릭터가 몬스터로 부터 공격받았을 때 HP를 감소시킨다 라는 것을 만든다면, 우리는 서버에서 캐릭터의 HP를 감소시키는 로직을 만들 것입니다. 이때 서버와 클라이언트의 프로퍼티는 다른 공간에 존재해 있기 때문에 서버의 HP 프로퍼티만 값이 갱신되고, 클라이언트의 HP 프로퍼티는 갱신되지 않은 상태가 됩니다. 실제 캐릭터의 HP 값은 줄어들었지만, 클라이언트 상 (대표적으로 눈에 보이는 UI)에서는 HP가 줄어들지 않게 되는 것이죠. 이럴 때 서버의 프로퍼티가 변경되면 수동으로 클라이언트의 값을 변경해 주거나, 또는 서버와 클라이언트가 같은 로직을 돌게 해야 하는데 이는 상당히 비효율적이면서 관리가 쉽지 않습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16353351388052ce5c7972f5f47abb1d5ff853ed1c98f.png) <캐릭터는 죽었지만, HP는 줄어들지 않는 이유는 서버와 클라이언트 간의 프로퍼티 동기화가 이루어지지 않아서입니다.>

# 동기화 방향

일부 네이티브 컴포넌트를 제외하면, 대체로 프로퍼티 동기화는 서버에서 클라이언트로 진행됩니다. 즉, 서버에서 프로퍼티에 값을 할당해주면, 서버에서 변경된 값이 클라이언트로 전송되어 같은 프로퍼티에 할당됩니다. 이는 반대로 클라이언트의 프로퍼티에 값을 할당한다고 서버의 값이 같이 변하지 않는다는 얘기이기도 합니다. 이유는 서버는 단독으로 존재하기 때문에 서버의 값이 변경되었을 때 각 클라이언트로 전송할 수 있지만, 클라이언트는 여러 개로 존재하면서 각자 다른 값으로 수정할 수 있기 때문에 서버 입장에서는 어떤 값으로 수정되어야 하는지 판단이 어려워지기 때문입니다.

메이플스토리 월드에서 클라이언트에서 서버로의 동기화는 대체로 제한되어 있고, 프로퍼티의 동기화 설정을 한 상태에서 클라이언트의 값만 단독으로 변경하는 것은 특수한 경우를 제외하고는 추천하는 방법은 아닙니다.

- **서버에서 변경된 값으로 동기화를 시도할 경우** ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1637147657269fd6b96b5c65e49ca9423a19a6f8af4c4.png)
- **클라이언트에서 변경한 값으로 동기화를 시도할 경우** ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1637147673759d03429e5f6a64067ac73010418dc8515.png)  동기화는 서버에서 변경한 값을 클라이언트로 전송한 뒤 같은 값으로 맞추는 것이기 때문에 약간의 딜레이가 발생할 수 있습니다. 이는 서버에서 값을 변경한 즉시 클라이언트에 반영되지 않는다는 뜻입니다. 서버에서 변경한 값이 클라이언트로 동기화된 시점에 맞춰 어떤 액션을 수행하고 싶다면, 기본 이벤트 함수 중 하나인 OnSyncProperty를 활용하면 됩니다. OnSyncProperty는 같은 컴포넌트에 있는 프로퍼티 값이 동기화되었을 때 호출되는 함수로, 서버로부터 동기화된 값을 클라이언트 상에 출력할 때와 같은 상황에서 유용하게 사용됩니다. OnSyncProperty에 대한 상세한 내용은 아래 가이드 참고하세요. [MSW 기본 이벤트 함수](https://mod-developers.nexon.com/docs?postId=163)

# 동기화 설정

동기화에 대해 기본적인 개념을 알아보았으니 이번에는 실제 동기화를 설정하는 방법과 프로퍼티 타입에 따른 동기화 설정 가능 여부에 대해 알아보도록 하겠습니다.

#### 동기화 설정 방법

동기화 설정 방법은 매우 간단합니다. 스크립트 에디터를 한 번이라도 열어서 프로퍼티를 추가해봤다면 프로퍼티 상단에 Sync라고 쓰여 있는 것을 본 적이 있을 것입니다. 이 Sync는 프로퍼티 동기화가 되고 있다는 것을 의미합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16353351805975c7eee1f898d423a80562096893bcc95.png)  만일 프로퍼티 동기화를 원치 않는다면 Sync를 눌러 None으로 변경해 줍니다. 동기화 표시가 None으로 되어 있으면 프로퍼티 동기화는 이루어지지 않는다는 것을 의미하며, 프로퍼티 값을 공간별로 따로 관리할 수 있게 됩니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16353351874159d1ae0e2b0e148ac8fe0075ef65b2f96.png)

#### 타입별 동기화 가능 여부

일부 타입의 프로퍼티는 동기화 설정이 제한됩니다.

| 타입 | 동기화 가능 여부 |
| --- | --- |
| any | X |
| string | O |
| integer | O |
| number | O |
| boolean | O |
| table | X |
| SyncTable< v > | O |
| SyncTable< k,v > | O |
| Vector2 | O |
| Vector3 | O |
| Vector4 | O |
| Color | O |
| Entity | O |
| Component | O |
| EntityRef | O |
| ComponentRef | O |

Update 2025-11-17 PM 08:14


# 함수

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

함수에 대한 간략한 소개와 함께 함수의 선언과 정의, 호출에 대해 알아봅니다.

# 메소드 소개

**컴포넌트**는 기본적으로 **프로퍼티**와 **메소드**로 구성됩니다. 그중 함수는 객체지향 프로그래밍에서 사용되는 용어로, 특정 액션을 수행하기 위한 코드들의 집합체라 할 수 있습니다. 메이플스토리 월드의 함수는 함수의 호출 주체가 누구냐에 따라 **기본 이벤트 메소드**와 **사용자 지정 메소드**로 나눌 수 있습니다. 기본 이벤트 함수는 게임 시작, 플레이 중, 게임 종료 시 등 특정 이벤트가 발생했을 때 호출되는 함수로, 호출 시점과 함수 이름이 정해져 있으며 모든 동작의 진입점이 되는 함수입니다. 사용자 지정 함수는 호출 시점이 정해져 있지 않고, 액션의 목적에 따라 이름을 자유롭게 지을 수 있습니다.

| **기본 이벤트 메소드** | **사용자 지정 메소드** |
| --- | --- |
| 호출 시점이 정해져 있고, 시스템 내부에서 호출<br>다른 사용자 지정 함수에서 호출 불가.<br>함수 이름, 리턴 타입, 매개 변수 설정 불가.<br>게임상의 모든 액션의 시작점. | 함수가 정의된 목적에 따라 호출 시점 및 이름 등을 자유롭게 설정 가능.<br>단, 시스템에서 자동으로 호출하지 않기 때문에 기본 이벤트 함수로부터 호출하여 실행. |

> **더 알아보기** 기본 이벤트 함수에 대해 더 알아보고 싶다면 아래 가이드를 참고하세요! [MSW 기본 이벤트 함수](https://mod-developers.nexon.com/docs?postId=163)

# 메소드선언과 삭제

#### 메소드 선언

스크립트 에디터에서 함수를 선언할 수 있습니다. 선언 방법을 알아보기 위해 먼저 새 스크립트 컴포넌트를 생성하여 스크립트 에디터를 엽니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1687496291799b05a128af08748b8bc69f2956c9de929.png)  **Function** 옆의 **[+]** 버튼을 누르면 함수 목록이 나옵니다. **New**를 클릭하면 사용자 지정 함수가 추가되고, 그 외 항목을 선택하면 기본 이벤트 함수가 추가됩니다. **New**를 클릭하여 사용자 지정 함수를 추가합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16735978319009a6594de0ce841a687bb1bfc3de66e85.png)  새로운 함수는 **Function1**이라는 이름으로 생성되는데, 목적에 맞게 이름을 변경할 수 있습니다. 함수의 이름을 클릭하여 텍스트 입력이 활성화되면 이름을 변경합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/163529625383210fdafccdf4d48389a20f83444d8da12.png)

#### 메소드 삭제

함수명 오른쪽의 ![script_more](https://mod-file.dn.nexoncdn.co.kr/bbs/16345206995612a35d54577d8466da03a9fe452a5218c.png) **[메뉴]** 버튼을 누른 뒤 **Remove**를 클릭해 함수를 제거합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1637035145550329a2d443fec46c4963e19267a80fbdc.png)

# 메소드 리턴 타입 설정

메이플스토리 월드의 함수는 리턴 타입을 설정해야 합니다. 기본적인 루아 문법과는 조금 다르지만, 스크립트의 내부적인 값 전달을 위해 리턴 타입은 반드시 설정해야 합니다. 함수 리턴 타입은 기본적으로 **void**로 설정되어 있습니다. 리턴 타입 텍스트를 클릭하면 선택 가능한 타입 목록이 나옵니다. 여기서 함수의 결과에 맞는 타입을 선택하면 해당 타입으로 변경됩니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1673598279122cc02c371fecc424e8c66e4783dc434d8.png)

# 메소드 정의

해당 함수가 호출되었을 때 어떻게 동작할지를 정의할 수 있습니다. 함수명 왼쪽의 **[+]** 버튼을 누르면 함수 구현부가 펼쳐집니다. 구현부에 해당 함수의 기능을 코드로 작성합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635296282345d1313e4452014e6ca076982525e7746f.png)

# 매개 변수

일반적으로 함수는 호출될 때 여러 타입의 값을 입력받을 수 있는데, 이를 위한 매개 변수도 추가할 수 있습니다. 매개 변수는 구현부 내에서 지역 변수처럼 사용하며, 초깃값은 함수가 호출될 때 할당됩니다. 만일 호출하는 곳에서 매개 변수에 아무 값도 넣지 않은 경우, **nil**로 넘어옵니다.

#### 매개 변수 추가

함수명 오른쪽의 ![script_more](https://mod-file.dn.nexoncdn.co.kr/bbs/16345206995612a35d54577d8466da03a9fe452a5218c.png) **[메뉴]** 버튼을 누른 뒤 **Add Parameter**를 클릭하면 함수에 매개 변수가 추가됩니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1637035161326431e96d64ef1404a80167ba28c6518ec.png)  추가된 매개 변수는 타입과 이름을 재설정 할 수 있습니다. 타입 텍스트를 클릭하면 타입 목록이 열립니다. 입력받을 매개 변수 값의 타입을 선택할 수 있습니다. ![8-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1673598346122b15e0c97880c46719660198439894ac4.png)  매개 변수 이름을 클릭하여 텍스트 입력이 활성화되면 이름을 변경합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1635296312284b23737fee9e14a94928f2350da9df274.png)  매개 변수가 추가된 상태에서 한 번 더 추가하면, 기존 매개 변수 우측에 새 매개 변수가 생성됩니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16370352064875922d8bb2fcd41088e3bb33edde931ed.png)

#### 매개 변수 삭제

추가한 매개 변수를 삭제할 수 있습니다. 메소드명 오른쪽의 ![script_more](https://mod-file.dn.nexoncdn.co.kr/bbs/16345206995612a35d54577d8466da03a9fe452a5218c.png) **[메뉴]** 버튼을 누른 뒤 **Remove Parameter**를 클릭하면 매개 변수가 삭제됩니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1637035223229386a07a202b04ebf99b8bbe5d31070bb.png)  만일 매개 변수가 2개 이상 있었다면, 오른쪽 매개 변수부터 차례로 삭제됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1637035232985d47aef4485fe42a29adeaa73f8a09678.png)

# 메소드 호출

메소드 내부에서는 다른 메소드를 호출해서 다른 함수의 기능을 작동시킬 수 있습니다. 기본적으로 메소드는 **컴포넌트 객체(또는 서비스):메소드명(매개 변수)** 형식으로 호출합니다.

#### 동일한 컴포넌트 내 메소드 호출 시

동일 컴포넌트의 메소드를 호출할 때는 다음과 같이 **self:메소드명(매개 변수)**형식으로 호출합니다. (**self**는 현재 작동 중인 메소드를 포함하고 있는 컴포넌트 객체를 의미합니다.)

```
--개념 이해를 돕기 위한 코드로, 컴포넌트에 적용 시 정상적으로 동작하지 않을 수 있습니다.
void OnBeginPlay()
{
    local param = "MethodCallTest"
    self:MethodPractice(param)          -- self:메소드명(매개 변수)으로 메소드 호출
}
 
void MethodPractice(string parameter)
{
    log(parameter)                     -- 콘솔 창에 "MethodCallTest" 출력
}
```

#### 다른 컴포넌트, 또는 서비스의 메소드 호출 시

다른 컴포넌트의 메소드를 호출할 때에는 **컴포넌트 객체:메소드명()** 형식으로 호출합니다. 다른 컴포넌트 객체는 일반적으로 해당 컴포넌트를 포함하고 있는 엔티티를 통해 참조할 수 있습니다. 서비스도 마찬가지로 **서비스명:메소드명()** 형식으로 호출합니다. 아래 스크립트를 테스트하기 위해 TestComponent를 추가하고, **map01**에 **Add component**를 사용하여 연결합니다.

```
--개념 이해를 돕기 위한 코드로, 컴포넌트에 적용 시 정상적으로 동작하지 않을 수 있습니다.
void OnBeginPlay()
{
    local param = "MethodCallTest" 
    local mapEntity = _EntityService:GetEntityByPath("/maps/map01")     -- 서비스의 메소드 호출 시
    local componentInstance = mapEntity.TestComponent                   -- 다른 컴포넌트 객체 참조
    componentInstance:MethodCallTest(param)                             -- 컴포넌트 객체의 메소드 호출
}
```

#### 메소드 호출 형식 예외

루아 스크립트에서 제공하는 일부 메소드 또는 일부 타입에서 제공하는 **Static** 메소드의 경우에는 **:이 아닌 .으로** 호출합니다.

```
--개념 이해를 돕기 위한 코드로, 컴포넌트에 적용 시 정상적으로 동작하지 않을 수 있습니다.
void OnBeginPlay()
{
    --루아 함수 사용 예시
    local tmpTable = {1,2,3,4,5}
    table.insert(tmpTable, 6)                   -- :이 아닌 .으로 함수 호출
    local len = string.len("Method Practice")     -- :이 아닌 .으로 함수 호출
 
    log(#tmpTable)                              -- 콘솔 창에 6 출력
    log(len)                                   -- 콘솔 창에 15 출력
    
    --Vector2 타입의 Static 함수 사용 예시
    local positionA = Vector2(0,0)
    local positionB = Vector2(10,10)
    local distance = Vector2.Distance(positionA, positionB)  -- :이 아닌 .으로 함수 호출
    log(distance)                                       -- 콘솔 창에 positionA와 positionB의 거리 출력
}
```

Update 2025-11-20 PM 02:03


# MSW 기본 이벤트 함수

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=50%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서 스크립트를 활용하면 크리에이터만의 독창적인 월드를 자유자재로 만들 수 있습니다. 스크립트를 작성할 때는 필요에 따라 기본 이벤트 함수를 활용하게 됩니다. **기본 이벤트 함수**란 다른 함수에서 직접 호출하지 않아도 **특정 조건이 되면 자동으로 호출되는 함수**를 말합니다. 이번 과정에서는 기본 이벤트 함수의 종류와 호출 시점을 알아봅시다.

# 기본 이벤트 함수 추가하기

기본 이벤트 함수를 추가해 봅시다.

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭해 새 스크립트 컴포넌트를 생성하고 스크립트 에디터를 엽니다.
2. **Function** 옆의 **[+]** 버튼을 클릭합니다. **New**(사용자 지정 함수) 외에는 모두 기본 제공되는 이벤트 함수입니다. 필요에 따라 함수를 추가합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16370612894139b23c38d3a884725832fe814dbe7be63.png) ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/163706129949446ade8e045fc4743a36f98f922e244da.png)

# 기본 이벤트 함수

메이플스토리 월드에서 제공하는 이벤트 함수는 기본적으로 서버에서 호출합니다. 크리에이터의 의도에 따라 호출 공간을 다르게 설정할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1665647356908d5c12958fef64370944c14f7d521bce3.png)

이제 함수를 좀 더 자세히 살펴봅시다.

### OnInitialize

`OnBeginPlay` 함수가 호출되기 전, 엔티티와 컴포넌트가 생성된 후에 1회 호출되는 함수입니다. 단, `OnInitialize` 함수는 엔티티의 컴포넌트가 생성되기 전에 호출될 수 있습니다. 그러므로 `OnInitialize` 함수에서 다른 컴포넌트 또는 엔티티 참조 시 **nil**을 받아올 가능성이 있습니다.

```
void OnInitialize()
{
    local myEntity = self.Entity      
    --자기 자신이 적용된 엔티티 참조 가능
    --콘솔 창에 myEntity의 이름과 "Hello MapleStory Worlds!" 출력
    log(myEntity.Name.."Hello MapleStory Worlds")

    --아래와 같이 OnInitialize 내부에서 다른 엔티티나 컴포넌트의 참조는 추천하지 않음
    local otherComponent = myEntity.컴포넌트 이름      --nil 일 가능성 있음
    local anotherEntity = _EntityService:GetEntityByPath("엔티티 경로")  --다른 엔티티 참조. nil 일 가능성 있음
}
```

### OnBeginPlay

본격적으로 로직이 시작되는 시점(`OnInitialize` 함수 호출 이후, `OnUpdate` 호출 직전)에 1회 호출되는 함수입니다. 엔티티의 `OnBeginPlay` 함수는 다른 엔티티와 컴포넌트가 모두 생성된 뒤에 호출됩니다. 동적으로 생성된 엔티티도 해당 엔티티의 컴포넌트가 모두 생성된 후에 `OnBeginPlay` 함수가 호출됩니다. 그러므로 `OnInitialize` 함수와는 달리 `OnBeginPlay` 함수는 다른 엔티티 및 컴포넌트의 참조가 보장됩니다.

```
void OnBeginPlay()
{
    local myEntity = self.Entity    -- 자기 자신이 적용된 엔티티 참조 가능.
    log(myEntity.Name.."Hello MapleStory Worlds")    -- 콘솔 창에 myEntity의 이름과 "Hello MapleStory Worlds!" 출력
     
    --OnInitialize와는 달리 아래와 같이 다른 엔티티, 다른 컴포넌트의 참조가 보장됨
    local otherComponent = myEntity.컴포넌트 이름
    local otherEntity = _EntityService:GetEntityByPath("엔티티 경로")
    local otherEntityComponent = otherEntity :GetComponent("컴포넌트 이름")
}
```

하지만 각 컴포넌트 간의 `OnBeginPlay` 함수 호출 순서는 보장되지 않습니다. 그러므로 특정 컴포넌트에서 `OnBeginPlay` 함수로 설정한 값을 받아오면 제대로 작동하지 않을 가능성이 있습니다. 예를 들어 봅시다.

- **컴포넌트 A**에서 **프로퍼티 B**를 **" "**로 정의합니다. 그리고 `OnBeginPlay` 함수에서 **프로퍼티 B**를 **"Hello"**로 설정합니다.
- **컴포넌트 C**의 `OnBeginPlay` 함수에서 **프로퍼티 B**를 참조합니다.
- 이때 **"Hello"**가 아닌 **nil**을 받아올 수도 있습니다.

```
-- ComponentA
Property: 
[Sync]
string B = ""

Method: 
[server only]
void OnBeginPlay()
{
    self.B = "Hello"
    log(self.B)
}

-- ComponentC    
Property: 

Method: 
[Server Only]
void OnBeginPlay()
{
    local myEntity = self.Entity
    local componentA = myEntity.ComponentA
    log(componentA.B)   
    --ComponentA와 ComponentC의 OnBeginPlay 중 무엇이 먼저 호출될지 모르므로, 콘솔 창에 nil이 출력될 수 있음.
}
```

따라서 다른 컴포넌트의 `OnBeginPlay` 함수에서 **컴포넌트 A**의 프로퍼티를 참조해야 한다면, 다음과 같이 `OnInitialize` 함수를 활용해 봅시다.

```
-- ComponentA
Property: 
[Sync]
string B = ""

Method: 
[server only]
void OnInitialize()
{
    self.B = "Hello"
    log(self.B)
}

-- ComponentC
Property: 

Method: 
[Server Only]
void OnBeginPlay()
{
    local myEntity = self.Entity
    local componentA = myEntity.ComponentA
    log(componentA.B)   
    -- ComponentA에서 OnInitialize를 통해 값을 할당했으므로, 콘솔 창에 "Hello"가 출력
}
```

### OnUpdate

`OnBeginPlay` 함수 호출 이후, 프레임마다 호출되는 함수입니다. 따라서 프레임별로 엔티티 위치, 상태, 동작을 변경하고 싶다면 `OnUpdate` 함수에 스크립트를 작성합니다. 매개 변수로 **delta**를 사용하며, 이전 프레임에 걸린 시간 값(단위: 초)을 받습니다. **delta**를 활용하여 프레임 단위 구현을 할 수 있고, 특정 시간마다 액션을 제어할 수 있습니다.

```
void OnUpdate(number delta)
{
    if self._T.Time == nil then self._T.Time = 0 end
    self._T.Time = self._T.Time + delta
     
    --3초마다 Console 창에 Hello MapleStory Worlds를 출력
    if self._T.Time >= 3 then
        self._T.Time = 0
        log("Hello MapleStory Worlds")
    end
}
```

### OnEndPlay

`OnDestroy` 함수와 함께 엔티티가 제거되는 시점에 1회 호출되는 함수입니다. 다만 `OnEndPlay` 함수가 완료된 후에도 엔티티는 제거되지 않고 유효한 상태입니다. `OnEndPlay` 함수가 호출된 이후, `OnDestroy` 함수가 호출됩니다.

```
void OnEndPlay()
{
    log("OnEndPlay!!")
    -- Console Result
    -- OnEndPlay!!
}
```

### OnDestroy

엔티티가 제거되는 시점에 1회 호출되는 함수입니다. `OnEndPlay` 함수 이후 호출됩니다. `OnEndPlay` 함수와는 달리, `OnDestroy` 함수 완료 뒤에는 엔티티가 제거됩니다.

```
void OnDestroy()
{
    log("OnDestroy!!")
    -- Console Result
    -- OnDestroy!!
}
```

> **더 알아보기** 위에 설명한 `OnInitialize` 함수에서 `OnDestroy` 함수까지 실행 순서는 다음과 같습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16352483627843dbf0389a0b64bf1beb7388ea89672e4.png)

### OnMapEnter

`OnBeginPlay`가 엔티티가 생성될 때마다 호출되는 함수라면, `OnMapEnter`는 엔티티가 맵에 입장하거나, 맵에 생성될 때마다 호출되는 함수입니다. 따라서 맵을 이동할 때마다 초기화해야 하는 엔티티에 사용하면 좋습니다.

`OnMapEnter` 함수를 호출하면 입장한 맵의 엔티티가 매개 변수로 넘어옵니다. 플레이어가 월드에 진입했을 때 `OnInitialize` 함수나 `OnBeginPlay` 함수를 활용해 초기화하는 것처럼, 플레이어가 특정 맵에 진입했을 때는 `OnMapEnter` 함수를 사용해 필요한 처리를 할 수 있습니다.

다음은 `OnMapEnter` 함수를 활용하여 map01에 입장할 때마다 플레이어의 크기가 커지도록 구현한 예시입니다.

```
void OnMapEnter(Entity enteredMap)
{
    --map01에 입장할 때마다 플레이어 크기가 커짐
    if enteredMap.Name == "map01" then
        local myPlayer = self.Entity
        local transform = myPlayer.TransformComponent
        local scale = transform.Scale
        scale.x = scale.x + 1
        scale.y = scale.y + 1
        transform.Scale = scale
    end
}
```

#### OnBeginPlay와 OnMapEnter 차이

예를 들어, 내 플레이어 엔티티가 **map01에서 map02로 이동**했다고 가정합니다. 이때 내 플레이어 엔티티의 스크립트 컴포넌트에 `OnMapEnter` 함수가 있었다면, map02로 이동할 때 내 플레이어 엔티티의 `OnMapEnter` 함수가 호출됩니다. 그런데 내 플레이어뿐만 아니라 다른 플레이어의 `OnMapEnter` 함수도 호출되는 것을 볼 수 있습니다. 클라이언트 상에서 보자면, 현재 내가 존재하는 맵에 다른 플레이어 엔티티가 생성된 것과 마찬가지이기 때문입니다.

하지만 서버상에서는 내 플레이어 엔티티가 map01에서 map02로 이동한다 해도, 원래 map02에 있던 다른 플레이어 엔티티가 새롭게 생기는 것은 아닙니다. 다른 플레이어 엔티티는 내 플레이어가 해당 월드에 진입한 순간부터 이미 존재했던 것입니다. 서버상의 생성은 해당 월드에 최초 진입하는 순간에 이루어지기 때문에, 서버상의 `OnBeginPlay` 함수는 내 플레이어가 **월드에 진입하여 엔티티들이 생성되는 단 한 번만 호출**됩니다.

이와는 달리 `OnMapEnter` 함수는 엔티티가 **맵을 이동할 때마다 호출**됩니다. 이는 클라이언트뿐만 아니라 서버 상에서도 동일하게 작동하기 때문에 플레이어 엔티티가 맵을 이동할 때마다 `OnMapEnter` 함수가 호출되는 것입니다. 이와 같은 차이점을 이해하고 용도에 맞게 `OnBeginPlay` 함수와 `OnMapEnter` 함수를 사용해야 합니다.

### OnMapLeave

`OnMapEnter` 함수와 반대로 엔티티가 맵에서 퇴장할 때, 혹은 맵에 제거될 때마다 호출되는 함수입니다. `OnMapEnter` 함수처럼 맵을 이동할 때마다 초기화가 필요한 엔티티에 활용하면 좋습니다.

`OnMapLeave` 함수를 호출하면 퇴장한 맵의 엔티티가 매개 변수로 넘어옵니다. 다음은 `OnMapLeave` 함수를 활용하여 map01에서 퇴장할 때마다 플레이어의 크기가 작아지도록 구현한 예시입니다.

```
void OnMapLeave(Entity leftMap)
{
    --map01에서 퇴장할 때마다 플레이어 크기가 작아짐
    if leftMap.Name == "map01" then
        local myPlayer = self.Entity
        local transform = myPlayer.TransformComponent
        local scale = transform.Scale
        scale.x = scale.x - 1
        scale.y = scale.y - 1
        transform.Scale = scale
    end
}
```

### OnSyncProperty

서버에서 변경된 값이 클라이언트로 동기화될 때 클라이언트에서 호출되는 함수입니다. `OnSyncProperty` 함수를 호출하면 동기화된 프로퍼티의 이름과 값이 매개 변수로 넘어옵니다. 프로퍼티 동기화 설정을 **None**으로 하면 동기화가 이루어지지 않으므로 `OnSyncProperty` 함수는 호출되지 않습니다.

```
Property: 
[Sync]
number HP = 100
[Sync]
number MP = 100
 
Method: 
[Client Only]
void OnSyncProperty(string name, any value) --name : 프로퍼티 이름, value : 변경된 프로퍼티 값
{
    if name == "HP" then
        if self.HP == value then 
            log("동기화가 완료된 시점에 호출되므로, 이 로그가 콘솔 창에 출력됩니다.")
            return 
        end
        
        if value > 0 then 
            return 
        end
        
        -- HP 값이 0 이하일 때의 처리를 추가합니다.
        
    elseif name == "MP" then
        if self.MP == value then
            log("동기화가 완료된 시점에 호출되므로, 이 로그가 콘솔 창에 출력됩니다.")
        end
        
        if value > 0 then 
            return 
        end
        
        -- MP 값이 0 이하 일 때의 처리를 추가합니다.   
        
    end
}
```

Update 2025-11-20 PM 02:03


# 엔티티와 컴포넌트 참조

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=50%EB%B6%84&amp;color=green)

# 학습 과정 소개

엔티티와 컴포넌트 구조를 간략하게 이해하고, 스크립트를 통해 엔티티와 컴포넌트에 접근하는 방법을 알아봅니다.

# 엔티티와 컴포넌트 구조

먼저 엔티티와 컴포넌트의 구조를 알아보겠습니다. 기본적으로 엔티티는 각기 다른 컴포넌트들로 구성되어 있고, 각각의 엔티티는 상위, 하위 관계로 연결되어 있습니다. 이 연결 구조를 이용하면 특정 컴포넌트에서 다른 엔티티나 컴포넌트로 접근할 수 있습니다. 아래 이미지는 엔티티 간의 상-하위 구조와 각 엔티티를 구성하는 컴포넌트를 도식화한 것입니다. 이후 이 구조를 바탕으로 설명하겠습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16371471617051e7a31dbcf5742d8b8f61020bf6913db.png)

> 엔티티와 컴포넌트 개념은 다음 강의를 참고하세요. [Entity, Component, Property](https://mod-developers.nexon.com/docs?postId=54)

# 엔티티 참조

스크립트 컴포넌트에서 다른 엔티티를 참조하는 방법을 살펴봅니다.

#### self.Entity

먼저 컴포넌트 자신을 포함하는 엔티티 참조 방법을 알아봅시다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291524024e210da552eaf462a8558eddda0c5b43c.png)  스크립트를 작성할 때, 위 도식처럼 Component A에서 Entity C를 참조하는 경우가 빈번하게 발생합니다. 참조 방법은 매우 간단합니다. 아래 코드처럼 self.Entity를 통해 엔티티를 받아올 수 있습니다.

```
void OnBeginPlay()
{
    local myEntity = self.Entity
    log(myEntity.Name)  -- 엔티티 이름 출력
}
```

#### Entity.Parent

상위 엔티티 참조 방법을 알아봅니다. 아래와 같이 Component A에서 Entity A를 참조하는 경우입니다. Entity C를 참조한 다음, 그 부모인 Entity A를 참조할 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291534007f6d3e36ca453424485607b7fda2dd06b.png)  예시 코드는 다음과 같습니다.

```
void OnBeginPlay()
{
    local myEntity = self.Entity
    log(myEntity.Name)  -- Entity C의 이름 출력
 
    local parentEntity = myEntity.Parent
    log(parentEntity.Name) -- Entity A의 이름 출력
}
```

#### Entity.Children

상위 엔티티에서 하위 엔티티를 가져오는 방법을 알아봅니다. Entity.Children으로 상위 엔티티에서 하위 엔티티들을 참조할 수 있습니다. 다만 Entity.Children는 하위의 모든 엔티티를 목록으로 가져옵니다. 아래 그림처럼 Entity A의 하위 엔티티 중 특정 엔티티인 Entity D만 참조하려면 배열을 순회하여 조건에 맞는 엔티티만 참조해야 합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/163529154797085c3b3e542834bb89e508df36a58dd18.png)  다음은 위 그림처럼 Component A에서 Entity D를 참조하는 코드 예시입니다.

```
void OnBeginPlay()
{
    local myEntity = self.Entity
    log(myEntity.Name)    -- Entity C의 이름 출력
      
    local parentEntity = myEntity.Parent
    log(parentEntity.Name)   -- Entity A의 이름 출력
    
    local children = parentEntity.Children  --Entity A의 하위 엔티티를 테이블 형태로 받아 옴
    local childrenEntityName = ""
          
    for index, child in pairs(children) do
        if child.Name == "EntityD" then
            childrenEntityName = child.Name
            break
        end
    end
         
    if childrenEntityName == "" then
        log("EmptyEntityD")
        return 
    end
     
    log(childrenEntityName)
}
```

#### Entity:GetChildByName()

Entity.Children처럼 하위 엔티티를 참조하는 또 다른 방법을 알아봅시다. Entity:GetChildByName()은 하위 엔티티 중 매개 변수로 넘겨진 값과 같은 이름의 엔티티를 반환하는 함수입니다. 따라서 Entity.Children처럼 모든 하위 엔티티를 받아온 후 반복문을 통해 원하는 엔티티를 찾을 필요가 없습니다. 찾고자 하는 엔티티의 이름만 알고 있다면 훨씬 간단하게 하위 엔티티를 가져올 수 있습니다.

- **매개 변수**
  - GetChildByName 함수는 두 개의 매개 변수를 받을 수 있습니다. | Parameter | Type | Description |
| --- | --- | --- | | name | string | 찾고자 하는 하위 엔티티의 이름을 넘겨줍니다. | | recursive | bool | 하위에 하위 엔티티를 재귀적으로 계속 찾을 것인지를 설정합니다.<br>true일 경우 하위에 하위 엔티티까지 재귀적으로 찾습니다<br>false일 경우 바로 아래 단계까지만 찾습니다.<br>옵셔널 매개 변수이기 때문에 아무 값도 넣지 않아도 됩니다.<br>값을 넣지 않으면 false(하위에 하위 엔티티 찾지 않음)로 설정됩니다. |

- **반환 값**
  - 만일 찾고자 하는 엔티티가 존재하면 해당 엔티티를 반환하고,
  - 그렇지 않으면 nil을 반환합니다.
- **스크립트 작성 예시**
  - 다음은 상위 엔티티인 EntityA에서 하위 엔티티인 EntityD를 받아오는 스크립트입니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/163529158705102eb762c67b14c3cbe9c07c0ef87e8f4.png) ```
void OnBeginPlay()
{
    local entityA = self.Entity    -- EntityA를 받아 옴
    local entityD = entityA:GetChildByName("EntityD")    -- 하위 엔티티인 EntityD를 받아 옴
    log(entityD.Name)    -- 콘솔 창에 EntityD의 이름 출력

    --만약 하위 엔티티가 없는 엔티티를 찾으면 nil 반환
    local entityF = entityA:GetChildByName("EntityF")
    log(entityF)    -- 콘솔 창에 nil 출력
}
```
- 다음은 상위 엔티티 EntityA에서 하위에 하위 엔티티인 EntityJ를 참조하는 스크립트입니다. 하위 엔티티를 가져올 때는 두 번째 매개 변수인 recursive 값을 true로 설정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291597805292fc8bfa543454eb370f7861ad928e3.png) ```
void OnBeginPlay()
{   
    local entityA = self.Entity    -- EntityA를 받아 옴
    local entityJ = entityA:GetChildByName("EntityJ", true)
    -- EntityJ의 이름인 "EntityJ"로 하위에 하위 엔티티를 찾습니다. 하위에 하위까지 찾아야 하기 때문에 두 번째 매개 변숫값을 true로 설정     
    log(entityJ.Name)    -- 콘솔 창에 EntityJ의 이름 출력
}
```

# _EntityService를 통한 Entity 참조

지금까지는 컴포넌트에서 상위, 하위 엔티티의 연결 구조로 엔티티를 참조하는 방법을 알아보았습니다. 이 방법은 컴포넌트와 가까운 엔티티를 찾을 때는 효율적이지만, 아래와 같이 부모의 부모의 부모를 찾고 다시 그 부모의 하위 엔티티를 찾아야 한다면 상당히 번거롭습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16352916095449bc3ee34f64745c8856c713169446ff5.png)  _EntityService를 활용하면 원하는 엔티티를 바로 찾아 반환하는 함수를 사용할 수 있어 편리합니다.

#### GetEntityByPath()

찾으려는 엔티티 경로(Path)를 매개 변수로 넘겨주면, 해당 경로의 엔티티를 반환하는 함수입니다. 가장 보편적으로 사용되는 함수입니다.

- **매개 변수**| Parameter | Type | Description |
| --- | --- | --- | | worldPath | string | 얻고자 하는 엔티티 경로를 넣어줍니다.<br>경로는 /maps/부터 시작해서 하위 엔티티들을 입력합니다.<br>예를 들어 다음과 같은 계층 구조에서 "object_1"의 경로는 다음과 같습니다.<br>![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1635483238562b41e1da8c00d4eeaab15d6db6080a4a3.png)<br>"/maps/map01/object_1" |
  > **Tip** 엔티티 경로를 수동으로 입력하면 번거롭고 오타 발생 가능성도 높아 비효율적입니다. 엔티티 경로 복사 기능을 사용하면 손쉽고 정확하게 엔티티 경로를 입력할 수 있습니다. 특정 엔티티의 콘텍스트 메뉴에서 **Copy Entity Path**를 클릭하면 해당 엔티티 경로가 클립보드에 저장됩니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1686210532005a4a5c0075ed74dfd84667cb938b58532.png)
- **반환 값**
  - 매개 변수로 입력한 경로와 일치하는 엔티티가 있으면 엔티티를 반환합니다.
  - 만일 경로 값과 일치하는 엔티티가 여러 개일 경우, 가장 먼저 찾은 엔티티만 반환합니다.
  - 경로 값과 일치하는 엔티티가 없으면 nil을 반환합니다.
- **스크립트 작성 예시**
  - 다음 그림과 같이 Component A에서 Entity E를 참조하는 예시 코드는 다음과 같습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291664607739291779c984748ad56f8bb91fddb83.png) ```
void OnBeginPlay()
{  
    --EntityE의 경로를 매개 변수로 입력하여 EntityE를 반환
    local EntityE = _EntityService:GetEntityByPath("/maps/map01/EntityO/EntityB/EntityE")   
    if isvalid(EntityE) == false then return end   

    log(EntityE.Name)
}
```

#### GetEntitiesByPath()

매개 변수로 넘겨진 경로와 일치하는 모든 엔티티를 리스트 형태로 반환하는 함수입니다. 생성된 엔티티는 서로 다르지만, 생성 시 같은 이름으로 생성되어 경로가 같을 때 사용하면 편리합니다. 예를 들어, 탄막이나 총알처럼 동일한 이름으로 대량 생성된 엔티티를 한 번에 제어할 때 유용하게 사용할 수 있습니다.

- **매개 변수**| Parameter | Type | Description |
| --- | --- | --- | | worldPath | string | 얻고자 하는 엔티티 경로를 넣어줍니다.<br>경로는 /maps/부터 시작해서 하위 엔티티들을 입력합니다. |
- **반환 값**
  - 매개 변수로 입력한 경로 값과 일치하는 모든 엔티티를 반환합니다.
  - 경로 값과 일치하는 엔티티가 없으면 nil을 반환합니다.
- **스크립트 작성 예시**
  - 다음은 ComponentA에서 EntityB의 하위 엔티티 중 이름이 EntityE인 엔티티를 가져오는 코드입니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16352916806362d0bfb38644b44e78e8ab10b2ce762e8.png) ```
void OnBeginPlay()
{
    --매개 변수로 넘겨진 경로 값과 일치하는 모든 엔티티를 List 형식으로 반환
    local entityTable = _EntityService:GetEntitiesByPath("/maps/map01/EntityO/EntityB/EntityE")
    if entityTable == nil then return end

    -- 반환된 모든 엔티티를 순회하며 엔티티의 이름을 출력. (모두 EntityE로 출력)
    for index, entity in pairs(entityTable) do
        log(entity.Name)
    end
}
```

#### GetEntity()

매개 변수로 엔티티 ID를 넘겨주면 해당 ID의 엔티티를 반환하는 함수입니다. 엔티티의 계층 구조가 동적으로 변경되거나 엔티티의 이름이 바뀌면서 경로가 변경될 여지가 있으면, 유니크한 ID를 이용해 엔티티를 받아올 수 있는 GetEntity를 사용하는 것이 효율적입니다.

- **매개 변수**| Parameter | Type | Description |
| --- | --- | --- | | ID | string | 얻고자 하는 엔티티 ID를 넣어줍니다.<br>엔티티의 콘텍스트 메뉴에서 **Copy Entity ID**를 클릭하면<br>해당 엔티티의 ID가 클립보드에 복사됩니다.<br>![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16862106228295b326090f635424abcc59cf1e2980a19.png)<br>또는 스크립트에서도 엔티티의 ID를 다음과 같이 얻을 수 있습니다.<br>local id = Entity.ID |
- **반환 값**
  - 매개 변수로 입력한 ID의 엔티티를 반환합니다.
  - ID에 해당하는 엔티티가 없으면 nil을 반환합니다.
- **스크립트 작성 예시**
  - ComponentA에서 EntityB 하위의 EntityE를 가져오는 예시 코드입니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291706386333eb05e82114f21a88219ec5980a571.png) ```
void OnBeginPlay()
{
    --매개 변수로 찾고자 하는 엔티티의 ID를 넘겨주면 해당 ID의 엔티티를 반환
    local entityE = _EntityService:GetEntity("eb9c3412-9730-4e32-a180-69f4d1596652")
    if entityE == nil then
        return nil
    end
    log(entityE.Name)
}
```

# 고유 엔티티 참조

지금까지 맵에 배치하거나 _SpawnService를 통해 동적으로 생성된 엔티티 참조 방법을 알아보았습니다. 이번에는 world, maps 또는 Player와 같이 고유한 엔티티 참조 방법을 알아봅시다. world, maps 같은 엔티티도 위의 방법으로 참조할 수 있지만, 게임 내에 하나만 존재하는 고유한 엔티티이기에 좀 더 쉽게 참조할 수 있습니다.

#### Entity.CurrentMap

Entity.CurrentMap은 특정 엔티티가 있는 맵 정보를 읽어옵니다. 엔티티의 Parent를 타고 들어가 맵 엔티티를 읽어올 순 있지만, CurrentMap을 활용하면 좀 더 쉽게 맵 엔티티를 가져올 수 있습니다. 다음은 EntityH의 ComponentA에서 EntityH가 있는 map01엔티티를 받아오는 예시 코드입니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1635291720112228087ed833e456688e74f3153ac2670.png)

```
void OnBeginPlay()
{  
    local myEntity = self.Entity    -- 자신이 포함하고 있는 EntityH를 받아 옴
    local curMap = myEntity.CurrentMap    -- 현재 EntityH가 속한 맵인 map01엔티티를 받아 옴
    if isvalid(curMap) == false then
        return
    end
     
    log(curMap.Name)    --콘솔 창에 "map01" 출력
}
```

#### Entity.CurrentWorld

엔티티를 통해 world 엔티티를 읽어올 수 있는 프로퍼티입니다. maps와 마찬가지로 게임 내에서 단 하나만 존재하기 때문에 어떤 엔티티에서든 CurrentWorld를 통해 world 엔티티를 읽어올 수 있습니다. 다음은 EntityB의 ComponentA에서 world 엔티티를 참조하는 예시 코드입니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/163714718037512f7b2e3d4114a4ca50976d3a41504a3.png)

```
void OnBeginPlay()
{
    local myEntity = self.Entity    -- 자신이 포함하고 있는 EntityB를 받아 옴
    local world = myEntity.CurrentWorld    -- 최상위 엔티티인 World 엔티티를 받아 옴
    if isvalid(world) == false then
        return
    end
     
    log(world.Name)    --콘솔 창에 "World" 출력
}
```

#### _UserService.UserEntities

게임에 접속해 있는 모든 플레이어 엔티티를 딕셔너리 형태로 받아오는 읽기 전용 프로퍼티입니다.

- Key: string UserId
- Value: Entity PlayerEntity

key 값인 UserId는 유저가 메이플스토리 월드에 가입 시 생성한 Id로 UserId와 플레이어 엔티티의 이름을 동일하게 사용하고 있습니다.

```
void PrintUserEntitiesName()
{
    log(_UserService:GetUserCount())
    local playerEntitiesDic = _UserService.UserEntities  
    
    -- 모든 플레이어를 순회하며 콘솔 창에 "플레이어 key 값/플레이어 이름" 형식으로 출력
    for key, playerEntity in pairs(playerEntitiesDic) do
        log(key.."/"..playerEntity.Name)                        
    end
}
```

#### _UserService.LocalPlayer

클라이언트 공간에서 내 플레이어 엔티티를 참조할 수 있는 읽기 전용 프로퍼티입니다. 서버에는 내 플레이어라는 개념이 없기 때문에 서버에서 사용하면 nil을 반환합니다.

```
[client Only]
void OnBeginPlay()
{
    local myPlayerEntity = _UserService.LocalPlayer
    log(myPlayerEntity.Name)    -- 내 플레이어 엔티티 이름 출력
}
 
[server Only]
void OnBeginPlay()
{
    -- 서버에서는 내 플레이어라는 개념이 없으므로 nil 반환
    local myPlayerEntity = _UserService.LocalPlayer     
    log(myPlayerEntity)    -- nil 출력
}
```

#### _UserService:GetUserEntityByUserID()

매개 변수로 넘겨진 플레이어의 Id를 통해 플레이어 엔티티를 반환하는 함수입니다.

- **매개 변수**

| Parameter | Type | Description |
| --- | --- | --- |
| UserId | string | 찾고자 하는 플레이어 엔티티의 UserId를 입력합니다.<br>UserId는 유저가 메이플스토리 월드에 가입 시 생성한 Id로 현재는 플레이어 엔티티의 이름과 동일한 값으로 사용됩니다. |

- **반환 값**
  - 매개 변수로 넘겨진 UserId와 동일한 플레이어 엔티티가 있으면, 플레이어 엔티티를 반환합니다.
  - UserId와 동일한 플레이어 엔티티가 없으면 nil을 반환합니다.
- **스크립트 작성 예시**```
Entity Event Handler:
    service UserService
    HandleUserEnterEventType (UserEnterEventType event) 
    {
        -- Parameters
        local UserId = event.UserId
        --------------------------------------------------------
        local GetUserId = _UserService:GetUserEntityByUserID(UserId)
        log(GetUserId)
    }
```

#### 컴포넌트의 접근과 동작

클라이언트 공간에서 내 플레이어 엔티티를 참조할 수 있는 읽기 전용 프로퍼티입니다. 프로퍼티 에디터에서 각 컴포넌트의 프로퍼티를 변경할 수 있는 것처럼 스크립트에서도 컴포넌트의 프로퍼티를 설정할 수 있습니다. 프로퍼티 에디터에서는 게임이 실행되기 전에 프로퍼티 초깃값만 설정이 가능하지만, 스크립트에서는 게임 실행 중 동적으로 프로퍼티 값을 변경할 수 있습니다. 그리고 프로퍼티 설정 외에도 컴포넌트에 속한 함수를 호출할 수 있기 때문에 크리에이터가 개발한 기능을 게임 실행 중에 작동시킬 수도 있습니다.  이번에는 각 엔티티에 포함된 컴포넌트 접근 방법을 알아보겠습니다. 또한 스크립트를 통해 게임 실행 중 동적으로 컴포넌트의 프로퍼티 값을 변경하고 함수를 호출하는 방법을 살펴보겠습니다.

#### 컴포넌트 접근

컴포넌트는 엔티티를 작동시키는 구성품입니다. 그러므로 반드시 엔티티를 통해 컴포넌트로 접근해야 합니다. 일반적으로 **Entity.컴포넌트 명** 형태로 컴포넌트에 접근할 수 있습니다. 네이티브 컴포넌트는 스크립트 에디터에서 컴포넌트 명이 자동 완성됩니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/163529175281398b0a801dd3e437cabba9f493741f9a1.png)  다음은 내 플레이어 엔티티의 **RigidbodyComponent**에 접근하는 예시 코드입니다.

```
[client only]
void OnBeginPlay()
{
    local myPlayerEntity = _UserService.LocalPlayer

    -- 내 플레이어 엔티티의 컴포넌트를 변수 rigidbody에 참조
    local rigidbody = myPlayerEntity.RigidbodyComponent 
    if rigidbody == nil then
        log("rigidbody is nil")
        return
    end
    log(rigidbody)
}
```

스크립트 컴포넌트도 네이티브와 동일하게 접근할 수 있습니다. 스크립트 컴포넌트를 생성할 때 작성한 컴포넌트 이름으로 접근하면 됩니다. 아래는 **CharacterStatus**라는 이름의 스크립트 컴포넌트에 접근하는 예시 코드입니다. **CharacterStatus** 컴포넌트를 직접 제작한 뒤 접근할 수 있습니다.

```
[client only]
void OnBeginPlay()
{
    local myPlayerEntity = _UserService.LocalPlayer
    
    -- 내 플레이어 엔티티의 스크립트 컴포넌트를 변수 status에 참조
    local status = myPlayerEntity.CharacterStatus   
    if status == nil then return nil end
    log(status)
}
```

> **더 알아보기** MSW는 상황에 따라 컴포넌트에 접근하는 여러 가지 방법을 제공합니다.**Array Entity:GetChildComponentsByTypeName(string typename, bool recursive)** 하위 엔티티에 포함된 컴포넌트 중 컴포넌트 이름이 typename과 일치하는 모든 컴포넌트를 Array 형태로 반환합니다. - **매개 변수**| Parameter | Type | Description |
| --- | --- | --- | | typename | string | 찾고자 하는 컴포넌트의 이름을 입력합니다. | | recursive | bool | 하위에 하위 엔티티까지 찾아 들어갈지를 설정합니다.<br>true로 설정할 경우, 하위에 하위 엔티티까지 컴포넌트를 찾습니다.<br>false로 설정할 경우, Entity의 하위 엔티티까지만 찾습니다.<br>아무 값도 넣지 않을 경우 false로 설정됩니다. | - **스크립트 작성 예시** 만일 아래 그림처럼 map01 하위의 모든 엔티티에서 ComponentA를 모두 반환받고 싶을 때 다음과 같이 스크립트를 작성할 수 있습니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/163529177940448f5ac49614d4075979b2c3dc83dda6d.png)```
void OnBeginPlay()
{
    local map01Entity = self.Entity.CurrentMap
    local ComponentsArr = map01Entity:GetChildComponentsByTypeName("ComponentA")         
    log(ComponentsArr)
}
```만일 아래와 같이 map01하위에 하위 엔티티에 있는 ComponentA까지 반환하려면 다음과 같이 작성합니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16352917921880070f662f0394704b49bd154c9903320.png)```
void OnBeginPlay()
{
    local map01Entity = self.Entity.CurrentMap

    --위 스크립트에서 두 번째 매개 변수에 true 입력 
    local ComponentsArr = map01Entity:GetChildComponentsByTypeName("ComponentA", true) 
    log(ComponentsArr)
}
```**Component Entity:GetFirstChildComponentByTypeName(string typename, bool recursive)** 하위 엔티티들을 순회하면서 하위 엔티티에 typename과 일치하는 컴포넌트가 있으면, 해당 컴포넌트를 반환합니다. - **매개 변수**| Parameter | Type | Description |
| --- | --- | --- | | typename | string | 찾고자 하는 컴포넌트의 이름을 입력합니다. | | recursive | bool | 하위에 하위 엔티티까지 찾아 들어갈지를 설정합니다.<br>true로 설정할 경우, 하위에 하위 엔티티까지 컴포넌트를 찾습니다.<br>false로 설정할 경우, Entity의 하위 엔티티까지만 찾습니다.<br>아무 값도 넣지 않으면 false로 설정됩니다. | - **스크립트 작성 예시** 만일 아래 그림처럼 map01하위의 모든 엔티티 중에서 ComponentA를 가진 첫 번째 엔티티의 ComponentA를 반환받고 싶다면 다음과 같이 스크립트를 작성해 줍니다. (하위 엔티티의 순회는 EntityA에서부터 EntityD로 한다는 가정) ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16352918189148ef0321fb0ad4e038085c66dd874e31a.png)```
void GetChildComponents()
{
    local map01Entity = self.Entity.CurrentMap

    --EntityA의 ComponentA 반환
    local ComponentsArr = map01Entity:GetFirstChildComponentByTypeName("ComponentA")   
}
```이번에는 엔티티의 하위뿐만 아니라 하위에 하위 엔티티에 있는 Component까지 검색하려면 다음과 같이 두 번째 매개 변숫값을 true로 설정해 줍니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/163529183127423266c0257414814a3a380f36d667ad0.png)```
void GetChildComponents()
{
    local map01Entity = self.Entity.CurrentMap

    --EntityF의 ComponentA 반환
    local ComponentsArr = map01Entity:GetFirstChildComponentByTypeName("ComponentA", true) 
}
```

Update 2025-11-17 PM 08:14


# 서버와 클라이언트

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

멀티 플레이를 제공하는 게임의 경우 각 게임의 특성에 따라 사용되는 통신 모델들이 다양합니다. MapleStory World는 다양한 통신 모델 중에서도 서버 - 클라이언트 모델을 사용하고 있습니다. 이번 과정에서는 MapleStory World의 통신 모델인 서버와 클라이언트의 개념과 구조, 그리고 각 공간 간의 정보전달 방법에 대해 알아보도록 하겠습니다.

# 서버와 클라이언트

클라이언트는 게임을 플레이하는 유저들의 모바일이나 PC, 또는 해당 기기에서 개별적으로 돌아가는 프로그램을 의미합니다.주로 유저의 입력을 처리하거나, 서버가 보내온 정보를 내부적으로 처리하여 유저에게 가시적으로 출력하는 역할을 수행합니다. 서버는 다수의 클라이언트가 연결된 단일 컴퓨터, 또는 해당 컴퓨터에서 돌아가는 프로그램을 의미합니다.일반적으로 각 클라이언트에서 보내온 요청에 대한 응답을 주기도 하지만, 게임 진행에 대한 주요 기능과 시스템을 서버에 구축함으로써 모든 클라이언트가 동일한 진행 상황이 될 수 있도록 할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637228699029a52751daf6c943c0a46ca3ca575c1f9e.png)

# 서버와 클라이언트의 관계

서버 - 클라이언트 모델에서 클라이언트는 다른 클라이언트와 통신하지 않으며, 오직 서버하고만 정보를 주고받습니다. 클라이언트는 유저의 입력을 받고, 입력된 내용에 따라 서버에게 정보를 요청하거나 현재 클라이언트의 상황을 서버에게 알립니다. 특정 클라이언트로부터 정보를 받은 서버는 클라이언트에게 다시 정보를 보내주거나, 혹은 전송한 내용을 게임 진행 상황에 업데이트시키고, 업데이트된 내용을 다시 모든 클라이언트에게 전송함으로써 게임을 이용하는 모든 유저가 동일한 상황이 될 수 있도록 맞춰줍니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1637228723887c6c077c9db624c6cb78924690d141edd.png)  서버 - 클라이언트 간 처리 구조는 제작자의 의도에 따라 자유롭게 설계할 수 있지만, 만일 클라이언트에서 모든 로직과 시스템을 구축하고, 서버는 동기화를 위한 통신용으로만 사용하도록 설계한다면 해킹에는 상당히 취약한 구조가 됩니다.예를 들어 다음과 같이 캐릭터의 레벨업을 클라이언트에서 처리 후, 서버를 통해 다른 클라이언트에게 알린다고 가정해봅시다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1637228744217901eadeec18549cd916b580dcb47bcaf.png) ▲주요 로직을 클라이언트에서 처리할 때의 예  주요 로직을 개별 클라이언트에서 처리하고 서버는 처리된 결과를 받아 다른 클라이언트에게 전송만 하면 되기 때문에 서버의 부하를 줄일 순 있습니다. 하지만 유저가 본인의 클라이언트를 해킹한 결과를 서버에게 전송한다면, 다른 유저들도 이용하는 게임이 해킹으로 인해 망가지게 됩니다. 예를 들어 위의 예시에서 User A가 몬스터를 잡았을 때 경험치 획득량이 많아지도록 클라이언트를 조작한다면, 서버는 조작된 과정에 의한 결과만 받아들이게 되고, 결국 UserA의 플레이어가 순간적으로 빠르게 레벨업되었다는 정보를 모든 클라이언트에게 전달하게 될 것입니다. 물론 이를 위해 서버에서 검증 로직을 따로 둘 수도 있겠지만, 그렇게 되면 결국 클라이언트와 서버 둘 다 같은 로직이 두 개 생기는 꼴이라 사실 효율적인 구조라 할 순 없습니다. 따라서 MapleStory World에서는 게임의 전반적인 로직과 시스템을 서버에서 구현하고, 클라이언트는 유저의 입력을 받아 서버로 전달하거나, 게임 진행 상황을 내려받아 유저에게 전달하는 역할로 구조를 가져가는 것을 추천합니다. 즉 서버는 게임의 전반적인 흐름을 가져가고, 클라이언트는 유저와 게임의 사이 중계자의 역할을 하는 것입니다. 이와 같은 구조로 레벨업 처리 과정을 변경한다면 다음과 같습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1653888266299a18ff1e10049438f981b133b2d61922a.png)

# 서버, 클라이언트에서의 프로퍼티와 함수

서버와 클라이언트가 어떻게 상호작용을 하는지를 알아보았으니, 이제 메이커에서 작성한 프로그램이 서버와 클라이언트에서 어떻게 돌아가는지 알아보도록 합니다. 제작자가 스크립트에서 선언한 프로퍼티와 함수는 별도의 설정을 하지 않는 한 기본적으로 서버와 클라이언트 두 개의 공간에 각각 독립적으로 생성됩니다. 이름은 같지만 서로 다른 공간에 존재하기 때문에 별도의 프로퍼티 또는 함수라 보는 것이 좋습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1635334094351321c58a15d5a48f2bdb9e10d7fd67482.png)  기본적으로 함수의 호출과 프로퍼티의 값 참조 및 할당은 같은 공간 내에서만 이루어집니다. 예를 들어 A라는 프로퍼티에 값을 B라는 함수에서 할당한다 했을 때, 서버에 있는 함수 B가 호출되면 서버에 있는 프로퍼티 A에 값이 할당되지만, 클라이언트에 있는 프로퍼티 A에는 값이 할당되지 않습니다. 반대의 경우도 마찬가지로 클라이언트의 함수 B를 호출하면 클라이언트에 있는 프로퍼티 A에는 값이 할당되지만, 서버에 있는 프로퍼티 A는 값이 할당되지 않습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635334104154192561b773054ed6833d2a775f827572.png)  함수 간 호출도 이와 비슷합니다. 예를 들어 A와 B라는 함수를 선언했다 가정했을 때, 클라이언트의 함수 A가 함수 B를 호출하면 클라이언트에 있는 함수 B만 호출되고 서버의 함수 B는 호출되지 않습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1635334116615c15afa2e69974975aaf8fea49703fb86.png)  종합해보면 서버에서 선언된 것은 서버에서만, 그리고 클라이언트에서 선언한 것은 클라이언트에서만 돌아간다는 말입니다. 그렇다면 멀티 플레이를 위한 서버-클라이언트 간 상호작용은 어떻게 할 수 있을까요?

# 동기화와 실행제어

서버와 클라이언트 간 통신 방법에는 여러 가지가 있습니다. MapleStory World에서는 데이터 또는 상태를 전달하는 방식인 동기화와 특정 상황에 발생해야 할 행위, 행동들을 전달하는 방식인 실행제어를 제공하고 있습니다.

#### 동기화

동기화는 서비스나 프로그램에 따라 의미가 조금씩 다르긴 하지만, MapleStory World에서는 서버와 클라이언트 별도 공간에 있는 프로퍼티 값의 동기화를 의미합니다. 예를 들어, 어느 한쪽의 프로퍼티 값을 변경하면, 다른 한쪽은 동일한 값으로 자동으로 변경되는 것이죠. 따라서 서버와 클라이언트의 프로퍼티가 동일한 값이 될 수 있도록 별도의 처리를 하지 않아도, 자동으로 동기화가 이루어지기 때문에 제작자는 좀 더 편하게 서버와 클라이언트 간 통신을 구현할 수 있습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/163533412709076a151563ef047af9002af8741822786.png)  그렇다고 모든 프로퍼티가 동기화되는 것은 아닙니다. 컴포넌트의 기능과 특성에 따라 프로퍼티 동기화가 될 수도, 혹은 안 될 수도 있습니다. 예를 들어, 주로 클라이언트에서만 작동하는 컴포넌트가 있다고 가정했을 때, 해당 컴포넌트는 서버로 데이터를 보낼 일이 없으니 프로퍼티는 동기화는 이루어지지 않습니다. 스크립트 컴포넌트에서는 프로퍼티 동기화 설정이 가능하도록 기능을 제공하고 있습니다.이는 제작자가 본인이 만든 컴포넌트의 기능과 특성, 또는 제작자의 스타일에 따라 동기화 가능 여부를 설정케 함으로써 불필요한 동작을 줄이고 효율적인 구조로 설계해 나갈 수 있게 합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/163533413853006f6f98fe3ee4579a26b2c848cf7a551.png) <프로퍼티 설정에 따라 동기화가 될 수도, 안될 수도 있습니다.>  일반적으로 동기화는 서버에서 클라이언트 단방향으로 진행됩니다. 프로퍼티 A가 있을 때, 서버에서 특정 조건에 의해 프로퍼티 A에 어떤 값이 할당되면, 클라이언트에 있는 프로퍼티 A는 서버에서 할당된 동일한 값으로 맞춰지게 됩니다. 하지만 반대로 클라이언트의 프로퍼티 A에 값을 할당하면 서버의 프로퍼티 A에는 어떤 변화도 발생하지 않습니다. 이유는 서버와 클라이언트는 일 대 일 관계가 아닌 일 대 다 관계이기 때문입니다. 클라이언트 A와 클라이언트 B가 있을 때, 클라이언트의 프로퍼티 C를 클라이언트 A에서는 1로, 클라이언트 B에서는 2로 할당했다고 가정한다면 서버는 프로퍼티 C의 값을 어떤 클라이언트의 값과 맞춰야 할지 판단이 어려워지게 됩니다.

| 서버에서 클라이언트로 동기화 | 클라이언트에서 서버로 동기화 |
| --- | --- |
| ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16372287876352eedf403ff9a494c9e6bb799f8c5172c.png) | ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1637228806316f799316c1c2540b6bbe5b0e680317a3a.png) |

때에 따라 클라이언트에서 할당한 값을 서버로 동기화하는 경우도 있지만, 특수한 몇몇 컴포넌트를 제외하고는 서버와 클라이언트 간의 관계적 특성으로 인해 주로 서버에서 할당한 값을 클라이언트로 동기화가 이루어지게 됩니다.

#### 실행제어

서버와 클라이언트 간 통신에는 데이터의 전달, 즉 동기화 외에도 공간에 정의된 "액션"을 요청하고 수행하는 과정도 필요합니다. 위의 레벨업 처리 과정을 예시로 들면, 클라이언트가 유저의 입력을 받으면, 서버에게 "몬스터 공격"이라는 "액션"을 요청하게 되고, 서버는 클라이언트의 요청에 따라 "몬스터 공격"이라는 "액션"을 수행하게 되는데요, 이렇듯 각 공간에 정의된 액션을 서로 요청하여 수행케 하는 것을 실행제어라고 합니다. 실행제어는 제작자의 의도에 따라 설정할 수 있습니다. 위에 말한 "액션"은 결국 스크립트에서는 "함수"라 할 수 있는데, 스크립트에서 각 함수의 설정을 어떻게 하느냐에 따라 클라이언트에서 서버로 수행을 요청할 수도 있고, 반대로 서버에서 클라이언트로 수행을 요청할 수도 있습니다. 아래 상황을 예로 들면, 서버에 선언된 함수 B의 실행 공간을 클라이언트로 설정했다면, 함수 B는 서버 내 다른 함수에서 호출이 가능하지만, 클라이언트에서 실행되기 때문에 서버에서 호출할 수 있는 클라이언트 함수처럼 사용이 가능합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1635334183953589a1ccd5a874edeaad70b12edca184c.png) <MethodB의 실행 공간을 클라이언트, MethodC의 실행 공간을 서버로 설정했을 때의 요청과 수행>

Update 2025-11-17 PM 08:14


# 실행 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

클라이언트와 서버의 흐름을 쉽게 제어할 수 있게 하는 실행 제어의 개념과 활용 방법을 알아봅니다.

##### 들어가기에 앞서

본 과정을 이해하기 위해선 다음 가이드 선행 학습이 필요합니다. [서버와 클라이언트](https://mod-developers.nexon.com/docs?postId=207)

# 서버 - 클라이언트 간 데이터 통신

**클라이언트 - 서버** 간의 흐름을 제어하려면 데이터를 전송해야 합니다. 예를 들어, 서버에서 클라이언트로 "3초간 춤을 춰!"라고 요청하려면 어떤 것이 필요할까요?  두 사람이 대화하는 상황으로 바꿔 생각해 봅시다.

- 한 사람이 할 말을 생각하고 (메시지 생성)
- 입이나 손으로 생각한 말을 합니다.(메시지 송신)
- 그러면 다른 한 사람이 귀나 눈으로 그 말을 이해하고 (메시지 수신)
- 말의 의미를 이해하고 다음 말을 합니다. (행동, 결과)  **"메시지 생성 → 메시지 송신 → 메시지 수신 → 행동/결과"**  전통적인 방식에 따르면 서버는 요청서(메시지)를 적어서 클라이언트에게 전송합니다. 클라이언트가 이를 수신하면 해당 메시지를 수신하고 읽고 행동을 수행하거나 판단합니다. 위 두 사람의 대화 상황처럼 **메시지 생성 → 메시지 송신 → 메시지 수신 → 메시지에 따른 행동**으로 진행됩니다.

| 메시지 전송 단계 | 참고 이미지 |
| --- | --- |
| 메시지 생성 | ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/163722331482011b84a68a4e346029197233b69705f53.png) |
| 메시지 송신 | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16372234583643c86a77df937414c89557893c88dfe7c.png) |
| 메시지 수신 | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223520910a4bda2879151452db4f8831d0f21c783.png) |
| 메시지에 따른 행동 | ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223532474323d466a087a4bb6b9527d3de064b96a.png) |

이 방법으로 많은 메시지를 처리하는 것은 효율적이지 않습니다. 메시지 양이 많아질수록 네트워크 비용이 증가하기 때문입니다.  메시지 전체를 전송하는 대신 동일한 의미를 부호로 전송하면 효율이 높아집니다. 부호를 사용하기 때문에 송수신 전후에 부호화, 복호화 과정이 필요하지만, 메시지 전체를 보내는 것보다 적은 용량으로 통신할 수 있습니다. 예를 들어 **Code-45**라는 메시지는 **X 초간 춤을 춘다는 명령**이라고 서로 약속하고 있으면 **Code-45**와 **3초**라는 아주 적은 용량의 정보만으로도 통신할 수 있습니다.

| 메시지 전송 단계 | 참고 이미지 |
| --- | --- |
| 메시지 생성 | ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/163722331482011b84a68a4e346029197233b69705f53.png) |
| 메시지 부호화 | ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223614276ad339b770dcc450abfd2f27fed8919dd.png) |
| 메시지 송신 | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223644960d8351081fc44495b9425a32213d9b15d.png) |
| 메시지 수신 | ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223663644d87a77c2927c414a91198c3ebf796f08.png) |
| 메시지 복호화 | ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223677232e564c75135114f74921e9fbd0cdcb2af.png) |
| 메시지에 따른 행동 | ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1637223532474323d466a087a4bb6b9527d3de064b96a.png) |

정보의 양은 줄었지만, 단계가 늘어나면서 조금은 복잡해졌습니다. 메이플스토리 월드에서는 위 과정을 간편하게 제어할 수 있는 실행 제어를 제공합니다. **실행 제어**는 서버 - 클라이언트 간 통신을 도와주며 복잡한 통신 흐름을 쉽게 제어할 수 있게 해줍니다. 능숙하게 사용하려면 시간이 필요하지만, 클라이언트 - 서버 통신을 활용하려면 **실행 제어**를 반드시 이해해야 합니다.

# 실행 제어

실행 제어의 동작 방식을 이해하기 위해 함수 호출 상황을 살펴봅시다. 특정한 소리 효과를 내는 `PlaySoundEffect` 함수가 있다고 가정합니다. 소리 효과는 개인 PC에서 나야 하므로 클라이언트에서만 사용하는 함수일 것입니다. 만약, 서버에서 특정 타이밍에 소리 효과를 내야 한다면, 서버는 효과음과 연관된 메시지를 생성해 송신하고, 클라이언트는 수신부를 구현해 `PlaySoundEffect` 함수를 호출합니다.

| 메시지 전송 흐름 | 참고 이미지 |
| --- | --- |
| 메시지 생성 | ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1637225064752e7bc9e15f693429abef9dbc62bf3b593.png) |
| 메시지 부호화 | ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1637225077456c4d173de75e5465999bd4414dffee512.png) |
| 메시지 송신 | ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1637225094693f9b508dae1af4fa6b39c3412894d527d.png) |
| 메시지 수신 | ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/163722510582956aa6c66e3f14d40b7d1a87b3c97c7fd.png) |
| 메시지 복호화 | ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16372251213042e8a4e6a2e8f4944840bfa40e7d7f4d7.png) |
| 메시지에 함수 호출 | ![50](https://mod-file.dn.nexoncdn.co.kr/bbs/1637294677515eca9f93011ce412bb9aac3b0d8764bc5.png) |
| 실행 | ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/163722545859347bd24cd99514181ae555fba18421eae.png) |

이 과정은 최초 방식보다는 낫지만, 반복해야 한다면 불필요한 과정도 반복되므로 효율이 떨어집니다. 단순하게 서버에서 클라이언트의 **PlaySoundEffect**를 직접 부르는 상황을 생각해 봅시다. ![51](https://mod-file.dn.nexoncdn.co.kr/bbs/1637294746599f3113cdff1cd432f9015952acfc95055.png)

만일 위와 같이 서버에서 직접 클라이언트의 함수를 직접 호출한다 해도 불편함은 남아있습니다. 메이플스토리 월드의 컴포넌트는 서버, 클라이언트 공용으로 사용합니다. 그러므로 컴포넌트에 속한 함수를 서버 또는 클라이언트에서 호출할 수 있습니다. 호출한 함수가 어떤 공간(서버 혹은 클라이언트)에서 호출되었는지, 어떤 공간에서 실행되어야 하는지 알고 있어야 합니다.  예를 들어 "만일 현재 공간이 클라이언트라면 **PlaySoundEffect**를 실행하고, 서버라면 클라이언트의 **PlaySoundEffect**를 실행하라."라는 코드를 작성하려면 분기문을 이용해야 합니다.

```
void CallPlaySoundEffect()
{
    if isClient == true then
    --PlaySoundEffect를 실행하라!
     
    elseif isServer == true then
    --클라이언트의 PlaySoundEffect를 실행하라!
    end
}
```

다른 공간에 있는 함수를 호출할 수는 있지만, 함수를 호출할 때마다 매번 분기를 태워야 하므로 이 또한 효율적이지 않습니다. 메이플스토리 월드에서는 함수 별로 호출 및 실행 공간을 설정할 수 있습니다. 예를 들어, 클라이언트에서 실행되는 `PlaySoundEffect` 함수를 서버에서 호출하도록 설정하면, `PlaySoundEffect`를 호출하는 함수에서 별도의 분기문을 태우지 않아도 알아서 클라이언트에서 실행됩니다.

```
[ServerOnly]
void CallPlaySoundEffect()
{
    self:PlaySoundEffect()  -- 어떤 공간에서든 같은 공간의 함수를 호출하듯이 사용할 수 있다.
}

[client] --각 함수별로 어떤 공간에서 호출하고 실행할지를 설정할 수 있다.
void PlaySoundEffect()
{
    --코드 작성 공간입니다.
}
```

# 실행 제어의 종류

함수별로 6가지의 실행 제어를 설정할 수 있고, 옵션에서 설정을 변경할 수 있습니다. 기본적으로 실행 제어를 사용하지 않으면 공용 함수가 되며, 호출하는 공간을 기준으로 동작합니다.

| 실행 제어 설정 | 서버에서 실행 시 | 클라이언트에서 실행 시 |
| --- | --- | --- |
| 사용하지 않음 | 서버에서 실행됨 | 클라이언트에서 실행됨 |
| client | 클라이언트로 전송하여 클라이언트에서 실행됨 | 클라이언트에서 실행됨 |
| client only | 무시됨 | 클라이언트에서 실행됨 |
| server | 서버에서 실행됨 | 서버로 전송하여 서버에서 실행됨 |
| sever only | 서버에서 실행됨 | 무시됨 |
| multicast | 서버에서 실행된 이후 클라이언트로 전송하여 클라이언트에서 실행됨 | 무시됨 |

![202](https://mod-file.dn.nexoncdn.co.kr/bbs/1637302950063ab2e4b57ae124ea59a38a38028a1c148.png)

# 실행 제어 설정 방법

함수를 추가하고 ![script_more](https://mod-file.dn.nexoncdn.co.kr/bbs/16345206995612a35d54577d8466da03a9fe452a5218c.png) **[메뉴]** 버튼을 누른 뒤, **Excution Space Setting**을 클릭해 실행 공간을 설정합니다. 실행 제어를 사용하지 않으려면 **사용하지 않음**을 선택합니다.

![20](https://mod-file.dn.nexoncdn.co.kr/bbs/168178285797811b83332e2ca4e9ab49ca4268be34b27.png)

# 실행 제어 표시

스크립트 함수의 실행 제어 설정을 아이콘으로 표시합니다. 아이콘은 다음과 같습니다.

| Icon | 실행 제어 설정 |
| --- | --- |
| 없음 | 사용하지 않음 |
| ![script_sent_to_client](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520790600fcf43ce1e20540d99206368bae5bfb29.png) | Client |
| ![clietn_only_line](https://mod-file.dn.nexoncdn.co.kr/bbs/16345204384345f2159bf5f7a4aadae190a6e66646a77.png) | ClientOnly |
| ![script_sent_to_server](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520851421b73268f466814035ba41893c8b45fd9c.png) | Server |
| ![script_server_only](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520890852542e95e200a647819d47b85d5c4d157e.png) | ServerOnly |
| ![script_send_to_all](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520769851d04d006c9114421f8e9ce34d5c47b721.png) | Multicast |

실행 제어가 설정된 함수에는 실행 제어 아이콘이 표시됩니다. 실행될 수 없는 함수는 ![CantCallFunction](https://mod-file.dn.nexoncdn.co.kr/bbs/1635387179103da42aef656b24301ba63221cd02c4bbf.png) 아이콘이 표시됩니다. ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/16817831861368eaf4d7f03b545759cb8f9a98c291601.png)

# 실행 제어 함수의 매개 변수

서로 다른 공간의 함수를 실행할 때 매개 변수를 통해 다른 공간으로 데이터를 전송할 수 있습니다. 예를 들어 서버에서 클라이언트에 표시되는 시스템 메시지를 출력하려면 시스템 메시지를 출력하는 클라이언트 함수를 서버에서 호출하고 함수의 매개 변수로 메시지를 전달합니다.

```
Method: 
[server only]
void OnUpdate(number delta)
{
    local users = _UserService.UserEntities
    local message = "Out of bounds"
    -- 모든 플레이어를 체크하며 플레이어가 특정 좌표 밖으로 나갔을 때 메시지 출력
    for id, user in pairs(users) do
    	local posX = user.TransformComponent.Position.x
    	if posX > 100 then 
    	   -- 메시지를 클라이언트 함수의 매개 변수로 전달
    		self:PrintSystemMessage(message)
    	end
    end
}

[client]
void PrintSystemMessage(string message)
{
    log(message)
}
```

이처럼 실행 제어 함수의 매개 변수를 통해 다른 공간으로 데이터를 전송할 수 있습니다. 하지만 모든 데이터를 전송할 수 있는 것은 아닙니다. 실행 제어 함수에서 사용할 수 있는 매개 변수 타입을 살펴봅시다.

| 타입 | 사용 가능 여부 |
| --- | --- |
| any | 사용 불가 |
| string | 사용 가능 |
| integer | 사용 가능 |
| number | 사용 가능 |
| boolean | 사용 가능 |
| table | 사용 가능 |
| SyncTable< v > | 제한적 사용 가능 |
| SyncTable< k, v > | 제한적 사용 가능 |
| Vector2 | 사용 가능 |
| Vector3 | 사용 가능 |
| Vector4 | 사용 가능 |
| Color | 사용 가능 |
| Entity | 사용 가능 |
| Component | 사용 가능 |
| EntityRef | 사용 가능 |
| ComponentRef | 사용 가능 |

**any** 타입을 제외한 모든 타입을 매개 변수로 사용할 수 있습니다. 하지만 SyncTable< v > 나 SyncTable< k , v >의 k 또는 v 타입은 목록에 나오는 것만 사용할 수 있습니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/1685938861944b5fa20659b7d4b3c809a765906fa012c.png)

## 실행 공간이 Client인 함수의 매개 변수 특수성

Client A에서 서버 함수를 실행하고 서버에서는 그에 대한 응답을 보내는 상황을 생각해봅시다. 보통 이런 경우에 서버는 모든 클라이언트에 응답을 보냅니다. ![client01](https://mod-file.dn.nexoncdn.co.kr/bbs/168075980289219c2a09110834a149783309cd2192038.png)

하지만 어떤 경우에는 처음 요청을 보낸 Client A에게만 응답하면 되는 상황도 있습니다. ![client02](https://mod-file.dn.nexoncdn.co.kr/bbs/168075982031597f4c778957346d1969d09fdd4ff3eb0.png)

메이플스토리 월드에서는 특정 클라이언트에만 응답을 보내는 기능을 제공합니다. 이 기능을 사용하는 방법은 "실행 공간이 Client인 함수의 마지막 매개 변수에 **보내려는 UserId**를 적는 것"입니다. 이 기능의 사용 예시를 보다 자세히 살펴보려면 [Effective MSW 1](/docs/?postId=559) 가이드에서 "특정 클라이언트에만 응답 보내기" 내용을 참고해 봅시다.

Update 2025-11-20 PM 02:03


# 로그

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

로그에 대해 알아보고 월드 제작 과정에서 로그를 효과적으로 활용하는 방법을 살펴봅시다.

# 로그 소개

로그(Log)란 월드 제작 중 발생하는 여러 가지 정보나 문제 상황에 대한 기록을 말합니다. 로그를 통해 현재 제작 중인 월드가 의도대로 잘 동작하고 있는지 확인할 수 있습니다. 만약 의도대로 동작하지 않는다면 문제의 원인을 파악하고 해결하는 데 로그를 활용할 수 있습니다. 로그 종류는 로그를 남기는 주체를 기준으로 구분합니다. 시스템 로그와 크리에이터 로그로 나누어 살펴봅시다.

## 시스템 로그

제작 중인 월드에서 발생하는 정보 메시지나 오류를 시스템에서 파악해 알려주는 로그를 말합니다. 시스템 로그의 오류는 그 중요도에 따라 아래와 같이 분류합니다.

| 중요도 | 아이콘 | 설명 |
| --- | :---: | --- |
| 낮음 | ![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png) | 월드의 동작에 문제가 되지 않는 수준의 각종 정보(Info) |
| 중간 | ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png) | 메이커에서 권하지 않는 방식이거나 문제가 발생할 확률이 높은 경우 발생하는 경고(Warning) |
| 높음 | ![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png) | 해결하지 않으면 확정적으로 문제가 발생하는 오류(Error) |

## 크리에이터 로그

크리에이터가 월드 제작 과정에서 log 함수를 사용해 남기는 로그를 말합니다. 크리에이터의 의도대로 월드가 잘 작동하고 있는지 확인할 때 사용합니다. log() 함수는 매개 변수로 넘겨진 값을 콘솔 창에 출력합니다. 변수나 프로퍼티 값, 또는 함수의 리턴 값들을 콘솔 창에 출력하여 확인할 수 있습니다. 예를 들어 스크립트 컴포넌트가 실행될 때 "Hello Maple World"라는 로그를 남겨보겠습니다.

```
[server only]
void OnBeginPlay() 
{
    log("Hello Maple World")
}
```

위와 같이 작성한 후 ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) 시작을 눌러 테스트하면 콘솔 창에서 로그를 확인할 수 있습니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1653635780944b306b67d58ac48f68585d42061a8ae00.png)

### 크리에이터 로그 함수 종류

크리에이터는 세 가지 종류의 로그 함수를 자신의 상황에 맞게 정의해 사용할 수 있습니다.

| 로그 함수 | 설명 |
| --- | :---: |
| log() | 로그의 아이콘이 정보(Info)![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png)로 표시됩니다. |
| log_warning() | 로그의 아이콘이 경고(Warning) ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png) 로 표시됩니다. |
| log_error() | 로그의 아이콘이 오류(Error)![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png)로 표시됩니다. |

```
[server only]
void OnBeginPlay()
{
    log("test_info")
    log_warning("test_warning")
    log_error("test_error")
}
```

위와 같이 작성한 후 ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) 시작을 눌러 테스트하면 콘솔 창에서 로그를 확인할 수 있습니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16546769028283859434d3a424558adaf5c5164899732.png)

> **Tip.** 월드를 제작하다 보면 의도대로 잘 진행되는지 확인하기 위해 로그를 수시로 남기게 됩니다. 하지만 플레이 테스트 도중 너무 많은 로그가 쌓이면 오히려 확인해야 할 로그를 놓칠 수도 있습니다. 불필요한 로그는 정리해가며 월드를 제작하기를 권장합니다.

# 로그의 확인

로그는 메이커의 콘솔 창에서 확인할 수 있습니다. **메이커의 상단 메뉴 - Panels - Console**을 클릭하면 콘솔 창이 열립니다. 콘솔은 아래와 같이 콘솔과 빌드 콘솔로 나뉩니다.

## 콘솔

콘솔에는 플레이 테스트 도중에 발생한 정보, 경고, 오류 로그가 출력됩니다. ![console](https://mod-file.dn.nexoncdn.co.kr/bbs/1654137093143eb77525627fd4de5b7fc28d2c98e7d97.png)

| 번호 | 설명 |
| :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 콘솔 창에 남아있는 로그를 삭제합니다. <br>Clear 오른쪽에 확장 버튼을 눌러 Clear on Play를 활성화하고, ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) 시작 버튼을 누르면 콘솔 창에 남아있던 로그를 자동으로 삭제하고 시작합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 버튼을 누르면 중복 로그를 하나로 합쳐줍니다. <br> ![9](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_09.jpg) 영역에 합쳐진 총 개수가 나옵니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 실행 공간(Client / Server) 별로 로그를 모아볼 수 있습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 로그를 검색합니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | ![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png)정보 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) 영역에 ![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png) 정보가 보이고 해제하면 보이지 않습니다. |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png)경고 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) 영역에 ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png) 경고가 보이고 해제하면 보이지 않습니다. |
| ![7](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | ![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png)오류 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) 영역에 ![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png) 오류가 보이고 해제하면 보이지 않습니다. |
| ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) | 로그의 심각도와 기록된 시간, 실행 공간과 세부 내용을 확인할 수 있습니다. |
| ![9](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_09.jpg) | 중복 로그가 몇 개 합쳐져 있는지 개수를 볼 수 있습니다. |
| ![10](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_10.jpg) | ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg)에서 특정 로그를 선택하면 해당 로그에 대한 자세한 정보를 볼 수 있습니다. <br>스크립트 에러일 경우, 링크를 누르면 스크립트의 해당 라인으로 이동합니다. 엔티티일 경우, ![Hierarchy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png) Hierarchy에서 해당 엔티티가 선택됩니다. |

## 빌드 콘솔

제작 중인 월드의 스크립트나 로직, 데이터 등에서 발생한 정보, 경고, 오류 로그가 출력됩니다. ![buildconsole](https://mod-file.dn.nexoncdn.co.kr/bbs/1676446566144a6c7151a74c84728887bfcbcddf511a4.png)

| 번호 | 설명 |
| :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | Current scrip Only 버튼을 활성화하면 현재 스크립트에서 발생한 로그만 모아볼 수 있습니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 로그를 검색합니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | ![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png)정보 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) 영역에 ![info](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_info_s.png) 정보가 보이고 해제하면 보이지 않습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png)경고 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) 영역에 ![caution](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_caution_s.png) 경고가 보이고 해제하면 보이지 않습니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | ![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png)오류 로그의 총 개수를 확인할 수 있습니다. <br> 이 버튼을 활성화하면 있으면 ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) 영역에 ![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_console_warning_s.png) 오류가 보이고 해제하면 보이지 않습니다. |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 로그의 종류와 내용을 확인할 수 있습니다. |
| ![7](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg)에서 특정 로그를 선택하면 해당 로그에 대한 자세한 정보를 볼 수 있습니다. <br>스크립트 에러일 경우, 링크를 누르면 스크립트의 해당 라인으로 이동합니다. 엔티티일 경우, ![Hierarchy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png) Hierarchy에서 해당 엔티티가 선택됩니다. |

# 출시 월드 콘솔

크리에이터는 출시된 월드에서 콘솔을 열고 로그를 확인할 수 있습니다. 월드의 스크립트나 로직, 데이터 등에서 발생한 정보, 경고, 오류 로그가 출력됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1735021134960de6269099c084e1ebd3ebe4c18796a69.png)

| 번호 | 설명 |
| :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 콘솔 창에 남아있는 로그를 삭제합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 콘솔을 접고 펼 수 있습니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 콘솔을 최소화된 크기로 변경합니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 로그를 txt 파일로 저장합니다.<br> 저장 위치: C:\Users\사용자명\AppData\LocalLow\nexon\MapleStory Worlds\ConsoleLogs\월드ID |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 콘솔 창의 투명도를 조절할 수 있습니다. |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | Clear on play를 활성화하면 남아있던 로그를 삭제하고 로그 출력을 시작합니다. |
| ![7](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | 버튼을 누르면 중복 로그를 하나로 합쳐줍니다. |
| ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) | 정보, 경고, 오류 로그의 총 개수를 확인할 수 있습니다. |
| ![9](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_09.jpg) | 로그를 검색합니다. |

# 로그의 활용

스크립트를 작성하고 플레이 테스트를 하다 보면 크리에이터의 생각대로 단번에 잘 작동하는 경우는 많지 않습니다. 크리에이터는 스크립트에 로그를 적절히 활용해 월드의 문제점을 보다 빠르게 파악하고 수정할 수 있습니다. 로그를 활용하여 시행착오를 줄이고 보다 효율적으로 스크립트를 작성해봅시다.

> **더 알아보기** 로그와 함께 디버그 기능을 적절히 활용하면 스크립트 오류를 보다 빠르고 정확하게 해결할 수 있습니다. [스크립트 디버그](https://mod-developers.nexon.com/docs/?postId=202)도 함께 참고해봅시다.

Update 2025-11-20 PM 02:03


# 메이플스토리 월드 루아 기초

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 **루아**라는 언어를 사용하여 스크립트를 작성합니다. 이번 시간에는 **루아**의 기본 사용법과 메이플스토리 월드에서 사용하는 예제를 함께 살펴보겠습니다.

# 변수

변수란 데이터를 저장하는 메모리 공간, 값을 담아두는 그릇입니다.

## 변수의 범위

루아에서 사용하는 변수는 아래의 두 가지로 나뉩니다.

| 변수 | 설명 |
| --- | --- |
| 전역(global) 변수 | 어느 곳이든 접근 가능한 변수로 아무 선언 없이 사용하면 전역 변수입니다. <br>**단, 메이플스토리 월드에서는 전역 변수 사용을 권장하지 않습니다.** <br>전역 변수처럼 사용하고 싶은 값이 있다면 스크립트에서 [프로퍼티](/docs/?postId=205)를 사용해 봅시다. |
| 지역(local) 변수 | 같은 함수 또는 같은 구문 내에서만 접근 가능한 변수입니다.<br>그 변수가 정의된 범위(scope)에서만 유효하며, 해당 범위의 실행이 끝나면 파괴됩니다. |

![scope](https://mod-file.dn.nexoncdn.co.kr/bbs/1671159060417acd3c899fc994089b6179d65757f711a.png)위의 그림에 나와있듯이, **Property a**는 스크립트 전체에서 참조할 수 있습니다. **지역 변수 b**는 **B 영역**에서 유효하며, **지역 변수 c**는 **C 영역**에서만 유효하고, 해당 범위의 실행이 끝나면 파괴됩니다.  예제를 통해 변수의 범위를 이해해 봅시다.

1. 먼저 메이커에서 **LuaTest**라는 새 스크립트 컴포넌트를 생성하고 **Hierarchy - common**에 **LuaTest** 컴포넌트를 추가합니다.
2. 아래와 같이 프로퍼티를 추가합니다.```
Property :
[Sync]
integer testP = 0
```
3. `OnBeginPlay()`, `testFunction()` 함수를 추가한 뒤 아래와 같이 입력해 봅시다. 원래 루아 문법에서는 출력할 때 **print**라는 명령을 사용하지만 메이플스토리 월드에서는 이것을 가공한 `log()` 함수를 사용하므로 앞으로의 예제에서도 `log()` 함수를 활용하겠습니다.  아래와 같이 입력하고 ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 눌러 콘솔 창에 **log**를 출력해 봅시다. 주석의 값이 각각 출력되는 것을 확인할 수 있습니다.```
Property:
[Sync]
integer testP = 0

Method:
[server only]
void OnBeginPlay()
{
    log(self.testP) -- 0
    self.testP = self.testP + 100
    log(self.testP) -- 100

    -- OnBeginPlay() 함수 내에서 유효한 지역 변수 a를 정의합니다.
    local a = "A"
    log(a) -- A

    if true then
    	-- 지역 변수 a의 값을 변경합니다.
    	a = 1

    	-- 조건문 내에서만 유효한 지역 변수 b를 정의합니다.
    	local b = "B"
    	log(b) -- B
    end

    log(a) -- 1

    --[[조건문 범위에서만 유효했던 지역 변수 b는 파괴되었으므로
    함수 범위에서 b 값은 nil입니다.]]
    log(b) -- nil

    -- testFunction()을 호출합니다.
    self:testFunction()
}

void testFunction()
{
    -- Property에서 정의한 testP는 스크립트 전체에서 접근할 수 있습니다.
    log(self.testP) -- 100

    --[[OnBeginPlay()에서 유효했던 지역 변수 a는 파괴되었으므로
    여기에서 a 값은 nil입니다.]]
    log(a) -- nil
}
```

## 변수 유형

루아의 변수는 내부적으로 유형이 존재하기는 하지만 변수를 생성할 때 그 유형을 명시하지는 않습니다. 변수에 들어가는 값에 따라 그 유형이 정해집니다.

| 변수 유형 | 설명 |
| --- | --- |
| nil | 값이 없음을 뜻합니다. <br>논리 연산에서 nil은 거짓(false)이고 전역 변수 및 테이블 키에서의 nil은 버려집니다. |
| boolean | true와 false 값만 갖습니다. <br>0, 1의 수치로 변환되지 않습니다. |
| number | 64비트 실수입니다. |
| integer | 64비트 정수입니다. |
| string | 문자열입니다. <br> 큰따옴표(") 또는 작은따옴표(')로 감싸서 사용합니다. |
| table | 복합 자료형입니다. <br>배열(Array) 형태와 사전(Dictionary) 형태로 모두 사용할 수 있습니다. |

type() 함수로 변수의 유형을 확인할 수 있습니다. 예를 들어 아래와 같이 입력하고 **log**를 출력하면 주석의 값이 각각 출력됩니다.

```
local a = 1
log(type(a)) -- number
	
a = 1234.5678
log(type(a)) -- number

a = "hello"
log(type(a)) -- string

a = (0 > 10)
log(type(a)) -- boolean

a= nil
log(type(a)) -- nil
    
a = {}
log(type(a)) -- table

a = {"Lua", "Test"}
log(type(a)) -- table
```

메이플스토리 월드에서는 위의 유형 외에도 별도의 데이터 타입을 제공합니다. [프로퍼티](/docs/?postId=205) 가이드의 **프로퍼티 타입** 항목에서 자세한 내용을 확인할 수 있습니다.

# 테이블

루아에서는 배열(Array)과 사전(Dictionary) 형태 모두 테이블입니다. 여러 개의 데이터를 다룰 때 보통 테이블을 활용하며 **{ }** 형태로 선언합니다.

```
local table = {}
```

## 배열(Array)

배열은 루아에서 상당히 많이 활용되며, 데이터를 모아서 저장하는데 유용합니다.

### 배열 만들기

예를 들어 아래의 형태로 만듭니다.

```
local testArray = {"A string", 1.234, self.Enable}
```

### 값 읽기

배열은 인덱스[no]로 접근할 수 있습니다. 대부분의 프로그래밍 언어에서는 첫 번째 인덱스로 **0**을 사용하는데 루아에서는 **1**을 사용합니다.

```
local testArray = {"A string", 1.234, self.Enable}
log(testArray[1]) -- A string
log(testArray[2]) -- 1.234
log(testArray[3]) -- true
```

### 값 작성하기

배열에 값을 작성하거나 변경하려면 인덱스[no]로 접근하여 값을 입력합니다.

```
local testArray = {11, 22, 33}

testArray[2] = "bb"
testArray[4] = "44"

log(testArray[2]) -- bb
log(testArray[3]) -- 33
log(testArray[4]) -- 44
```

### 값 추가하기

배열에 값을 추가하는 두 가지 방법을 소개합니다.

- `table.insert()` 함수를 활용합니다.
- `array[#array+1]` 문법을 활용합니다.

```
local testArray = {"A", 1.234}

table.insert(testArray, "C")
testArray[#testArray+1] = "D"

log(testArray[3]) -- C
log(testArray[4]) -- D
```

배열의 중간에 값을 추가하려면 `table.insert()` 함수의 두 번째 인수에 추가하려는 인덱스 값을 적습니다.

```
local testArray = {"A", "B"}

-- 2번 인덱스에 "and"를 추가
table.insert(testArray, 2, "and")

log(testArray[1]) -- A
log(testArray[2]) -- and
log(testArray[3]) -- B
```

### 값 제거하기

배열에서 값을 제거할 때는 `table.remove()` 함수를 사용합니다.

```
local array = {11, 22, 33, 44, 55}

-- 1번 인덱스를 제거
table.remove(array, 1)
log(array[1]) -- 22
```

> **더 알아보기** 스크립트 에디터에서 테이블에서 활용할 수 있는 다양한 함수들을 확인할 수 있습니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16703984668191d7f941283f84d42b1b97146d6773bce.png)

## 사전(Dictionary)

사전은 **key - value** 형태의 테이블입니다. 자료 구조에서 데이터를 빠르게 검색하기 위해 주로 사용합니다.

### 사전 만들기

사전을 만들 때는 `key = value` 형태로 정의하고 콤마(,)로 구분합니다.

```
local myDictionary = {a = "myNumber", myNumber = 5, myString = "TTT", myBoolean = true}
```

### 값 읽기

사전은 아래와 같은 형태로 읽습니다.

```
local myDictionary = {a = "myNumber", myNumber = 5, myString = "TTT", myBoolean = true}

log(myDictionary.myNumber) -- 5
log(myDictionary.myString) -- TTT
log(myDictionary["myBoolean"]) -- true
```

### 값 작성하기

사전에 값을 정의하거나 다시 쓸 때도 **Key**를 활용합니다.

```
local myDictionary = {name = "Tom", age = 20}

-- 값 변경
myDictionary.name = "Katy"
myDictionary.age = 25

-- Key - Value 추가
myDictionary.favoriteGame = "MapleStory Worlds"

log(myDictionary.name) -- Katy
log(myDictionary.age) -- 25
log(myDictionary.favoriteGame) -- MapleStory Worlds
```

### Key - Value 삭제하기

**Key - Value**를 삭제하려면 **Key**의 값을 **nil**로 설정합니다.

```
local myDictionary = {name = "Tom", age = 30, favoriteGame = "MapleStory Worlds", job = "Programmer"}

-- Key - Value 삭제
myDictionary.job = nil

-- myDictionary 전체를 순회하며 key, value를 출력
for key, value in pairs(myDictionary) do
    log(key, value)
end

-- [[결과 :
age 30
name Tom
favoriteGame MapleStory Worlds
]]
```

> **더 알아보기** 위의 예제에서 활용한 for 문에 대해서는 [메이플스토리 월드 루아 구문](/docs?postId=944) 가이드의 **for 문** 부분을 참고합시다.

## 테이블 참조

테이블을 새 변수에 저장하면 루아에서는 해당 테이블의 복사본을 만들지 않습니다. 대신 변수는 원본 테이블을 참조합니다.

```
local original = {10, 100, 1000}
local reference = original

log(reference[1], reference[2], reference[3]) -- 10, 100, 1000

-- 원본 값 수정
original[1] = "A"
original[2] = "B"

log(reference[1], reference[2], reference[3]) -- A, B, 1000
```

# 연산자

루아에서 사용할 수 있는 연산자입니다.

## 산술 연산자

산술 연산을 할 때 사용하는 연산자입니다.

| 연산자 | 설명 |
| --- | --- |
| `+` | 더하기 |
| `-` | 빼기 |
| `*` | 곱하기 |
| `/` | 나누기 |
| `//` | 나눈 후 몫만 취함 |
| `%` | 나눈 후 나머지만 취함 |
| `^` | 지수 |

예를 들어 아래와 같이 입력하고 **log**를 출력하면 주석의 값이 출력됩니다.

```
log(1 + 1) -- 2
log(1 - 1) -- 0
log(5 * 5) -- 25
log(13 / 5) -- 2.6
log(13 // 5) -- 2
log(13 % 5) -- 3
log(2 ^ 4) -- 16.0
```

## 관계 연산자

관계를 판단할 때 사용하는 연산자입니다. 결과는 boolean입니다.

| 연산자 | 설명 |
| --- | --- |
| `=` | 선언 |
| `==` | 같다 |
| `~=` | 다르다 |
| `>` | 크다 |
| `<` | 작다 |
| `>=` | 크거나 같다 |
| `<=` | 작거나 같다 |

예를 들어 아래와 같이 입력하고 **log**를 출력하면 주석의 값이 출력됩니다.

```
local a = 1
local b = 2
log(a == b) -- false
log(a ~= b) -- true
log(a > b) -- false
log(a < b) -- true
log(a >= b) -- false
log(a <= b) -- true
```

## 논리 연산자

논리 연산자는 참 또는 거짓을 반환합니다. 인수가 거짓이 아니면, 그리고 0이 아니면 참으로 반환합니다.

| 연산자 | 설명 |
| --- | --- |
| `and` | A and B. A와 B가 모두 true이어야 true. |
| `or` | A or B. A 또는 B가 true이어야 true |
| `not` | true 면 false, false 면 true |

## 기타 연산자

그밖에 유용하게 사용할 수 있는 연산자입니다.

| 연산자 | 설명 |
| --- | --- |
| `#` | 배열의 길이 |
| `..` | 문자열 합치기 |

예를 들어 아래와 같이 입력하고 **log**를 출력하면 주석의 값이 출력됩니다.

```
local a = {"HELLO", "MapleStory Worlds"}

log(#a) -- 2
log(a[1].."! "..a[2]) -- HELLO! MapleStory Worlds
```

# 함수

함수는 명령으로 여러 번 실행할 수 있는 코드 블록입니다. 이벤트에 연결하거나 콜백으로 할당할 수 있습니다. 더 자세한 내용은 [함수](/docs/?postId=172) 가이드를 참고합니다.

# 주석과 Annotation

주석은 아래와 같이 표시합니다.

| 주석 | 설명 |
| --- | --- |
| `--` | 한 줄 주석 |
| `--[[]]` | 다중 라인 주석 |
| `---@` | Annotation은 코드에 추가하여 사용하는 일종의 메타데이터입니다. <br>더 자세한 내용은 [Annotation](/docs/?postId=824) 가이드를 참고합니다. |

# 마무리

루아의 기본 사용법과 예제를 살펴보았습니다. 이어서 루아로 스크립트를 작성할 때 자주 사용하는 구문의 사용법을 익혀봅시다. [메이플스토리 월드 루아 구문](/docs?postId=944)에서 관련 내용을 확인할 수 있습니다.

Update 2025-11-17 PM 08:14


# 메이플스토리 월드 루아 구문

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서 루아로 스크립트를 작성할 때 자주 사용하는 구문의 사용법을 알아봅시다. 본 가이드를 보기 전 [메이플스토리 월드 루아 기초](/docs?postId=822)를 학습하는 것을 권장합니다.

# 조건문

보통 프로그램의 로직을 살펴보면 반복문과 조건문의 조합으로 이뤄지는 경우가 많습니다. 그만큼 조건문과 반복문은 프로그래밍의 기본이 되는 구문입니다.  먼저 조건문을 살펴봅시다.

- **if**
  - 기본 조건문입니다. 조건이 **true** 면 **then**과 **end** 사이의 내용을 실행합니다.
- **elseif**
  - **if**에 추가적으로 붙는 조건문입니다. **기본 if 문**이 있어야 사용할 수 있습니다.
  - **if**의 조건이 **false** 면 **elseif**의 조건을 확인합니다.
  - **elseif**는 필수적인 요소는 아닙니다.
- **else**
  - **기본 if 문**이 있어야 사용할 수 있습니다.
  - **if, elseif**의 조건이 **false** 면 **else**의 내용을 실행합니다.
  - **else**는 필수적인 요소는 아닙니다.

예제를 살펴봅시다.

```
[server only]
void OnBeginPlay()
{
    local a = 7
    
    -- if 조건 then 실행 내용 end
    if a > 10 then
        log("big")
    
    -- elseif 조건 then 실행 내용
    elseif a > 5 then
        log("middle")
    
    -- else 실행 내용
    else
        log("little")
    end
}
```

위 조건문을 살펴보면 아래와 같이 조건이 설정되어 있습니다.

- a가 10보다 크면 **big**을 출력
- a가 10보다는 작지만 5보다 크면 **middle**을 출력
- 그 외의 경우라면(즉, a가 5보다 작다면) **little**을 출력

a는 7이므로 위 내용을 실행하면 **middle**이 출력됩니다.

# 반복문

루아에서 자주 사용하는 반복문의 형태를 살펴봅시다.

## while 문

**while 문**은 조건식을 먼저 평가하고 조건이 **false** 또는 **nil** 이면 반복이 끝납니다. 조건이 **true** 면 반복 코드를 실행합니다. 예제를 살펴봅시다.

```
-- while 조건 do 반복할 내용 end

local a = 10

while(a <= 15)
do
    log(a)
    a = a + 2
end

--[[결과:
10
12
14
]]
```

## repeat 문

**repeat - until 반복문**은 조건이 참이 될 때까지 반복하는 구문입니다. 코드 블록이 실행되어야 조건부가 참인지 확인할 수 있으므로 코드 블록은 최소 1번 이상 실행됩니다. 예제를 살펴봅시다.

```
local countdown = 5

repeat
    countdown = countdown - 1
    log(countdown)
until countdown == 0

log("The countdown is over.")

--[[결과:
4
3
2
1
0
The countdown is over.
]]
```

## for 문

**for 문**은 숫자 또는 항목의 개수를 기반으로 반복 탐색하는 구문입니다.

### 수치 for 문 (Numeric For Loops)

**수치 for 문**에서는 초깃값, 최종값, 증감값을 정의합니다. 초깃값에서 최종값이 될 때까지 증감값을 넣어 반복 계산합니다.

예제를 살펴봅시다.

```
-- for 변수 = 초깃값, 최종값, 증감값 do end
-- 증가값이 1인 경우에는 1을 생략해도 됩니다.

for i = 10, 15
do
    log(i)
end

--[[결과:
10
11
12
13
14
15
]]

for i = 20, 10, -2
do
    log(i)
end

--[[결과:
20
18
16
14
12
10
]]
```

### 일반 for 문 (Generic For Loops)

**일반 for 문**은 일련의 숫자가 아닌 테이블의 항목을 반복합니다. 일반 for 문을 사용하면 각 테이블에 대한 코드를 실행할 수 있고, 코드에서 각 항목을 쉽게 사용할 수 있습니다. 일반 for 문은 함수나 반복자가 필요합니다. `ipairs()`는 배열(Array)의 반복을 반환하고 `pairs()`는 사전(Dictionary)의 반복을 반환합니다.

#### 배열(Array)

`ipairs()`는 배열의 인덱스와 값을 반복해서 반환합니다. 예제를 살펴봅시다.

```
local testArray = {"A", "B", "C", "D", "E"}
for index, value in ipairs(testArray) do
    log(index, value)
end

--[[결과:
1 A
2 B
3 C
4 D
5 E
]]
```

#### 사전(Dictionary)

`pairs()`는 사전의 **key - value**를 반복해서 반환합니다. 사전의 반환 순서는 내부적으로 정해지는 것이기에 크리에이터가 작성한 순서가 보장되지 않는다는 점을 기억합시다. 예제를 살펴보겠습니다.

```
local testdictionary = {name = "Tom", age = 20, favoriteGame = "MapleStory Worlds", job = "Programmer"}

for key, value in pairs(testdictionary) do
    print(key, value)
end

--[[결과:
favoriteGame MapleStory Worlds
name Tom
job Programmer
age 20
]]
```

## 반복 종료

반복을 종료할 때는 `break` 명령을 사용합니다. 무한 반복을 종료하는 예제를 살펴봅시다.

```
local secondsElapsed = 0
local timeout = 5

while true do
	log(secondsElapsed.."초")
	wait(1)
	secondsElapsed = secondsElapsed + 1

	if secondsElapsed == timeout then
		break
	end
end

log("5초가 지났습니다. 다음 맵으로 이동합니다.")

--[[결과:
0초
1초
2초
3초
4초
5초가 지났습니다. 다음 맵으로 이동합니다.
]]
```

Update 2025-11-17 PM 08:14


# 메이플스토리 월드 루아 문법 확장

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 루아에서 기본적으로 지원하지 않지만 다른 프로그래밍 언어에서 유용하게 사용되는 문법을 확장하여 지원합니다. 본 과정에서는 메이플스토리 월드에서 지원하는 루아 확장 문법 및 사용 예시를 소개합니다.

# Continue

**continue**는 해당 루프 사이클에 남아 있는 나머지 명령어를 건너뛰고 다음 단계의 루프를 수행하도록 하는 키워드입니다.

```
local oddNumbers = {}
for i = 1, 10 do
    if i % 2 == 0 then
        continue -- 짝수는 이후 작업을 하지 않음
    end
    print("odd number : ", i)
    table.insert(oddNumbers, i)
end
-- Output :
-- odd number : 1
-- odd number : 3
-- odd number : 5
-- odd number : 7
-- odd number : 9
```

# 복합 할당 연산자

복합 할당 연산자(Compound assignment operators)란 연산과 할당을 동시에 할 수 있는 연산자입니다.

#### 더하기 할당 연산자

더하기 할당 연산자(Addition assignment operator) `+=`는 더하기 연산 결과를 할당합니다.

```
self.Entity.TransformComponent.Position.x += 0.1 -- Position의 x값을 0.1 증가시킴
local num = 1
num += 2 -- num에 2를 더한 값을 할당함
print(num)
-- Output :
-- 3
```

#### 빼기 할당 연산자

빼기 할당 연산자(Subtraction assignment operator) `-=`는 빼기 연산 결과를 할당합니다.

```
self.Entity.TransformComponent.Position.x -= 0.1 -- Position의 x값을 0.1 감소시킴
local num = 1
num -= 2 -- num에 2를 뺀 값을 할당함
print(num)
-- Output :
-- -1
```

#### 곱하기 할당 연산자

곱하기 할당 연산자(Multiplication assignment operator) `*=`는 곱하기 연산 결과를 할당합니다.

```
local num = 2
num *= 3 -- num에 3을 곱한 값을 할당함
print(num)
-- Output :
-- 6
```

#### 나누기 할당 연산자

나누기 할당 연산자(Division assignment operator) `/=`는 나누기 연산 결과를 할당합니다.

```
local num = 5
num /= 2 -- num을 2로 나눈 값을 num에 할당함
print(num)
-- Output :
-- 2.5
```

#### 정수 나누기 할당 연산자

정수 나누기 할당 연산자(Floor Division assignment operator) `//=`는 나누기 연산을 수행한 후 몫을 할당합니다.

```
local num = 5
num //= 2 -- num을 2로 나눈 몫을 num에 할당함
print(num)
-- Output :
-- 2
```

#### 나머지 할당 연산자

나머지 할당 연산자(Remainder assignment operator) `%=`는 나누기 연산을 수행한 후 나머지를 할당합니다.

```
local num = 5
num %= 2 -- num을 2로 나눈 나머지를 num에 할당함
print(num)
-- Output :
-- 1
```

#### 거듭 제곱 할당 연산자

거듭 제곱 할당 연산자(Exponentiation assignment operator) `^=`는 거듭 제곱 연산 결과를 할당합니다.

```
local num = 5
num ^= 2 -- num의 제곱을 num에 할당함
print(num)
-- Output :
-- 25.0
```

#### 문자열 이어 붙이기 할당 연산자

문자열 이어 붙이기 할당 연산자(String concatenation assignment operator) `..=`는 문자열을 이어 붙인 결과를 할당합니다.

```
local str = 'Hello, '
str ..= 'MapleStory '
str ..= 'World!'
print(str)
-- Output :
-- Hello, MapleStory World!
```

#### 왼쪽 비트 시프트 할당 연산자

비트 시프트는 프로그래밍에서 사용되는 비트 연산자 중 하나로, 이진수 값을 왼쪽이나 오른쪽으로 이동시킵니다. 왼쪽 비트 시프트 `<<`는 이진수를 왼쪽으로 이동시키며 오른쪽에는 0을 추가합니다. 왼쪽 비트 시프트 할당 연산자(Bitwise left shift assignment operator) `<<=`는 비트를 왼쪽으로 이동한 결과를 할당합니다.

```
local num = 2    -- 0b0010

-- 0b는 해당 숫자가 이진수임을 나타내는 표기법
-- num의 이진수를 왼쪽으로 1만큼 이동시킴
num <<= 1       -- 0b0100
print(num)
-- Output :
-- 4
```

#### 오른쪽 비트 시프트 할당 연산자

오른쪽 비트 시프트 할당 연산자(Bitwise right shift assignment operator) `>>=`는 비트를 오른쪽으로 이동한 결과를 할당합니다.

```
local  num = 2   -- 0b0010

-- num의 이진수를 오른쪽으로 1만큼 이동시킴
num >>= 1        -- 0b0001
print(num)
-- Output :
-- 1
```

#### 비트 AND 할당 연산자와 비트 OR 할당 연산자

비트 AND 연산자(Bitwise AND operator) `&`는 두 개의 값을 비교하여 같은 위치의 비트가 모두 1이면 결과로 1을 반환하고, 그렇지 않으면 0을 반환합니다. 반면, 비트 OR 연산자(Bitwise OR operator) `|`는 두 개의 값을 비교하여 같은 위치의 비트 중 하나라도 1이면 결과로 1을 반환하고, 그렇지 않으면 0을 반환합니다. 예를 들어 봅시다.

```
local a = 10 -- 이진수 1010
local b = 7 -- 이진수 0111

local result = a & b -- 비트 AND 연산 수행
print(result)
-- Output : 
-- 2 (이진수 0010)

local result = a | b -- 비트 OR 연산 수행
print(result)
-- Output : 
-- 15 (이진수 1111)
```

비트 AND 할당 연산자(Bitwise AND assignment operator) `&=`는 비트 AND 연산을 수행한 후 그 결과를 할당합니다. 비트 OR 할당 연산자(Bitwise OR assignment operator) `|=`는 비트 OR 연산을 수행한 후 그 결과를 할당합니다. 사용 예시를 살펴봅시다.

```
local cardKeywords =
{
    Taunt = 1 << 0,
    BattleCry = 1 << 1,
    Deathrattle = 1 << 2,
    Windfury = 1 << 3,
    Immune = 1 << 4,
}

local function HasKeyword(card, keyword)
    return (card & keyword) == keyword
end

local newCard = cardKeywords.Taunt | cardKeywords.BattleCry
print("Taunt : ",HasKeyword(newCard, cardKeywords.Taunt))
-- Output :
-- Taunt : true

newCard &= ~cardKeywords.Taunt -- newCard에서 Taunt 제거
print("Taunt : ",HasKeyword(newCard, cardKeywords.Taunt))
-- Output :
-- Taunt : false

newCard |= cardKeywords.Immune -- newCard에 Immune 추가
print("Immune : ",HasKeyword(newCard, cardKeywords.Immune))
-- Output :
-- Immune : true
```

> **더 알아보기** 복합 할당 연산자를 사용할 때 지원하지 않는 기능도 있습니다. 먼저, 다중으로 복합 할당을 할 수 없습니다.```
a , b += 1, 2 -- Error
```
> 또한 복합 할당을 인수(argument)로 사용할 수 없습니다.```
print(a += 1) -- Error
```

Update 2025-11-17 PM 08:14


# 맵 생성과 관리

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

다양한 맵은 월드를 탐험하는 유저들에게 다채로운 재미를 선사합니다. 이번 과정에서는 맵 생성과 관리 방법을 알아봅시다.

# 맵 관리 방법

맵 관리 방법에는 2가지가 있습니다.

- **Hierarchy - maps** 하위 엔트리의 콘텍스트 메뉴를 통해 관리
- **Window - Map List** 창에서 관리

# 새 맵 만들기

| Hierarchy | Map List |
| --- | --- |
| **Hierarchy - maps**의 콘텍스트 메뉴에서 **Create New Map** 클릭 <br>![maplist03](https://mod-file.dn.nexoncdn.co.kr/bbs/168619256953482671c21f29e4b3fa358e803384cd88a.png) | <ul><li>**Map List** 창 하단에서 **[새 맵 만들기]** 버튼 클릭</li><li>맵의 콘텍스트 메뉴에서 **[추가하기]** 버튼 클릭</li></ul>![New map](https://mod-file.dn.nexoncdn.co.kr/bbs/17407188118992865ea930bfa4fe1b74a91f24ebf7b22.png) |

> **Tip.** 맵 이름의 번호는 오름차순으로 생성됩니다. 변경 사항이 있다면, 저장 안내 창이 뜹니다.

# 맵 복제하기

| Hierarchy | Map List |
| --- | --- |
| 복제하려는 맵의 콘텍스트 메뉴에서 **Duplicate** 클릭<br>![maplist008](https://mod-file.dn.nexoncdn.co.kr/bbs/166547548197887e3c38de1bc42f9aa9c4444a464c110.png) | 복제하려는 맵의 콘텍스트 메뉴에서 **Duplicate Map** 클릭<br>![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1740718860985a71d3757d77e4e9ca91ff837e5a8fc73.png) |

# 맵 삭제하기

| Hierarchy | Map List |
| --- | --- |
| 삭제하려는 맵의 콘텍스트 메뉴에서 **Delete** 클릭<br>![maplist007](https://mod-file.dn.nexoncdn.co.kr/bbs/16654754071719502fdc9e05a4db98079408b2c3dc57d.png) | 삭제하려는 맵의 콘텍스트 메뉴에서 **Delete Map** 클릭<br>![maplist011](https://mod-file.dn.nexoncdn.co.kr/bbs/1687510622017287506de587c442eae8f10a1f3fffa35.png) |

> **Tip.** **시작 맵**과 **현재 Scene에서 작업 중인 맵**은 삭제할 수 없습니다.

# 다른 맵 불러오기

| Hierarchy | Map List |
| --- | --- |
| 불러올 맵을 더블클릭 <br>![maplist005](https://mod-file.dn.nexoncdn.co.kr/bbs/1665475758380d0ae41686e544179a2f88336522d930c.png) | 원하는 맵을 선택한 후 **[불러오기]** 버튼 클릭 <br>![loadingMap](https://mod-file.dn.nexoncdn.co.kr/bbs/1740718976840ed493cfcbddd4f90907cabafff1a3d8d.png) |

# 시작 맵 설정

시작 맵은 출시한 월드를 실행했을 때 플레이어 아바타가 처음 들어가는 맵입니다. 기본 시작 맵은 **map01**이지만, 필요에 따라 시작 맵을 변경할 수 있습니다.

| Hierarchy | Map List |
| --- | --- |
| 시작 맵으로 변경하려는 맵의 콘텍스트 메뉴에서 **Set Starting Map** 클릭 <br>![startingmap01](https://mod-file.dn.nexoncdn.co.kr/bbs/16654761105842d01f5d7edc04abcb2e4fa0d6fb3c16d.png) | 시작 맵으로 변경하려는 맵에서 **시작 맵**을 클릭 <br>![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1745302055551dc8af652634a4081bded884b0a7f9c17.png) |

> **'시작 맵'과 '게임 시작 위치' 차이점** 시작 맵 설정과 테스트를 위한 위치 설정은 서로 다른 개념입니다. 게임 제작 중에 테스트를 위해서 플레이할 경우 작업 중인 맵에서 바로 시작합니다. 자세한 내용은 [게임 시작 위치 설정](docs?postId=115)을 참고하세요.

# 맵 출시 여부 선택

생성한 맵은 기본적으로 출시 대상에 포함됩니다. 하지만 일부 맵을 출시 대상에서 제외할 수 있습니다.

| Hierarchy | Map List |
| --- | --- |
| 출시 제외할 맵의 콘텍스트 메뉴에서 **Exclude from Released Map** 클릭 <br>![exclude](https://mod-file.dn.nexoncdn.co.kr/bbs/1684214359320ddda193ee6d5445a89731c10103fe946.png) <br> 출시 대상에서 제외하면 출시 아이콘이 보이지 않습니다. <br>![exclude03](https://mod-file.dn.nexoncdn.co.kr/bbs/166554042257954731952e0df4c27bdbe47c466b052f7.png) | 출시 제외할 맵의 콘텍스트 메뉴에서 **Exclude from Released Map** 클릭 <br>![exclude01](https://mod-file.dn.nexoncdn.co.kr/bbs/168445486910307dd7acb82f944ff8fe7ceea8b39e53c.png) <br> 출시 대상에서 제외하면 출시 아이콘이 보이지 않습니다. <br>![exclude02](https://mod-file.dn.nexoncdn.co.kr/bbs/16844549675036d34a9a31b9548acaa2567c5858198e0.png) |

> **더 알아보기**- 시작 맵은 출시 대상에서 제외할 수 없습니다. 또한 출시 대상에서 제외한 맵을 시작 맵으로 변경하면 해당 맵은 자동으로 출시 대상에 포함됩니다. - 공동 제작 월드에서는 그룹장만 맵의 출시 여부를 설정할 수 있습니다. - 출시 제외했던 맵을 다시 출시 대상에 포함하려면 해당 맵의 콘텍스트 메뉴에서 **Add Map to Publish**를 클릭합니다.

# 포탈을 이용한 맵 이동

1. 연결하려는 맵에 포탈을 설치합니다. ![maplist30](https://mod-file.dn.nexoncdn.co.kr/bbs/16377379799957f5bcea9eb1d44a899fedb83cd07f630.png)
2. 포탈의 프로퍼티 에디터에서 **TargetPortal**의 **[◉]** 버튼을 클릭합니다. 이후 **Reference** 팝업 창에서 이동할 포탈을 선택합니다. ![maplist31](https://mod-file.dn.nexoncdn.co.kr/bbs/1665477149603091fc46daa8d480cb009d0d4fa2ea34e.png)
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 클릭한 뒤, 출발 포탈에서 도착 포탈로 잘 이동하는지 확인합니다.

# 마무리

좋은 맵의 크기와 개수는 정해진 답이 없습니다. 크리에이터의 기획에 맞게 여러 개의 맵을 만들거나, 하나의 커다란 맵을 만들어도 좋습니다. 그러나 맵이 너무 거대하거나 배치된 오브젝트가 많으면 로딩 및 플레이 지연이 발생할 수 있습니다. 그러므로 맵의 크기와 오브젝트 수를 적절히 조절해야 합니다.

Update 2025-11-20 PM 02:03


# 메이플 타일맵 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 여러 가지 지형과 이동 방식을 제공하고 있습니다. 이번 시간에는 가장 기본이 되는 지형인 메이플스토리 형태의 타일 맵에 대해 알아보겠습니다. 메이플스토리 형태의 지형은 메이플스토리 형태의 이동과 매우 밀접한 연관이 있습니다.

> **더 알아보기**  메이플스토리 형태의 이동에 대해서는 [메이플 이동 개념 이해하기](/docs?postId=750)를 참고해주세요.

# 메이플스토리 형태의 지형

메이플스토리 형태의 지형은 타일 에디터에서 MapleTile 모드를 선택한 후 만들 수 있습니다. ![tileEditor](https://mod-file.dn.nexoncdn.co.kr/bbs/1658282762014c76e4b1dd653437aa0b54c0f45122fb0.png) ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg)의 타일 에디터 버튼을 길게 눌러 MapleTile 모드를 선택한 뒤, ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg)의 **Preset List**에서 원하는 타일을 골라 지형을 만들면 됩니다. 단, 하나의 맵에서는 하나의 타일 맵 모드만 사용할 수 있습니다. 예를 들어 MapleTile 모드로 지형을 만든 뒤, 다른 타일 맵 모드로 변환하면 기존 지형은 모두 초기화되므로 주의해야 합니다.

타일 맵 모드를 선택하면 **Hierarchy**에 해당 타일 맵 모드에 맞는 맵 컴포넌트가 생성됩니다. ![tilemap](https://mod-file.dn.nexoncdn.co.kr/bbs/16576297374183614fc621c3747f8bd1478bddd3da31c.png) 타일 맵 모드로 MapleTile을 선택하면 **Hierarchy**에서 **TileMap** 엔티티를 확인할 수 있으며, 이 엔티티에 속한 **TileMapComponent**를 통해 MapleTile의 속성이나 색상, 형태 등을 변경할 수 있습니다.

# 지형 생성하기

## 타일 선택하기

지형은 굉장히 넓은 범위에 자유롭게 만들 수 있습니다. 따라서 메이커에서는 지형을 생성하고 수정하는데 필요한 여러 가지 편의 기능을 제공합니다.

![tilepick](https://mod-file.dn.nexoncdn.co.kr/bbs/1657699332147b812f9a825ea47818c4bd63cfc4b6d68.png)

**Preset List**에서 원하는 **TileSet**을 선택하면 지형을 만들 수 있습니다. 하나의 **Map Layer**에서는 하나의 **TileSet**만 사용할 수 있습니다. ![maplayer](https://mod-file.dn.nexoncdn.co.kr/bbs/16577003279588aa2927b92194ba99c8f3cfb929b5e1c.png) 위와 같이 **Map Layer**에서 ![addlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_layer_add.png) 버튼을 눌러 레이어를 추가하면 하나의 맵에서 여러 **TileSet**을 사용할 수 있습니다.

> **Tip1.** TileSet을 변경하면 이전에 해당 레이어에 배치했던 지형도 모두 새로운 TileSet으로 변경되므로 주의해야 합니다.
> **Tip2.** `TileMapComponent`의 TileSetRUID를 수정하여 TileSet을 변경할 수도 있습니다.

## 타일 보조선 표시

**Scene**의 오른쪽 상단에 ![gridinfo](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_grid2.png) 그리드 정보 버튼이 있습니다. ![grid](https://mod-file.dn.nexoncdn.co.kr/bbs/1657710972697056c508aa0f047ea994612920898098c.png) ![gridinfo](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_grid2.png) 그리드 정보 버튼을 누르면 격자 형태의 보조선이 보입니다. 이 보조선은 지형을 그리는 데 도움을 줍니다.

## 지형 그리기

지형 그리기 도구에서 지형을 그리는 방식을 선택할 수 있습니다. ![tiletool](https://mod-file.dn.nexoncdn.co.kr/bbs/1657711565470477997a2f4b14bf093847b8c29899d77.png)

| 번호 | 항목 | 설명 |
| :---: | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 선 칠하기 | 커서를 클릭한 지점에 타일을 그립니다. 드래그하면 드래그하는 선을 따라 그립니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 박스 칠하기 | 드래그한 사각형 안을 모두 타일로 채웁니다. |

선 칠하기 모드에서 격자 형태의 보조선을 클릭하면 클릭 위치에 따라 생성되는 지형의 모양이 달라집니다.

| 클릭 위치 | 생성되는 지형 | 설명 |
| :---: | --- | --- |
| 점 | ![line1](https://mod-file.dn.nexoncdn.co.kr/bbs/1657712926265695555a3dfba412796f23cbf1ca5b906.png) | 보조선이 교차하는 점을 클릭하면 그 지점에 작은 지형이 생성됩니다. |
| 선 | ![line2](https://mod-file.dn.nexoncdn.co.kr/bbs/1657713375917614def59a5674c0289c399b71c910bd3.png) | 선을 클릭하면 양쪽 교차 지점을 포함한 선까지 지형이 생성됩니다. |
| 면 | ![line3](https://mod-file.dn.nexoncdn.co.kr/bbs/16577598884962e68f73359ad41aa82bf4279e3f87f9d.png)<br>![line4](https://mod-file.dn.nexoncdn.co.kr/bbs/165776120779882e8cb42c179416bae4c8fd6fdeab856.png) | 면을 클릭하면 면의 테두리 선을 포함하는 지형이 생성됩니다. <br><br> 또한 아래와 옆 선에 지형이 있는 상태에서 면의 가운데를 클릭하면 대각선 지형이 생성됩니다. |

## 지형 지우기

### 우클릭으로 지우기

그리기 모드일 때, 마우스 우클릭을 하면 지형을 지울 수 있습니다. 우클릭으로는 지형만 지울 수 있기 때문에 지형을 편집하는 동안에 편리하게 사용할 수 있습니다. ![rightClick](https://mod-file.dn.nexoncdn.co.kr/bbs/16582894594106cf5ad992ec04c6a9d79ccb1f3616aaa.gif)

### 지우개로 지우기

지우개를 사용해서 지형을 지울 수도 있습니다. ![erase](https://mod-file.dn.nexoncdn.co.kr/bbs/1657762131044a2e122fbd3f1482698e73370ac8d4be0.png) ![eraser](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_eraser.png) 지우개 커서를 선택한 뒤 **Scene**에서 지형을 클릭하여 지우면 됩니다. 단, 전체 지우개 커서는 지형뿐만 아니라 다른 엔티티까지도 삭제하기 때문에 사용할 때 주의해야 합니다. 타일만 지우거나 엔티티만 지우고 싶다면 지우개 커서 옵션을 바꿔봅시다. ![erase2](https://mod-file.dn.nexoncdn.co.kr/bbs/16577635580024e93d1c0c63b490a99cfbc548a3604c4.png) **TileOnly**를 통해 타일만 지우거나 **TileExceptOnly**를 통해 타일 외 다른 엔티티만 지울 수 있습니다.

## 발판(Foothold)

지형을 생성하는 가장 큰 이유는 엔티티가 이동할 수 있는 공간이 필요하기 때문일 것입니다. 메이플 타일에서 이동할 수 있는 영역을 **발판**이라고 합니다. 메이플 타일과 쌍을 이루는 [RigidbodyComponent](/docs?postId=750)의 이동 방식은 두 가지가 있습니다.

**1. 발판 위에서 이동 2. 발판 밖에서 이동**

발판은 지형 생성 규칙에 의해 만들어지며 대부분 직관적으로 지형과 1:1 매칭됩니다. ![footholdicon](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_foothold.png) 발판 정보 버튼을 누르면 지형 위에 빨간색 선으로 발판 정보가 나타납니다. ![foothold](https://mod-file.dn.nexoncdn.co.kr/bbs/16577650286084cedcd11123845d9a418c15946fd025f.png)

> **더 알아보기** 발판은 지형뿐만 아니라 `CustomFootholdComponent`를 사용해 엔티티에도 추가할 수 있습니다. 자세한 내용은 [발판 만들기](/docs?postId=71)를 참고하세요.

Update 2025-11-17 PM 08:14


# 발판 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

여러 오브젝트를 사용해 발판을 만들어 게임의 보는 재미를 풍성하게 만들어봅시다. **FootholdComponent**와 **CustomFootholdComponent** 개념과 발판 편집 방법을 소개합니다.

# Foothold 모델로 발판 만들기

**Foothold** 모델을 이용해 발판을 만드는 방법입니다. 타일이 아닌 **Foothold** 모델을 이용해 다채로운 길을 만들 수 있습니다.

1. **Preset List** 패널에서 **Foothold**를 선택합니다.
2. 원하는 모델을 선택해 **Scene** 패널에 배치합니다.**Foothold** 모델의 스프라이트에 어울리는 발판이 모델에 함께 저장되어 있습니다. ![foothold01](https://mod-file.dn.nexoncdn.co.kr/bbs/165995816559970800486aa594605aec8a12193083ba3.png)

> Tip. 발판 정보 확인 **Scene** 패널에서 발판 정보 아이콘![Common_foothold](https://mod-file.dn.nexoncdn.co.kr/bbs/163453674810369fa34e7367d462bba709d528166c58d.png)을 클릭하면, 발판 영역이 빨간색 선으로 보입니다.

# 새로운 발판 만들기

**Foothold**에 원하는 모델이 없을 때, 직접 새로운 발판을 만들 수 있습니다. **Workspace** 패널에서 **Foothold**를 검색하면 두 개의 컴포넌트가 나옵니다. 두 컴포넌트 모두 **Foothold**와 관련되어 있지만, 개념과 용도가 다릅니다. 새로운 발판을 만들 때는 **CustomFootholdComponent**를 사용해야 합니다.

- **FootholdComponent** : 맵 전체의 발판 정보를 저장, 제공하는 컴포넌트입니다. 프로퍼티 에디터 창에서 검색 시 값은 나오나 이용할 수 없습니다. 해당 컴포넌트의 [API 문서](/apiReference?postId=336)를 참고하시기 바랍니다.
- **CustomFootholdComponent** : 발판을 만들고 조정하는 컴포넌트입니다. Foothold 모델에 이 컴포넌트가 포함되어 있습니다. 자세한 내용은 해당 컴포넌트의 [API 문서](/apiReference?postId=331)를 참고하시기 바랍니다.

# Custom Foothold Component 활용

#### 발판 경로 그리기

1. 발판으로 사용하고 싶은 스프라이트를 **Scene** 패널에 배치합니다.
2. 발판 엔티티의 프로퍼티 에디터에서 **CustomFootholdComponent**를 추가합니다. ![foothold02](https://mod-file.dn.nexoncdn.co.kr/bbs/1635312202910484e69092aac41a488ba45bc39c9edb2.png)
3. **edgeLists**(발판의 시작점)의 **Size**(발판 시작점 개수)를 입력하고, **Scene** 패널에서 발판 모양을 조정합니다. ![foothold03](https://mod-file.dn.nexoncdn.co.kr/bbs/1635312618765c3d8f742150b4a67bc2700d94d8f8379.png)

| 이름 | 설명 |
| --- | --- |
| edgeLists | 발판의 **시작점**을 의미합니다.<br>시작점을 여러 개 만들면, 하나의 엔티티에 개별 발판을 입력한 수만큼 만들 수 있습니다. |
| Size | 발판을 이루고 있는 점의 개수를 의미합니다.<br>edgeLists의 Size에 입력한 값만큼, **시작점**이 생성됩니다. <br>[ 숫자 ]의 Size에 입력한 값만큼 **연결점**이 생성됩니다. |
| [ 숫자 ] | 발판의 **연결점 개수**를 의미합니다.<br>0부터 시작하며, Size에 입력한 값만큼 연결점이 추가됩니다.<br>연결점은 Scene에서 해당 엔티티를 선택하고, 콘텍스트 메뉴에서 **Add Point**를 선택해 추가할 수 있습니다. <br>연결점은 x, y 값으로 위치를 나타냅니다. |

#### 활용 예시

1. **edgeLists**의 **Size**에 **1**을 입력해 시작점을 만듭니다.
2. **[1] - Size**에 **1**을 입력합니다.
3. 해당 엔티티의 콘텍스트 메뉴에서 **Edit Foothold**를 클릭합니다.
4. 시작점을 원하는 곳으로 옮깁니다.
5. 해당 엔티티의 콘텍스트 메뉴에서 **Add Point**를 클릭해 연결점을 추가합니다.
6. 연결점을 추가를 반복하며 원하는 동선을 만듭니다. 
7. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 동선을 따라 아바타가 이동하는지 확인합니다. ![foothold50](https://mod-file.dn.nexoncdn.co.kr/bbs/16419850592877b797c57a7064aa7af39d73058b42c22.gif)

> **Tip. 쉽게 오를 수 있는 발판 만들기** 점들의 연결이 완만할수록 플레이어 아바타가 수월하게 이동할 수 있습니다. 제작 시 테스트를 거쳐 아바타가 쉽게 이동할 수 있는지 확인해보세요.

#### 발판에 속성 부여하기

새롭게 만든 발판에 속성을 바꿔 크리에이터만의 독특한 발판으로 만들 수 있습니다. 각 프로퍼티 값을 조정해 특정 방향에서 나아갈 수 없는 발판, 특별히 느리게 이동하는 발판 등으로 활용해 재미를 더할 수 있습니다.

| 이름 | 설명 |
| --- | --- |
| FootholdDrag | RigidbodyComponent가 포함된 Entity가 발판 위에 있을 때 적용되는 마찰력을 의미합니다. 값이 클수록 엔티티가 발판에서 미끌어지다 빠르게 감속해 정지합니다. <br> 특정 지점에서 엔티티가 날아와 해당 값이 1과 10인 발판에 각각 떨어졌다면 값이 10인 발판에서 상대적으로 더 짧게 밀려나며 멈추게 됩니다. 플레이어가 기본 이동할 때는 해당 값에 영향을 받긴 하지만 적용되는 힘이 미미한 경우 플레이 시 눈에 띄지 않습니다. |
| FootholdForce | RigidbodyComponent가 포함된 Entity가 발판 위에 있을 때 가해지는 힘입니다. 엔티티는 값이 양수면 오른쪽, 음수면 왼쪽으로 이동합니다. 반대 방향으로 이동하려고 할 경우 저항으로 인해 방해 받습니다. |
| FootholdWalkSpeedFactor | RigidbodyComponent가 포함된 Entity가 발판 위에 있을 때 이동속도에 곱해지는 계수입니다. 값이 클수록 이동속도가 빨라집니다. |

# 마무리

발판의 시작점을 하나로 만들어 발판을 이을 것인지, 여러 개의 시작점으로 이뤄진 발판을 만들 것인지는 크리에이터의 선택입니다. 선택한 스프라이트와 어울리는 발판을 제작하길 바랍니다.

##### 참고 가이드

[컴포넌트 추가와 삭제](/docs?postId=58)

Update 2025-11-17 PM 08:14


# 이동 발판 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

움직이는 발판을 만들어 이동에 재미를 더해보세요. CustomFootholdComponent의 IsDynamicFoothold 프로퍼티를 이용해 나만의 움직이는 발판을 만들 수 있습니다. [발판 만들기](/docs/?postId=71)에서 기본 발판 제작 방법을 배울 수 있습니다.

# 이동 발판 만들기

이동 발판은 CustomFootholdComponent를 활용해 크리에이터가 직접 만들어야 합니다. 발판의 움직임을 만드는 방식은 다르지만, 기본 CustomFootholdComponent를 움직이게 만들기 위해선 IsDynamicFoothold, RigidbodyMovementOption 프로퍼티를 설정해야 합니다.

| 프로퍼티 명 | 설명 |
| --- | --- |
| IsDynamicFoothold | 움직이는 발판을 만들기 위해 활성화합니다. |
| RigidbodyMovementOption | 움직이는 발판 위의 플레이어 엔티티가 어떤 관성을 받을 것인지 방식을 적용합니다.<ul><li>RelativeX: x축 관성은 적용하고, y축 관성은 적용하지 않습니다. 플레이어가 발판의 이동 방향과 반대로 움직이면 속도가 감속하고, 같은 방향으로 움직이면 가속합니다.</li><li>Absolute: 플레이어가 어느 방향으로 움직여도 속도가 동일합니다.</li></ul> |

| RelativeX | Absolute |
| --- | --- |
| ![reletiveX](https://mod-file.dn.nexoncdn.co.kr/bbs/16466307010962640bc0dca2b4ba28d72e8138ee4a5cf.gif) | ![absolute](https://mod-file.dn.nexoncdn.co.kr/bbs/1646633877812d9fd5ab7b34d468abc8018984875cdf5.gif) |

#### 활용 예시

1. 발판으로 사용할 오브젝트에 CustomFootholdComponent를 추가하고, 발판을 만듭니다.
2. CumstomFootholdComponent - **IsDynamicFoothold**를 활성화합니다.
3. CumstomFootholdComponent - **RigidbodyMovementOption을 RelativeX**로 설정합니다.![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16820538852880d9d1813790d4636b5b483c6f0b7e885.png)
4. 새로운 컴포넌트를 생성하고 발판 오브젝트에 추가합니다.
5. 새로운 컴포넌트의 스크립트 에디터 창을 열고, 발판의 이동 시간과 범위를 아래와 같이 작성합니다. `TransformComponent:Translate(0,0)`의 x 값만 입력할 경우 좌우로 이동하고, y 값만 입력할 경우 상하로 움직입니다. 두 값을 모두 입력하면 대각선으로 움직입니다.

```
Property:
[Sync]
number totalTime = 0
    
Method:
[Server only]
void OnUpdate(number delta)
{
    self.totalTime = self.totalTime + delta
    if self.totalTime > 0 and self.totalTime <= 5.0 then
        self.Entity.TransformComponent:Translate(0,0.009)
    elseif self.totalTime > 5.0 and self.totalTime <= 10.0 then
        self.Entity.TransformComponent:Translate(0,-0.009)
    elseif self.totalTime > 10 then
        self.totalTime = 0
    end
}
```

Update 2025-11-20 PM 02:03


# RectTileMap의 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 RectTileMap 모드를 활용해 횡스크롤이 아닌, 탑다운 뷰의 월드를 제작할 수 있습니다. 이번 시간에는 RectTileMap에 대해 알아봅시다.

# RectTileMap과 플레이어 이동

메이플스토리 월드에서는 MapleTile, RectTile, SideViewRectTile 모드로 지형을 만들 수 있습니다.

- **MapleTile**
  - 메이플스토리 형태의 횡스크롤 맵을 만들 수 있습니다. [RigidbodyComponent](/apiReference/Components/RigidbodyComponent)가 플레이어의 이동을 제어합니다.
- **RectTile**
  - 탑다운 뷰 맵을 만들 수 있습니다. 플레이어는 상하좌우 이동을 하며 [KinematicbodyComponent](/apiReference/Components/KinematicbodyComponent)가 플레이어의 이동을 제어합니다.
- **SideViewRectTile**
  - RectTile을 기반으로 하지만 플레이어는 횡스크롤 방식으로 이동합니다. [SideviewbodyComponent](/apiReference/Components/SideviewbodyComponent)가 플레이어의 이동을 제어합니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1658737408689f48e44ffdffb4cbd8a4934cd33fb2bbe.png)MapleTileMap과 달리 RectTileMap 환경에서는 일반적으로 플레이어가 상하좌우로 이동합니다. [KinematicbodyComponent](/apiReference/Components/KinematicbodyComponent)가 플레이어의 상하좌우 이동 및 점프, 타일과의 충돌 등을 지원합니다. 따라서 RectTileMap에서는 [KinematicbodyComponent](/apiReference/Components/KinematicbodyComponent)가 플레이어 엔티티에 활성화되어 있어야합니다. 현재 DefaultPlayer에는 [RigidbodyComponent](/apiReference/Components/RigidbodyComponent), [KinematicbodyComponent](/apiReference/Components/KinematicbodyComponent), [SideviewbodyComponent](/apiReference/Components/SideviewbodyComponent)가 모두 포함되어 있기 때문에, 맵 모드에 따라 이동 컨트롤의 주체가 달라집니다.

> **더 알아보기**  RectTileMap에서의 이동에 대해서는 [RectTileMap에서 캐릭터 이동 제어](/docs?postId=748)를 참고해주세요.

# RectTileMap 모드 변경

아래 두 가지 방법 중 하나를 택해 RectTileMap 모드로 변경할 수 있습니다.

| 1. Hierarchy에서 변환 | 2. 타일 에디터 버튼 눌러 변환 |
| :---: | :---: |
| **Hierarchy - 원하는 맵의 콘텍스트 메뉴 - Switch To RectTileMap** 선택 <br>![2](https://mod-file.dn.nexoncdn.co.kr/bbs/168620964686807e552bd474248cdae01ec5e9d51530a.png) | 타일 에디터 버튼 1초 이상 클릭 - **RectTile** 모드 선택 <br> ![sideview2](https://mod-file.dn.nexoncdn.co.kr/bbs/1658472803827bec010dc49a346efbc96c900cbe8ca0a.png) |

# 타일 셋 제작과 편집

#### 타일 셋 추가와 편집

타일을 배치하려면 먼저 타일 셋을 만들어야 합니다. 타일 셋 팔레트에서 새로운 타일 셋을 만들고 편집할 수 있습니다.

1. 타일 셋 팔레트에서 **[+]** 버튼을 눌러 타일 셋을 생성합니다. ![newtileset](https://mod-file.dn.nexoncdn.co.kr/bbs/165880028492527213e6739b64fec99b34b1ce6aa4f39.png)
2. **Workspace - MyDesk**에 **NewTileSet**이 생성됩니다. 타일 셋의 이름을 자유롭게 변경합니다. (예: TileSetExample) ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/16808618014123977d1ec0ccb4476bcb815083121136f.png)
3. 타일 셋 팔레트의 드롭박스에서 새 타일 셋을 선택합니다. (처음 생성한 타일 셋은 자동으로 선택됩니다.) ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606029806f7ed3d33041e480f9ecf2c6712caf4f4.png)

#### 타일 셋에 타일 추가

새 타일 셋에 원하는 타일을 추가해봅시다.

- **RosourceStorage로 타일 추가**

1. 타일 셋 팔레트 하단의 ![addtile_rect](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_addtile_rect.png) 버튼 클릭 - **Add ResourceStorage Image**를 클릭하면 **Resource Picker**가 열립니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16530468681401f0132f4322843df987e486e38236682.png)
2. **Resource Picker** - **MSW 리소스** 탭에서 기본 제공하는 스프라이트를 타일로 추가합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1680863607804674f5efaf1e54b96a9f9bbd76b067820.png)

- **Workspace의 이미지를 타일로 추가**

1. 타일 셋 팔레트 하단의 ![addtile_rect](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_addtile_rect.png) 버튼 클릭 - **Add Workspace Image**를 클릭하면 **Reference**가 열립니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1653047049074a99d1de3a0084236b89f4d37942e0852.png)
2. **Reference**에서 이미지를 선택해 타일로 추가합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1652917565746a7f06f04492340e9b1057560e5c1497d.png)

- **Atlas Unpacker로 타일 추가** Atlas Unpacker에서 아틀라스를 잘라 **렉트타일 셋에 추가**를 선택하면 타일로 사용할 수 있습니다. 아틀라스를 자르는 방법은 [아틀라스 활용하기](/docs?postId=687)를 참고하세요 자른 스프라이트가 선택한 타일 셋에 각각의 타일로 추가됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16528661656754c6d218fbbe040bfba3c0c83bfd730a9.png)

#### 타일 속성 설정

타일 편집 모드로 변환하면 타일 속성을 설정할 수 있습니다. 타일 셋 팔레트 오른쪽 상단의 편집 버튼을 누르면 타일 편집 모드로 변환됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16820562489076f422b063d3141858ff2b66b72ef021c.png)

**타일 이름 변경** 타일 하단 텍스트를 더블 클릭하면 해당 타일의 이름(예: Tile02)을 설정할 수 있습니다. 타일 이름은 스크립트로 타일을 생성할 때 사용됩니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/164689337602731f90bf9601147b8b66f5ffa207ef6bf.png)

**스프라이트 편집** 추가한 타일의 스프라이트 이미지를 변경할 수 있습니다.

1. **스프라이트 편집** 체크 박스 클릭 - **[타일 편집]** 버튼 클릭 - **Resource Picker**가 열립니다. ![00](https://mod-file.dn.nexoncdn.co.kr/bbs/1682056375105d198d3fb7d974f4e90dcd223b5917e60.png)
2. **Resource Picker**에서 변경하려는 스프라이트를 선택하면 타일 이미지가 해당 스프라이트로 바뀝니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/1682056468382b9d5dff7fc734709803c078c48577a85.png) 이미 맵에 배치한 타일의 스프라이트를 변경하면, 해당 타일도 함께 바뀝니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16456061645131caf59bf83324f438f862a5af508ba87.png)

**이동 가능 타일 편집** 플레이어가 이동 가능한 타일인지를 설정할 수 있습니다. **이동 가능 타일 편집** 체크 박스를 선택하면 속성을 편집할 수 있습니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1682055950758f06cded450704d6e91621ec719b3b73a.png)

화살표 버튼을 클릭하면 이동 가능 속성이 변경됩니다.

- ![green](https://mod-file.dn.nexoncdn.co.kr/bbs/16636525526508fb98d4ba8974da19fa2ae6118820054.png): 플레이어가 이동할 수 있는 타일
- ![red](https://mod-file.dn.nexoncdn.co.kr/bbs/1663652575156a3a8a3d780ee400a83a0b283ff8be1b0.png): 플레이어가 이동할 수 없는 타일 ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/168205596410879c055ebeef24f9bad7e99dba11b6af5.png)

#### 타일 셋에 포함된 타일 제거

타일 셋 팔레트에서 제거할 타일을 선택하고 **[삭제]** 버튼을 누릅니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606220639116d64b78c364589b890061155388a68.png)

# 타일 그리기

#### 타일 배치 하기

타일 셋 팔레트에서 원하는 타일을 선택한 후 드래그하여 타일을 배치합니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16456062306076fefdf58a8264dbea4b8fcacb255d982.png)

#### 편리한 타일 배치

타일을 쉽게 배치하기 위해 4가지 기능을 이용할 수 있습니다. 기본 위치는 **Scene**의 왼쪽 상단입니다.

| 아이콘 | 설명 |
| --- | --- |
| ![brush](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_tile_draw_brush.png) | 타일이 그리는 움직임에 맞게 그려집니다. |
| ![tilefill](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_tile_draw_fill.png) | 설정한 사각형 크기에 타일이 그려집니다. |
| ![tilemarquee](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_tile_elliptical_marquee.png) | 설정한 원형 안에 타일이 그려집니다. |
| ![timepaint](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_tile_draw_paint.png) | 선택한 타일이 맵 전체에 배치됩니다. |

#### 배치한 타일 삭제

타일을 우클릭하여 삭제할 수 있습니다. 우클릭 드래그 하면 드래그한 위치에 있던 타일이 모두 삭제됩니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/16456062487051dd3a7b4ed62497a9dafc5f8e690919b.png)

#### 타일 격자 크기 설정

타일 격자 크기는 현재 편집 중인 맵 하위의 **RectTileMap 엔티티 - RectTileMapComponent - GridSize**에서 설정할 수 있습니다.

| GridSize (x = 1, y = 1) | GridSize (x = 0.5, y = 0.5) |
| --- | --- |
| ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16456062694889c7e72b895c140ce93b353ea7cc3ba33.png) | ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606280377b40fec3292dd4738a54caf7fee26fd98.png) |
| ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606294167b95cdf311685440e9bae999e36d3dfcc.png) | ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/164560630741654c491198180455da76d8629fe612227.png) |

# 레이어 설정

레이어를 추가하면 이미 배치한 타일 위에 다른 타일을 배치할 수 있습니다.

#### 레이어 추가

1. **Map Layer** 패널 하단의 **[+]** 버튼을 누르면 새로운 맵 레이어가 추가됩니다. **Hierarchy - 맵 엔티티**에 새 RectTileMap 엔티티도 추가됩니다. ![26](https://mod-file.dn.nexoncdn.co.kr/bbs/1661148577594d85c8f9327f04b3289a718aa44a2daef.png)
2. 새 레이어 선택 후 타일을 배치하면, 이전 타일 맵 위에 다른 타일을 배치할 수 있습니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606334153ac37196bd49c453cb90f2b72229eafcb.png)

#### 레이어 별 타일 셋 적용

레이어를 추가하면 기본적으로 이전 타일 셋을 공용으로 사용합니다. 그래서 특정 타일의 속성을 변경하면 의도치 않게 다른 레이어의 타일 속성까지 변경하는 경우가 생깁니다. 예를 들어, **레이어 1**에 **타일 셋 1**을 적용 중일 때 **레이어 2**를 생성하면 **레이어 2**에도 **타일 셋 1**이 적용됩니다. **레이어 1**에 배치한 특정 타일의 이미지를 변경하려고 **타일 셋 1**의 타일 속성을 변경하면 **레이어 2**의 타일도 함께 변경됩니다. 이러한 상황을 피하려면 레이어 별로 각각 다른 타일 셋을 적용하는 것이 좋습니다. ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606345066334e779be0bd4779890385dcae16387c.png)

레이어마다 다른 타일 셋을 추가하는 방법은 아래와 같습니다.

1. 기존 타일 셋이 있는 상태에서 새로운 타일 셋을 추가합니다. (예: TileSetExample2) 새 타일 셋에 몇 가지 타일도 함께 추가합니다. ![29](https://mod-file.dn.nexoncdn.co.kr/bbs/164560635412061c42fedcd1a4f32a853fbc48ee0940d.png)
2. 새로운 맵 레이어를 추가합니다. (예: Layer 2) ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/16644394470198d98072e5bb44d7fa21e9a5c1b092fa7.png)
3. 추가한 레이어를 선택한 상태에서 새 타일 셋(예: TileSetExample2)을 선택합니다. 그러면 새 레이어에는 새 타일 셋이 적용됩니다. 이후 새 레이어에 타일을 배치해봅니다. ![32](https://mod-file.dn.nexoncdn.co.kr/bbs/166443979497645960ec72f1d435698bad0417102aced.png)
4. **Hierarchy**의 **RectTileMap** 또는 **Map Layer**에서 레이어를 차례로 선택해 봅니다. 타일 셋 팔레트에서 **RectTileMap** 마다 서로 다른 타일 셋이 적용된 것을 확인합니다. ![33](https://mod-file.dn.nexoncdn.co.kr/bbs/164560640382826178fc21ac34e7d99d4c13f1cc0f215.png)

# 스크립트를 활용한 타일 동적 생성

RectTileMap 엔티티의 [RectTileMapComponent](/apiReference/Components/RectTileMapComponent)는 타일을 배치하거나 월드 좌표를 타일 좌표로 변환하는 등 여러가지 기능을 제공합니다. [RectTileMapComponent](/apiReference/Components/RectTileMapComponent)를 활용해 타일을 동적으로 배치해봅시다.

**예제 개요**

- 맵에는 기본적으로 Sand 타일이 깔려있다.
- 플레이어가 Sand 타일 위를 돌아다니며 특정 키를 누를 때마다 플레이어가 위치한 타일을 다른 타일로 교체한다.
- z 키 : Grass 타일 배치
- x 키 : Rock 타일 배치

1. 맵을 RectTileMap 모드로 변환합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/168620964686807e552bd474248cdae01ec5e9d51530a.png)
2. 새로운 타일 셋을 추가하고 이름을 **DefaultTileSet**으로 설정합니다. ![35](https://mod-file.dn.nexoncdn.co.kr/bbs/16611487607867a88e4492c31418db5965701b4aa9bfe.png)
3. 타일 셋 팔레트 하단의 ![addtile_rect](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_addtile_rect.png) 버튼 클릭 - **Add ResourceStorage Image**를 클릭하여 **Resource Picker**를 엽니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16530468681401f0132f4322843df987e486e38236682.png)
4. 아래 이미지를 저장합니다. ![37-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606456025f9dcb42718e54d048a4ef4d68caeb5c3.png) ![37-2](https://mod-file.dn.nexoncdn.co.kr/bbs/164560648032304c0fb4f292b4738a29f50d683c16a74.png) ![37-3](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606496185fa29d88d5fe74731b4086ee5b157af0f.png) **Resource Picker - etc** 폴더에 저장한 이미지를 드래그하여 스프라이트를 추가합니다. ![38](https://mod-file.dn.nexoncdn.co.kr/bbs/1680863851481860cfa8aacb14d61b9be8f8d5bbba757.png)
5. 추가한 스프라이트를 차례로 선택하면 타일이 추가됩니다. ![40](https://mod-file.dn.nexoncdn.co.kr/bbs/16636620067727a0b1d62198d4c88bd0adcc1557464e3.png)
6. 타일 셋 팔레트에서 타일 편집 버튼을 클릭합니다. 추가된 타일의 이름을 다음과 같이 설정합니다. ![41](https://mod-file.dn.nexoncdn.co.kr/bbs/1682056924392cd4e5ae8557540c29db887c2c2e4a298.png) | 스프라이트 | 이름 |
| :---: | :---: | | ![37-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606456025f9dcb42718e54d048a4ef4d68caeb5c3.png) | Sand | | ![37-2](https://mod-file.dn.nexoncdn.co.kr/bbs/164560648032304c0fb4f292b4738a29f50d683c16a74.png) | Grass | | ![37-3](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606496185fa29d88d5fe74731b4086ee5b157af0f.png) | Rock |
7. 타일 속성 편집 버튼을 다시 한번 클릭하여 편집 모드를 종료합니다. Sand 타일을 선택하여 다음과 같이 배치합니다. ![42](https://mod-file.dn.nexoncdn.co.kr/bbs/1645606624729d3b155764feb452b8a536c74a08fb8b8.png)
8. **Workspace**에 새 스크립트 컴포넌트를 추가하고 이름을 **EditRectTile**로 입력합니다. ![43](https://mod-file.dn.nexoncdn.co.kr/bbs/16611488907978a25e171e4884b109464ee22559ebff5.png)
9. **DefaultPlayer**에 **EditRectTile** 컴포넌트를 추가합니다. ![44](https://mod-file.dn.nexoncdn.co.kr/bbs/16611489073306b5098a2ff0548cc87bb5c84adc1288e.png)
10. **EditRectTile** 스크립트 컴포넌트를 엽니다. `ChangeCurrentTile()` 함수를 추가하고 **string** 타입의 매개 변수 **tileName**도 추가합니다. 이후 함수를 아래와 같이 작성합니다.```
[server]
void ChangeCurrentTile(string tileName)
{
    if  tileName == nil then 
        return 
    end

    local pos = self.Entity.TransformComponent.Position
    local tilemap = _EntityService:GetEntityByPath("/maps/map01/RectTileMap").RectTileMapComponent

    -- 월드 공간 좌표를 타일맵 공간 좌표로 변환
    local cellPos = tilemap:ToCellPosition(pos)

    -- 현재 플레이어가 위치한 타일의 정보 반환
    local tileInfo = tilemap:GetTile(cellPos)

    if tileInfo ~= nil then
        tilemap:SetTile(tileName, cellPos.x, cellPos.y)
    end
}
```
11. **Event Handler**에서 **KeyDownEvent**를 추가하고, 내용을 다음과 같이 작성합니다.```
Event Handler : 
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------
    if key == KeyboardKey.Z then
        self:ChangeCurrentTile("Grass") -- Z키 : Grass 타일 배치
    elseif key == KeyboardKey.X then
        self:ChangeCurrentTile("Rock") -- X키 : Rock 타일 배치
    end
}
```
12. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 플레이어를 움직이며 Z나 X 키를 눌러봅니다. 플레이어가 위치한 지점의 타일이 변경되는 것을 확인합니다.

Update 2025-11-17 PM 08:14


# SideViewRectTile모드로 맵 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

RectTileMapComponent와 KinematicbodyComponent는 탑다운뷰 게임 제작에는 적합하지만 횡스크롤 게임 제작에는 적합하지 않습니다. SideViewRectTile 모드는 RectTileMap을 활용해 손쉽게 횡스크롤 게임을 제작할 수 있도록 횡스크롤 방식의 이동, 점프, 타일과의 충돌 등을 지원합니다. 이번 시간에는 SideViewRectTile 모드에 대해 알아보고 맵을 제작해봅시다.

> **더 알아보기**  SideViewRectTile 모드는 RectTile 모드를 기반으로 합니다. 본 과정을 살펴보기 전에 먼저 [RectTileMap의 활용](/docs?postId=589)을 참고해보세요.

# SideViewRectTile 모드 변경

SideViewRectTile을 활용하려면 맵 타일 모드를 변경해야 합니다. 맵 타일 모드를 변경하는 첫 번째 방법은 ![hierarchy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png) Hierarchy에서 현재 편집 중인 맵 엔티티를 선택하고, 우클릭 메뉴에서 **Switch To SideViewRectTileMap**을 선택하는 것입니다. ![sideview1](https://mod-file.dn.nexoncdn.co.kr/bbs/1686212940229528039cf5e884de28be22ce0db30fcd2.png)

두 번째 방법은 상단 메뉴의 타일 에디터 버튼을 길게 눌러 타일 모드 선택 메뉴를 연 뒤, **SideViewRectTile**을 선택하는 것입니다. ![sideview2](https://mod-file.dn.nexoncdn.co.kr/bbs/1658472803827bec010dc49a346efbc96c900cbe8ca0a.png)

SideViewRectTile 모드를 선택하면 아래와 같이 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene이 변경됩니다. ![scene](https://mod-file.dn.nexoncdn.co.kr/bbs/165847431530038c061258d764f4183969cb9c60201df.png)

# SideViewRectTile 맵 만들기

SideViewRectTile 모드로 맵을 만드는 것은 전반적으로 RectTileMap 제작 과정과 동일합니다. 이번 시간에는 아래와 같이 간단한 SideViewRectTile 맵을 만들어봅시다. ![sideviewmap](https://mod-file.dn.nexoncdn.co.kr/bbs/1658474735348794bdba4e80f40338aefc482a15595e0.png)

먼저 아래 4개의 이미지를 저장한 뒤, 예제를 살펴봅시다. ![tundraRight](https://mod-file.dn.nexoncdn.co.kr/bbs/16584737735555de4cfef1e6846b881fb08dd974e18f1.png) ![tundraMid](https://mod-file.dn.nexoncdn.co.kr/bbs/1658473786750f09028c3d7164a2694e9f0a099456a1c.png) ![tundraLeft](https://mod-file.dn.nexoncdn.co.kr/bbs/1658473808386f01655943b5f452a842aaf7f7ba3c4a6.png) ![ice](https://mod-file.dn.nexoncdn.co.kr/bbs/1658473825666f3080a29dece4ce685465b7018636cbe.png)

1. 타일 모드를 **SideViewRectTile**로 변경합니다.
2. 위에서 저장했던 4개의 이미지를 ![resourcestorage](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_resource_storage.png) Resource Storage - 내 리소스 - etc에 추가합니다. ![rs](https://mod-file.dn.nexoncdn.co.kr/bbs/1658475210960ed4d68009339425b894f180174bb7bd7.png)
3. ![preset](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_asset.png)Preset List - Background에서 back-4를 검색한 뒤 선택하여 맵의 배경을 변경합니다. ![bg](https://mod-file.dn.nexoncdn.co.kr/bbs/1658475486669606fbfbe07024b8dad2697df10431fec.png)
4. 타일 셋 팔레트 좌측 상단의 "+" 버튼을 누르고 **Create Empty TileSet**을 선택합니다. 새 타일 셋의 이름을 **TileSet**으로 입력합니다. ![newtileset](https://mod-file.dn.nexoncdn.co.kr/bbs/1658475711945ea21f592fcdb4a90a3e75c8a22e34d85.png)
5. 타일 셋 팔레트 하단의 ![add](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_addtile_rect.png) 타일 추가 버튼을 누른 뒤 **Add ResourceStorage Image**를 선택합니다. ![add](https://mod-file.dn.nexoncdn.co.kr/bbs/1658476061494e0157e24c4f94541828910e14356cc6f.png)
6. Resource Picker에서 미리 추가해두었던 이미지를 선택합니다. ![picker](https://mod-file.dn.nexoncdn.co.kr/bbs/1681090546377990fe7a74f8944eba5c211259fed8919.png)
7. 타일 셋에서 타일을 선택해 원하는 대로 맵을 꾸며줍니다. 맵에 어울리는 오브젝트도 배치합니다. ![mapedit](https://mod-file.dn.nexoncdn.co.kr/bbs/16584776165678f4bf1e92d9845bcb7a0745d3802952d.png)
8. 타일 위에 캐릭터가 설 수 있도록 타일을 이동 불가로 설정합니다. ![move](https://mod-file.dn.nexoncdn.co.kr/bbs/1658477949218d34942db72a14aaaac72a17787948e87.gif)
9. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작 버튼을 눌러 횡스크롤 이동이 잘 되는지 확인해봅시다. ![play](https://mod-file.dn.nexoncdn.co.kr/bbs/1658478611789db5a20547f4f40a5bec1c0b961ad97a7.gif)

> **더 알아보기** SideViewRectTile에서의 이동은 [SideViewRectTileMap에서 캐릭터 이동 제어](/docs?postId=759)를 참고해주세요.

Update 2025-11-17 PM 08:14


# 메이플 이동 개념 이해하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드 제작에 필수적인 이동 방식 중 메이플스토리 이동 방식을 따르는 RigidbodyComponent 특성을 알아봅시다. 이동은 [메이플 타일 맵 만들기](/docs?postId=747)와 함께 학습하기 권장합니다.

# 메이플스토리 이동 방식

RigidbodyComponent는 메이플스토리 이동 방식처럼 이동하고자 할 때 사용합니다. 이동 방식은 지형 종류와 밀접한 연관이 있기에 TileMapComponent를 함께 사용해 메이플스토리식 이동 방식을 만들 수 있습니다. 이때 타일 위에서 이동은 RigidbodyComponent에서 관리합니다.

> **Tip.** 플레이어 캐릭터는 이동하는 동안 가속도 운동을 하므로 WalkAcceleration, WalkDrag, WalkSlant 같은 이동 속성 프로퍼티들은 RigidbodyComponent와 지형의 이동 속성 모두에게 관여하게 됩니다.

# 기본 이동

RigidbodyComponent의 기본 이동 방식을 알아봅시다.

#### 발판 위에서 이동

플레이어는 특별한 이동 변화가 없는 이상 현재 밟고 있는 발판 위만 밟으며 계속 이동합니다. 그러다 발판과 떨어지면 해당 발판과의 관계가 끊어지고, 다음 밟은 발판 이동 규칙을 따르게 됩니다. 아래 그림처럼 빨간색 발판을 밟고 있는 플레이어는 초록색 발판과 교차하는 지점을 지나가더라도 초록색 발판으로 옮겨 가며 이동하지 않습니다. 그러나 빨간색과 초록색 발판이 겹치는 지점에서 플레이어 캐릭터가 점프한다면 초록색 발판을 밟게 되고, 초록색 발판 이동 규칙을 따라 이동하게 됩니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1658193798420c9b8127ab85542ac8c25008d67ca62e6.png)

![1-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16581938215047ccafa3686d54c30a7ed3194be7c793a.gif)

#### 수직 발판 이동 제한

바닥과 이어진 수직 발판은 플레이어 캐릭터의 이동을 막습니다.

![blocked2](https://mod-file.dn.nexoncdn.co.kr/bbs/165822007557308684a3bc9b44795a843406f14f5b8b9.gif)

#### 발판을 벗어난 이동

- **내려갈 때**: 발판을 밟고 있지 않을 때는 중력의 영향을 받아 아래로 내려가는 것이 기본 이동 방식입니다. 플레이어 캐릭터는 아래로 떨어지다가 발판을 만나면 하강을 중지하고 착지합니다. 착지한 캐릭터는 다시 발판 위 이동 규칙을 따르게 됩니다.
- **올라갈 때**: 플레이어 캐릭터가 위로 올라가는 도중에 다른 발판을 만나더라도 무시하고 통과하며 올라갈 수 있습니다. ![UP](https://mod-file.dn.nexoncdn.co.kr/bbs/1658883585804ef670a8a5f244cd49d1aaee440b64e30.gif)

# 심화 이동

#### 지형 Layer

Map Layer는 10개까지 생성할 수 있고, 레이어마다 고유한 타일을 사용합니다. 이는 다른 레이어에서 동일한 모양의 패턴을 그릴 수 있다는 의미입니다. 그러나 타일이 속한 Layer가 다르므로 서로 다른 발판으로 생성됩니다. 그러므로 Layer가 다르면 발판은 하나로 이어져 있지 않습니다. 어떤 월드에서 서로 다른 모양의 타일이 이어져 있고, 그 발판들을 자연스럽게 떨어지지 않고 잘 걷고 있을지라도 실제로는 밟고 있는 발판 정보가 바뀌게 됩니다.

아래처럼 Layer 1과 2에 동일한 모양의 타일을 일정 부분 겹치게 그렸습니다. 플레이어 캐릭터가 Layer 1에서 2로 이동할 때는 수직 발판을 통과할 수 있지만, Layer 2의 발판에서 1로 이동할 때는 수직선 발판에 막혀 이동할 수 없습니다. Layer 1에 속할 때는 Layer 2에 속한 수직선 발판을 무시하기 때문에 이동할 수 있습니다.

![maplayer2](https://mod-file.dn.nexoncdn.co.kr/bbs/16593207875474437a8ce52584df9bd06b8487e5d5dec.png)![maplayerblocked](https://mod-file.dn.nexoncdn.co.kr/bbs/165823394560592e2768650e94a9fb15284bd030a570a.gif)

#### SortingLayer

대부분의 SortingLayer는 크리에이터가 스크립트에서 변경하지 않는 이상 자동으로 변경되어 씬에서 보이는 순서가 바뀌는 일은 없습니다. 그러나 엔티티에 RigidbodyComponent가 있을 때는 보이는 순서가 바뀔 수 있습니다. RigidbodyComponent가 있는 엔티티, 예를 들어 플레이어 캐릭터의 SortingLayer는 현재 밟고 있는 TileMap Layer를 따라 변경됩니다. 아래처럼 다른 MapLayer에 타일 일부가 겹치게 그리고, Layer 2에 수풀 오브젝트를 배치했습니다. 플레이어 캐릭터가 Layer 1에서 Layer 2로 이동한다면 Layer 2가 더 앞에 보이는 Layer이므로 플레이어 캐릭터가 수풀 뒤에 그려지다, Layer 2를 밟으면 수풀 앞에 배치되어 보입니다. ![SortingLayer](https://mod-file.dn.nexoncdn.co.kr/bbs/1658231806874225549d7abfd4083aa75e5de3ed69aaf.gif)

#### 수직선 지형

가로 지형 발판(지면)과 이어진 수직 발판은 RigidbodyComponent의 이동을 막는 벽이 됩니다. 하지만 지면 발판과 떨어져 있는 수직 발판은 RigidbodyComponent가 통과할 수 있습니다. ![notblocked](https://mod-file.dn.nexoncdn.co.kr/bbs/16588846011832681a46df73b40e09ecf4140c57c09ce.gif)

# 메이플스토리와 다른 이동 만들기

#### 수직선 지형

지면 발판과 붙어있든, 떨어져 있든 점프로 수직 발판을 통과하지 못하게 만들고 싶다면 RigidbodyComponent의 **IsBlockvertialLine**을 활성화합니다.

| IsBlockvertialLine활성화 | IsBlockvertialLine비활성화 |
| --- | --- |
| ![BlockedTrue](https://mod-file.dn.nexoncdn.co.kr/bbs/165830397057921277d58d2954629b55e8db6b9ca6d99.gif) | ![BlockedFalse](https://mod-file.dn.nexoncdn.co.kr/bbs/1658304402181bdd5063510e848f090ae484b1467f48e.gif) |

##### 특정 레이어의 수직선 지형만 막기

RigidbodyComponent의 **IsBlockvertialLine**를 활성화하면 맵 내부의 모든 수직 지형을 통과하지 못합니다. 만약 일부 맵 레이어에서만 RigidbodyComponent가 수직 지형을 통과하지 못하게 막고 싶다면, 해당 맵 레이어의 **TileMapComponent - IsBlockvertialLine**을 활성화합니다.

예를 들어 봅시다. 아래와 같이 맵 레이어 2개를 만든 뒤, 잔디 타일은 수직 지형을 통과할 수 있게 두고, 돌 타일은 통과하지 못하게 설정해 봅시다. ![v01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681114270716dcd0db08af484f42987ea977046172d4.png)

**Hierarchy**에서 **MapleMapLayer_1**을 선택한 뒤 프로퍼티 에디터를 보면 **MapLayerName**이 돌 타일인 **Layer2**로 설정되어 있습니다. ![v02](https://mod-file.dn.nexoncdn.co.kr/bbs/16811145893012649f50aa9c84d239be7289931be4c5b.png)

**TileMap_1**을 선택한 뒤, **TileMapComponent**에서 **IsVerticalLine**을 활성화합니다. ![v03](https://mod-file.dn.nexoncdn.co.kr/bbs/1681114736635e34bcba0a8e84b7d9588196e14f563c8.png)

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 잔디 타일은 수직 지형을 통과할 수 있지만, 돌 타일의 수직 지형은 점프했을 때 막히는 것을 확인할 수 있습니다. ![v04](https://mod-file.dn.nexoncdn.co.kr/bbs/1681115054201040f1c2e91564fe4919afebd2bcd9b7d.gif)

#### 맵 바운더리

맵 바운더리를 무시하고, 맵 지형 밖에서도 이동하게 만들고 싶다면 RigidbodyComponent의 **IgnoreMoveBoundary** 프로퍼티를 활성화합니다.

#### LayerSettingType

**RigidbodyComponent의 LayerSettingType** 타입을 변경해 메이플스토리 이동을 따르게 설정합니다. 혹은 사다리/로프/발판의 SortingLayer와 RigidbodyComponent를 가진 Entity의 SortingLayer들과의 관계를 변경해 메이플스토리 이동과 다르게 설정할 수 있습니다.

아래와 같이 Layer1에 타일을 그리고, Layer1,2,3,4에 각각 사다리를 배치했을 때 각 타입에 따라 아바타와 사다리의 관계가 어떻게 변하는지 살펴보겠습니다. DefaultPlayer에는 RigidbodyComponent와 AvatarRendererComponent가 함께 있습니다. RigidbodyComponent의 LayerSettingType을 변경했을 때 AvatarRendererComponent의 SortingLayer가 어떻게 변하는지 확인해보겠습니다.

![layer](https://mod-file.dn.nexoncdn.co.kr/bbs/16740182831894ef72030e7074c09ab7a37a5e34bc3e0.png)

- **All**: 메이플스토리 이동을 따릅니다. RigidbodyComponent가 발판을 밟고 있을 때는 **발판의 SortingLayer**를 따라갑니다. 사다리/로프를 타고 있을 때는 AvatarRendererComponent의 SortingLayer 값이 **탄 사다리의 SortingLayer** 값을 따라갑니다. ![all](https://mod-file.dn.nexoncdn.co.kr/bbs/16739467083350b8e1b78aa7f4626a6aa3a10630ee873.gif)
- **Climbable**: RigidbodyComponent가 마지막으로 탔던 **사다리/로프의 SortingLayer**를 기준으로 AvatarRendererComponent의 SortingLayer 값이 바뀝니다. 아바타가 사다리에서 내려와 발판을 밟아도 사다리의 SortingLayer 값을 따릅니다. ![climable](https://mod-file.dn.nexoncdn.co.kr/bbs/1673946686984683664c7c7484952b78440846bdcf879.gif)
- **None**: 크리에이터가 설정한 **RigidbodyComponent를 가진 Entity의 SortingLayer**를 따릅니다. 아래 예시의 AvatarRendererComponent의 SortingLayer 값은 Default입니다. 그러므로 어떤 사다리를 타더라도 SortingLayer 값은 Default로 유지됩니다. ![none](https://mod-file.dn.nexoncdn.co.kr/bbs/1673946729714d6916a24f5b1426ea7df4a97d8a71964.gif)

##### 참고 가이드

- [발판 만들기](/docs/?postId=71)
- [이동 발판 만들기](/docs/?postId=579)
- [맵 레이어](/docs?postId=53)
- [메이플스토리 타일 맵](/docs/?postId=747)

##### 참고 API Reference

- [RigidbodyComponent](/apiReference?postId=378)
- [MapComponent](/apiReference?postId=358)
- [TileMapComponent](/apiReference?postId=379)

Update 2025-11-17 PM 08:14


# MovementComponent를 활용한 엔티티의 이동 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 점프, 플레이어 이동 및 엔티티 좌표 설정 등 MovementComponent가 제공하는 주요 기능들과 MovementComponent의 기본 작동 방식에 대해 알아봅니다.

# MovementComponent 소개

**MovementComponent**는 캐릭터의 이동속도와 점프력 설정은 물론 RigidbodyComponent가 포함된 엔티티를 강제로 점프시키거나 이동 또는 정지시킬 수 있는 여러 기능을 제공합니다. 스크립트 컴포넌트를 통해 TransformComponent를 제어하여 동적으로 엔티티를 이동시킬 수 있지만, 만일 엔티티에 RigidbodyComponent가 포함되어 있는 경우 RigidbodyComponent 또한 TransformComponent를 제어하기 때문에 의도한대로 이동하지 않을 수 있습니다. MovementComponent는 엔티티에 RigidbodyComponent 포함 여부를 체크하여 TransformComponent 또는 RigidbodyComponent를 제어하여 이동시킵니다. 따라서 제작자가 직접 RigidbodyComponent의 포함 여부를 체크할 필요 없이 MovementComponent를 이용해 쉽게 엔티티의 이동을 제어할 수 있습니다.

> **Tip.** **KinematicbodyComponent**와 **SideviewbodyComponent**도 동일하게 제어할 수 있습니다.

# 플레이어의 이동 관련

#### 플레이어 이동 속도 설정

플레이어의 이동 속도는 **InputSpeed**를 통해 설정합니다. 조작키(방향키)를 눌렀을 때 얼마만큼의 힘으로 엔티티를 이동시킬지를 설정하는 프로퍼티로 플레이어 엔티티에만 유효합니다. 입력된 값이 크면 클수록 플레이어 엔티티의 속도가 빨라집니다.

| InputSpeed = 1.2 | InputSpeed = 3 | InputSpeed = 5 |
| --- | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16560435039321a16b7ea2c7148098f921cc915250d8e.gif) | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/165604352590254034248ce564039be047668cf8da65b.gif) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1656043549528b8d89f6ae69347248beb409c73e868e0.gif) |

#### 사다리에서의 정지 여부 확인

플레이어가 사다리에서 이동을 멈추었는지는**IsClimbPaused** 프로퍼티를 통해 확인할 수 있습니다. 엔티티가 사다리 또는 로프 위에서 멈춰있는 상태인지를 확인할 수 있는 프로퍼티로, 플레이어 엔티티에만 유효합니다. IsClimbPaused는 boolean 타입으로 플레이어 엔티티가 사다리에서 이동 중 멈춰있을 때 true를 읽어올 수 있습니다. ReadOnly 프로퍼티이기 때문에 읽기만 가능합니다.

```
[server only]
void OnUpdate(number delta)
{
    local isClimbPaused = self.Entity.MovementComponent.IsClimbPaused
    log(isClimbPaused)
}
```

![isclimbpaused](https://mod-file.dn.nexoncdn.co.kr/bbs/1656043847301b2708b6a8c8740c5b3fd687fee8dd93a.gif)

#### 플레이어가 바라보고 있는 방향 확인

플레이어가 바라보고 있는 방향은 **IsFaceLeft** 함수를 통해 확인할 수 있습니다. 플레이어 엔티티 전용 함수로 플레이어 엔티티가 좌측을 바라보면 true를, 그렇지 않으면 false를 리턴합니다.

```
[serive: InputService]
HandleKeyUpEvnet(KeyUpEvent event)
{
	-- Parameters
	local key = event.key
	--------------------------------------------------------
	--좌우 키를 입력할 때마다 플레이어가 좌측을 향하고 있으면 콘솔 창에 true를 출력합니다.
	if key == KeyboardKey.LeftArrow or key == KeyboardKey.RightArrow then
		log(self.Entity.MovementComponent:IsFaceLeft())
	end
}
```

![isfaceleft](https://mod-file.dn.nexoncdn.co.kr/bbs/1656043891044e47a017f5f0746648ec1081bf5829c3c.gif)

# 엔티티 점프 관련

#### 엔티티 점프

MovementComponent의 **Jump** 함수는 엔티티를 JumpForce에 입력한 힘만큼 점프시킵니다. boolean 타입으로 점프에 성공한 경우 true를 리턴합니다. 엔티티에 RigidbodyComponent가 함께 있어야 작동하며, RigidbodyComponent가 없으면 false를 리턴합니다. 동기화를 위해 일반적으로 server 공간에서 호출하는 것이 좋지만, 플레이어 엔티티의 경우에는 client에서 호출해야 합니다.

```
[server only]
void OnUpdate(number delta)
{
    -- 플레이어 엔티티인 경우 실행 제어 공간을 client 또는 client only로 변경합니다.
	if self._T.accTime == nil then 
		self._T.accTime = 0 
	end
	
	self._T.accTime = self._T.accTime + delta
	
	--3초마다 엔티티를 점프시킵니다.
	if self._T.accTime >= 3 then
		self.Entity.MovementComponent:Jump()
		self._T.accTime = 0
	end
}
```

![jump](https://mod-file.dn.nexoncdn.co.kr/bbs/1656043915462a19ef1f74b3a4006ba2e0f38f492f7d1.gif)

#### 점프력 설정

**JumpForce**는 엔티티가 점프했을 때 얼마나 높이 뛸지를 설정할 수 있는 프로퍼티로, MovementComponent의 Jump함수가 호출되었을 때 JumpForce값이 점프력으로 반영됩니다.

| JumpForce = 1 | JumpForce = 3 | JumpForce = 5 |
| --- | --- | --- |
| ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16560437341534e08dd0a7a2d4eeba225a5b7b7e99282.gif) | ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1656043756640d0205b1f8b7f4b5f95a941c61ca310f7.gif) | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16560437769096cd53f7210b74a1f8a08694f05ddeb9b.gif) |

#### 다운 점프

**DownJump**는 엔티티가 놓여진 풋홀드 아래에 또다른 풋홀드가 존재할 경우, 엔티티를 아래 풋홀드로 이동시키는 함수입니다. RigidbodyComponent가 있을 때 작동하며, RigidbodyComponent가 없다면 무시됩니다. 리턴 타입은 boolean으로 엔티티가 정상적으로 이동한 경우 true를 리턴합니다. 만일 아래와 같이 작성된 컴포넌트를 MovementComponent와 RigidbodyComponent가 있는 엔티티에 추가하면, 3초마다 아래 풋홀드로 내려가는 것을 볼 수 있습니다. Jump와 마찬가지로 플레이어 엔티티를 다운 점프시킬 때에는 client에서 호출합니다.

```
[server only]
void OnUpdate(number delta) 
{
    -- 플레이어 엔티티인 경우 실행 제어 공간을 client 또는 client only로 변경합니다.
	if self._T.accTime == nil then 
		self._T.accTime = 0 
	end
	
	self._T.accTime = self._T.accTime + delta
	
	--3초마다 엔티티를 다운 점프시킵니다.
	if self._T.accTime >= 3 then
		self.Entity.MovementComponent:DownJump()
		self._T.accTime = 0
	end
}
```

![downjump](https://mod-file.dn.nexoncdn.co.kr/bbs/165604394157048172dcceb554c5f99f7bca5f20aca41.gif)

> **더 알아보기** 플레이어 엔티티의 RigidbodyComponent는 다른 엔티티의 컴포넌트처럼 server에서 client로 동기화 되는 것이 아닌, client에서 server로 동기화되기 때문에 플레이어의 RigidbodyComponent는 client 공간에서 제어하는 것이 좋습니다.

# 엔티티 이동

#### 엔티티 좌표 이동

MovementComponent에서는 SetPosition 함수를 통해 엔티티의 좌표를 설정합니다. `SetPosition()`함수는 기본적으로 TransformComponent의 Position을 설정하지만, RigidbodyComponent가 엔티티에 포함되어 있을 경우 RigidbodyComponent를 통해 Position을 설정합니다. 매개 변수로 Vector2 값을 받으며, 이 값에 해당하는 좌표로 엔티티가 이동합니다.

```
[server only]	
void OnUpdate(number delta)
{
    local deltaX = 1
    local pos = self.Entity.TransformComponent.Position
    pos.x = pos.x + deltaX * delta
    local deltaPos = Vector2(pos.x, pos.y)
    self.Entity.MovementComponent:SetPosition(deltaPos)
}
```

![setposition](https://mod-file.dn.nexoncdn.co.kr/bbs/16560439621203295e712472d457299cb202c757c42ef.gif)

Update 2025-11-20 PM 02:03


# RectTileMap에서 캐릭터 이동 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

RectTileMap에서는 KinematicbodyComponent로 캐릭터의 이동을 제어합니다. 크리에이터는 KinematicbodyComponent를 통해 캐릭터를 2차원 평면에서 자유롭게 움직이고 점프하게 할 수 있습니다. 또한 그림자를 그릴 수도 있습니다. 이번 시간에는 KinematicbodyComponent에 대해 알아보고 간단한 예제를 통해 활용법을 살펴봅시다.

##### 참고 API Reference

[KinematicbodyComponent](/apiReference/Components/KinematicbodyComponent)

> **더 알아보기** RectTileMap에 대한 내용은 [RectTileMap의 활용](docs?postId=589)을 참고하세요.

# KinematicbodyComponent 소개

**Workspace - DefaultPlayer - Property** 창에서 **KinematicbodyComponent**의 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| Acceleration | 더 이상 사용하지 않습니다. SpeedFactor를 사용해주세요. |
| ApplyClimbableRotation | True인 경우 회전하거나 기울어진 사다리를 탄 캐릭터는 사다리의 모습을 따릅니다. False인 경우 캐릭터는 사다리의 기울기, 회전에 영향을 받지 않습니다. |
| EnableJump | True면 점프 기능을 사용합니다. |
| EnableShadow | True면 그림자를 사용합니다. |
| ShadowColor | 그림자의 색상입니다. |
| ShadowOffset | 그림자의 위치입니다. |
| ShadowSize | 그림자의 크기입니다. |
| ShadowScalingRatio | 그림자 크기 변화율입니다. Entity의 점프 높이에 따라 크기가 변화합니다. |
| EnableTileCollision | True면 사각형 타일맵과 충돌합니다. |
| JumpDrag | 점프 속력 감소량을 조절합니다. 값이 클수록 지면에 더 빨리 떨어집니다. |
| JumpSpeed | 점프할 때 튀어 오르는 속력을 조절합니다. 값이 클수록 더 높이 점프합니다. |
| SpeedFactor | 이동할 때 X축, Y축 속력에 곱해지는 가중치입니다. 값이 클수록 이동 속력이 빨라집니다. |
| Enable | True면 KinematicbodyComponent를 활성화합니다. |

# KinematicbodyComponent 활용

## 속도 증가 타일 만들기

밟으면 속도가 증가하는 타일을 만들어 봅시다.

1. 타일맵 모드를 RectTile로 설정합니다. ![recttile](https://mod-file.dn.nexoncdn.co.kr/bbs/16582959899857d48535b46064d39a8b24d45268f5e02.png)
2. 타일 셋 팔레트 좌측 상단의 **[+]** 버튼을 누른 뒤, **Create TileSet From Template - BnB** 타일 셋을 선택합니다. ![tileset](https://mod-file.dn.nexoncdn.co.kr/bbs/169034747395370bf20b37bcd4b86900f6f1b9c52284f.png)
3. 타일 셋의 이름을 **BnB TileSet**으로 설정합니다. ![BnB](https://mod-file.dn.nexoncdn.co.kr/bbs/1690347500526ff0abc6e49f34688b95fbe284a378453.png)
4. 타일 셋 팔레트 우측 상단의 편집 버튼을 눌러 타일 속성 편집 모드로 들어갑니다. ![tileedit](https://mod-file.dn.nexoncdn.co.kr/bbs/1658300856970ff2537ee3b9f46a7a74b1756bf4d48cb.png)
5. 편집 대상에서 **이동 가능 여부**를 체크한 뒤, 캐릭터가 이동하지 못하게 할 타일을 선택합니다. 초록색 화살표 아이콘은 이동 가능 타일, 빨간색 화살표 아이콘은 이동 불가 타일임을 나타냅니다. ![dontmove](https://mod-file.dn.nexoncdn.co.kr/bbs/16583010193566a5de34f71cc43d3b1144241c5a25f86.gif) 편집이 끝나면 편집 모드를 해제합니다.
6. **Map Layer**에서 Layer1을 선택한 뒤 맵을 만들어줍니다. ![map1](https://mod-file.dn.nexoncdn.co.kr/bbs/16582986986052598c60d8a5c4f97bd12a101ee3feaba.png)
7. **Map Layer**에서 ![addlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_swatches_add.png) 버튼을 눌러 Layer2를 만든 뒤 집, 나무 등을 배치하여 추가로 맵을 꾸며줍니다. ![map2](https://mod-file.dn.nexoncdn.co.kr/bbs/16582993425778cfc274e817a4e18876539fddcf14ec2.png)
8. **Map Layer**에서 ![addlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_swatches_add.png) 버튼을 눌러 Layer3을 추가합니다. ![layer](https://mod-file.dn.nexoncdn.co.kr/bbs/16589727962500e6f27c08a514189afcd6c49e7ad6047.png)
9. . 타일 셋 팔레트 좌측 상단의 **[+]** 버튼을 누른 뒤, **Create Empty TileSet**을 선택합니다. **Buff TileSet**이라는 이름으로 새 타일 셋을 추가합니다.
10. 타일 셋 팔레트 좌측 하단의 ![add](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_addtile_rect.png) 타일 추가 버튼을 누른 뒤 **Add ResourceStorage Image**를 선택합니다. ![addtile](https://mod-file.dn.nexoncdn.co.kr/bbs/1690349260069399d7e9a5a21497d9c52ec63ab26c4c2.png)
11. **Resource Picker - MSW 리소스**에서 아래의 RUID로 검색된 스프라이트를 클릭해 타일 셋에 추가합니다. **Buff** : 02652c247d9d40518702255bed1376c8 **Trap** : 510cf1b467634a3db7624041432c3de5 ![buff](https://mod-file.dn.nexoncdn.co.kr/bbs/1681089901719aaffc22778cf4002bfb94d014335dba1.png) ![trap](https://mod-file.dn.nexoncdn.co.kr/bbs/168108991743400ee8085f2a9498bbd7de0ec45f07c9f.png)
12. 타일 속성 편집 모드로 들어간 뒤 이름을 더블클릭해 각각 **Buff, Trap**으로 설정합니다. ![rename](https://mod-file.dn.nexoncdn.co.kr/bbs/1658302497559e3e8a975004c4a788dd4b95635d907de.gif) 편집이 끝나면 편집 모드를 해제합니다.
13. **Map Layer**에서 Layer3을 선택한 상태로 맵에 Buff 타일을 배치합니다.
14. **MyDesk** 아래에 새 스크립트 컴포넌트 **CheckSpeedBuffTile**를 만든 뒤, **DefaultPlayer**에 추가합니다.
15. 아래와 같이 **CheckSpeedBuffTile**를 작성합니다.```
Method:
[server]
void IncreaseSpeedFactor()
{
    local kb = self.Entity.KinematicbodyComponent
    local oldSpeedFactor = kb.SpeedFactor
    local newSpeedFactor = Vector2(oldSpeedFactor.x + 1, oldSpeedFactor.y + 1)

    kb.SpeedFactor = newSpeedFactor
}

Event Handler :
[client only]
HandleRectTileEnterEvent(RectTileEnterEvent event)
{
    -- Parameters
    local Kinematicbody = event.Kinematicbody
    local TileInfo = event.TileInfo
    local TileMap = event.TileMap
    local TilePosition = event.TilePosition
    --------------------------------------------------------  

    -- 'Buff' 타일을 밟으면 SpeedFactor를 증가시킵니다.
    if TileInfo.Name == "Buff" and Kinematicbody:IsOnGround() then
        self:IncreaseSpeedFactor()
    end
}
```
16. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작 버튼을 눌러 버프 타일을 밟으면 속력이 조금씩 증가하는 것을 확인해봅시다. ![speedup](https://mod-file.dn.nexoncdn.co.kr/bbs/165830449805569dd931c42f04da08e73ac13afcbf882.gif)

## 장애물 타일 피하기

점프로만 넘어갈 수 있는 장애물을 만들고, 장애물을 밟으면 캐릭터가 죽도록 설정해 봅시다.

1. 맵에 Trap 타일을 배치합니다.
2. **MyDesk** 아래에 새 스크립트 컴포넌트 **CheckTrapTile**를 만든 뒤, **DefaultPlayer**에 추가합니다.
3. 아래와 같이 **CheckTrapTile**을 작성합니다.```
Property:
[None]
string CurrentTileName = ""

Method:
[client only]
void OnUpdate(number delta)
{
    local kb = self.Entity.KinematicbodyComponent

    -- 지면에 있을 때만 타일과 충돌합니다.
    kb.EnableTileCollision = kb:IsOnGround()

    -- 'Trap' 타일을 밟으면 죽습니다. 신중하게 점프하세요!
    if self.CurrentTileName == "Trap" and kb:IsOnGround() then
        self.Entity.PlayerComponent:ProcessDead()
    end
}

Event Handler:
[client only]
HandleRectTileEnterEvent(RectTileEnterEvent event)
{
    -- Parameters
    local Kinematicbody = event.Kinematicbody
    local TileInfo = event.TileInfo
    local TileMap = event.TileMap
    local TilePosition = event.TilePosition
    --------------------------------------------------------

    self.CurrentTileName = TileInfo.Name
}
```
4. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작 버튼을 눌러 Trap을 뛰어넘을 수 있고, 실수로 밟게 되면 캐릭터가 죽는지 확인해봅시다. ![trap](https://mod-file.dn.nexoncdn.co.kr/bbs/16583053608016b9cb5709e7749bcb2a121412c7d3c2f.gif)

Update 2025-11-17 PM 08:14


# SideViewRectTileMap에서 캐릭터 이동 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

DefaultPlayer에는 RigidbodyComponent, KinematicbodyComponent, SideviewbodyComponent가 모두 포함되어 있기 때문에 맵이 제작된 모드에 따라 자동으로 이동 제어의 주체가 달라집니다. 그중 SideViewRectTile 모드로 제작된 맵에서는 SideviewbodyComponent로 캐릭터의 이동을 제어합니다. 이번 시간에는 SideviewbodyComponent에 대해 알아보고 간단한 예제를 통해 활용법을 살펴봅시다.

##### 참고 API Reference

[SideviewbodyComponent](/apiReference/Components/SideviewbodyComponent)

> **더 알아보기** SideViewRectTile에 대한 내용은 [SideViewRectTile 모드로 맵 만들기](/docs/?postId=758)를 참고하세요.

# SideviewbodyComponent 소개

SideviewbodyComponent는 SideviewRectTile 맵에서 횡스크롤 방식의 캐릭터 이동을 제어할 때 사용합니다. ![workspace](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_workspace.png) Workspace - ![defaultplayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer - ![property](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_inspector.png) Property에서 ![move](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/move.png) SideviewbodyComponent를 살펴봅시다.

![sideviewbody](https://mod-file.dn.nexoncdn.co.kr/bbs/165871206539396a3c85df20c4f439e76b91157a57a82.png)

| 프로퍼티 | 설명 |
| :---: | --- |
| ApplyClimbableRotation | true인 경우 회전하거나 기울어진 사다리를 탄 캐릭터는 사다리의 모습을 따릅니다. false인 경우 캐릭터는 사다리의 기울기, 회전에 영향을 받지 않습니다. |
| EnableDownJump | 아래 점프 기능을 키거나 끕니다. |
| DownJumpSpeed | 아래 점프 시 위로 튀어 오르는 속력을 조절합니다. 값이 클수록 더 높게 점프합니다. |
| JumpDrag | 점프 속력 감소량을 조절합니다. 값이 클수록 지면에 더 빨리 떨어집니다. |
| JumpSpeed | 점프 시 튀어 오르는 속력을 조절합니다. 값이 클수록 더 높게 점프합니다. |
| Enable | True면 SideviewbodyComponent를 활성화합니다. |

# SideviewbodyComponent 활용

SideviewbodyComponent의 활용법을 알아봅시다. 먼저 [SideViewRectTile 모드로 맵 만들기](/docs/?postId=758)를 참고하여 아래의 맵을 만든 뒤, 이어서 본 가이드의 예제를 진행하는 것이 좋습니다. ![play](https://mod-file.dn.nexoncdn.co.kr/bbs/1658478611789db5a20547f4f40a5bec1c0b961ad97a7.gif)

## 2단 점프 구현하기

캐릭터의 이동은 `MoveVelocity`를 통해 제어합니다. `MoveVelocity`를 통해 간단한 2단 점프 기능을 만들어봅시다.

1. ![mydesk](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_folder_no.png)MyDesk 아래에 새 스크립트 컴포넌트 ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) DoubleJump를 만든 뒤, ![DefaultPlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer에 추가합니다.
2. 아래와 같이 ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) DoubleJump에 `IsDoubleJumping` 프로퍼티와 `TryDoubleJump` 함수를 추가합니다.```
Property:
[None]
boolean IsDoubleJumping = false

Method:
[client only]
void TryDoubleJump()
{
    local sb = self.Entity.SideviewbodyComponent

    -- 캐릭터가 아직 2단 점프를 수행하지 않았고, 공중에 있는 상태라면 속도의 Y축 값을 변경합니다.
    if self.IsDoubleJumping == false and sb:IsOnGround() == false then
        local jumpSpeed = sb.JumpSpeed
        local vel = sb.MoveVelocity

        vel.y = jumpSpeed
        sb.MoveVelocity = vel

        -- 캐릭터가 2단 점프를 하면 IsDoubleJumping를 true로 변경합니다.
        self.IsDoubleJumping = true
    end
}
``` 캐릭터가 아직 2단 점프를 수행하지 않았고, 공중에 있는 상태라면 속도의 Y축 값을 변경해줍니다. IsDoubleJumping 프로퍼티는 2단 점프를 수행하면 true가 되고 착지할 때 다시 false가 되는 상태 변수입니다.
3. 아래와 같이 `OnUpdate` 함수도 추가합니다.```
Method:
[client only]
void OnUpdate(number delta)
{
    local sb = self.Entity.SideviewbodyComponent

    -- 캐릭터가 착지하면 IsDoubleJumping를 false로 변경합니다.
    if sb:IsOnGround() then
        self.IsDoubleJumping = false
    end
}
```
4. 아래와 같이 ![event](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_mod_event_no.png) KeyDownEvent도 추가합니다.```
Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{  
    -- Parameters
    local key = event.key
    --------------------------------------------------------

    if key == KeyboardKey.LeftAlt or key == KeyboardKey.Space then
        self:TryDoubleJump()
    end
}
```
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해봅시다. LeftAlt나 Space 키를 입력하면 2단 점프를 할 수 있습니다. ![doublejump](https://mod-file.dn.nexoncdn.co.kr/bbs/165872170517526609c30a97c4a2e9a175212254925b8.gif)

## 미끄러운 타일 만들기

`MoveVelocity`를 응용하면 크리에이터가 의도하는 게임의 콘셉트에 맞게 캐릭터의 움직임을 만들어낼 수 있습니다. 이번 예제에서는 눈과 얼음이 가득한 필드라는 콘셉트에 맞게 가속도와 마찰력 개념을 추가해 미끄러운 길을 걷는 듯한 움직임을 만들어보겠습니다.

1. ![mydesk](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_folder_no.png)MyDesk 아래에 새 스크립트 컴포넌트 ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) CustomPlayerController를 만든 뒤, ![DefaultPlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer에 추가합니다.
2. ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png)CustomPlayerController를 연 뒤, 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
Vector2 InputDirection = Vector2(0,0)
[None]
boolean IsJumpKeyPressed = false
[None]
boolean IsCrouchKeyPressed = false
```
3. `OnBeginPlay` 함수를 추가하고 유저 입력을 직접 처리하기 위해 PlayerControllerComponent는 비활성화합니다.```
[client only]
void OnBeginPlay()
{
    -- 유저 입력을 직접 처리하기 위해 PlayerControllerComponent는 비활성화합니다.
    local controller = self.Entity.PlayerControllerComponent
    controller.Enable = false
}
```
4. ![event](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_mod_event_no.png)KeyDownEvent와 ![event](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_mod_event_no.png) KeyUpEvent를 추가하여 키 입력 상태를 기록합니다.```
Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------

    if key == KeyboardKey.RightArrow then
        self.InputDirection.x = self.InputDirection.x + 1
    end
    if key == KeyboardKey.LeftArrow then
        self.InputDirection.x = self.InputDirection.x - 1
    end
    if key == KeyboardKey.UpArrow then
        self.InputDirection.y = self.InputDirection.y + 1
    end
    if key == KeyboardKey.DownArrow then
        self.InputDirection.y = self.InputDirection.y - 1
        self.IsCrouchKeyPressed = true
    end
    if key == KeyboardKey.LeftAlt or key == KeyboardKey.Space then
        self.IsJumpKeyPressed = true
    end
}

[service: InputService]
HandleKeyUpEvent(KeyUpEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------

    if key == KeyboardKey.RightArrow then
        self.InputDirection.x = self.InputDirection.x - 1
    end
    if key == KeyboardKey.LeftArrow then
        self.InputDirection.x = self.InputDirection.x + 1
    end
    if key == KeyboardKey.UpArrow then
        self.InputDirection.y = self.InputDirection.y - 1
    end
    if key == KeyboardKey.DownArrow then
        self.InputDirection.y = self.InputDirection.y + 1
        self.IsCrouchKeyPressed = false
    end
    if key == KeyboardKey.LeftAlt or key == KeyboardKey.Space then
        self.IsJumpKeyPressed = false
    end
}
```
5. 가속도와 마찰력 기반으로 캐릭터의 이동을 계산해보겠습니다. 먼저 아래와 같이 프로퍼티를 추가해줍니다.```
Property:
[None]
number MaxSpeed = 4 -- 최대 속도
[None]
number Accel = 10 -- 가속도
[None]
number Drag = 8 -- 마찰력 
[None]
number AirAccel = 6 -- 공중 가속도
[None]
number AirDrag = 4 -- 공중 마찰력
```
6. 좀 더 나은 조작감을 위해 공중에서는 가속도와 마찰력의 값을 다르게 적용해봅시다. 아래와 같이 `GetAccel`, `GetDrag` 함수를 추가합니다.```
-- 지면에 있을 때와 공중에 있을 때 적절한 가속도 값을 반환해 줍니다.
Method:
number GetAccel()
{
    local body = self.Entity.SideviewbodyComponent

    if body:IsOnGround() then
        return self.Accel
    else
        return self.AirAccel
    end
}

-- 지면에 있을 때와 공중에 있을 때 적절한 마찰력 값을 반환해 줍니다.
number GetDrag()
{
    local body = self.Entity.SideviewbodyComponent

    if body:IsOnGround() then
        return self.Drag
    else
        return self.AirDrag
    end
}
```
7. 유저의 키 입력이 없을 때는 감속하고 키 입력이 있을 때는 가속하도록 설정해봅시다. 아래와 같이 `UpdateVelocity` 함수와 `SignOf` 함수를 추가합니다.```
number SignOf(number value)
{
    if value >= 0 then
        return 1
    else
        return -1
    end
}

void UpdateVelocity(number delta)
{
    local body = self.Entity.SideviewbodyComponent
    local vel = body.MoveVelocity

    if self.InputDirection.x == 0 then
        -- 입력이 없을 땐 감속합니다.
        if vel.x ~= 0 then
            local sign = self:SignOf(vel.x)
            local drag = self:GetDrag()
            vel.x = vel.x - drag * sign * delta

            if self:SignOf(vel.x) ~= sign then
                vel.x = 0
            end
        end
    else
        -- 입력이 있을 땐 가속합니다.
        local sign = self:SignOf(vel.x)
        local accel = self:GetAccel()
        vel.x = vel.x + self.InputDirection.x * accel * delta
        vel.x = math.min(vel.x * sign, self.MaxSpeed) * sign
    end

    -- 최종 계산 결과를 적용합니다.
    body.MoveVelocity = vel
}
```
8. `OnUpdate` 함수에서 `UpdateVelocity` 함수를 호출하도록 합니다.```
[client only]
void OnUpdate(number delta)
{  
    -- 속도 제어
    self:UpdateVelocity(delta)
}
```
9. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해봅시다. 좌우 이동이 미끄러지듯 부드럽게 되는 것을 확인할 수 있습니다. ![slide](https://mod-file.dn.nexoncdn.co.kr/bbs/1658730031714e5dd719655354d66878ba051e490182e.gif) 하지만 PlayerControllerComponent를 비활성화했기 때문에 아직은 캐릭터의 점프 동작이나 이동 애니메이션이 작동하지 않는 상태입니다. 정상 작동을 위해서 동작과 애니메이션 제어 함수를 추가해봅시다.
10. 다시 ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) CustomPlayerController를 연 뒤, 캐릭터의 동작을 제어하는 `UpdateAction` 함수를 추가합니다.```
void UpdateAction()
{
    local controller = self.Entity.PlayerControllerComponent
    local body = self.Entity.SideviewbodyComponent

    -- 엎드리기
    if self.IsCrouchKeyPressed and body:IsOnGround() then
        controller:ActionCrouch()
    end

    -- 점프 및 다운 점프
    if self.IsJumpKeyPressed and body:IsOnGround() then
        if self.IsCrouchKeyPressed then
            controller:ActionDownJump()
        else
            controller:ActionJump()
        end
    end
}
```
11. 캐릭터의 애니메이션을 제어하는 `UpdateAnimationState` 함수도 추가합니다.```
void UpdateAnimationState()
{
    local body = self.Entity.SideviewbodyComponent
    local state = self.Entity.StateComponent

    if body:IsOnGround() then
        if self.InputDirection.x ~= 0 then
            -- 걷는 애니메이션
            state:ChangeState("MOVE")
        elseif self.IsCrouchKeyPressed then
            -- 엎드리는 애니메이션
            state:ChangeState("CROUCH")
        else
            -- 서 있는 애니메이션
            state:ChangeState("IDLE")
        end
    else
        -- 공중에 떠 있는 애니메이션
        state:ChangeState("FALL")
    end
}
```
12. 캐릭터의 좌우 시선을 제어하는 `UpdateLookDirection` 함수도 추가합니다.```
void UpdateLookDirection()
{
    local controller = self.Entity.PlayerControllerComponent

    -- 플레이어가 바라보는 방향
    if self.InputDirection.x ~= 0 then
        if self:SignOf(self.InputDirection.x) < 0 then
            -- 왼쪽을 바라봅니다.
            controller.LookDirectionX = -1
        else
            -- 오른쪽을 바라봅니다.
            controller.LookDirectionX = 1
        end
    end
}
```
13. `OnUpdate` 함수에서 `UpdateAction`, `UpdateAnimationState`, `UpdateLookDirection`를 호출하도록 합니다.```
void OnUpdate(number delta)
{  
    -- 속도 제어
    self:UpdateVelocity(delta)

    -- 추가 : 동작 제어
    self:UpdateAction()

    -- 추가 : 애니메이션 제어
    self:UpdateAnimationState()

    -- 추가 : 좌우 시선 제어
    self:UpdateLookDirection()
}
```
14. ![workspace](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_workspace.png)Workspace - ![defaultplayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer - ![property](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_inspector.png) Property - ![move](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/move.png) SideviewbodyComponent에서 `EnableDownJump`에 체크합니다. `DownJumpSpeed` 값으로 3.3을 입력합니다. ![sideviewbody2](https://mod-file.dn.nexoncdn.co.kr/bbs/1658731157148bf72bff0378b464f9addc47a64839d56.png)
15. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해봅시다. 캐릭터의 동작 및 애니메이션, 시선 제어가 정상적으로 되는지 확인합니다. ![slide2](https://mod-file.dn.nexoncdn.co.kr/bbs/1658731907252ed230a57a59f4b899f347a4ba97f0ebf.gif)

## 더 미끄러운 타일 만들기

`GetUnderfootTile` 함수를 사용하면 캐릭터가 현재 밟고 있는 타일이 무엇인지 알 수 있습니다. 이를 이용해서 얼음 타일을 밟으면 마찰력이 감소해 더 많이 미끄러지는 기능을 만들어 보겠습니다.

1. ![mydesk](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_folder_no.png)MyDesk 아래에 새 스크립트 컴포넌트 ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) IceTileChecker를 만든 뒤, ![DefaultPlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer에 추가합니다.
2. ![scriptcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png)IceTileChecker를 연 뒤, 아래와 같이 프로퍼티를 추가합니다.```
Property :
[None]
number IceDrag = 2
[None]
number DefaultDrag = 0
```
3. `OnBeginPlay` 함수를 추가하고 아래와 같이 내용을 작성합니다.```
[client only]
void OnBeginPlay()
{
    self.DefaultDrag = self.Entity.CustomPlayerController.Drag
}
```
4. `OnUpdate` 함수를 추가하고 `GetUnderfootTile` 함수를 사용해 캐릭터가 밟은 타일이 "Ice"일 경우, 더 많이 미끄러지도록 해봅시다.```
[client only]
void OnUpdate(number delta)
{
    local customController = self.Entity.CustomPlayerController
    local body = self.Entity.SideviewbodyComponent
    local underfootTile = body:GetUnderfootTile()

    customController.Drag = self.DefaultDrag

    if underfootTile == nil then
        return
    end

    if underfootTile.Name == "Ice" then
        customController.Drag = self.IceDrag
    end
}
```
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해봅시다. 눈 타일보다 얼음 타일에서 더 잘 미끄러지는 것을 확인합니다. ![iceslide](https://mod-file.dn.nexoncdn.co.kr/bbs/16587333763832e690f96aaf64196b8a4bd6dfef571cd.gif)

Update 2025-11-17 PM 08:14


# 사다리와 로프 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

캐릭터가 사다리나 로프를 타면 수직으로 올라갈 수 있습니다. 이는 사다리나 로프의 동작과 연관된 **ClimbableComponent**가 있기 때문입니다. 이 컴포넌트를 활용하면 사다리, 로프뿐만 아니라 다른 오브젝트에서도 등반할 수 있습니다. 또한 크리에이터가 원하는 대로 등반 영역이나 등반 속도를 조절할 수 있습니다. 관련된 컴포넌트로 **ClimbableSpriteRendererComponent**도 있습니다. 이 컴포넌트는 사다리나 로프와 같이 머리, 몸통, 꼬리 형태의 스프라이트를 그리기 위한 용도로 사용됩니다. 이번 시간에는 위의 두 가지 컴포넌트를 살펴봅시다.

##### 참고 API Reference

[ClimbableComponent](/apiReference/Components/ClimbableComponent) [ClimbableSpriteRendererComponent](/apiReference/Components/ClimbableSpriteRendererComponent)

# ClimbableComponent

[ClimbableComponent](/apiReference/Components/ClimbableComponent)는 등반 액션과 관련된 사항을 설정합니다. **ClimbableComponent**의 프로퍼티를 살펴봅시다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16626264079829a7791304acd40db8bcb63b170f65d22.png)

| 프로퍼티 명 | 설명 |
| :---: | --- |
| Collider | Edit 버튼을 누른 후 등반 영역을 조절할 수 있습니다. |
| AllowHorizontalMove | 자유로운 등반 이동 여부를 설정합니다. true일 경우 X, Y 축 모두 이동 가능합니다. |
| ClimbableAnimationType | 캐릭터의 등반 애니메이션을 설정합니다. <br>Ladder 또는 Rope를 선택할 수 있습니다. |
| IsUseDefaultObjectBoxSize | 등반 영역 설정을 스프라이트 크기에 맞출지 설정합니다. <br>메이커 편집 모드에서만 동작합니다. <br>true일 경우에 Boxsize, BoxOffset을 자동으로 스프라이트 크기에 맞게 설정합니다. <br>false일 경우 Boxsize, BoxOffset을 임의로 설정할 수 있습니다. |
| SpeedFactor | 등반 시 X, Y축 속력에 곱해지는 가중치입니다. 값이 클수록 이동 속력이 빨라집니다. |

# ClimbableSpriteRendererComponent

[ClimbableSpriteRendererComponent](/apiReference/Components/ClimbableSpriteRendererComponent)는 사다리나 로프의 스프라이트를 설정하고 길이를 조절할 수 있습니다. 사다리나 로프는 ①머리, ②몸통, ③꼬리 부분으로 이루어져 있는데 그 길이를 늘리면 몸통 부분의 스프라이트가 반복되며 늘어납니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/166262931403925ecbf22b49a4917b916676ac2835e47.png)

**ClimbableSpriteRendererComponent**의 프로퍼티를 살펴봅시다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/167568565117370e633f438a04a19b05285b2f9cc1902.png)

| 프로퍼티 명 | 설명 |
| :---: | --- |
| FlipX | Sprite의 X축을 기준으로 반전 여부를 결정합니다. |
| FlipY | Sprite의 Y축을 기준으로 반전 여부를 결정합니다. |
| IgnoreMapLayerCheck | SortingLayer에 Map Layer 이름을 지정했을 때 자동 치환을 수행하지 않습니다. |
| MaterialId | 랜더러가 사용할 머티리얼의 ID를 지정합니다. |
| OrderInLayer | 같은 Layer 내의 우선순위를 결정합니다. 수가 클수록 앞에 보입니다. |
| SortingLayer | 2개 이상의 Entity가 겹쳤을 때 Sorting Layer에 따라 보이는 우선순위가 결정됩니다. <br> Map Layer 이름으로 지정하면 해당하는 Sorting Layer로 변경됩니다. |
| SpriteRUID | 사다리 몸통에 사용할 Sprite RUID를 설정합니다. |
| TiledSize | Y값을 변경해 사다리의 세로 높이를 설정 할 수 있습니다. X값 변경은 지원하지 않습니다. |
| Color | Sprite에 색깔을 씌웁니다. 기본 흰색일 경우에 원본의 색이 나옵니다. |

> **Tip.** 엔티티가 **ClimbableComponent**와 **ClimbableSpriteRendererComponent**를 모두 포함하고 있다면 등반 영역을 수동으로 조절할 수 없고, 무조건 오브젝트의 **BoxSize**를 등반 영역으로 사용합니다.

# 오브젝트를 사다리처럼 활용하기

1. 사다리처럼 활용하려는 오브젝트를 월드에 추가하겠습니다. 오브젝트를 추가하려는 map의 콘텍스트 메뉴로 들어가 **Create Entity - Create Empty**를 선택합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/168619968509130d481ace9ef49e19fb609ae4446ab5e.png)
2. 생성된 **EmptyEntity**의 이름을 **Net**로 변경합니다.
3. **Net**의 프로퍼티 에디터에서 **Add Component**를 눌러 **TransformComponent**를 추가합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/166303145507485459a1a3bf34f75be561c8837b6c2dd.png)
4. **Net**의 프로퍼티 에디터에서 **SpriteRendererComponent**를 추가하고, 그물 SpriteRUID를 입력합니다. 그러면 아래와 같이 그물 오브젝트가 나타납니다.
  - SpriteRUID : **3f5d1c1eddf9428e8ca1c5581f1453d4** ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16630319308118bab7fbc64d8412a843c3f7964e0b419.png)
5. **Net**의 프로퍼티 에디터에서 **ClimbableComponent**를 추가합니다.
6. **IsUseDefaultObjectBoxSize**의 체크박스를 해제해 **false**로 설정합니다. 이후 **Collider - [Edit]** 버튼을 눌러 등반 영역을 조절하면 **IsUseDefaultObjectBoxSize**의 **BoxOffset**과 **BoxSize**가 설정됩니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16630324973683251945ba48b41b1a2dfacdca51c87e6.png)
7. **AllowHorizontalMove**를 **True**로 설정하여 X, Y축 모두 이동 가능 하도록 설정해줍니다.
8. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 캐릭터가 그물을 타고 오르락내리락 하는 것을 확인할 수 있습니다. ![ladder](https://mod-file.dn.nexoncdn.co.kr/bbs/1663033197084cc25b9e0220d41339699fa7de794d565.gif)

Update 2025-11-17 PM 08:14


# 원하는 이미지 갖고 오기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임에 필요한 이미지 리소스를 찾아 메이커에서 활용할 수 있습니다.

# 이미지 불러오기

1. **Workspace - MyDesk**의 콘텍스트 메뉴를 열고, **Import From - Import Image**를 선택합니다. ![imageimport02](https://mod-file.dn.nexoncdn.co.kr/bbs/1687511864531a541669c7cc441c1985c2a9b4c307622.png)
2. 사용할 이미지를 선택하여 불러옵니다. **MyDesk** 하위에 불러온 이미지 파일이 개별 생성됩니다. ![imageimport03](https://mod-file.dn.nexoncdn.co.kr/bbs/16353942151556a266b763b3343f194c7b4b853fe7c55.png)
3. 원하는 방식으로 이미지를 활용합니다.

# 이미지 활용 방식

이미지를 배치하는 방법은 크게 3가지가 있습니다.

**첫 번째 방법**은 **Workspace - MyDesk**에서 사용할 이미지의 콘텍스트 메뉴를 열고 **Place To Hierarchy**를 클릭하는 것입니다. ![importimage04](https://mod-file.dn.nexoncdn.co.kr/bbs/1687512556186a61f88719dfd4f82994335f2831d5f49.png)  **두 번째 방법**은 **Workspace - MyDesk**에서 사용할 이미지를 **Scene**에 배치하는 것입니다. ![imageimport10](https://mod-file.dn.nexoncdn.co.kr/bbs/1656656308226c74e950564b4428db3edd9c04a2368c7.gif)  **세 번째 방법**은 **Workspace - NativeModel**에서 **Scene**에 배치하고, **Sprite RUID**와 **Image RUID** 값을 변경해 사용하는 것입니다. ![importimage05](https://mod-file.dn.nexoncdn.co.kr/bbs/1635395341076bd0bed7dba0d4a6c890d8eafec477074.png)

크리에이터가 사용하기 편한 방법으로 이미지를 활용해 봅시다.

##### 참고 가이드

[스프라이트 색상 조정](/docs?postId=116)

Update 2025-11-17 PM 08:14


# 아틀라스 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

아틀라스를 필요한 규격으로 잘라 다양하게 활용할 수 있습니다. 아틀라스 언패커의 구성과 사용 방법을 알아봅시다.

# 아틀라스 언패커 소개

아틀라스란 한 장의 이미지에 여러 개의 스프라이트가 함께 있는 이미지를 의미합니다. 아틀라스의 이미지를 잘라 렉트타일로 사용하는 등 다양하게 활용할 수 있습니다. 아틀라스 언패커는 아틀라스를 크리에이터가 개별의 스프라이트로 자르고 편집해 저장할 수 있습니다. 자른 스프라이트 중 필요한 것만 선택해 Resource Storage에 저장한 뒤 사용하거나, 바로 TileDataSet으로 넣어 렉트타일로 사용할 수 있습니다. 아틀라스 언패커에서 자를 수 있는 단일 아틀라스의 최대 크기는 2048*2048px이며, 최대 256 조각으로 자를 수 있습니다. ![AtlasUnpacker](https://mod-file.dn.nexoncdn.co.kr/bbs/1687513798252916899bf05f9499bbf19567965588c04.png)

| 번호 | 설명 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 파일 선택: 자를 이미지 파일을 외부에서 불러옵니다.<ul><li>All: 잘라진 모든 스프라이트의 목록 중 저장하고자 하는 특정 스프라이트만 선택하거나, 목록 전체를 선택 또는 선택 취소할 수 있습니다.</li><li>파일 이름 접두사: 자른 이미지를 저장하기 위해서 반드시 입력해야 하는 항목입니다. 입력한 이름 뒤에 수가 하나씩 커지며 '이름_숫자'로 저장됩니다.</li></ul> |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | <ul><li>자르기: 자르기 설정을 활용해 자를 셀의 개수 혹은 크기를 설정할 수 있습니다.</li><li>Scale: 이미지의 전체 크기를 확대, 축소하거나 원 상태로 되돌릴 수 있습니다.</li></ul> |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | <ul><li>카테고리: 자른 이미지가 저장될 카테고리를 선택합니다. 저장 시 선택한 카테고리로 Resource Storage에 저장됩니다.</li><li>렉트타일 셋에 추가: 자른 이미지를 선택한 렉트타일 셋에 추가합니다.</li><li>AnimationClip에 추가 : 이 옵션을 선택한 상태로 자른 이미지를 업로드하면 자른 이미지가 곧바로 AnimationClip Editor 창에 추가됩니다.</li></ul> |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 불러온 아틀라스를 확인할 수 있는 미리보기 창입니다. 마우스 오른쪽을 누른 채 이동하면 화면을 이동시킬 수 있습니다.<br>아틀라스를 자르면 이미지 위에 파란색 선이 생성됩니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 자른 이미지가 3번의 설정에 맞춰 저장됩니다. |

# 아틀라스 자르기

1. **Window - Atlas Unpacker**를 선택해 아틀라스 언패커 창을 엽니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16528540865389d7c47d2f2b747c99924d748f6c18163.png)
2. 파일 선택을 눌러 자를 아틀라스를 불러옵니다. 상단의 **자르기**를 누르고, 원하는 자르기 설정 값을 입력합니다.![02](https://mod-file.dn.nexoncdn.co.kr/bbs/168751554538180aaeefd2e4d4aa2ab647feed7edb273.png)
3. 자른 스프라이트 중 불필요한 이미지는 선택을 해제한 후 **[업로드]** 버튼을 눌러 이미지를 Resource Storage에 저장합니다.![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16875159466158034a64f151b4837a10bf671b671044a.png)

#### 셀 크기, 셀 개수 자르기

셀 크기는 설정한 X, Y 값에 따라 동일한 크기의 사각형이 아틀라스 크기에 맞게 생성되고, 잘라집니다. 셀 개수는 전체 이미지를 설정한 행과 열 개수에 따라 잘라집니다. 자르기 설정에 따라 이미지를 자를 때 포함되지 않는 아틀라스의 일부 여백은 스프라이트로 저장되지 않습니다.

![04](https://mod-file.dn.nexoncdn.co.kr/bbs/16875161330420c3aa0db95274d089f58db3c96404b28.png)

#### 오프셋 조절

X, Y 축을 기준으로 오프셋을 조절할 수 있습니다. 설정한 오프셋 값에 따라 아틀라스를 자르는 위치를 조정합니다.

![08](https://mod-file.dn.nexoncdn.co.kr/bbs/1687516298212f390271a14934c66a4432d0d664bcf2c.png)

#### 패딩 조절

패딩 값을 조정하면 나뉜 셀을 기준으로 X, Y 값에 따라 여백이 생기고, 여백을 제외하고 아틀라스를 자릅니다. ![09](https://mod-file.dn.nexoncdn.co.kr/bbs/16875163895425d939f8086df4a3c97661cc466924550.png)

# 렉트타일로 사용하기

자른 스프라이트를 바로 렉트타일로 활용하고 싶다면, **렉트타일 셋에 추가** 기능을 활용합니다. 렉트타일 활용 방법은 [RectTileMap의 활용](/docs/?postId=589)을 참고하세요.

1. **Workspace - MyDesk - Create TileDataSet**을 눌러 자른 스프라이트를 추가할 새로운 타일 데이터 셋을 만듭니다.
2. **[⋯]** 버튼을 누르고, **Reference** 창에서 자른 스프라이트들을 추가할 **TileDataSet**을 선택합니다.![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16875169132067a31bbf1c39343488599f4114284cb20.png)
3. 파일 이름 접두사와 세부 정보를 설정한 뒤 **[업로드]** 버튼을 누릅니다. 선택했던 **TileDataSet**에 모든 이미지가 추가된 것을 확인할 수 있습니다.

Update 2025-11-17 PM 08:14


# 스프라이트 색상 조정

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

스프라이트를 간단하게 여러 색상으로 변경할 수 있습니다. 스프라이트와 웹스프라이트의 차이점과 스프라이트 색상 변경 방법을 알아보겠습니다.

# 스프라이트

2D 이미지를 스프라이트(Sprite)라 칭합니다. 스프라이트는 위치, 크기, 회전 등을 변경할 수 있습니다. 스프라이트마다 고유한 RUID 값을 갖고 있습니다. RUID 값을 이용해 간편하게 빈 모델에 스프라이트를 넣거나, 변경할 수 있습니다. 크리에이터가 직접 제작한 이미지 파일을 메이커에 업로드하면 RUID 또한 자동으로 발급됩니다.

> Tip. RUID란 스프라이트, 애니메이션, 사운드 등 다양한 리소스가 가진 고유한 아이디 값입니다.

# 활용 예시

#### MSW의 리소스 이용하기

1. 리소스 검색창에서 원하는 리소스를 검색합니다. 예시 RUID : 214069132ceb4962b374c8080fe265ef
2. RUID를 복사한 후,**Workspace - NativeModel - MapObject**를 선택해 배치합니다.![sprite09](https://mod-file.dn.nexoncdn.co.kr/bbs/16353870233517f049b81ee534a72bd40584976a70c91.gif)
3. SpriteRendererComponent의 **SpriteRUID** 프로퍼티에 복사한 RUID를 입력합니다. ![sprite](https://mod-file.dn.nexoncdn.co.kr/bbs/168775319866329eb7f3e76cb4d72a8729ab30e0cc030.png)

#### 크리에이터가 만든 리소스 이용하기

1. **Workspace - MyDesk - Import From - Import Image**를 선택, 외부에서 사용할 이미지를 불러옵니다.
2. **Workspace - BaseEnvironment - NativeModel - MapObject**를 선택해  ![TabScene](https://mod-file.dn.nexoncdn.co.kr/bbs/163452458863504f49c7a23aa4a41af56b5b4611a6daf.png)Scene에 배치합니다.
3. **SpriteRendererComponent의 SpriteRUID** 프로퍼티에 복사한 RUID를 입력합니다.

# 웹 스프라이트

웹에 있는 이미지의 Url을 이용해 웹 스프라이트(Web Sprite)로 사용할 수 있습니다. 직접 제작한 이미지나 메이플스토리 월드에서 제공하는 리소스가 아닌 경우 사용이 가능한지와 활용 범위를 반드시 확인하길 바랍니다.

#### 활용 예시

메이플스토리 라라 아트웍을 스프라이트로 이용할 수 있습니다.

1. 사용할 이미지 주소를 복사합니다. 예시 주소: https://lwi.nexon.com/maplestory/common/media/artwork/artwork_108.jpg
2. **Workspace - BaseEnvironment - NativeModel - WebSprite** 모델을 선택해 배치합니다.
3. 모델을 선택해 프로퍼티 에디터 창에서 **WebSpriteComponent의 Url에 값**을 입력합니다.![websprite02](https://mod-file.dn.nexoncdn.co.kr/bbs/1687753413264ea7d4470867c43b6862bb02387c52d00.png)
4. 웹 스프라이트가 적용된 것을 확인합니다. ![sprite04](https://mod-file.dn.nexoncdn.co.kr/bbs/16349585335040cdf2dc709064f778ce427cbc7742cde.png)

# 스프라이트 색상 조정

SpriteRendererComponent와 WebSpriteComponent의 Color 프로퍼티에서 이미지의 색, 명도, 채도, 투명도를 조정할 수 있습니다. ![sprite05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634958560351159c6025128b4a19a8f1ab8637f28572.png)

| 번호 | 설명 |
| --- | --- |
| ![NO01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg) | 색상 창에서 마우스를 드래그 해 원하는 값을 찾을 수 있습니다. |
| ![NO_02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg) | 색상을 조정하는 바입니다. |
| ![NO_03](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg) | 투명도를 조정하는 바입니다. 아래로 갈수록 스프라이트가 투명해집니다. |
| ![NO_04](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541326353d8628c1473944497bf376acb7a65ca45.jpg) | new칸에는 새롭게 고른 색상, 아래 current에는 이미 적용된 색상이 보입니다. |
| ![NO_05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541338689678f574f21e54a6ca533737924124d7e.jpg) | HSV, RGB, Lab 색 공간에 맞는 값을 입력해 원하는 색을 찾을 수 있습니다. |
| ![NO_06](https://mod-file.dn.nexoncdn.co.kr/bbs/163454135201207284554a25b498380fff224cd767f6b.jpg) | 투명도를 0-100 사이에서 조정할 수 있습니다. 0에 가까울수록 스프라이트가 투명해집니다. |
| ![NO_07](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541365429e8d9fdf4049149eb96f0ec7fdae4b3d1.jpg) | 헥스코드(HexCode)값입니다. 해당 코드를 복사해 다른 스프라이트에 동일한 컬러를 씌울 수 있습니다. |
| ![NO_08](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541383202032ed6f9f38046119acf89fd019b41cf.jpg) | ![TabScene](https://mod-file.dn.nexoncdn.co.kr/bbs/163452458863504f49c7a23aa4a41af56b5b4611a6daf.png)Scene에서 원하는 곳을 클릭해 색을 추출할 수 있습니다. |
| ![NO_09](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541395594e0bdbc1a69204d11aef5d9fbdf7f7ecd.jpg) | 팔레트에서 고른 색을 저장할 수 있습니다. 마지막 칸을 누를 때마다 새로운 칸이 만들어집니다. |

##### 활용 예시

배치한 스프라이트의 헥스코드 값을 ff53a1으로 변경하면 오른쪽 스프라이트처럼 해당 색이 씌워집니다. ![sprite05](https://mod-file.dn.nexoncdn.co.kr/bbs/16349599595174f2002b15ef9488ba312034ed37a93ed.png)

# 마무리

기존 스프라이트 색상을 바꾸는 것만으로 새로운 느낌을 줄 수 있습니다. 어둠에 묻힌 세계가 배경인 게임을 제작한다면 모든 엔티티의 명도를 조정해 어두컴컴한 느낌을 줘야 할 것입니다 내 게임에 어울리는 색으로 변경해 게임 분위기와 전체 완성도까지 한층 높일 수 있습니다.

##### 참고가이드

[원하는 이미지 갖고 오기](docs?postId=99) [리소스 찾기](docs?postId=211)

Update 2025-11-20 PM 02:03


# 스프라이트 색상을 픽셀 단위로 설정하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

**PixelRendererComponent**를 활용하면 크리에이터가 비어있는 스프라이트에 픽셀 단위로 원하는 색을 지정할 수 있습니다. 특정 위치의 픽셀 색상만 바꾸거나 전체 스프라이트 색상을 지정할 수도 있고, 랜덤한 색상으로 변경할 수도 있습니다. 먼저 **PixelRendererComponent**의 프로퍼티를 살펴보고 예제를 통해 활용법을 알아봅시다.

##### 참고 API Reference

[PixelRendererComponent](https://mod-developers.nexon.com/apiReference/Components/PixelRendererComponent)

# PixelRendererComponent

**PixelRendererComponent**의 프로퍼티를 살펴봅시다. ![00](https://mod-file.dn.nexoncdn.co.kr/bbs/169033280248125b25ac7adff41e0a1e7b6d3a06778a6.png)

| 이름 | 타입 | 주요 기능 |
| --- | --- | --- |
| Width | int | 스프라이트의 가로 길이입니다. |
| Height | int | 스프라이트의 세로 길이입니다. |
| OrderInLayer | int | 같은 Layer 내의 우선순위를 결정합니다. 수가 클수록 앞에 보입니다. |
| SortingLayer | string | 2개 이상의 Entity가 겹쳤을 때 Sorting Layer에 따라 보이는 우선순위가 결정됩니다. |
| IgnoreMapLayerCheck | boolean | SortingLayer에 Map Layer 이름을 지정했을 때 자동 치환을 수행하지 않습니다. |

# 픽셀 단위로 색상 변경하기

예제를 통해 **PixelRendererComponent**의 활용법을 알아봅시다.

## 픽셀 색상 변경

`SetPixel` 함수를 활용해 스프라이트에서 원하는 위치의 픽셀 색상을 변경할 수 있습니다. 버튼을 누르면 스프라이트의 랜덤한 위치에 랜덤한 색상의 픽셀이 표시되도록 해봅시다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/165336981276805b48f5770644fda8af385755872a17d.gif)

1. **Hierarchy - map01 - Create Entity - Create Empty**를 눌러 새로운 **SetPixelTest**를 생성합니다.
2. **SetPixelTest** 엔티티에 **TransformComponent**를 추가하고 **Scale** 프로퍼티에 **X = 10, Y = 10**을 입력합니다. 그리고 **PixelRendererComponent**도 추가합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16903328503829c4718ba1607411297b9379c8f304622.png)
3. 새 스크립트 컴포넌트 **PixelRendererTest**를 생성합니다.
4. 아까 생성한 **SetPixelTest** 엔티티의 **Property**에 **PixelRendererTest** 컴포넌트를 추가합니다.
5. **Workspace - MyDesk - PixelRendererTest**를 열고 아래와 같이 **Property**를 추가합니다.```
Property:
[None]
Color color = Color(0,0,0,0)
[None]
Color lastColor = Color(0,0,0,0)
[None]
number lastX = 0
[None]
number lastY = 0
```
6. UI 에디터에서 ![button](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_button.png) 을 눌러 새로운 **SetPixel** 버튼을 만듭니다.
7. **SetPixel** 버튼의 **Property**에 **TextComponent**를 추가하고 프로퍼티를 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| :---: | :---: | :---: | | TextComponent | Text | SetPixel |
8. 새 스크립트 컴포넌트 **ButtonClick_SetPixel**을 생성합니다.
9. **ButtonClick_SetPixel** 스크립트에 아래와 같이 **Property**를 추가합니다.```
Property:
[None]
Entity PR = /maps/map01/SetPixelTest
```
10. **PixelRendererTest** 스크립트를 열고 `SetRandomPixel` 함수를 작성합니다.```
[client only]
void SetRandomPixel()
{
    local pixelRendererComponent = self.Entity.PixelRendererComponent

    local x = _UtilLogic:RandomIntegerRange(1, pixelRendererComponent.Width)
    local y = _UtilLogic:RandomIntegerRange(1, pixelRendererComponent.Height)

    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
    local a = _UtilLogic:RandomDouble()

    -- SetPixel을 사용하여 픽셀 값을 변경합니다.
    pixelRendererComponent:SetPixel(x, y, Color(r,g,b,a))

    self.lastColor = Color(r,g,b,a)
    self.lastX = x
    self.lastY = y

    log("X : "..tostring(x)..", Y : "..tostring(y)..",Color = "..tostring(Color(r,g,b,a)))
}
```
11. **ButtonClick_SetPixel** 스크립트에 **ButtonClickEvent**도 추가합니다.```
Event Handler:
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    -- 버튼을 클릭하면 SetRandomPixel 함수를 호출합니다.
    self.PR.PixelRendererTest:SetRandomPixel()
```
12. **UI - DefaultGroup - SetPixel** 버튼의 **Property**에 **ButtonClick_SetPixel** 컴포넌트를 추가합니다.
13. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 테스트를 진행합니다. **SetPixel** 버튼을 누르면 픽셀이 스프라이트에 무작위로 나타나고 로그가 나오는지 확인합니다.

## 여러 픽셀 색상 변경

`SetPixels` 함수를 활용해 스프라이트 픽셀들의 색상을 변경할 수 있습니다. 버튼을 누르면 스프라이트에 픽셀 단위로 랜덤한 색상이 표시되도록 해봅시다. ![002](https://mod-file.dn.nexoncdn.co.kr/bbs/16534560711537b9397a8eb804578b2045aa1d5517c9a.gif)

1. UI 에디터에서 ![button](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_button.png) 을 눌러 새로운 **SetPixels** 버튼을 만듭니다.
2. **SetPixels** 버튼의 **Property**에 **TextComponent**를 추가하고 **Text**에 **SetPixels**를 입력합니다.
3. 새로 스크립트 컴포넌트 **ButtonClick_SetPixels**를 생성합니다.
4. **ButtonClick_SetPixels** 스크립트에 아래와 같이 **Property**를 추가합니다.```
Property:
[None]
Entity PR = /maps/map01/SetPixelTest
```
5. **PixelRendererTest** 스크립트를 열고 `SetPixelsTest` 함수를 작성해야 합니다. 그전에 먼저 **PixelRendererTest**의 기존 **Property**에 `[None] SyncTable<Color> colors`를 추가합니다.```
Property:
[None]
Color color = Color(0,0,0,0)
[None]
Color lastColor = Color(0,0,0,0)
[None]
number lastX = 0
[None]
number lastY = 0
[None]
SyncTable<Color> colors -- 추가
``` 위와 같이 설정한 후 `SetPixelsTest` 함수를 작성합니다.```
[client only]
void SetPixelsTest()
{
    local width = self.Entity.PixelRendererComponent.Width
    local height = self.Entity.PixelRendererComponent.Height

    local colors = {}

    for i=1, width * height do
        local r = _UtilLogic:RandomDouble()
        local g = _UtilLogic:RandomDouble()
        local b = _UtilLogic:RandomDouble()

        colors[i] = Color(r,g,b,1) 
    end

    -- SetPixels를 사용하여 스프라이트 픽셀들의 색상을 변경합니다.
    self.Entity.PixelRendererComponent:SetPixels(colors)
}
```
6. **ButtonClick_SetPixels** 스크립트에 **ButtonClickEvent**도 추가합니다.```
Event Handler:
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    -- 버튼을 클릭하면 SetPixelsTest 함수를 호출합니다.
    self.PR.PixelRendererTest:SetPixelsTest()
 }
```
7. **UI - DefaultGroup - SetPixels** 버튼의 **Property**에 **ButtonClick_SetPixels** 컴포넌트를 추가합니다.
8. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 테스트를 진행합니다. **SetPixels** 버튼을 누르면 스프라이트에 픽셀 단위로 무작위 색상이 표시되는 것을 확인할 수 있습니다.

## 스프라이트 크기와 여러 픽셀 색상 변경

`ResetWithColors` 함수를 활용해 스프라이트의 크기와 픽셀들의 색상을 변경할 수 있습니다. ![007](https://mod-file.dn.nexoncdn.co.kr/bbs/1653456362928aa034bd72e7b4298ae6919d32fde6401.gif) 예시 코드는 아래와 같습니다. 버튼을 만들고, 함수를 추가한 다음 버튼에 **ButtonClickEvent**를 연결하는 것은 위의 예제와 동일합니다.

```
[client only]
void ResetColorsTest()
{
    local newWidth = _UtilLogic:RandomIntegerRange(8, 32)
    local newHeight = _UtilLogic:RandomIntegerRange(8, 32)
     
    local colors = {}
     
    for i=1, newWidth * newHeight do
        local r = _UtilLogic:RandomDouble()
        local g = _UtilLogic:RandomDouble()
        local b = _UtilLogic:RandomDouble()
     
        colors[i] = Color(r,g,b,1) 
    end
 
    -- ResetWithColors를 사용하여 스프라이트의 크기와 픽셀들의 색상을 변경합니다.
    self.Entity.PixelRendererComponent:ResetWithColors(newWidth, newHeight, colors)
}
```

# 스프라이트 전체 변경하기

**PixelRendererComponent**를 활용하면 스프라이트 전체 색상을 변경할 수도 있습니다.

## 스프라이트를 단색으로 변경

`FillColor` 함수를 활용해 스프라이트 전체를 단색으로 변경할 수 있습니다. 지정한 색으로 변경할 수도 있고 아래와 같이 랜덤한 색으로 변경할 수도 있습니다. ![003](https://mod-file.dn.nexoncdn.co.kr/bbs/1653376631359d2f630081b4b4e74835f35ec5df965d1.gif) 예시 코드는 아래와 같습니다. 버튼을 만들고, 함수를 추가한 다음 버튼에 **ButtonClickEvent**를 연결하는 것은 위의 예제와 동일합니다.

```
[client only]
void FillColorTest()
{
    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
     
    -- FillColor를 사용하여 스프라이트 전체 색상을 변경합니다.
    self.Entity.PixelRendererComponent:FillColor(Color(r,g,b,1))
}
```

## 스프라이트 크기와 전체 색상 변경

`ResetWithColor` 함수를 활용하면 스프라이트의 크기와 전체 색상을 변경할 수 있습니다. ![004](https://mod-file.dn.nexoncdn.co.kr/bbs/1653378536538b82441c0538b4e2da706381061607fe5.gif) 예시 코드는 아래와 같습니다. 버튼을 만들고, 함수를 추가한 다음 버튼에 **ButtonClickEvent**를 연결하는 것은 위의 예제와 동일합니다.

```
[client only]
void ResetColorTest()
{
    local newWidth = _UtilLogic:RandomIntegerRange(8, 32)
    local newHeight = _UtilLogic:RandomIntegerRange(8, 32)
 
    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
         
    -- ResetWithColor를 사용하여 스프라이트 크기와 전체 색상을 변경합니다.
    self.Entity.PixelRendererComponent:ResetWithColor(newWidth, newHeight, Color(r,g,b,1))
}
```

## 알파 값 변경

`SetAlpha` 함수를 활용하면 스프라이트 전체의 알파 값을 변경할 수 있습니다. ![005](https://mod-file.dn.nexoncdn.co.kr/bbs/165337928365796df7621cff04bc68247b9ffe1280269.gif) 예시 코드는 아래와 같습니다. 버튼을 만들고, 함수를 추가한 다음 버튼에 **ButtonClickEvent**를 연결하는 것은 위의 예제와 동일합니다.

```
[client only]
void SetAlphaTest()
{
    local a = _UtilLogic:RandomDouble()
    -- SetAlpha를 사용하여 스프라이트 전체의 알파 값을 변경합니다.
    self.Entity.PixelRendererComponent:SetAlpha(a)
}
```

# 스프라이트 색상 받아오기

`GetPixel`, `GetPixels` 함수를 활용해 픽셀의 위치와 색상을 받아와 월드에 표시하는 방법을 알아봅시다.

## 픽셀 색상 받기

`GetPixel` 함수를 활용하면 제일 최근에 변경된 픽셀의 위치와 색상을 받아올 수 있습니다. ![006](https://mod-file.dn.nexoncdn.co.kr/bbs/165344235792573c3640770c64858902a84cf1af10904.gif)

1. **Hierarchy - map01 - Create Entity - Create Empty**를 눌러 새로운 **CheckGetEntity**를 생성합니다.
2. **CheckGetEntity**에 **TransformComponent**를 추가하고 **Scale** 값으로 **X = 10, Y = 10**을 입력합니다. 그리고 **PixelRendererComponent**도 추가합니다.
3. UI 에디터에서 ![button](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_button.png) 을 눌러 새로운 **GetPixel** 버튼을 만듭니다.
4. **GetPixel** 버튼의 **Property**에 **TextComponent**를 추가하고 **Text**에 **GetPixel**을 입력합니다.
5. 새 스크립트 컴포넌트 **ButtonClick_GetPixel**을 생성합니다.
6. **ButtonClick_GetPixel** 스크립트에 아래와 같이 **Property**를 추가합니다.```
Property:
    [None]
    Entity PR = /maps/map01/SetPixelTest
```
7. **PixelRendererTest** 스크립트를 열고 `GetPixelTest` 함수를 작성해야 합니다. 그전에 먼저 **PixelRendererTest**의 기존 **Property**에 아래와 같이 내용을 추가해줍니다.```
Property:
[None]
Entity PRCheck = /maps/map01/CheckGetEntity
``` 위와 같이 설정한 후 `GetPixelTest` 함수를 작성합니다.```
[client only]
void GetPixelTest()
{
    -- GetPixel을 사용해 SetPixelTest에 최근에 표시된 픽셀 하나의 좌표 및 색상을 받아옵니다.
    local color = self.Entity.PixelRendererComponent:GetPixel(self.lastX, self.lastY)
    -- 위에서 받아온 값을 SetPixel을 사용해 CheckGetEntity에 표시합니다.
    self.PRCheck.PixelRendererComponent:SetPixel(self.lastX, self.lastY, color)
}
```
8. **ButtonClick_GetPixel** 스크립트에 **ButtonClickEvent**도 추가합니다.```
Event Handler:
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    -- 버튼을 클릭하면 GetPixelTest 함수를 호출합니다.
    self.PR.PixelRendererTest:GetPixelTest()
 }
```
9. **UI - DefaultGroup - GetPixel** 버튼의 **Property**에 **ButtonClick_GetPixel**을 추가합니다.
10. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 테스트를 진행합니다. **SetPixel** 버튼을 누른 다음 **GetPixel** 버튼을 누르면 **SetPixelTest**에 가장 최근에 표시된 픽셀이 **CheckGetEntity**에도 잘 표시되는지 확인합니다.

## 스프라이트 전체 픽셀 받기

`GetPixels` 함수를 활용하면 스프라이트 전체의 픽셀 값을 모두 받아올 수 있습니다. ![008](https://mod-file.dn.nexoncdn.co.kr/bbs/16534576466290e6655858bc24915b190bc343b8daf73.gif) 예시 코드는 아래와 같습니다. 버튼을 만들고, 함수를 추가한 다음 버튼에 **ButtonClickEvent**를 연결하는 것은 위의 예제와 동일합니다.

```
[client only]
void GetPixelsTest()
{
    -- GetPixels을 사용해 SetPixelTest 전체의 픽셀 값을 받아옵니다.
    local getPixels = self.Entity.PixelRendererComponent:GetPixels()
    -- 위에서 받아온 값을 SetPixels를 사용해 CheckGetEntity에 표시합니다.
    self.PRCheck.PixelRendererComponent:SetPixels(getPixels)
}
```

Update 2025-12-03 PM 03:40


# 머티리얼 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

머티리얼(Material)은 다양한 프로퍼티를 통해 엔티티가 렌더링될 방법을 나타내는 객체입니다. 엔티티의 프로퍼티는 엔티티를 렌더링하는 코드에 따라 변경됩니다. 셰이더(Shader)란 물체를 렌더링할 때 사용할 코드(또는 스크립트)입니다. 셰이더의 프로퍼티 및 코드는 동적으로 변경될 수 없기 때문에, 셰이더마다 표현하는 효과가 다르게 나타납니다. 메이플스토리 월드에서는 다양한 셰이더를 제공합니다. 크리에이터는 머티리얼을 생성하고 원하는 의도에 맞게 셰이더 프로퍼티를 조절할 수 있습니다.

# 머티리얼 생성하기

머티리얼 생성 방법을 알아봅니다.

1. 새로운 머티리얼은 아래의 3가지 중 원하는 방법으로 만들 수 있습니다. | 1. Workspace [+] 버튼 | 2. Workspace 콘텍스트 메뉴 | 3. Create 메뉴 |
| :---: | :---: | :---: | | ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1686538286105d45a745926da4e4b812578f6b51690c2.png) | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16865382991887b1f0a30aae44c31bb97404200571ed7.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/168653831150808fff6cb82914b4691ae98c678a78ae6.png) |
2. 머티리얼을 생성한 후 이름을 지정합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/166840323583571410bb4351f4e0badb9b51d500f8b81.png)

# 엔티티에 머티리얼 적용하기

엔티티에 머티리얼을 적용하는 방법을 알아봅니다.

1. 엔티티 선택 후 **프로퍼티 에디터 - SpriteRendererComponent - MaterialID**에서 ![Common_Select](https://mod-file.dn.nexoncdn.co.kr/bbs/1668408907363c261c9faa43d4ee3b131624dd723e3a2.png) 버튼을 클릭합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/166908403861011c64e140fd04f8f90bbdb8d5d57af59.png)
2. **Reference** 창에서 원하는 머티리얼을 선택합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1668409227396b253b59b89094a9c9ec4b914a1c29bb5.png)
3. **Shader** 타입을 지정합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/168681313976760c074e2954f4814a93d511c9b9e3c12.png)  필터 기능을 활용하여 선택한 컴포넌트에서 사용할 수 있는 셰이더만 추려볼 수도 있습니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16868168758722d20cb35ccae47d29c99d45b0314426c.png)

# 셰이더 타입

셰이더 타입에 따라 렌더링 방식이 달라지며, 조절할 수 있는 프로퍼티도 다릅니다. 메이플스토리 월드에서 제공하는 셰이더 타입을 살펴봅시다.

## Default

기본 머티리얼입니다. 아무 효과도 적용되지 않은 상태입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Default | ![00](https://mod-file.dn.nexoncdn.co.kr/bbs/1668479786163abb0a4314fe34db0885f9d118d23236f.png) | 머티리얼이 지정되지 않았거나 찾을 수 없을 때 Default를 사용합니다. |

## Outline

스프라이트의 외곽선을 그리는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Outline | ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/166841095184460411e0fbd3d419cbe83b632bce31401.png) | 스프라이트 바깥쪽으로 외곽선을 그립니다. |
| InnerOutline | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/166841143439790c697d7e2f24b368d3a3ad635d19020.png) | 스프라이트 안쪽으로 외곽선을 그립니다. |
| ColorDiffOutline | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16684114971291ab4281d87cc4b9b87fd25f52356d572.png) | 스프라이트 색상 차이를 이용해 외곽선을 그립니다. |

## ColorEffect

스프라이트 위에 여러 색상을 표현하는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Rainbow | ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413469593d7bd1d3a1aa44677b8ac611864878d88.gif) | 무지개 색상으로 블렌딩합니다 |
| LineGradient | ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413449478ceb1da170e9147d48914323930b9b404.png) | Y 축 기준 4개 색상을 점차적으로 블렌딩합니다. |
| VertexGradient | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16684135009255cd62251f9bc4a8c90b0430dff483926.png) | 꼭짓점 색상 4개를 점차적으로 블렌딩합니다. |
| RadialGradient | ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16684135201985614fc9d040440078b52333b4e6f751a.png) | 중심부 - 외부 색상을 점차적으로 블렌딩합니다. |
| Gradient | ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413536391582e7b18622a46eeb8bc117524eead9b.gif) | 시간에 따라 단일 색상으로 블렌딩합니다. |
| Reverse | ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16684135490414f64d3e9f5ac40ed9d8ccec8a7b5f49d.png) | 목표 색상과 반대 색상으로 출력합니다. |
| GrayScale | ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16684135604161d31df8cdb724a77b9b85129b1d5a79f.png) | 회색 조로 출력합니다. |
| Hologram | ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16684135717173629a30e711f41c79d6ce3bd85fa0baf.gif) | 일정한 방향으로 색상 있는 빛 효과를 출력합니다. |
| LimLight | ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413583454c85ff546505745bda50ecb4b3b1e1797.png) | 밝은 빛 효과를 출력합니다. |
| Posterize | ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413596725492a72e7ca45438ebb10abb856ef3701.png) | 렌더링 색상 개수를 제한합니다. |
| ColorOverride | ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413607254b9983afe45d44979bf13be197d61c2fe.gif) | 지정된 단일 색상으로 변경합니다. |
| ColorGlow | ![colorglow](https://mod-file.dn.nexoncdn.co.kr/bbs/1678961863541f622336dc27645c9b69ccace791963fb.png) | GlowColor로 지정한 색상과 비슷한 색상 영역을 밝게 처리합니다. |
| DropShadow | ![dropshadow](https://mod-file.dn.nexoncdn.co.kr/bbs/1678962067474c059773fcc6c490981a9faf032335085.png) | TargetColor로 지정한 색상에 그림자 효과를 적용합니다. |
| ConcentrationLine | ![concentrationline](https://mod-file.dn.nexoncdn.co.kr/bbs/1678959255414e67530f0ca6142cbbca85a7a939f3ea9.png) | 지정한 위치를 향해 집중선 효과를 적용합니다. |

## UVEffect

스프라이트 좌표를 왜곡하는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Noise | ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413949472f7b0b5a86aa4405ba3f4cccaec032045.gif) | 지속적으로 엔티티가 흔들립니다. |
| RoundWave | ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16684136490085c94218d5b2f4a618666646fea88d23c.gif) | 중심 기준으로 동심원 파동을 그립니다. |
| UVScroll | ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16684137205168eccf5a92ada47f5883928a58ba1815c.png) | 스프라이트 렌더링할 때 UV 좌표를 이동시킵니다. |
| Wave | ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1668413755673c476bd19b1774a808c070a6f1a37d7a4.gif) | 특정 지점에서 원형 파동을 그립니다. |
| Glitch | ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/166841389198235926a2352554e5fa7634e64c2ab2e7b.gif) | 무작위로 스프라이트의 다른 구역을 샘플링합니다. |
| GrassMovement | ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16684139052283945063a36ea4c02b3f33b2dfcc0c1bc.gif) | 풀이 흔들리는 듯한 효과입니다. |
| Distortion | ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/166841391898321b73ca5b9884b8aa4141328b906457d.gif) | 엔티티를 왜곡합니다. |
| Ripple | ![ripple](https://mod-file.dn.nexoncdn.co.kr/bbs/1678959633804aacda73d12264dc0be37ffb71af134dd.gif) | 잔물결 효과를 적용합니다. |

## Blurry

스프라이트를 흐려 보이게 하는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Pixel | ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16684141311201c1f06b39e27416b96255925150be57c.png) | 스프라이트를 픽셀화합니다. |
| ChromaticAberration | ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16684144518044c88ee2c6581467cbd882eab77e2bed6.gif) | 색수차 효과를 적용합니다. |
| Blur | ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16684144693599a45ff2fd5c34efb8bba4ee8d9ecdf7b.png) | 흐림 효과를 적용합니다. |
| MotionBlur | ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/16684144858279a9c29b9aee64a65a3271537c4835c99.png) | 방향성 있는 흐림 효과를 적용합니다. |
| RadialBlur | ![radialblur](https://mod-file.dn.nexoncdn.co.kr/bbs/16789605975780c74d541a0824bfea9f28e699737e860.png) | 중앙 중심의 흐림 효과를 적용합니다. |
| KuwaharaFilter | ![KuwaharaFilter](https://mod-file.dn.nexoncdn.co.kr/bbs/16789606314994a9b29416cc14c9ab2072cfd7e3f5a99.png) | kuwahara 필터를 적용합니다. <br>Intensity를 조절하면 수채화 느낌을 표현할 수 있습니다.<br> 도트 이미지에 사용했을 때는 큰 차이를 느끼기 어렵습니다. |

## AlphaMask

스프라이트의 일부를 보이지 않게 만드는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| AlphaCutoff | ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/1668414746608f412644c0aae4f7d913cd7ccfda21ac8.png) | 투명도 낮은 부분은 렌더링하지 않습니다. |
| AlphaRound | ![29](https://mod-file.dn.nexoncdn.co.kr/bbs/1668414760640a654dd3c8bc6429594372014855d9166.png) | 기준 투명도보다 낮으면 알파 값을 0으로, 높으면 1로 처리합니다. |
| Clipping | ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/16684260189626d960534962e4a0589215d868f611bf0.png) | 스프라이트 일부를 잘라냅니다. |
| Mask | ![31](https://mod-file.dn.nexoncdn.co.kr/bbs/1668482058357b63335cd7bfb40ae87c30a952e404255.png) | 스프라이트를 인수로 받아 마스킹 영역을 지정합니다.<br>예) **MaskTexture** : **0005fdee112f4ab8a59764021ac1dda0** 적용 <br>![312](https://mod-file.dn.nexoncdn.co.kr/bbs/16684822611015fb0223e1b4844738039ffd237b746a5.png) |

## BlendColor

스프라이트의 색상이 적용되는 방식을 다양한 형태로 변형하는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| BlendDarken | ![32](https://mod-file.dn.nexoncdn.co.kr/bbs/16684260934885895cb89035b485189cc3c2987d86870.gif) | 각 RGB 채널에서 더 작은 값을 사용해 어둡게 만듭니다. |
| BlendMultiply | ![33](https://mod-file.dn.nexoncdn.co.kr/bbs/166848152367162fef2866b0b475aac9f3635770d6466.gif) | 두 색상을 곱한 결과물을 표현합니다. |
| BlendColorBurn | ![34](https://mod-file.dn.nexoncdn.co.kr/bbs/16684261191845675af047a21421aa335ef5ae24e488c.gif) | 채도는 높이고 대비를 증대시키며 기본 색상을 어둡게 합니다. |
| BlendLinearBurn | ![35](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426133282cddb3c0ee4fe4191bfecf3739a8c0677.gif) | 원본 스프라이트의 색상 대비는 유지하되 색상을 어둡게 합니다. |
| BlendDarkerColor | ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426170398e831fc11796e4fafbd329e11a1744bad.gif) | **Color**와 스프라이트 중 더 어두운 색상을 적용합니다. |
| BlendLighten | ![37](https://mod-file.dn.nexoncdn.co.kr/bbs/16684261855583ea181a43a0c4925b6212596777e1fd5.gif) | 각 RGB 채널에서 더 큰 값을 사용해 밝게 만듭니다. |
| BlendScreen | ![38](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426201094510bec9a701d434fa499d049c9506565.gif) | 혼합색과 기본색의 반전색을 곱하여 밝게 만듭니다. |
| BlendColorDodge | ![39](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426214619ccd1f984bfac4ff8b6c62e2cc92bfabe.gif) | 채도를 높이고 대비를 증대시키며 밝게 만듭니다. |
| BlendLinearDodge | ![40](https://mod-file.dn.nexoncdn.co.kr/bbs/166842622931445eada41c5154dee92f5b5944142249f.gif) | 두 색상을 더하여 밝게 만듭니다. |
| BlendOverlay | ![41](https://mod-file.dn.nexoncdn.co.kr/bbs/16684262452622aa6ab0bbb9d432e94226ea8fe61e8e6.gif) | 어두운 색상에는 Multiply, 밝은 색상에는 Screen 효과를 적용합니다. |
| BlendSoftLight | ![42](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426262251183016eda21c4e07b9e21e6879ca2b3f.gif) | Overlay와 유사하지만, Overlay보다는 대비와 색조 차이가 작습니다. |
| BlendHardLight | ![43](https://mod-file.dn.nexoncdn.co.kr/bbs/166842627472882eb382dd2184fd88abf98d4ade02ef9.gif) | SoftLight와 유사하지만 이미지 대비가 강하고 밝습니다. |
| BlendVividLight | ![44](https://mod-file.dn.nexoncdn.co.kr/bbs/166842629152549952cd63e774a36a4d9f5a3321b2086.gif) | 블렌딩할 색상이 어두우면 Color Burn 효과를, 밝으면 Color Dodge 효과를 적용합니다. |
| BlendLinearLight | ![44_2](https://mod-file.dn.nexoncdn.co.kr/bbs/1673418964186d00f27d5a60b4bd2939245ab8eb9f498.gif) | LinearBurn과 LinearDodge 효과를 조합하여 적용합니다. <br>VividLight와 비슷하지만 VividLight에 비해 대조가 증가하진 않습니다. |
| BlendPinLight | ![45](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426308466df7b6151174b4c91bff2ff8069026131.gif) | 블렌딩할 색상이 어두우면 Darken 효과를, 밝으면 Lighten 효과를 적용합니다. |
| BlendHardMix | ![46](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426325065c2d5f6d9609e4eb3b025e6a01f55aeb8.png) | 두 개의 이미지를 강한 색으로 섞습니다. <br>블렌딩 결과는 무조건 8가지 색상으로만 나타납니다. |
| BlendDifference | ![47](https://mod-file.dn.nexoncdn.co.kr/bbs/166842634679204790bae607048f1b20b6577182fd0b1.gif) | 두 색상의 차이를 반환합니다. <br>동일 색상이면 검은색이 됩니다. |
| BlendExclusion | ![48](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426366592d90b1f754849452d9adb34b139062a36.gif) | 두 색상을 Exclusion 연산합니다. <br>동일 색상이면 회색이 됩니다. <br>Difference와 달리 원본의 색조 대비가 약합니다. |
| BlendSubtract | ![49](https://mod-file.dn.nexoncdn.co.kr/bbs/166842638191501ba6d72ea244bf0b9825d54d2611095.gif) | 원본에서 색상을 뺀 결과를 반환합니다. |
| BlendDivide | ![50](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426394581cb26db187efd4041905dbcd8b20c0465.gif) | 원본에서 색상 값을 나눈 결과를 반환합니다. |
| BlendHue | ![51](https://mod-file.dn.nexoncdn.co.kr/bbs/16684264113953037882a6fc040878105a8508905e558.png) | 명도, 채도는 유지하고 새로운 색상에 맞게 변경합니다.<br> 새로운 색상이 무채색이면 원본도 무채색으로 만듭니다. |
| BlendSaturation | ![54](https://mod-file.dn.nexoncdn.co.kr/bbs/1668426455903b9564b1fd8b84ac589fc78bf614869c6.png) | 명도, 색조는 유지하고 새로운 색상의 채도에 맞게 변경합니다. <br>새로운 색상이 무채색이면 원본도 무채색으로 만듭니다. |
| BlendColor | ![52](https://mod-file.dn.nexoncdn.co.kr/bbs/16684264237827483efddb1634d42bf77a1ca0b247de2.png) | 명도는 유지하고 새로운 색상의 색조와 채도에 맞게 변경합니다. |

## AlphaBlend

셰이더의 투명도를 변경하는 효과입니다.

| 셰이더 | 설명 |
| :---: | --- |
| Additive | ![53](https://mod-file.dn.nexoncdn.co.kr/bbs/1668515969651ddbdb3c1da904a82b6c8184c7347ce38.png) | 물체 앞에 렌더링할 때 Additive 효과를 적용합니다. |
| SoftAdditive | ![55](https://mod-file.dn.nexoncdn.co.kr/bbs/1668515996851bead4bcb2bfe4ceeabae9240247da0f8.png) | 물체 앞에 렌더링할 때 SoftAdditive 효과를 적용합니다. |

## Screen

스크린 전체에 적용하는 효과입니다. **CameraComponent**에만 적용할 수 있습니다.

| 셰이더 | 설명 |
| :---: | --- |
| LensDistortion | ![lensdistortion](https://mod-file.dn.nexoncdn.co.kr/bbs/167896118717416bf94656d5344f18cae0a12cb3def94.png)<br>![lensdistortion](https://mod-file.dn.nexoncdn.co.kr/bbs/1678961600478271874df2997410684f8ba6c5f80c965.png) | 렌즈 왜곡 효과를 적용합니다. <br>(Intensity가 양수면 볼록렌즈, 음수면 오목렌즈) |
| Vignette | ![vignette](https://mod-file.dn.nexoncdn.co.kr/bbs/1678961508666ec8dd0224f3d431293b7b24a161305f6.png) | 색상 있는 비네트 효과를 적용합니다. |

Update 2025-11-17 PM 08:14


# 머티리얼 응용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

머티리얼은 **SpriteRendererComponent** 외의 다른 여러 가지 렌더러 컴포넌트에서 사용할 수 있습니다. 이를 통해 크리에이터는 시각적으로 다채롭고 색다른 나만의 월드를 구현할 수 있습니다. 이번 과정에서는 여러 컴포넌트에서 어떻게 머티리얼을 사용하는지 알아보겠습니다. 또한 예제를 통해 스크립트로 머티리얼을 제어하는 방법도 살펴보겠습니다.

# 여러 가지 컴포넌트에서 머티리얼 사용하기

머티리얼은 다양한 렌더러 컴포넌트에서 사용할 수 있습니다. 사용 방법은 **SpriteRendererComponent**에 머티리얼을 적용하는 방법과 동일합니다.

> **더 알아보기** [머티리얼 활용하기](/docs/?postId=828) 가이드에서 머티리얼 생성 및 적용 방법을 확인할 수 있습니다.

머티리얼은 다양한 렌더러 컴포넌트에 적용할 수 있습니다. 단, 일부 렌더러 컴포넌트에서는 사용할 수 있는 셰이더 종류가 제한됩니다. 각 컴포넌트 별로 사용할 수 있는 셰이더를 확인하려면 **Shader Picker** 창의 필터에서 컴포넌트를 선택하면 됩니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16868168758722d20cb35ccae47d29c99d45b0314426c.png)

# 스크립트로 머티리얼 교체하기

플레이어 캐릭터와 닿으면 엔티티의 머티리얼이 교체되는 예제를 살펴봅시다.

1. 새 머티리얼을 만들고 이름에 **Material01**을 입력합니다.
2. **Scene**에 원하는 엔티티를 배치합니다. 이 예제에서는 **Preset List - npc-964**를 사용했습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/166849476370816e1074387b747d684879d5a30fcb8a8.png)
3. **npc-964**의 **프로퍼티 에디터 - SpriteRendererComponent - MaterialID**에서 ![Common_Select](https://mod-file.dn.nexoncdn.co.kr/bbs/1668408907363c261c9faa43d4ee3b131624dd723e3a2.png) 버튼을 클릭하고 **Reference** 창에서 **Material01**을 선택합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1668494966129a62b76ffce2740339a667c03d48974c8.png)
4. **Material01**의 프로퍼티 에디터에서 **Shader - Outline - InnerOutline**을 선택합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16684932469197db2f5663ffe4856adf503ff2bb3e8e3.png)
5. 새 스크립트 컴포넌트 **MaterialTest**를 생성하고 **npc-964**에 추가합니다.
6. 플레이어 캐릭터와의 충돌을 확인하기 위해 **npc-964**에 **TriggerComponent**도 추가합니다.
7. 새 머티리얼을 만들고 이름에 **Material02**를 입력합니다.
8. **Material02**의 프로퍼티 에디터에서 **Shader - ColorEffect - Rainbow**를 선택합니다.
9. **Workspace - MyDesk - Material02**의 콘텍스트 메뉴에서 **Copy Entry ID**를 클릭합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/166856445652712d2f198c1c94887a49a7b3a9075715f.png)
10. **MaterialTest** 스크립트를 연 뒤, **TriggerEnterEvent**를 추가하고 아래와 같이 작성합니다. 위에서 복사한 **Material02**의 **Entry ID**를 **ChangeMaterial**에 붙여 넣습니다.```
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    -- local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------

    self.Entity.SpriteRendererComponent:ChangeMaterial("material://Entry ID")
    -- 위에서 복사했던 Material02의 Entry ID를 "material://Entry ID" 부분에 붙여 넣기
}
```
11. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 플레이어 캐릭터가 닿으면 **InnerOutline**에서 **Rainbow**로 셰이더가 바뀌는 것을 확인할 수 있습니다. ![test](https://mod-file.dn.nexoncdn.co.kr/bbs/1668496643847defbbbec4521479f96f8f9c2fc2768f2.gif)

# 머티리얼 프로퍼티 제어

스크립트를 활용해 월드 플레이 도중 머티리얼 프로퍼티를 제어할 수 있습니다. 예제를 통해 머티리얼 프로퍼티 제어 방법을 살펴봅시다.

1. "기본" 템플릿으로 월드를 생성합니다. ![0](https://mod-file.dn.nexoncdn.co.kr/bbs/1656419849546d61c1ab96b5d454a971009e8053fe3c1.png)
2. 맵에 상호 작용할 오브젝트를 배치합니다. 예제에서는 **Preset List - Object - object-273**을 사용했습니다. 그리고 **object-273**의 이름을 **StarTree**로 변경합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16728125334251c9368198cf54d0a93fc0d2f46d44ce6.png)
3. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Material**을 클릭해 새 머티리얼을 생성하고 이름을 **NewMaterial**로 설정합니다.
4. **NewMaterial**의 프로퍼티 에디터에서 **Shader** 프로퍼티를 **Blurry - Pixel**로 설정합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16733186086991f9a5b0bd0204fccaf1aaa7cbfe781ed.png)
5. **StarTree** 오브젝트의 프로퍼티 에디터에서 **SpriteRendererComponent**의 **MaterialID**에 **NewMaterial**을 적용합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1672813499766954bfde0c3e44620a6138288f25d19d9.png)
6. 새 스크립트 컴포넌트 **MaterialTest**를 생성하고 **StarTree** 엔티티에 **MaterialTest** 컴포넌트를 추가합니다.
7. 플레이어와 오브젝트 사이의 거리에 따라 **PixelateSize** 프로퍼티가 변경되도록 해봅시다. **MaterialTest** 컴포넌트에 `OnUpdate()` 함수를 추가하고 실행 공간은 **client only**로 설정합니다. 이후 `OnUpdate()` 함수 내용을 아래와 같이 작성합니다.```
[client only]
void OnUpdate(number delta)
{
    local userPosition = _UserService.LocalPlayer.TransformComponent.Position
    local selfPosition = self.Entity.TransformComponent.Position

    local v = Vector2(userPosition.x - selfPosition.x, userPosition.y - selfPosition.y)
    local dist = Vector2.Distance(Vector2.zero, v)

    local changeValue = {["PixelateSize"] = dist * 16 + 16;}
    -- 아래 NewMaterial Entry ID 에는 NewMaterial의 Entry ID를 복사해서 붙여넣기
    _MaterialService:ChangeMaterialProperty("NewMaterial Entry ID", changeValue)
}
```
8. 위에 작성한 코드에서 **NewMaterial Entry ID** 부분에는 자신이 생성한 **NewMaterial**의 **Entry ID**을 복사해서 붙여 넣어야 합니다. **NewMaterial**의 콘텍스트 메뉴에서 **Copy Entry ID**를 클릭합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/167331896565459a96e99c98942dab9fb9c85f4013d86.png) 그 다음, **MaterialTest** 스크립트를 열고 `OnUpdate()` 함수의 "NewMaterial Entry ID" 부분에 붙여 넣습니다.
9. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **StarTree** 오브젝트에 플레이어가 가까이 다가가면 나무가 점점 픽셀화되는 것을 확인합니다. ![pixel](https://mod-file.dn.nexoncdn.co.kr/bbs/16733192431971878d51398c04d65bcb4083bbba1cab6.gif)

Update 2025-11-17 PM 08:14


# 아틀라스블루프린트 에디터

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 안내

제작 중인 월드에서 사용하는 스프라이트들을 아틀라스로 패킹해 이미지를 효율적으로 로드할 수 있습니다.

# 아틀라스

아틀라스(Atlas)란 여러 개의 스프라이트를 묶은 한 장의 큰 이미지입니다. 아틀라스는 묶인 스프라이트들의 RUID 정보를 가지고 있어, 아틀라스를 호출하면 그 아틀라스에 포함된 RUID들이 함께 호출해 월드 성능 개선에 도움을 줄 수 있습니다.

# AtlasBlueprint 소개

AtlasBlueprint는 스프라이트들을 아틀라스로 묶기 위해 사용하는 엔트리입니다. 아틀라스를 만들기 위해서는 AtlasBlueprint를 먼저 생성하고, AtlasBlueprint Editor에서 스프라이트들을 해당 AtlasBlueprint로 추가해야 합니다. AtlasBlueprint는 3가지 방법으로 생성할 수 있습니다.

1. **Create - Create AtlasBlueprint** ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1686213349231380059f652bd4f4cad87d2486766311f.png)
2. **Workspace - [+] - Create AtlasBlueprint** ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16813720723871d71d34343e4463e9bba1ef8de5e0919.png)
3. **Workspace - MyDesk - Create AtlasBlueprint** ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/168137208490909091639575b490084b0ced4b4033f9b.png)

AtlasBlueprint를 생성하고 **Workspace**에서 선택하면 아래와 같이 **Property** 창에서 확인할 수 있습니다. **[Open AtlasBlueprintEditor]** 버튼을 클릭하면 AtlasBlueprint Editor 창이 열립니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16891260098872f1102e5cbdc40229c5cdfe09e6908f7.png)

# AtlasBlueprint Editor 소개

![AtlasBlueprintEditor](https://mod-file.dn.nexoncdn.co.kr/bbs/16953746354894902d817383145ed8f4a0b90bc9e9ad2.png)

| 번호 | 설명 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 스프라이트를 검색할 수 있습니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | <ul><li>**사용 중인 리소스**: 편집 중인 맵에서 사용 중인 스프라이트를 보여줍니다.</li><li>**Workspace**: Workspace에 추가한 스프라이트를 보여줍니다.</li><li>**기본 UI**: MSW에서 기본적으로 제공하는 UI만 보여줍니다.</li><li>**내 리소스**: 크리에이터가 직접 추가한 스프라이트만 보여줍니다.</li><li>**MSW 리소스**: MSW에서 제공하는 리소스만 보여줍니다.</li></ul> |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 리소스 카테고리입니다. **Sprite**와 **AnimationClip**으로 구분되어 있습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 스프라이트의 섬네일입니다. 스프라이트 정보를 확인할 수 있습니다. 이미 AtlasBlueprint에 추가된 스프라이트인 경우 경고![error](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Atlas_Blueprint_Editor/icon_atlasblueprint_error.png) 표시가 나타납니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 선택한 스프라이트들를 지정한 AtlasBlueprint로 추가하는 버튼입니다. |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 패킹할 AtlasBlueprint를 지정합니다. 지정한 AtlasBlueprint로 선택한 스프라이트들이 추가됩니다.<ul><li>[+] 버튼으로 새로운 AtlasBlueprint를 생성할 수 있습니다.</li></ul> |
| ![7](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | <ul><li>**최대 크기**: AtlasBlueprint의 크기를 설정합니다. **2048** 크기를 권장합니다. 4096은 월드를 PC 전용으로 출시할 때만 사용하는 것을 권장합니다.</li><li>**패딩**: 아틀라스에 패킹되는 스프라이트들의 간격을 설정합니다. 권장 값은 **4**입니다.</li><li>**필터 모드**: 아틀라스의 필터 모드를 설정합니다.<ul><li>Point: 색을 선명하게 유지합니다. 스프라이트를 확대했을 때 색의 경계가 또렷하게 보입니다.<br>![point](https://mod-file.dn.nexoncdn.co.kr/bbs/1681376094059d24365daf6f3448a828a3c0570a4ca17.png)</li><li>Bilinear: 특정 색과 주변 색을 섞어 부드럽게 표현합니다. 스프라이트를 확대했을 때 본래의 스프라이트보다 색의 경계가 흐릿하게 보일 수 있습니다.<br>![bilinear](https://mod-file.dn.nexoncdn.co.kr/bbs/1681376194233746640e900964e7288a13327aae2cbc9.png)</li><li>Trilinear:특정 색과 주변 색을 섞어 부드럽게 표현합니다. 스프라이트를 확대했을 때 본래의 스프라이트보다 색의 경계가 흐릿하게 보일 수 있습니다.</li></ul></li></ul> |
| ![8](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_08.jpg) | **Sprite RUIDs to pack**: 아틀라스로 만들어질 스프라이트들의 목록입니다. 하나의 RUID는 하나의 아틀라스에만 포함될 수 있습니다. 패킹 성공/실패 및 이상 여부에 따라 아이콘이 다르게 나타납니다.<ul><li>![check](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Atlas_Blueprint_Editor/icon_atlasblueprint_check.png): 스프라이트를 패킹할 수 있습니다.</li><li>![warning](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Atlas_Blueprint_Editor/icon_atlasblueprint_warning.png): 스프라이트에 이상이 있습니다.아틀라스로 패킹이 가능합니다.주로 Resource Storage에서 내 리소스의 스프라이트를 교체했거나, Workspace에서 같은 이름의 이미지를 업로드해 교체한 경우입니다.</li><li>![error](https://mod-file.dn.nexoncdn.co.kr/storage/icons/Atlas_Blueprint_Editor/icon_atlasblueprint_error.png): 스프라이트를 패킹할 수 없습니다.</li></ul> |
| ![9](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_09.jpg) | 선택한 스프라이트들을 아틀라스로 패킹합니다. 패킹에 실패한 스프라이트가 목록에 포함된 경우 버튼이 활성화되지 않습니다. |

# AtlasBlueprint 패킹하기

여러 스프라이트를 아틀라스로 패킹하는 방법은 아래와 같습니다. 아틀라스로 묶인 스프라이트는 별도의 추가 처리가 필요하지 않습니다. 스프라이트는 하나의 아틀라스에만 적용할 수 있습니다. 그러므로 만약 패킹된 스프라이트를 다른 아틀라스에 중복으로 패킹하기 위해 AtlasBlueprint의 Sprite RUIDs to Pack 목록에 스프라이트가 추가했더라도, 아틀라스로 패킹되지 않고 해당 스프라이트 칸에 에러 아이콘이 나타납니다. 또한 다른 크리에이터가 공유한 RUID를 내 아틀라스로 패킹할 수 없습니다. 스프라이트를 아틀라스로 묶을 때는 크리에이터가 기준을 세워 적절하게 용도를 구분하는 것이 좋습니다. 예를 들어 한 화면에 등장하는 스프라이트들끼리 묶거나 혹은 화면에 겹쳐서 나타나는 스프라이트끼리 묶어 아틀라스로 패킹하면 월드 성능 개선에 도움이 됩니다.

1. **Workspace - MyDesk 콘텍스트 메뉴에서 Create AtlasBlueprint**를 선택해 새로운 **MyAtlasBlueprint**를 생성합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/168137208490909091639575b490084b0ced4b4033f9b.png)
2. **Panels - AtlasBlueprint Editor**를 선택합니다.
3. AtlasBlueprint Editor에서 **Current Blueprint**를 MyAtlasBlueprint로 지정합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/168870727519948389940bc5541d0a25a097d4bcd77d5.png)
4. 패킹하고 싶은 스프라이트 또는 애니메이션 클립을 선택하고, **[블루프린트에 추가]** 버튼을 누릅니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16956391411664007e51a9fb741c0be18fc8b22fee100.png)
  > **Tip.** 애니메이션 클립을 패킹할 때는 [>] 버튼을 눌러 애니메이션 스프라이트를 미리 확인할 수 있습니다. ![4-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16956397038866e474ee87bed43dbbc2e3f2a31845755.png)
5. **Atlas Settings**에서 최대 크기, 패딩, 필터 모드 값을 크리에이터의 의도대로 조정합니다. **[Pack]** 버튼을 눌러 스프라이트를 아틀라스로 패킹합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16887055695712cf0218ae48c457aa3a1b534549950e7.png)
6. 성공 알림창에서 **예**를 눌러 패킹된 아틀라스 정보를 확인할 수 있습니다. **아니오**를 누르면 세부 정보창을 열지 않습니다. **[Open]** 버튼을 눌러 세부 정보창을 열 수 있습니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1688705596011073d2f580db94f058464f6ac53779051.png)  패킹된 AtlasBlueprint 미리보기는 **Property** 창에서도 확인할 수 있습니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1689126815360b6a57da2448b4507b4daf444e26f3e16.png)

> **Tip.** **Sprite RUIDs to Pack** 목록에서 패킹 성공/실패 및 스프라이트 이상 여부를 확인할 수 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1688706020438d8d6eac716f24536a86c2efbfcc1c10f.png)

Update 2025-11-17 PM 08:14


# Skeleton 리소스 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터가 제작한 **Skeleton** 리소스를 사용해 메이플스토리 월드에서 다양한 애니메이션을 재생할 수 있습니다.

# Skeleton 리소스 등록하기

**Spine 4.1**로 제작된 리소스만 메이플스토리 월드에 Skeleton 리소스로 추가 가능합니다. Resource Storage에 Skeleton을 추가하기 위해서는 한 폴더에 임포트하고자 하는 **png, atlas, skel** 파일이 있어야 하고, 그 외에 다른 파일이 포함되면 안 됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17641465058783591e788b6144e72beac49549043fcdc.png)

1. **Spine 4.1**에서 리소스를 제작합니다.
2. **Resource Storage - 내 리소스 - Skeleton**을 선택하고 [+] 버튼을 누릅니다.
3. 추가할 리소스 폴더를 선택해 추가합니다.

#### 유의사항

- **Spine 4.1**로 제작된 리소스만 등록이 가능합니다.
- **png, atlas, skel**의 파일이 모두 있어야 정상적으로 리소스가 등록됩니다.
- **png, atlas, skel**외 다른 파일이 있으면 리소스 등록이 실패합니다.
- 하나의 skeleton 리소스에 포함 가능한 **png** 파일은 **최대 8개**입니다.
- **png** 파일당 최대 크기는 **4096*4096**입니다.

# Skeleton 활용

Skeleton 리소스를 월드에서 사용할 때는 [SkeletonRendererComponent](/apiReference/Components/SkeletonRendererComponent)를, UI에서 사용할 때는 [SkeletonGUIRendererComponent](/apiReference/Components/SkeletonGUIRendererComponent)를 사용합니다. 두 컴포넌트의 프로퍼티를 사용해 간단하게 애니메이션을 재생하거나, 함수를 활용해 크리에이터가 원하는 방식으로 애니메이션을 제어할 수도 있습니다.

1. 엔티티에 **SkeletonRendererComponent**를 추가합니다.
2. SkeletonRUID에 크리에이터가 추가한 Skeleton 리소스의 RUID를 추가합니다.
3. 프로퍼티 값을 변경해 원하는 스킨과 애니메이션을 재생합니다.

## 주요 프로퍼티

#### AnimationNames

**AnimationNames** 값을 추가하고 애니메이션 재생 순서를 지정할 수 있습니다. AnimationNames 1번부터 차례대로 재생됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1764146578340778f661831ad441894e15bfd64eed436.png)

##### SkinNames

**SkinNames** 값을 추가하고 스킨을 지정할 수 있습니다. 다양한 스킨이 있는 Skeleton 리소스를 사용할 경우 하나의 엔티티에서 다양한 스킨 조합으로 애니메이션을 재생할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17641465585439341bd4463404e948916b8fcd67bc851.png)

#### Loop

**Loop**를 **true**로 설정하면 애니메이션이 반복 재생됩니다.

# Skeleton 애니메이션 제어

## 애니메이션 추가

`AddAnimation()` 함수를 사용해 애니메이션을 추가할 수 있습니다. `AddAnimation()` 함수를 사용하면 **AnimationNames** 프로퍼티와 달리 여러 속성들을 지정할 수 있습니다. `AddAnimation()` 함수는 [SkeletonAnimationClip](/apiReference/Misc/SkeletonAnimationClip)를 매개 변수로 받습니다. `SkeletonAnimationClip`은 애니메이션의 상세한 속성을 나타냅니다. 이 매개 변수를 사용해 애니메이션 트랙 번호, 이름, 반복 재생 시간, 속도 등을 설정할 수 있습니다.

#### SkeletonAnimationClip

`SkeletonAnimationClip`은 애니메이션의 상세 속성을 나타냅니다. 주요 프로퍼티는 아래와 같습니다. 자세한 내용은 [SkeletonAnimationClip](/apiReference/Misc/SkeletonAnimationClip)를 참고하세요.

| 이름 | 설명 |
| --- | --- |
| Alpha | 다른 트랙과 섞이는 비율을 나타냅니다. 기본값은 1입니다. |
| Delay | 애니메이션 재생을 시작하기까지 대기하는 시간입니다. 시간은 초 단위입니다. |
| MixDuration | 애니메이션이 전환될 때 이전 애니메이션과 섞이는 시간입니다. 시간은 초 단위입니다. |
| TimeScale | 애니메이션 재생 속도입니다. 기본값은 1입니다. |

## 트랙 추가

**TrackIndex**를 활용해 여러 개의 트랙을 추가할 수 있습니다. **TrackIndex**는 애니메이션을 재생할 트랙 번호이며, 트랙에 애니메이션을 추가하면 여러 애니메이션을 동시에 재생할 수 있습니다. 트랙은 크리에이터가 원하는 번호로 추가할 수 있습니다. 예를 들어 걷는 애니메이션을 2번 트랙에, 총을 쏘는 애니메이션을 3번 트랙에 추가하면 걸으면서 총을 쏘는 모습을 표현할 수 있습니다.

> **Tip** **1번 트랙**은 **AnimationNames** 프로퍼티에서 사용하기 때문에 TrackIndex로 지정할 수 없습니다.

**TrackIndex**는 높은 번호의 트랙이 낮은 번호의 트랙을 덮어쓰는 특징이 있습니다. 예를 들어 아래와 같이 2번 트랙에 걷는 애니메이션을 추가하고, 3번 트랙에 사격 애니메이션을 추가했다면 걷기 애니메이션이 손을 앞뒤로 흔드는 모습이더라도, 3번 트랙의 사격 애니메이션은 손을 앞으로 내미는 모습이기 때문에 3번 트랙의 사격 모습으로 보이게 됩니다.

```
local skel = self.Entity.SkeletonRendererComponent
 
local walk = SkeletonAnimationClip()
walk.TrackIndex = 2
walk.AnimationName = "walk"
skel:AddAnimation(walk)
 
local shoot = SkeletonAnimationClip()
shoot.TrackIndex = 3
shoot.AnimationName = "shoot"
skel:AddAnimation(shoot)
```

## 트랙 비우기

`SetAnimation()` 함수를 활용해 트랙을 비우고, 애니메이션을 추가할 수 있습니다. 비우는 트랙에 재생 중인 애니메이션이 있는 경우 새 애니메이션으로 전환되면서 `MixDuration`도 함께 적용됩니다.

## 빈 애니메이션 추가

`AddEmptyAnimation()`, `SetEmptyAnimation()` 함수를 활용해 빈 애니메이션을 추가할 수 있습니다. 빈 애니메이션은 주로 두 애니메이션 사이의 전환 효과로 사용합니다. 두 함수 모두 `SkeletonAnimationClip`를 매개 변수로 받고, `AnimationName`은 무시됩니다. 만약 아래와 같이 사격 종료(ShootEnd) 애니메이션에서 걷기(Walk) 애니메이션으로 전환할 때 `SetEmptyAnimation()` 함수를 사용한다면, 전환 시간을 MixDuration으로 설정해 자연스럽게 전환될 수 있습니다.

```
local skel = self.Entity.SkeletonRendererComponent
 
local shootEnd = SkeletonAnimationClip()
shootEnd.TrackIndex = 3
shootEnd.MixDuration = 0.5
skel:SetEmptyAnimation(shootEnd)
```

## 애니메이션 제거

`ClearTrack()`을 사용해 애니메이션을 제거할 수 있습니다. `ClearTrack()` 함수를 사용해 재생 중인 애니메이션을 지울 수 있습니다. 하지만 이 경우 애니메이션이 즉시 전환되므로 급작스러운 전환으로 보일 수 있으므로 이러한 특징을 염두에 두고 사용해야 합니다.

```
local skel = self.Entity.SkeletonRendererComponent

skel:ClearTrack(3)
```

## 어태치먼트 추가

`SetAttachment()` 함수를 활용해 지정한 슬롯에 어태치먼트를 추가하거나 제거할 수 있습니다. 아래와 같이 고글 어태치먼트를 추가할 수 있습니다.

```
local skel = self.Entity.SkeletonRendererComponent
 
skel:SetAttachment("face", "goggle")
```

## 어태치먼트 제거

어태치먼트를 제거할 때는 `SetAttachment()` 함수의 두 번째 인수인 `attachmentName`에 **nil**을 전달합니다.

```
local skel = self.Entity.SkeletonRendererComponent

skel:SetAttachment("face", nil)
```

Update 2025-11-28 PM 02:51


# 아바타 표정 바꾸기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

AvatarRendererComponent의 `PlayEmotion`을 사용해 플레이어 아바타의 표정을 바꿀 수 있습니다. 특정 입력 키와 표정을 연결 지어 생동감 있게 감정을 표현할 수도 있고, 몬스터에게 맞았을 때 특정 표정을 재생시킬 수도 있습니다. 적극적으로 사용해 유저들끼리의 활발하고 쉬운 의사소통을 할 수 있게 도와주세요.

# 표정 종류

총 22가지의 표정을 제공합니다. 표정은 얼굴마다 다르게 나타나므로 크리에이터가 설정한 얼굴에 따라 가이드의 표정과 다를 수 있습니다

| 표정 | key | 예시 |
| --- | --- | --- |
| 맞기 | Hit | ![hit](https://mod-file.dn.nexoncdn.co.kr/bbs/16396401188336e54b6adf42b4088ad1c61a60f9c8731.png) |
| 웃음 | Smile | ![smile](https://mod-file.dn.nexoncdn.co.kr/bbs/16395549609346e876f6386bc4eda97306a53e89f0895.png) |
| 난처 | Troubled | ![troubled](https://mod-file.dn.nexoncdn.co.kr/bbs/16395541972918701350d6bd1425384b71f7eef150433.png) |
| 울음 | Cry | ![cry](https://mod-file.dn.nexoncdn.co.kr/bbs/1639554951149c507945a898d4ec58fd2629df70cbeee.png) |
| 분노 | Angry | ![angry](https://mod-file.dn.nexoncdn.co.kr/bbs/16395560553809d8ab80b78c14f0faec4be3781b0a5fb.png) |
| 당황 | Bewildered | ![bewildered](https://mod-file.dn.nexoncdn.co.kr/bbs/16395560679398458bd2b686545c4bb2a8d20fe31f94b.png) |
| 곤란 | Stunned | ![stunned](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556098745cf8aff308154417c80014aa9b6e9d68e.png) |
| 토 | Vomit | ![vomit](https://mod-file.dn.nexoncdn.co.kr/bbs/163955611166849281f37d4bb4107a3dce003f53d1fbc.png) |
| 황당 | Oops | ![oops](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556132963546e5fdf3cde4a50b027994f3d086744.png) |
| 꺄오 | Cheers | ![cheers](https://mod-file.dn.nexoncdn.co.kr/bbs/16395561463349a5bd1cd4ff8472bbea5a534cb19b75e.png) |
| 뽀뽀 | Chu | ![chu](https://mod-file.dn.nexoncdn.co.kr/bbs/163955615577069cd9078b46c4f16aabf999e635012bf.png) |
| 윙크 | Wink | ![wink](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556257543f249e7a3d02a4707bdee12ea1acf54e2.png) |
| 눈물찍 | Pain | ![pain](https://mod-file.dn.nexoncdn.co.kr/bbs/16395562727335d82e3d6a88242839d6f176747b03346.png) |
| 초롱초롱 | Glitter | ![Glitter](https://mod-file.dn.nexoncdn.co.kr/bbs/166684095544355abeeb3a60e4e85a4118483915dfd1d.png) |
| 후하후하 | Despair | ![despair](https://mod-file.dn.nexoncdn.co.kr/bbs/16395562836016f39a4e3e8a54ef8ae0566e3b8862318.png) |
| 뿅 | Love | ![love](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556295930004061735ea14375bd2d90ede8cdc232.png) |
| 반짝반짝 | Shine | ![shine](https://mod-file.dn.nexoncdn.co.kr/bbs/163955630509906604406ad084f3284149221faaa08ce.png) |
| 활활 | Blaze | ![blaze](https://mod-file.dn.nexoncdn.co.kr/bbs/163955631518406f4825034d74f1cb1952c139f46face.png) |
| 흐음 | Hum | ![hum](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556324667dee4cdfa35eb41148d1becc71419f1fd.png) |
| 꾸벅꾸벅 | Bowing | ![bowing](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556334026de94b9e28d764207a8bd6e58d4429199.png) |
| 앗뜨거 | Hot | ![hot](https://mod-file.dn.nexoncdn.co.kr/bbs/163955640187085d52926ecf749ee8d6884447137ecd6.png) |
| 메롱 | Dam | ![dam](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556413232d9ef215a4d144933ab1ae2fc01aa618b.png) |
| 창백 | qBlue | ![qblue](https://mod-file.dn.nexoncdn.co.kr/bbs/1639556423490af2cf4bd2f4445898d4edc084cc4d99e.png) |

# 아바타 표정 바꾸기

키보드의 숫자키를 1부터 5까지 누르면 각각 다른 표정이 5초 동안 재생합니다.

1. MyDesk에서 새로운 컴포넌트를 만들고, 스크립트 작성 화면을 엽니다.
2. Function: 옆의 추가 ![AddPropertyFunction](https://mod-file.dn.nexoncdn.co.kr/bbs/1635134683611e1fb1dfaa0c94f7386a012836b986188.png)를 눌러 **New**를 선택합니다.  ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/164006572761813e6a63db24c41c8a87930b114f0ae3d.png)
3. 함수 이름을 Emote로 변경하고, 더 보기 ![script_more](https://mod-file.dn.nexoncdn.co.kr/bbs/16345206995612a35d54577d8466da03a9fe452a5218c.png) 를 선택해 **Add Parameter**를 두 번 추가해 매개 변수를 입력합니다.![parameter](https://mod-file.dn.nexoncdn.co.kr/bbs/164006784006957fd839bd3d546f8aa9c9e1639bfb3a0.png)
4. `PlayEmotion`을 이용해 재생할 표정을 작성합니다.
5. Entity Event Handler에 `KeyDownEvent`를 추가하고, 표정 재생을 위해 필요한 입력 키를 작성합니다.

```
Method:
[server]
void Emote (number key, string userId)
{
    local avatar = _UserService:GetUserEntityByUserId(userId).AvatarRendererComponent

    if key == 1 then
        avatar:PlayEmotion(EmotionalType.Angry, 5) -- 화난 표정을 5초 동안 재생
    elseif key == 2 then
        avatar:PlayEmotion(EmotionalType.Cry, 5)
    elseif key == 3 then
        avatar:PlayEmotion(EmotionalType.Chu, 5)
    elseif key == 4 then
        avatar:PlayEmotion(EmotionalType.Smile, 5)
    elseif key == 5 then
        avatar:PlayEmotion(EmotionalType.Wink, 5)
    end
}
     
Event Handler:
[Client Only] [service: InputService]
HandleKeyDownEvent (KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local key = event.key
    ---------------------------------------------------------
    
    local myUserId = _UserService.LocalPlayer.OwnerId
    
    if key == KeyboardKey.Alpha1 then -- 숫자 1을 누르면, Emote 함수의 key 1 표정 재생
        self:Emote(1, myUserId) 
    elseif key == KeyboardKey.Alpha2 then
        self:Emote(2, myUserId)
    elseif key == KeyboardKey.Alpha3 then
        self:Emote(3, myUserId)
    elseif key == KeyboardKey.Alpha4 then
        self:Emote(4, myUserId)
    elseif key == KeyboardKey.Alpha5 then
        self:Emote(5, myUserId)
    end
}
```

![emotion](https://mod-file.dn.nexoncdn.co.kr/bbs/1656036982832fc9cbd58c5f241c0a6b505178529fffb.gif)

Update 2025-11-20 PM 02:03


# 아바타의 외형 변경과 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

아바타 구성을 살펴보고, 아바타의 장비를 교체하는 방법을 알아봅니다. 아바타의 구성을 이해해 새로운 방식으로 아바타를 활용할 수 있습니다.

# 아바타

**DefaultPlayer**의 프로퍼티 에디터에는 **AvatarRendererComponent**와 **CostumeManagerComponent**가 있습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1639736344111420c42a85e1c4f678dbdd11dabf7ee64.png)

- **AvatarRendererComponent**
  - 복장 정보를 가져와 아바타를 그리는(Rendering) 역할을 합니다.
- **CostumeManagerComponent**
  - 복장 정보를 가지고 있습니다.
  - 프로퍼티에 특정한 값을 지정하지 않았다면 유저 개개인이 장착한 옷의 정보를 가져와 보여줍니다.
  - 만약, 크리에이터가 제작한 맵에 모두 동일한 무기를 가지고 싸우길 원한다면 **CostumeManagerComponent**에서 복장을 지정합니다. 월드를 실행했을 때 **AvatarRendererComponent**가 지정된 복장 정보를 가져와 월드에 접속하는 모든 유저에게 같은 무기를 적용합니다.

**아바타**는 **Body**와 **Face**로 나누어져 있고, **AvatarRoot**의 하위에 위치합니다. **Body**에는 **AvatarBodyActionSelectorComponent**가, **Face**에는 **AvatarFaceActionSelectorComponent**가 자동으로 함께 구현됩니다. 두 **Selector** 컴포넌트는 어떤 애니메이션을 재생할지 **AvatarRendererComponent**에게 전달하는 역할을 합니다. ![avatarroot1](https://mod-file.dn.nexoncdn.co.kr/bbs/163972976884316a24d6b6a37457aaa19b6fa1e57fdd7.png)

#### 아바타 장착 규칙

**CostumeManagerComponent**의 프로퍼티 값을 변경해 아바타에 특정 아이템을 장착할 수 있습니다.

- 피부, 모자, 망토, 코트, 귀 장식, 귀, 눈 장식, 얼굴 장식, 얼굴, 장갑, 헤어스타일, 롱코트, 한손무기, 하의, 신발, 보조무기, 두손무기 모두 변경할 수 있습니다.
- 다만, **장비**는 아래의 규칙에 따라 장착할 수 있기에 중복으로 장착할 수 없는 항목이 있습니다.
  - 상하의와 한벌옷은 중복으로 착용할 수 없습니다.
  - 한손무기 혹은 보조무기는 양손무기와 중복으로 착용할 수 없습니다.
  - 동시 착용이 불가능한 아이템을 같이 입력했다면 한벌옷, 두손무기만 출력됩니다.

크리에이터가 **UseCustomeEquipOnly** 프로퍼티를 ![Editbox_Visible](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176985962dcc6fd403f34978b50521f0a8329013.png) 비활성화한 상태라면, 모든 유저는 자신의 아바타를 기준으로 변경된 복장만 장착하게 됩니다. 만일 모든 유저를 같은 아바타 상태로 입장하게 하고 싶다면, **UseCustomeEquipOnly**를 ![Editbox_Check](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176407708cb3de01eaaf48a68ab2dd6fe1b1183f.png) 활성화해야 합니다. 롱코트만 값을 지정하고, **UseCustomeEquipOnly** 활성 상태를 다르게 하면, 아래와 같이 적용됩니다.

| UseCustomeEquipOnly 비활성 | UseCustomeEquipOnly 활성 |
| :---: | :---: |
| ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1656037430966b3ed208e362047fd96fc353a923d5694.png) | ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/165603717861326007c18880e4f3ab95ec987302d4b82.png) |

# 아바타에 색 입히기

**AvatarRendererComponent**의 `SetColor` 함수와 **확장한 TriggerComponent**를 사용해 특정 엔티티와 유저가 닿으면(충돌하면) 유저가 빨간색으로 변하게 합니다.

1. **BaseEnvironment - NativeScripts - Component - TriggerComponent**를 선택합니다.
2. **TriggerComponent**의 콘텍스트 메뉴를 열고 **Extend**를 클릭합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1687754755702bcecc1f59a204f3ca931773a1849464d.png)
3. 확장한 스크립트 이름을 변경하고, 아바타와 부딪힐 엔티티에 컴포넌트를 추가합니다.
4. 아래와 같은 스크립트를 작성합니다.

```
Function:
override void OnEnterTriggerBody(TriggerEnterEvent enterEvent)
{
    __base:OnEnterTriggerBody(enterEvent)
     
    -- 오브젝트와 충돌한 대상(플레이어)을 받아옵니다.
    local player = enterEvent.TriggerBodyEntity
     
    -- 오브젝트와 충돌한 대상에게 AvatarRendererComponent가 없다면 색은 변하지 않습니다.
    local avatarRenderer = player.AvatarRendererComponent
    if avatarRenderer == nil then
        return
    end
     
    -- 오브젝트에 부딪혔을 때 플레이어에게 씌울 색을 지정합니다(빨간색).
    avatarRenderer:SetColor(1.0, 0.0, 0.0, 1.0)
}
```

![avatarcolour](https://mod-file.dn.nexoncdn.co.kr/bbs/1656037221622eb2a951c9c6a4efc8911926e1553490b.gif)

> **TIP** TriggerComponent를 확장했기 때문에 OnEnterTriggerBody 함수를 추가하면 앞에 ![override](https://mod-file.dn.nexoncdn.co.kr/bbs/1640768458649f5cbcbca48d348adb5f4cb490510b822.png)가 붙습니다.

# 아바타 옷 바꾸기

**CostumeManagerComponent**의 `SetEquip`을 이용해 아바타가 특정 엔티티와 닿았을 때 크리에이터가 지정한 의상으로 모습을 변경합니다. 특정 엔티티에 닿으면 아바타의 의상을 아래의 RUID로 바꾸는 예제를 살펴봅시다.

| Parts | RUID |
| :---: | --- |
| 모자 | 08346b77089b468baa34389b2bf299c7 |
| 롱코트(한벌옷) | 0858e3dba9fb4fd3a20273cdeddff5ce |
| 한손무기 | 2f921322114549da9ef5725e980a28c9 |

1. **BaseEnvironment - NativeScripts - Component - TriggerComponent**를 선택합니다.
2. **TriggerComponent**의 콘텍스트 메뉴를 열고 **Extend**를 클릭합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1687754755702bcecc1f59a204f3ca931773a1849464d.png)
3. 확장한 스크립트 이름을 변경하고, 아바타와 부딪힐 엔티티에 컴포넌트를 추가합니다.
4. 아래와 같은 스크립트를 작성합니다.

```
{
    override void OnEnterTriggerBody(TriggerEnterEvent enterEvent)
    __base:OnEnterTriggerBody(enterEvent)
     
    -- 오브젝트와 충돌한 대상(플레이어)을 받아옵니다.
    local player = enterEvent.TriggerBodyEntity
     
    -- 오브젝트와 충돌한 대상에게 AvatarRendererComponent가 없다면 복장은 바뀌지 않습니다.
    local costumeManager = player.CostumeManagerComponent
    if costumeManager == nil then
        return
    end
    
     -- 바뀔 장비의 RUID를 입력합니다.
    costumeManager.CustomCapEquip = "08346b77089b468baa34389b2bf299c7"
    costumeManager.CustomLongcoatEquip = "0858e3dba9fb4fd3a20273cdeddff5ce"
    costumeManager.CustomOneHandedWeaponEquip = "2f921322114549da9ef5725e980a28c9"
}
```

![avatarchaing](https://mod-file.dn.nexoncdn.co.kr/bbs/16560372660016a0c0a7f65d346e1aa7d166ed839ec13.gif)

# 아바타를 다르게 활용하기

**AvatarRendererComponent**와 **CostumeManagerComponent**를 활용해 새로운 아바타를 만들어 사용할 수 있습니다. 몬스터, 포탈, NPC 혹은 크리에이터만의 특별한 엔티티로 제작할 수 있습니다. 이때 **TransformComponent, AvatarRendererComponent, CostumeManagerComponent** 총 3가지는 필수 컴포넌트입니다. 필수 컴포넌트와 더불어 다른 네이티브 컴포넌트를 추가하거나, 크리에이터가 제작한 새로운 컴포넌트를 추가해 활용합니다.

#### 아바타 모양 포탈 만들기

![avatar05](https://mod-file.dn.nexoncdn.co.kr/bbs/16397077408772b3142d25d454ec2811260ef4c5400d5.png)

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Model**를 선택해, 새로운 모델을 만듭니다.
2. 새로운 모델에 **TransformComponent, AvatarRendererComponent, CostumeManagerComponent**를 추가합니다. ![avatar02](https://mod-file.dn.nexoncdn.co.kr/bbs/16397058202122eac734eedb14d1fb88237289b257b05.png)
3. **CostumeManagerComponent**에 복장 정보 RUID를 입력해 크리에이터의 아바타와 다른 모습의 아바타를 만듭니다. | Parts | RUID |
| :---: | --- | | Body | 504244b76e654f5db23dc62693106bc8 | | Cape | 0c40fcbc25844082981d2f4ca04ee383 | | EyeAccessory | e3846cade85f4a04a603a9a8f5f705d4 | | Face | 0b67e20c585145b7b50bdce28386bef0 | | Glove | 43e864f8cd77466db4d0d7d342e72410 | | Hair | 0521135d1c234f10ab5c1c02b1aed813 | | Longcoat | 1141b91758e54052ac1f39cfb0680574 | | Shoes | ad81534ee2e34e4b98e312517ca3e192 |![avatar3](https://mod-file.dn.nexoncdn.co.kr/bbs/16397063807041913c00c619e43c980832b999591973c.png)
4. **PortalComponent**과 **NameTagComponent**를 추가합니다. ![avatar04](https://mod-file.dn.nexoncdn.co.kr/bbs/1639707712623152a28523dd74a3e8b5f5140fe31ba9b.png)

##### 참고 가이드

- [캐릭터 초기 속성 편집](/docs?postId=48)
- [다른 위치로 이동하는 포탈 만들기](/docs?postId=90)
- [엔티티에 이름표 붙이기](/docs?postId=29)

Update 2025-11-17 PM 08:14


# 아바타 애니메이션 제어하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

아바타 애니메이션을 제어하는 3가지 방법을 살펴봅니다. 본 과정을 통해 크리에이터가 원하는 기능에 맞게 아바타 애니메이션을 제어해 봅시다.

# ActionStateChangedEvent로 제어

아바타는 **AvatarRoot**에 **Body**와 **Face**로 나뉘어 있습니다. **Body**는 말 그대로 아바타의 몸통이며 **Face**는 아바타의 얼굴을 뜻합니다. 아바타의 **Body**와 **Face**에 어떤 애니메이션을 재생할지는 [ActionStateChangedEvent](/apiReference/Events/ActionStateChangedEvent)로 설정할 수 있습니다.

- **Face**는 아바타 얼굴 애니메이션, 즉 표정을 제어합니다.
- **Body**는 아바타의 몸통 액션과 파츠 액션을 제어합니다.

**ActionStateChangedEvent**의 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| CoreActionName | 아바타 몸통의 액션 이름입니다. |
| PartsActionName | 각 파츠의 액션 이름입니다. <br>얼굴 장식을 제외한 아바타 장착 아이템의 액션입니다. |
| PlayRate | 재생 속도입니다. |
| PlayType | 재생 타입입니다. |
| StartFrameIndex | 애니메이션 시작 프레임입니다. |
| EndFrameIndex | 애니메이션 종료 프레임입니다. |

## ActionName

**ActionStateChangedEvent**는 **ActionName**으로 어떤 애니메이션을 재생할지 결정합니다. 아래는 **ActionName**의 목록입니다.

| ActionName |
| :---: |
| stand1 | swingO1 | stabO1 | shoot1 |
| stand2 | swingO2 | stabO2 | shoot2 |
| walk1 | swingO3 | stabOF | shootF |
| walk2 | swingOF | stabT1 | |
| alert | swingT1 | stabT2 | |
| prone | swingT2 | stabTF | |
| proneStab | swingT3 |  | |
| jump | swingTF |  | |
| fly | swingP1 |  | |
| sit | swingP2 |  | |
| ladder | swingPF |  | |
| rope |  |  | |
| dead |  |  | |
| heal |  |  | |
| blink |  |  | |

각 액션의 애니메이션은 메이커의 **AvatarItem Editor**에서 미리 볼 수 있으며, 방법은 아래와 같습니다.

1. [뒤통수가 개방된 모자](/docs/?postId=684) 가이드에서 **Avatar_Cap_A1.psd**를 다운로드합니다.
  > **Tip.** [아바타 아이템 제작](/ko/docs/?postId=582) 가이드 하위 문서에서 제공하는 예시 리소스 파일(psd)은 모두 사용해도 됩니다. 반드시 **Avatar_Cap_A1.psd**를 사용할 필요는 없습니다.
2. 메이커의 내비게이션 메뉴에서 **Window - AvatarItem Editor**를 클릭합니다.
3. **[PSD 파일 선택]** 버튼을 클릭한 뒤, 다운로드했던 **Avatar_Cap_A1.psd**를 선택합니다.
4. 조금 기다린 뒤, psd 파일이 적용되면 **ActionName** 목록에서 원하는 이름을 선택합니다. 선택한 애니메이션을 확인할 수 있습니다. ![action](https://mod-file.dn.nexoncdn.co.kr/bbs/1666762416657685d48785e8e4eec9deb8320f75bbd3a.gif)

**ActionName**은 **CoreActionName**과 **PartsActionName**에서 함께 활용합니다. 위에서 설명했듯이 **CoreActionName**은 아바타의 **맨몸 액션**이고 **PartsActionName**은 얼굴 장식을 제외한 **아바타 장착 아이템의 액션**입니다. **CoreActionName**과 **PartsActionName**을 서로 다르게 설정한 아바타의 움직임을 보면 두 가지의 차이점을 쉽게 이해할 수 있습니다. 예를 들어 아래 이미지를 보면, **CoreActionName**을 **walk1**로 설정했기 때문에 아바타의 몸통은 걷고 있지만, **PartsActionName**은 **stand1**로 설정했기 때문에 옷이나 신발은 가만히 서 있습니다. ![walk](https://mod-file.dn.nexoncdn.co.kr/bbs/1666850718269278086006fbe4b198a9c492c952bd8c4.gif)

**CoreActionName**과 **PartsActionName**가 다르면 대부분 위와 같이 어색한 모습이 연출되기 때문에 일반적으로는 두 가지를 동일하게 설정합니다. 물론 **죽음** 액션처럼 **CoreActionName**를 **dead**, **PartsActionName**를 **stand1**로 서로 다르게 설정해야 자연스러운 경우도 있습니다. 크리에이터의 의도에 따라 **CoreActionName**과 **PartsActionName**를 설정하면 됩니다.

## PlayRate

애니메이션의 재생 속도를 제어합니다. 숫자가 커지면 재생 속도가 빨라집니다.

## PlayType

애니메이션의 재생 방식을 설정합니다. **PlayType**에는 **OneTime, Loop, ZigzagLoop**가 있습니다.

| SpriteAnimClipPlayType | 설명 |
| :---: | --- |
| OneTime | 한번 재생합니다. |
| Loop | 순행해서 반복 재생합니다. |
| ZigzagLoop | 순행 - 역행 순서로 반복 재생합니다. |

## 시작/종료 프레임

각 애니메이션의 총 프레임은 **AvatarItem Editor**에서 확인할 수 있습니다.

![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16667657292657df3e93d54f8437cb7a709131c0ab531.png)

위와 같이 총 프레임을 확인한 뒤, 크리에이터가 재생하기를 원하는 애니메이션 시작 프레임(StartFrameIndex)과 종료 프레임(EndFrameIndex)을 설정하면 됩니다. 프레임을 설정할 때는 다음 사항을 주의해야 합니다.

- 프레임은 양수로 설정해야 합니다.
- 시작 프레임은 종료 프레임보다 작거나 같아야 합니다.
- 종료 프레임은 총 애니메이션 프레임보다 작거나 같아야 합니다.
- 프레임값을 잘못 설정하면 보정됩니다.
- 프레임값을 입력하지 않으면 기본값으로 설정됩니다.
- **CoreActionName**(몸통 액션)과 **PartsActionName**(파츠 액션)을 입력해야 애니메이션이 정상 출력됩니다.

## 예제

**ActionStateChangedEvent**는 아바타의 **body**를 통해 발생하기 때문에 **AvatarRendererComponent**의 **GetBodyEntity**로 이벤트를 보내야 합니다. 기본적으로는 아래와 같이 설정합니다.

```
local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
local event = ActionStateChangedEvent("walk1", "walk1", 1, SpriteAnimClipPlayType.Loop, 1, 2)
body:SendEvent(event)
```

일부 프로퍼티는 생략해도 정상 작동합니다. 하지만 **CoreActionName**과 **PartsActionName**은 반드시 입력해야 합니다.

```
local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
local event = ActionStateChangedEvent("walk1", "walk1")
-- 재생 속도, 재생 타입, 시작 프레임, 종료 프레임은 생략할 수 있습니다.
-- ActionStateChangedEvent("walk1", "walk1", 1, SpriteAnimClipPlayType.Loop, 0, 종료 프레임)과 같은 의미입니다.
body:SendEvent(event)
```

프레임값을 잘못 입력하면 자동으로 보정됩니다.

```
local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
local event = ActionStateChangedEvent("walk1", "walk1", 1, SpriteAnimClipPlayType.Loop, -1, 4) 
-- 프레임값으로 양수를 넣어야 하는데 위와 같이 startFrameIndex로 음수를 넣으면 "0"으로 보정됩니다.
-- endFrame이 "3"인데 endFrameIndex로 "4"를 잘못 넣었다면 "3"으로 보정됩니다.
-- 결과적으로 ActionStateChangedEvent("walk1", "walk1", 1, SpriteAnimClipPlayType.Loop, 0, 3)으로 보정됩니다.
body:SendEvent(event)
```

이처럼 **ActionStateChangedEvent**를 사용하면 몸통과 파츠의 애니메이션을 각각 다르게 조절하고, 여러 액션을 세밀하게 설정할 수 있습니다. 하지만 매번 액션을 지정해야 하는 번거로움도 있습니다. '서기' 또는 '걷기'처럼 자주 사용하는 애니메이션을 매번 이렇게 설정한다면 쓸데없이 반복되는 코드도 늘어날 것입니다. 또한 아바타가 한 손 무기나 양손 무기를 들었을 때 각각 다른 애니메이션을 취해야 하는데 이러한 것도 별도로 설정해야 합니다. **BodyActionStateChangeEvent**를 사용하면 이러한 불편을 해소할 수 있습니다.

# BodyActionStateChangeEvent로 제어

[BodyActionStateChangeEvent](/apiReference/Events/BodyActionStateChangeEvent)는 이름 그대로 아바타의 bodyActionState를 변경하는 이벤트입니다. 이 이벤트는 무기 타입에 따른 애니메이션을 별도로 지정할 필요가 없어 편리합니다. **BodyActionStateChangeEvent**는 **MapleAvatarBodyActionState**로 애니메이션을 제어합니다. **MapleAvatarBodyActionState**에는 각 상태별로 어떤 몸통 액션과 파츠 액션을 쓸 것인지, 재생 속도와 재생 타입은 무엇인지 미리 정의되어 있습니다. 자주 사용하는 애니메이션 프리셋이 정의되어 있다고 생각하면 이해하기 쉽습니다.  **MapleAvatarBodyActionState**는 아래 표와 같이 **ActionStateChangedEvent**에 매칭됩니다.

| MapleAvatarBodyActionState | CoreActionName | PartsActionName | PlayRate | PlayType |
| :---: | :---: | :---: | :---: | :---: |
| Stand | stand1 | stand1 | 1 | ZigzagLoop |
| stand2 | stand2 | 1 | ZigzagLoop |
| Walk | walk1 | walk1 | 1 | Loop |
| walk2 | walk2 | 1 | Loop |
| Attack | alert | alert | 1 | Loop |
| Crouch | prone | prone | 1 | Loop |
| Fall | jump | jump | 1 | Loop |
| Sit | sit | sit | 1 | Loop |
| Rope | rope | rope | 1 | Loop |
| Ladder | ladder | ladder | 1 | Loop |
| Dead | dead | stand1 | 1 | Loop |
| Blink | blink | blink | 1 | Loop |
| Fly | fly | fly | 1 | Loop |
| Hit | alert | alert | 1 | ZigzagLoop |
| Alert | alert | alert | 1 | ZigzagLoop |
| Heal | heal | heal | 1 | Loop |
| Invalid | - | - | - | - |

## 예제

**BodyActionStateChangeEvent**가 **MapleAvatarBodyActionState**로 **Fly** 상태를 호출하는 예시를 살펴봅시다.

```
local event = BodyActionStateChangeEvent()
event.ActionState = MapleAvatarBodyActionState.Fly
event.needResetAction = true
event.startFrameIndex = 1
event.endFrameIndex = 2
self.Entity:SendEvent(event)
```

이 이벤트는 위의 매칭 표에 나오는 것처럼 결과적으로 다음과 같이 **ActionStateChangedEvent**를 호출합니다.

```
ActionStateChangedEvent("fly", "fly", 1, SpriteAnimClipPlayType.Loop, 1, 2)
```

물론 **BodyActionStateChangeEvent**에서 시작/종료 프레임을 잘못 입력했더라도 **ActionStateChangedEvent**에서 보정됩니다.

# ActionSheet와 StateComponent로 제어

이미 정의된, 혹은 새로 정의할 아바타의 상태가 바뀔 때마다 매번 이벤트를 보내서 애니메이션을 변경하는 것도 번거로울 수 있습니다. 이벤트를 보내지 않고도 아바타 상태가 바뀔 때마다 애니메이션도 함께 변경되면 매우 편리할 것입니다. [AvatarStateAnimationComponent](/apiReference/Components/AvatarStateAnimationComponent)의 **ActionSheet**에 아바타 상태와 연결될 애니메이션을 설정하고 [StateComponent](/apiReference/Components/StateComponent)로 원하는 타이밍에 아바타 상태를 바꾸면 애니메이션을 손쉽게 변경할 수 있습니다.

**AvatarStateAnimationComponent**에서 기본으로 제공되는 **ActionSheet**는 다음과 같습니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1666838653260b4a969d3d22a438990ede8add75f3edb.png)

| Key | Value |
| :---: | :---: |
| IDLE | stand |
| MOVE | walk |
| ATTACK | attack |
| HIT | hit |
| CROUCH | crouch |
| FALL | fall |
| JUMP | fall |
| CLIMB | rope |
| LADDER | ladder |
| DEAD | dead |
| SIT | sit |

**ActionSheet**에서

- **Key**는 **State**를 의미합니다.
- **Value**는 **MapleAvatarBodyActionState**를 의미합니다. | ActionSheet Value | MapleAvatarBodyActionState |
| :---: | :---: | | stand | Stand | | walk | Walk | | attack | Attack | | crouch | Crouch | | fall | Fall | | sit | Sit | | rope | Rope | | ladder | Ladder | | dead | Dead | | blink | Blink | | fly | Fly | | hit | Hit | | alert | Alert |

아바타가 특정 **State**가 되면 **ActionSheet**에서는 해당 **State**의 **Value** 값에 매칭되는 **MapleAvatarBodyActionState**를 찾습니다. 위에서 살펴본 것처럼 **MapleAvatarBodyActionState**에는 어떤 몸통, 파츠 애니메이션을 재생할지 이미 정의되어 있습니다. 그러므로 **StateComponent**로 **State**만 바꾸면 아바타 애니메이션도 따라서 변경되는 것입니다.  이처럼 **ActionSheet**는 상태에 따른 애니메이션을 쉽게 변경할 수 있어 편리합니다. 예를 들어, **IDLE** 상태에 **walk** 애니메이션을 재생하고 싶다면 **Value** 값을 **walk**로 바꾸기만 하면 됩니다. 크리에이터가 수동으로 새로운 상태를 추가하는 것도 손쉽게 할 수 있습니다.

> **더 알아보기** **ActionSheet**와 **StateComponent**를 사용해 간단하게 애니메이션을 변경하는 예시는 [ActionSheet로 아바타 애니메이션 손쉽게 제어하기](/docs/?postId=545) 가이드를 참고합니다.

**ActionSheet**와 **StateComponent**로 애니메이션을 변경하는 방법은 간편하지만 단점도 있습니다.

- 애니메이션의 시작과 끝 프레임은 선택할 수 없습니다.
- 정의된 기본/사용자 상태 변경 조건이 있다면 이 조건에 의해서 상태가 자동으로 변경될 수 있습니다. 따라서 원하는 애니메이션이 출력되기 전에 바로 상태가 변경되어 버릴 수 있습니다.

## 정리

애니메이션 변경 과정을 정리하면 다음과 같습니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16666629577385097ba49f896467aace2023dbb6bc7eb.png)

위에서 알아본 3가지 아바타 애니메이션 제어 방법의 장단점을 정리하면 아래 표와 같습니다. 각 방법은 장단점이 명확하므로 크리에이터의 의도에 맞는 방법을 적절히 선택하면 됩니다.

| 아바타 애니메이션 제어 방법 | 장점 | 단점 |
| :---: | --- | --- |
| ActionStateChangedEvent | <ul><li>몸통과 파츠 애니메이션을 각각 다르게 조절할 수 있습니다.</li><li>재생 속도, 재생 타입, 애니메이션 시작/종료 프레임을 세밀하게 설정할 수 있습니다.</li></ul> | <ul><li>자주 사용하는 액션을 매번 이렇게 설정하기는 번거롭습니다.</li><li>무기에 따라 달라지는 애니메이션을 별도로 지정해야 합니다.</li></ul> |
| BodyActionStateChangeEvent | <ul><li>무기에 따라 달라지는 애니메이션을 별도 지정할 필요가 없습니다.</li><li>애니메이션 시작/종료 프레임을 설정할 수 있습니다.</li></ul> | <ul><li>몸통과 파츠 애니메이션을 각각 다르게 조절할 수는 없습니다.</li><li>MapleAvatarBodyActionState에서 정의되지 않은 상태로는 변경할 수 없습니다.</li></ul> |
| ActionSheet와 StateComponent | <ul><li>프로퍼티 에디터의 ActionSheet에서 아바타 상태별 애니메이션을 간단하게 변경할 수 있습니다.</li><li>아바타 상태를 손쉽게 추가할 수 있습니다.</li><li>StateComponent로 원하는 타이밍에 State만 바꿔주면 애니메이션도 따라서 바뀝니다.</li></ul> | <ul><li>애니메이션 시작/종료 프레임을 설정할 수 없습니다.</li><li>다른 상태 변경 조건에 의해 상태가 자동으로 변경되면 원하는 애니메이션이 출력되지 않을 수 있습니다.</li></ul> |

# 애니메이션 프레임 이벤트

재생되는 애니메이션의 프레임 정보를 알 수 있는 3가지 이벤트를 살펴봅시다. 알아낸 프레임 정보를 활용해, 특정 프레임이 재생될 때 다른 애니메이션으로 변경하는 예제도 확인해 봅시다.

| 이벤트 | 설명 |
| :---: | --- |
| [SpriteAnimPlayerChangeFrameEvent](/apiReference/Events/SpriteAnimPlayerChangeFrameEvent) | 스프라이트 애니메이션의 프레임이 바뀔 때 발생합니다. |
| [SpriteAnimPlayerStartFrameEvent](/apiReference/Events/SpriteAnimPlayerStartFrameEvent) | 스프라이트 애니메이션이 첫 번째 프레임을 재생할 때 발생합니다. |
| [SpriteAnimPlayerEndFrameEvent](/apiReference/Events/SpriteAnimPlayerEndFrameEvent) | 스프라이트 애니메이션이 마지막 프레임을 재생할 때 발생합니다. |

각 이벤트는 프레임 번호(FrameIndex)와 역재생 여부(ReversePlaying), 총 프레임 수(TotalFrameCount)를 전달합니다. 이벤트는 **ConnectEvent**를 사용해 아바타의 **Body** 또는 **Face**에 연결해야 제대로 사용할 수 있습니다.

## 예제

다음의 예제 코드를 보면서 **FrameEvent**의 사용법을 알아봅시다.

1. 어떤 아바타 애니메이션의 2번째 프레임이 재생될 때 다른 애니메이션으로 변경하고 싶다고 가정합니다. 그렇다면 **SpriteAnimPlayerChangeFrameEvent**를 활용할 수 있을 것입니다. `OnBeginPlay` 함수를 추가하고, 위에서 설명한 대로 이벤트를 **Body**와 연결합니다. 구독 취소를 대비해 연결한 이벤트의 핸들러는 프로퍼티로 가지고 있도록 합니다.```
Property:
[None]
any handler = nil

Method:
[client only]
void OnBeginPlay()
{
    local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
    self.handler = body:ConnectEvent("SpriteAnimPlayerChangeFrameEvent", self.ChangeFrameEvent)
    -- SpriteAnimPlayerChangeFrameEvent를 body와 연결합니다. 
    -- SpriteAnimPlayerChangeFrameEvent가 발생하면 ChangeFrameEvent 함수를 호출합니다.
}
``` 이제 **SpriteAnimPlayerChangeFrameEvent**가 발생할 때 `ChangeFrameEvent` 함수를 호출하게 되었습니다.
2. `ChangeFrameEvent` 함수를 작성합니다. 애니메이션 프레임이 2로 변경됐을 때 **ActionStateChangedEvent**를 통해 **swingOF** 애니메이션을 **0.5** 재생 속도로 **2~3프레임을 반복 재생**하도록 설정합니다.```
[client]
void ChangeFrameEvent(any event)
{
    if event.FrameIndex == 2 then
        local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
        local actionEvent = ActionStateChangedEvent("swingOF", "swingOF", 0.5, SpriteAnimClipPlayType.Loop, 2,3)
        body:SendEvent(actionEvent)
    end
}
``` 위의 코드는 애니메이션 재생까지는 문제가 없습니다. 하지만 여전히 **SpriteAnimPlayerChangeFrameEvent**를 구독 중이기 때문에 애니메이션이 시작되자마자 다시 새로운 **ActionStateChangedEvent**를 보내는 과정이 반복될 것입니다. 그러면 원하는 결과를 얻을 수 없으므로 **SpriteAnimPlayerChangeFrameEvent**를 구독 취소해야 합니다.
3. 아까 저장한 **handler**를 통해 **SpriteAnimPlayerChangeFrameEvent** 구독을 취소합니다. `ChangeFrameEvent` 함수를 수정해 봅시다.```
[client]
void ChangeFrameEvent(any event)
{
    if event.FrameIndex == 2 then
        local body = self.Entity.AvatarRendererComponent:GetBodyEntity()
        body:DisconnectEvent("SpriteAnimPlayerChangeFrameEvent", self.handler) 
        -- SpriteAnimPlayerChangeFrameEvent 구독 취소
        local actionEvent = ActionStateChangedEvent("swingOF", "swingOF", 0.5, SpriteAnimClipPlayType.Loop, 2,3)
        body:SendEvent(actionEvent)
    end
}
``` 이제 플레이 후 처음 애니메이션의 2번째 프레임이 재생될 때 **swingOF** 애니메이션으로 변경됩니다.  **SpriteAnimPlayerStartFrameEvent**나 **SpriteAnimPlayerEndFrameEvent**도 사용법은 같습니다. 크리에이터의 구현 의도에 따라 이벤트를 활용하여 원하는 애니메이션을 만들어봅시다.

> **Tip.** 아바타 애니메이션은 클라이언트를 통해 재생되므로 클라이언트로 제어해야 합니다.

Update 2025-11-17 PM 08:14


# ActionSheet로 아바타 애니메이션 손쉽게 제어하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

**StateToAvatarBodyActionSheet**의 아바타 상태를 통해 애니메이션을 손쉽게 제어하는 방법을 소개합니다.

# 아바타 애니메이션

아바타가 걸을 때, 앉을 때, 공격할 때, 점프할 때를 유저가 인지하려면 상태에 맞는 애니메이션이 필요합니다. [AvatarStateAnimationComponent](/apiReference/Components/AvatarStateAnimationComponent)의 **StateToAvatarBodyActionSheet**에 **Key**와 **AvatarBodyActionStateName**가 있으면 아바타가 특정 상태가 될 때, 이에 해당하는 애니메이션이 재생됩니다. 이 특징을 이용해 기본 애니메이션 값을 지우고, 새로운 상태와 아바타의 애니메이션을 연결할 수 있습니다. 예를 들어, 공격 키를 눌렀을 때 **attack** 애니메이션이 기본이지만 **dead** 애니메이션으로 바꿀 수 있습니다.

**StateToAvatarBodyActionSheet**에는 기본적으로 아바타의 11가지 상태(Key)와 그에 연결된 애니메이션(AvatarBodyActionStateName)이 정의되어 있습니다. **Key**는 아바타가 특정 상태가 되었을 때 동작 재생을 요청하고, **AvatarBodyActionStateName**에 해당하는 애니메이션을 재생합니다. 만약 상태(Key)를 입력하지 않고, **AvatarBodyActionStateName**만 입력한다면 연결된 상태가 없기 때문에 애니메이션이 재생되지 않습니다. **AvatarStateAnimationComponent**는 **Player** 모델의 기본 컴포넌트입니다. **DefaultPlayer**에서 이 컴포넌트를 비활성화할 수 있고, 컴포넌트에 프로퍼티를 추가할 수 있습니다. **StateToAvatarBodyActionSheet** 프로퍼티의 **Size** 값을 변경하거나 하단의 **[+], [-]** 버튼을 누르면 **Key**를 추가/삭제할 수 있습니다.

![animation105](https://mod-file.dn.nexoncdn.co.kr/bbs/167927196496004370d09cca342d0b0ae918cc40e24ac.png)

**StateToAvatarBodyActionSheet**에는 아래의 값이 기본으로 등록되어 있습니다. 기본값을 변경하거나 삭제하면 해당하는 애니메이션은 재생되지 않습니다. 예를 들어 **AvatarBodyActionStateName**에서 **ladder**를 삭제했다면, 아바타가 사다리를 올라갈 때 사다리 올라가는 애니메이션(ladder)이 재생되지 않고, 걷기 애니메이션이 멈춘 상태로 올라가게 됩니다. **PlayRate**로 아바타 애니메이션의 기본 재생 속도를 조정할 수 있습니다. AvatarBodyActionStateName별로 기본값이 다릅니다.

| Key | AvatarBodyActionStateName | PlayRate |
| --- | --- | --- |
| IDLE | stand | 1 |
| MOVE | walk | 1.68 |
| ATTACK | attack | 1.33 |
| HIT | hit | 1 |
| CROUCH | crouch | 1 |
| FALL | fall | 1 |
| JUMP | fall | 1 |
| CLIMB | rope | 1 |
| LADDER | ladder | 1 |
| DEAD | dead | 1 |
| SIT | sit | 1 |

> **Tip.** Key는 항상 **대문자**로 입력해야 합니다.

# 기존의 상태 키에 다른 애니메이션 연결하기

**StateToAvatarBodyActionSheet** 프로퍼티의 **AvatarBodyActionStateName** 값을 수정해 기존의 상태에 다른 애니메이션을 연결할 수 있습니다.

1. **attack**을 **dead**로 변경합니다. ![animation104](https://mod-file.dn.nexoncdn.co.kr/bbs/16793645420245e8a2fcc25234f7391c1c2585fb08417.png)
2. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 왼쪽 **Ctrl** 키를 눌러 공격을 합니다. 변경 전에는 공격 애니메이션이 재생되었지만, 연결 애니메이션을 **Dead**로 변경했기 때문에 죽음 애니메이션이 재생됩니다.![animation103](https://mod-file.dn.nexoncdn.co.kr/bbs/1656037601843938b5091f64c4a3499ff0940db8d3670.gif)

# 새로운 상태 키와 애니메이션 추가하기

새로운 상태(Key)를 추가하고, 애니메이션을 지정할 수 있습니다. 기존의 키를 삭제하지 않고 새로운 상태와 액션을 추가하면 두 상태 모두 동작합니다. 숫자 6, 7, 8, 9를 눌렀을 때 특정 애니메이션이 재생되게 만들어봅시다.

1. **Workspace - DefaultPlayer - AvatarStateAnimationComponent**의 **Size**를 **15**로 변경합니다.
2. 추가한 칸에 새로운 **Key**와 **AvatarBodyActionStateName**를 입력합니다. | Key | AvatarBodyActionStateName |
| --- | --- | | NEW_ATTACK | attack | | NEW_DEAD | dead | | NEW_JUMP | fall | | NEW_CROUCH | crouch |![ActionSheet100](https://mod-file.dn.nexoncdn.co.kr/bbs/1679272025027f89505b96cf948aba9190b4a1bac83be.png)
3. **MyDesk**에서 새로운 **NewAvatarAnimation** 스크립트 컴포넌트를 생성하고, **DefaultPlayer**에 추가합니다.
4. **NewAvatarAnimation** 스크립트를 엽니다. 새롭게 추가한 **Key**를 재생할 수 있도록 **StateComponent**의 `AddState()`, `ChangeState()` 함수를 활용해 작성합니다.```
Property:
[None]
any stateComponent = nil

Method:
[clinet only]
void OnBeginPlay() 
{
    self.stateComponent = self.Entity.StateComponent
    self.stateComponent:AddState("NEW_ATTACK") -- 새로운 상태를 추가합니다.
    self.stateComponent:AddState("NEW_DEAD")
    self.stateComponent:AddState("NEW_JUMP")
    self.stateComponent:AddState("NEW_CROUCH")
}

[clinet only]
void Animate(number key) 
{
    if key == 6 then
        self.stateComponent:ChangeState("NEW_ATTACK") 
    elseif key == 7 then
        self.stateComponent:ChangeState("NEW_DEAD")
    elseif key == 8 then
        self.stateComponent:ChangeState("NEW_JUMP")
    elseif key == 9 then
        self.stateComponent:ChangeState("NEW_CROUCH")
    end
}

Event Handler:
[client only] [service: InputService] 
HandleKeyDownEvent(KeyDownEvent event) 
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------

    if key == KeyboardKey.Alpha6 then
        self:Animate(6) 
    elseif key == KeyboardKey.Alpha7 then
        self:Animate(7)
    elseif key == KeyboardKey.Alpha8 then
        self:Animate(8)
    elseif key == KeyboardKey.Alpha9 then
        self:Animate(9)
    end
}
```
  > **더 알아보기** 새로운 상태와 액션을 추가했지만 기존의 상태를 삭제하지 않았기 때문에 두 가지 입력 모두 작동합니다.
5. 시작을 눌러 숫자 키를 누르면 애니메이션이 재생됩니다. ![animation101](https://mod-file.dn.nexoncdn.co.kr/bbs/1656037637302737656324fc249a3a33872e34f4e54c4.gif)

Update 2025-11-20 PM 02:03


# 아바타를 UI에서 표현하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

**AvatarGUIRendererComponent**를 활용하면 UI에 캐릭터 정보를 보여줄 수 있습니다. 본 과정을 통해 **AvatarGUIRendererComponent** 활용 방법을 알아봅시다.

##### 참고 가이드

[아바타 애니메이션 제어하기](docs/?postId=820)

##### 참고 API Reference

[AvatarGUIRendererComponent](/apiReference/Components/AvatarGUIRendererComponent)

#### AvatarGUIRendererComponent 프로퍼티

**AvatarGUIRendererComponent**의 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| --- | --- |
| Color | 색상을 조절합니다. |
| FlipX | X축을 기준으로 반전 여부를 결정합니다. |
| FlipY | Y축을 기준으로 반전 여부를 결정합니다. |
| PlayRate | 아바타 애니메이션 재생 속도를 지정할 수 있습니다. <br> 0 이상의 값을 지원하며 숫자가 클수록 속도가 빨라집니다. |
| PreserveAvatar | <ul><li>None: 원본 비율과 관계없이 자유롭게 크기를 조절합니다.</li><li>AspectOnly: 원본 비율을 유지하며 크기를 조절합니다.</li><li>NativeSize: 원본 크기를 유지합니다.</li></ul> |
| RaycastTarget | true로 설정할 경우 화면 터치 또는 마우스 클릭 대상이 됩니다. AvatarGUIRendererComponent 뒤에 가려진 UI는 화면 터치와 마우스 클릭 입력을 받지 못합니다. |

# 예제

**AvatarGUIRendererComponent**의 프로퍼티를 조절하거나 함수를 활용하여 UI에 보이는 아바타의 모습을 변경해 봅시다

#### UI에서 아바타 보여주기

간단하게 UI에서 아바타를 보여주는 방법을 살펴봅시다.

1. UI 에디터를 연 뒤, **[이미지]** 버튼을 눌러 엔티티를 추가합니다. 본 예제에서는 **DefaultGroup**에 추가하겠습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16734983895969a0457ac51754fd2923c7d97e8360a34.png)
2. 추가한 이미지 엔티티의 이름을 **MyInfoWindow**로 변경하고 **ImageRUID**에 아래 내용을 입력합니다. 이후 **RectSize**에 적당한 값을 입력합니다.
  - **ImageRUID** : **8122dd6f67f3d9b4db8a3152172f9063**
  - **RectSize** : **X = 350, Y : 460**
3. **Hierarchy**에서 콘텍스트 메뉴를 열고 **Create Entity - Create UIEmpty**를 클릭해서 **UIEmpty**를 만듭니다.
4. **UIEmpty**의 이름을 **MyInfo**로 변경하고 프로퍼티 에디터에서 **CostumeManagerComponent**와 **AvatarGUIRendererComponent**를 추가합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16747841322955b99b98e5ecc4c569cf74afef544d15b.png)
5. **RectSize**에 적당한 값을 입력합니다. 그리고 **MyInfoWindow** 위의 적당한 곳에 위치를 잡아줍니다.
  - **RectSize** : **X = 270, Y : 400** ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16747852539050f91bb139c244f2190199e8436edaf5c.png)
6. **Hierarchy**에서 **MyInfo**의 위치를 **MyInfoWindow** 하위로 옮깁니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16734988019776451e912fdc64b22947bb1f22db571c0.png)

#### UI 아바타 옷 변경하기

특정 오브젝트에 부딪히면 캐릭터의 옷이 바뀌고, UI에 보이는 아바타 옷도 바뀌는 예제를 살펴보겠습니다.

1. **Preset List**에서 아무 오브젝트나 배치한 뒤, **SpriteRUID**에 아래의 값을 입력합니다. 그리고 오브젝트의 이름을 **Pinkbean**으로 변경합니다.
  - **SpriteRUID** : **5a81ed24c1354d08b38f8db4b497b607** ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1673503382686e463830b58984fe0a02931f0950220a3.png)
2. **BaseEnvironment - NativeScripts - Component - TriggerComponent**의 콘텍스트 메뉴에서 **Extend**를 클릭합니다.
3. 확장한 스크립트 컴포넌트의 이름을 **ChangeUIAvatar**으로 변경합니다.
4. 위에서 배치한 오브젝트인 **Pinkbean**에 **ChangeUIAvatar** 컴포넌트를 추가합니다.
5. **ChangeUIAvatar** 스크립트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
Entity myInfo = /ui/DefaultGroup/MyInfoWindow/MyInfo
[None]
string changeCap = "1e6e49a6ecf94cc6872926598dcf179c"
[None]
string changeLongcoat = "22ab95fb9c3c4539b04d6a540f464e79"
[None]
string changeOHWeapon = "bbe63d40682c4f8ebcdbc22e7d92a5eb"
```
6. **Overridable Function**에서 `OnEnterTriggerBody()` 함수를 추가하고 아래와 같이 작성합니다.```
override void OnEnterTriggerBody(TriggerEnterEvent enterEvent)
{
    __base:OnEnterTriggerBody(enterEvent)

    -- 오브젝트와 충돌한 대상(플레이어)를 받아옴
    local player = enterEvent.TriggerBodyEntity

    -- 오브젝트와 충돌한 대상에게 AvatarRendererComponent가 없으면 의상 변경 되지 않음
    local costumeManager = player.CostumeManagerComponent
    if costumeManager == nil then
        return
    end

    -- 내 캐릭터 장비 변경
    costumeManager.CustomCapEquip = self.changeCap
    costumeManager.CustomLongcoatEquip = self.changeLongcoat
    costumeManager.CustomOneHandedWeaponEquip = self.changeOHWeapon

    if self:IsServer() then 
        return 
    end

    -- UI 아바타 장비 변경
    local myInfo = self.myInfo
    local myInfoCostumeManager = myInfo.CostumeManagerComponent

    myInfoCostumeManager.CustomCapEquip = self.changeCap
    myInfoCostumeManager.CustomLongcoatEquip = self.changeLongcoat
    myInfoCostumeManager.CustomOneHandedWeaponEquip = self.changeOHWeapon
}
```
7. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 핑크빈 오브젝트에 캐릭터가 닿으면 캐릭터의 의상과 UI 아바타의 의상이 모두 변경되는 것을 확인합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16735057387005fe75284eb82440fa0f179c088110d32.gif)

#### 아바타 색상 변경

스크립트로 **AvatarGUIRendererComponent**의 **Color** 프로퍼티를 변경해봅시다. 버튼을 누르면 UI에 보이는 아바타의 색상 값이 랜덤하게 변경되는 예제를 살펴보겠습니다.

1. UI 에디터에서 버튼을 추가한 뒤 이름을 **SetColorBtn**으로 입력합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1673836836089d930239e5f034b8785e475aa09296d7c.png)
2. **SetColorBtn**에 **TextComponent**를 추가하고 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| :---: | :---: | :---: | | TextComponent | Text | SetColor | | FontColor | #FFFFFF |
3. **ChangeUIAvatar** 스크립트 컴포넌트에 `SetColor()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client Only]
void SetColor()
{
    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
    local a = _UtilLogic:RandomDouble()
    self.myInfo.AvatarGUIRendererComponent.Color = Color(r,g,b,a)
}
```
4. 새로 **TestUIBtn** 스크립트 컴포넌트를 생성합니다. 그리고 **SetColorBtn**에 **TestUIBtn** 컴포넌트를 추가합니다.
5. **TestUIBtn** 스크립트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
ChangeUIAvatar changeUIAvatar = /maps/map01/Pinkbean
```
  > **Tip.** 프로퍼티 타입을 ChangeUIAvatar로 설정하려면, 프로퍼티 타입에서 Component를 클릭한 뒤 ChangeUIAvatar 컴포넌트를 검색해서 추가하면 됩니다.
6. **TestUIBtn** 스크립트의 이벤트 핸들러에 **ButtonClickEvent**를 추가하고 아래와 같이 작성합니다.```
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --Parameters
    local Entity = event.Entity
    --------------------------------
    local name = Entity.Name
    local changeUIAvatar = self.changeUIAvatar

    --Property
    if name == "SetColorBtn" then
        changeUIAvatar:SetColor()
    end
}
```
7. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **[SetColor]** 버튼을 누를 때마다 UI 아바타의 색상 값이 변경됩니다. ![color](https://mod-file.dn.nexoncdn.co.kr/bbs/1673935701110863dae7d69624a3bb8f1f747cd007fbf.gif)

#### 파츠 색상 변경

버튼을 누르면 UI에 보이는 아바타 파츠 색상 값이 랜덤하게 변경되는 예제입니다.

1. **SetColorBtn** 버튼의 콘텍스트 메뉴에서 **Duplicate**를 클릭해 복제합니다.
2. 버튼의 위치를 적당히 옮기고 이름을 **SetPartColorBtn**으로 변경합니다.
3. **SetPartColorBtn - TextComponent - Text** 프로퍼티에 **SetPartColor**를 입력합니다.
4. **ChangeUIAvatar** 스크립트 컴포넌트에 `SetPartColor()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client Only]
void SetPartColor()
{
    local parts = 
    {
    	MapleAvatarItemCategory.Body,
    	MapleAvatarItemCategory.Cap,
    	MapleAvatarItemCategory.Cape,
    	MapleAvatarItemCategory.Coat,
    	MapleAvatarItemCategory.Ear,
    	MapleAvatarItemCategory.EarAccessory,
    	MapleAvatarItemCategory.EyeAccessory,
    	MapleAvatarItemCategory.Face,
    	MapleAvatarItemCategory.FaceAccessory,
    	MapleAvatarItemCategory.Glove,
    	MapleAvatarItemCategory.Hair,
    	MapleAvatarItemCategory.Head,
    	MapleAvatarItemCategory.Longcoat,
    	MapleAvatarItemCategory.OneHandedWeapon,
    	MapleAvatarItemCategory.Pants,
    	MapleAvatarItemCategory.Shoes,
    	MapleAvatarItemCategory.SubWeapon,
    	MapleAvatarItemCategory.TwoHandedWeapon
    }

    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
    local a = _UtilLogic:RandomDouble()

    local index = _UtilLogic:RandomIntegerRange(1,18)

    self.myInfo.AvatarGUIRendererComponent:SetAvatarPartColor(parts[index], r, g, b, a)
}
```
5. **TestUIBtn** 스크립트의 **ButtonClickEvent**에 아래 내용을 추가합니다.```
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --Parameters
    local Entity = event.Entity
    --------------------------------
    local name = Entity.Name
    local changeUIAvatar = self.changeUIAvatar

    --Property
    if name == "SetColorBtn" then
        changeUIAvatar:SetColor()
    -- 아래 내용 추가
    elseif name == "SetPartColorBtn" then
    	changeUIAvatar:SetPartColor()
    end
}
```
6. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **[SetPartColorBtn]** 버튼을 누를 때마다 UI 아바타 랜덤 파츠의 색상 값이 변경됩니다. ![partcolor](https://mod-file.dn.nexoncdn.co.kr/bbs/167393592286102105ba6e40f42b099350d3a70dfb1f4.gif)

#### 감정 표현 변경

버튼을 누르면 UI에 보이는 아바타 감정 표현이 랜덤하게 변경되는 예제입니다.

1. **SetColorBtn** 버튼의 콘텍스트 메뉴에서 **Duplicate**를 클릭해 복제합니다.
2. 버튼의 위치를 적당히 옮기고 이름을 **SetEmotionBtn**으로 변경합니다.
3. **SetEmotionBtn - TextComponent - Text** 프로퍼티에 **SetEmotion**을 입력합니다.
4. **ChangeUIAvatar** 스크립트 컴포넌트에 `SetEmotion()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client Only]
void SetEmotion()
{
    local emotions = 
    {
    	EmotionalType.Hit,
    	EmotionalType.Smile,
    	EmotionalType.Troubled,
    	EmotionalType.Cry,
    	EmotionalType.Angry,
    	EmotionalType.Bewildered,
    	EmotionalType.Stunned,
    	EmotionalType.Vomit,
    	EmotionalType.Oops,
    	EmotionalType.Cheers,
    	EmotionalType.Chu,
    	EmotionalType.Wink,
    	EmotionalType.Pain,
    	EmotionalType.Glitter,
    	EmotionalType.Despair,
    	EmotionalType.Love,
    	EmotionalType.Shine,
    	EmotionalType.Blaze,
    	EmotionalType.Hum,
    	EmotionalType.Bowing,
    	EmotionalType.Hot,
    	EmotionalType.Dam,
    	EmotionalType.qBlue
    }

    local index = _UtilLogic:RandomIntegerRange(1, 23)
    self.myInfo.AvatarGUIRendererComponent:PlayEmotion(emotions[index], 3)
}
```
5. **TestUIBtn** 스크립트의 **ButtonClickEvent**에 아래 내용을 추가합니다.```
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --Parameters
    local Entity = event.Entity
    --------------------------------
    local name = Entity.Name
    local changeUIAvatar = self.changeUIAvatar

    --Property
    if name == "SetColorBtn" then
        changeUIAvatar:SetColor()
    elseif name == "SetPartColorBtn" then
    	changeUIAvatar:SetPartColor()
    -- 아래 내용 추가
    elseif name == "SetEmotionBtn" then
        changeUIAvatar:SetEmotion()
    end
}
```
6. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **[SetEmotion]** 버튼을 누를 때마다 UI 아바타 감정 표현이 변경됩니다. ![emotion](https://mod-file.dn.nexoncdn.co.kr/bbs/16739360881637f9ea067d7444efd8b7148aafc5cb01c.gif)

Update 2025-11-17 PM 08:14


# 영상 재생시키기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

내가 찍은 영상 혹은 함께 보고 싶은 영상을 가져와 재생할 수 있습니다.

# Youtube 관련 컴포넌트 소개

영상은 UI로 사용하거나 World에 배치해 사용할 수 있습니다. UI로 사용할 경우 YoutubeGUIPlayerComponent를 사용하고, World에 배치할 경우 YoutubePlayerWorldComponent를 사용합니다. UI로 사용한다면 영상은 배치한 곳에 고정되므로, 맵을 돌아다니더라도 유저가 보고 있는 화면의 특정 위치에서 움직이지 않습니다. World에서 영상을 사용한다면 배치한 위치에 고정되며, 기본적으로 플레이어가 움직여도 영상은 따라오지 않습니다. ![youtube](https://mod-file.dn.nexoncdn.co.kr/bbs/1639617553145463b36f7117043408f8c0fea93f888fe.gif)

> **Tip** 연결한 영상을 바로 재생으로 설정했더라도, 테스트 시 재생됩니다.

#### YoutubePlayerWorldComponent 프로퍼티

| 프로퍼티 | 설명 |
| --- | --- |
| Urls | 재생할 영상의 주소를 입력합니다. <br><li>Size: 입력한 수만큼 영상의 Url을 입력할 수 있습니다.</li> |
| LocalScale | 영상의 크기를 설정합니다. |
| ShowController | 영상을 제어할 수 있는 UI를 보여줍니다. |
| ControllerScale | 영상을 제어하는 재생 바와 버튼의 크기를 설정합니다. |
| IgnoreMapLayerCheck | 활성화하면 맵 레이어에 노출되는 이름으로 SortingLayer를 지정할 수 있는 기능을 끕니다. |
| PlayOnAwake | 활성화 시 월드에 입장하면 영상이 자동 재생됩니다. |
| Loop | 영상을 반복 재생합니다. |
| Shuffle | 활성화 시 영상의 재생 순서를 섞어 재생합니다. |
| Volum | 음량 크기를 설정합니다. 0부터 1 사이의 값을 사용할 수 있습니다. |
| PlaySpeed | 영상의 재생 속도를 설정합니다. 0.5부터 3 사이의 값을 사용할 수 있습니다. |
| SortingLayer | SortingLayer에 따라서 2개 이상의 YoutubePlayer가 겹쳤을 때 보이는 우선순위가 달라집니다. |
| OrderInLayer | 레이어를 정렬합니다. 한 레이어 안에 엔티티들의 순서를 정할 수 있습니다. |

#### YoutubePlayerGUIComponent 프로퍼티

| 프로퍼티 | 설명 |
| --- | --- |
| Loop | 활성화 시 영상을 반복 재생합니다. |
| PlayOnAwake | 활성화 시 월드에 입장하면 영상이 자동 재생됩니다. |
| Shuffle | 활성화 시 영상 순서를 뒤섞어 재생합니다. |
| Urls | 재생할 영상의 주소를 입력합니다. <br><li>Size: 입력한 수만큼 영상의 Url을 입력할 수 있습니다.</li> |
| Volum | 음량 크기를 설정합니다. 0부터 1 사이의 값을 사용할 수 있습니다. |
| PlaySpeed | 영상의 재생 속도를 설정합니다. 0.5부터 3 사이의 값을 사용할 수 있습니다. |

# 월드에 영상 재생하기

1. **![Tab_Workspace](https://mod-file.dn.nexoncdn.co.kr/bbs/1634542479186400047df886b445e959cb1503f312508.png)Workspace - ![workspace_NativeFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634598960433b8c2accd227347b29b0efb94f1320156.png) NativeModel - ![workspace_Model](https://mod-file.dn.nexoncdn.co.kr/bbs/16345998699992db91451454e4357a1a26f2fc8d94b61.png) YoutubePlayerWorld**를 선택해 배치합니다.![youtube01](https://mod-file.dn.nexoncdn.co.kr/bbs/1638869874178184b15bdee814320afc34e98cac68bdf.png)
2. Size에 2 입력하고, 영상 Url을 입력합니다.
  - https://www.youtube.com/watch?v=hvzp4kOtaSw
  - https://youtu.be/3Kom6vz6nic
3. 프로퍼티 값을 설정한 뒤 ![Common_SoundPlay](https://mod-file.dn.nexoncdn.co.kr/bbs/1635317657654c59c47ffc44d414db579b8d2fc0715a8.png) 시작을 눌러 확인합니다.![youtube02](https://mod-file.dn.nexoncdn.co.kr/bbs/163886989504016bb3fe6c3374db3ae0875f29add252f.png)

# GUI로 영상 재생하기

1. ![TabUI](https://mod-file.dn.nexoncdn.co.kr/bbs/16345246682320aa0a7ca88a64b33b1bdeddb56363f63.png)UI에디터로 전환하고, **![Tab_Asset](https://mod-file.dn.nexoncdn.co.kr/bbs/1634542426491c95a16f3ea3e4ffcb78909e4c6bbbd3d.png) Preset List에서 Youtube 모델**을 선택해 화면에 배치합니다.![youtube15](https://mod-file.dn.nexoncdn.co.kr/bbs/1639102697425418eca0a352b42ab89c28ba2ce5e2a15.png)
2. Size에 값 2를 입력하고 영상 Url을 입력합니다.
  - https://youtu.be/3Kom6vz6nic
  - https://www.youtube.com/watch?v=hvzp4kOtaSw
3. 프로퍼티 값을 설정한 뒤 ![Common_SoundPlay](https://mod-file.dn.nexoncdn.co.kr/bbs/1635317657654c59c47ffc44d414db579b8d2fc0715a8.png) 시작을 눌러 확인합니다.![youtube03](https://mod-file.dn.nexoncdn.co.kr/bbs/1638871880838e765a1ff0c754da9b2396f95522c81c0.png)

# 함수 활용 예시

월드에 입장하면 영상을 바로 00:20초부터 재생을 시작하게 만들고, 재생 중에 특정 키를 입력할 때 함수가 동작하게 만듭니다. YoutubePlayerWorldComponent와 YoutubePlayerGUIComponent의 함수 사용법은 동일합니다. 예시는 YoutubePlayerWorldComponent가 기준입니다. 예시 Url: https://www.youtube.com/watch?v=9pL_b1fl9LQ&t=1s

1. YoutubePlayerController 스크립트 컴포넌트를 만들어, 배치한 Youtube 모델에 추가합니다.![youtube20](https://mod-file.dn.nexoncdn.co.kr/bbs/16391219258191430dbcee5304feb98a12e950231b349.png)
2. 키보드의 특정 키가 눌렸을 때 영상을 제어하는 스크립트를 작성합니다.
  - 월드에 입장하면 영상의 00:20 지점부터 자동 재생
  - P 입력: 영상 멈춤
  - L 입력: 영상 일시 정지, 재생
  - 숫자 0 입력: 영상의 처음으로 돌아가 재생 시작

> **더 알아보기** 모든 함수의 실행 제어는 ClientOnly로 설정했기 때문에 특정 시간에 모든 유저가 같은 장면을 보고 있지 않습니다. 만약 모든 유저가 같은 화면을 보길 원한다면 동기화 작업이 필요합니다.

#### 특정 지점에서 영상 시작

영상의 재생 지점을 00:20으로 지정하고 플레이합니다.

```
[client only]
void Jump(int timeInSeconds, string targetUserId)
{
    void OnBeginPlay()
    self.Entity.YoutubePlayerWorldComponent:Jump(20.0)
}
```

#### P키를 눌러 영상 멈추기

```
[client only]
void Pause(string targetUserId) 
{
    void Pause() 
    self.Entity.YoutubePlayerWorldComponent:Pause()
}
```

#### 0키를 눌러 영상 처음부터 재생하기

```
[client only]
void PlayFromStart()
{
    self.Entity.YoutubePlayerWorldComponent:Play()
    self.Entity.YoutubePlayerWorldComponent:Jump(0)
}
```

#### L 키를 눌러 영상 일시 정지, 다시 재생하기

```
[client only]
void PlayPause(string targetUserId)
{
    self.Entity.YoutubePlayerCommonComponent:PlayPause()
}
```

#### KeyDownEvent 활용

키 입력을 위해선 **EntityEventHandler**에 아래와 같이 `KeyDownEvent`를 활용해야합니다. 특정 키가 입력되었을 때 실행될 함수를 이벤트 핸들러에 작성합니다.

```
[Service: InputService] 
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local key = event.key
    ---------------------------------------------------------

    local keyStr = tostring(key)
    if keyStr == "P" then
        self:Pause()
    elseif keyStr == "Alpha0" or keyStr == "Keypad0" then
        self:PlayFromStart()
    elseif keyStr == "L" then
        self:PlayPause()
    end
}
```

Update 2025-11-17 PM 08:14


# 다양한 선 그리기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

LineRendererComponent를 활용해 다양한 선을 월드에 자유롭게 그릴 수 있습니다.

# LineRendererComponent

LineRendererComponent는 점의 개수를 지정해 MapleTile, RectTile 위에서 원하는 직선, 곡선을 그릴 수 있습니다. LineRendererComponent 하나당 하나의 선을 그릴 수 있으므로, 여러 선을 표현하고 싶다면 여러 개의 LineRendererComponent가 포함된 엔티티를 사용해야 합니다. 주요 프로퍼티는 아래와 같습니다.

#### IsSmooth

활성화 시 부드러운 곡선을 그려지고, 비활성화 시 날카로운 꺾은 선으로 그립니다. ![IsSmoothExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1657949398141826c485f476c4c54b73aea6bfb6198d6.png)

#### Loop

활성화 시 시작점과 끝점을 이어 닫힌 선을 그려줍니다. 기본값은 비활성화 상태입니다. ![LoopExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1657949416703539389372f8641d7b98f05d5d5cb287e.png)

#### Points

선을 구성하는 정점들의 집합입니다.

- **Points Edit**: [Edit] 버튼을 눌러 편집을 활성화할 수 있습니다. Scene에서 Point 위치를 수정 및 추가, 삭제할 수 있습니다.
- **Size**: 선을 연결하는 점의 개수를 의미합니다. 0부터 시작하며, Size에 입력한 값만큼 점이 추가됩니다.
- **[숫자]**: 선의 연결점 개수를 의미합니다.
- **Color**: 선 색상을 지정합니다. 하나의 컴포넌트에서 Size마다 다른 색을 지정하면, 색이 교차하는 지점은 자연스럽게 섞여 보입니다 ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16944139559805794266b75bd4670835226315bec0354.png)
- **Position**: 선을 연결하는 점의 위치를 나타냅니다. 최소 2개를 만들어야 선이 그려집니다. 가장 처음 [1]을 (0,0) 기준으로 삼아 x, y 값을 변경해 선을 그릴 수 있습니다.
- **Width**:선의 두께를 지정합니다. 수가 클수록 두꺼워집니다.![WidthExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1657949740811c064ec15791d40c0a2fc0c98dbbf57b6.png)

# 월드에 선 그리기

#### 직선 그리기

Points 2개를 이용해 Position을 정하고 직선을 그릴 수 있습니다.

1. ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png)EmptyEntity를 생성하고, LineRendererComponent를 추가합니다.
2. Size에 3을 입력하고, Color와 Width를 지정합니다.
3. 각각의 Position에 (0,0), (4,0)을 입력합니다. ![line](https://mod-file.dn.nexoncdn.co.kr/bbs/166358584146243474ff4f1644094891eed7a6da66834.png)

#### 삼각형 그리기

Points 3개를 활용해 시작점과 끝점을 이어 삼각형을 그릴 수 있습니다.

1. ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png)EmptyEntity를 생성하고, LineRendererComponent를 추가합니다.
2. Size에 3을 입력하고, Color와 Width를 지정합니다.
3. 각각의 Position에 (0,0), (1,1), (2,0)을 입력합니다.
4. Loop 프로퍼티를 활성화합니다. ![triangle](https://mod-file.dn.nexoncdn.co.kr/bbs/1663844235905ace8de03857e44f1b9c55a8c83d2199d.png)

#### 곡선으로 모양 그리기

Points 4개와 IsSmooth 프로퍼티를 활용해 선을 곡선으로 그릴 수 있습니다.

1. ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png)EmptyEntity를 생성하고, LineRendererComponent를 추가합니다.
2. Size에 4을 입력하고, Color와 Width를 지정합니다.
3. 각각의 Position에 (0,0), (1,1), (2,-1), (3,0)을 입력합니다.
4. IsSmooth와 Loop 프로퍼티 활성화합니다. ![loop](https://mod-file.dn.nexoncdn.co.kr/bbs/16579497886734ab7d8aba66a4ceab4f245a45535c6cd.png)

#### 머티리얼을 사용해 그리기

머티리얼의 SpritePattern 셰이더를 활용해 선을 그릴 수 있습니다. 머티리얼 활용 방법은 [머티리얼 활용하기](docs/?postId=828)를 참고하세요. LineRendererComponent에 활용하는 스프라이트로는 유저 리소스와 복제한 MSW 리소스를 사용할 수 있습니다. MSW 리소스 복제 방법은 [리소스 관리](docs/?postId=690)를 참고하세요.

1. **Workspace - MyDesk - Create Material**을 선택해 새로운 Material을 만듭니다.
2. 생성한 머티리얼의 프로퍼티 창에서 **Shader - LineRenderer - SpritePattern**를 선택합니다.
3. **SpriteRUID**에 사용할 이미지를 선택합니다. 필요한 경우 Offset, Scale 값을 조정합니다.
4. ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png)EmptyEntity를 생성하고, LineRendererComponent를 추가합니다.
5. LineRendererComponent의 **MaterialId**에서 ![open](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_open_folder.png)을 눌러 머티리얼을 지정합니다.
6. Size와 Position 값을 변경해 선을 그립니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16842378305042dc663a11c3b49eebd58b8804d407e88.png)

> **Tip.** 유저 리소스와 복제한 MSW 리소스 모두 랩 모드를 **Repeat**로 설정해야 합니다. ![Repeat](https://mod-file.dn.nexoncdn.co.kr/bbs/168422631874542cfe7bb765e4d659b113e430d223b99.png)
> **Tip.** LinePoints 수가 10000개가 넘으면, 그 이후의 LinePoints는 선이 그려지지 않습니다. 또한 IsSmooth를 사용하면 그릴 수 있는 LinePoints 총 개수는 약 1000개로 감소합니다.

# 활용 예시

플레이어를 따라 다니는 모델을 만들어, 플레이어의 움직임을 따라 선이 그려지고, 사라지게 만들어봅시다.

![TrailExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1657952569571be162fe5c3c64716b82f6a51e091f1cc.gif)

1. ![model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png)Trail 모델을 생성하고, TransformComponent와 LineRendererComponent를 추가합니다.
2. 새로운 ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) TrailDrawer 컴포넌트를 생성하고, Trail 모델에 추가합니다.```
[None]
Vector3 PrevPos = Vector3(0,0,0)
[None]
number Threshold = 0.1
[None]
number PointLife = 2
[None]
SyncTable<number> PointLives
[None]
Entity Target = nil

Method:
[client only]
void OnUpdate(number delta)
{
    self:EraseTail(delta)

    local currPos = self.Target.TransformComponent.WorldPosition
    local dist = Vector3.Distance(self.PrevPos, currPos)

    if dist < self.Threshold then
    	return
    end

    self.PrevPos = currPos
    self:AddPoint(currPos)
}

void EraseTail(number delta)
{
    local currPos = self.Target.TransformComponent.WorldPosition

    for i = 1, #(self.PointLives) do
    	local life = self.PointLives[i]
    	life = life - delta
    	self.PointLives[i] = life
    end

    if #(self.PointLives) == 1 then
    	self:RemovePointAt(1)
    	self:AddPoint(currPos)
    	return
    end

    if self.PointLives[1] <= 0 then
    	self:RemovePointAt(1)
    end
}

void AddPoint(Vector3 pos)
{
    local line = self.Entity.LineRendererComponent
    local pointPos = Vector2(pos.x, pos.y + 0.25)

    -- 랜덤으로 색상 그리기
    local r = _UtilLogic:RandomDouble()
    local g = _UtilLogic:RandomDouble()
    local b = _UtilLogic:RandomDouble()
    line.Points:Add(LinePoint(pointPos, Color(r, g, b), 1))
    table.insert(self.PointLives, self.PointLife)
}

void RemovePointAt(number idx)
{
    -- 선 삭제
    table.remove(self.PointLives, idx)
    self.Entity.LineRendererComponent.Points:RemoveAt(idx)
}


void Init(Entity target)
{
    self.Target = target

    local pos = target.TransformComponent.WorldPosition

    self.PrevPos = pos

    self:AddPoint(pos)
}
```
3. 새로운 ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) TrailSpawner 컴포넌트를 생성하고, ![DefaultPlayer](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer에 추가합니다.
4. ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png)TrailSpawner 컴포넌트에 움직임에 따라 선이 스폰되도록 `SpawnService`를 활용해 아래와 같이 작성합니다. SpawnByModelId에는 ![model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Trail의 ID를 입력해야합니다. 예시의 ID를 사용하면 정상 동작하지 않으므로 주의해 작성하세요.```
Property:
[None]
Entity TrailEntity = nil

Method:
[client only]
void OnBeginPlay ()
{
    self.TrailEntity = _SpawnService:SpawnByModelId("8ae67c69-32ac-40e3-82b1-03d1409be467", "Trail", Vector3.zero, nil)
    self.TrailEntity.TrailDrawer:Init(self.Entity)
}

void OnEndPlay ()
{
    if self.TrailEntity ~= nil then
    	self.TrailEntity:Destroy()
    end
}
```

##### 참고 가이드

- [RectTileMap의 활용](/docs/?postId=589)
- [엔티티의 위치, 크기, 회전 조정](/docs/?postId=82)

Update 2025-11-17 PM 08:14


# 다각형 그리기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 안내

PolygonRendererComponent를 활용해 다각형을 월드에 자유롭게 그릴 수 있습니다.

# PolygonRendererComponent

`PolygonRendererComponent`는 점을 이어 월드에 다각형을 그릴 수 있습니다. 추가된 점의 순서를 따라 다각형이 그려집니다. 만약 점을 이을 때 선이 교차하면 다각형은 그려지지 않습니다. 다각형이 그려지는지 확인이 필요할 때는 `IsDrawable()` 함수를 사용해 확인할 수 있습니다.

아래와 같이 점들의 좌표를 입력하면 (0,0) (3,2)를 연결한 선과 (1,0) (2,2)를 연결한 선이 교차하기 때문에 다각형이 그려지지 않습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1692247765816f43f2f51cd72421fa5b6b38c8f1a1b4e.png)

선끼리 교차하지 않게 점들의 좌표를 입력하면 다각형이 그려집니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16922477424456fa94597546b46dfb64ac2eed48916c7.png)

`PolygonRendererComponent`의 주요 프로퍼티는 아래와 같습니다.

- **Points Edit**: [Edit] 버튼을 눌러 편집을 활성화 할 수 있습니다. Scene에서 Point 위치를 수정 및 추가, 삭제할 수 있습니다.
- **Color**: 다각형의 색상을 지정합니다.
- **Points**: 선을 구성하는 정점들의 집합입니다.
  - **Size**: 선을 연결하는 점의 개수를 의미합니다. 0부터 시작하며, Size에 입력한 값만큼 점이 추가됩니다.
  - **[숫자]**: 몇 번째 점인지를 의미합니다. X, Y 값은 점의 좌표입니다.

# 활용 예제

#### 다각형 그리기

1. 새로운 ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png) EmptyEntity를 생성하고, **TransformComponent, PolygonRendererComponent**를 추가합니다.
2. PolygonRendererComponent의 **Points**를 선택하고, **Size**에 수를 입력합니다.
3. 점의 좌표를 입력하고, **Color**를 지정합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16944121241288615fed41bbe4d32bc36b4eea6e4b651.png)

> **Tip.** Points가 2,000개를 초과하면 이후 Points는 그려지지 않습니다. 서로 다른 변을 교차하게 Points를 배치하면 다각형이 그려지지 않습니다.

#### 머티리얼로 다각형 그리기

머티리얼의 **PolygonSprite** 셰이더를 활용해 다각형을 칠할 수 있습니다. 머티리얼 활용 방법은 [머티리얼 활용하기](docs/?postId=828)를 참고하세요. PolygonRendererComponent에 활용하는 머티리얼의 스프라이트로는 유저 리소스와 복제한 MSW 리소스를 사용할 수 있습니다. MSW 리소스 복제 방법은 [리소스 관리](docs/?postId=690)를 참고하세요.

1. **Workspace - MyDesk - Create Material**을 선택해 새로운 Material을 만듭니다.
2. 생성한 머티리얼의 프로퍼티 창에서 **Shader - PolygonRenderer - PolygonSprite**를 선택합니다.
3. **SpriteRUID**에 사용할 이미지를 선택합니다. 필요한 경우 Offset, Scale 값을 조정합니다.
4. ![entity](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_entity_no.png)EmptyEntity를 생성하고, PolygonRendererComponent를 추가합니다.
5. PolygonRendererComponent의 **MaterialId**에서 ![open](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_open_folder.png)을 눌러 머티리얼을 지정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1694413381584443e343db0c5476daf441bf8017867cf.png)

> **Tip.** 유저 리소스와 복제한 MSW 리소스 모두 랩 모드를 **Repeat**로 설정해야 합니다. ![Repeat](https://mod-file.dn.nexoncdn.co.kr/bbs/168422631874542cfe7bb765e4d659b113e430d223b99.png)
> **Tip.** 머티리얼이 적용된 다각형의 크기를 키우면 머티리얼도 따라 커집니다. 다각형의 Rotate 값이 변경되면, 머티리얼의 스프라이트도 따라 변경됩니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/169225197319446744ec0a8594315ade9ee52da40ac70.png)

Update 2025-11-17 PM 08:14


# 웹 브라우저 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

**WebViewComponent**를 활용하면 웹 브라우저를 월드에 배치하고 탐색할 수 있습니다. 간단한 예제를 통해 월드에서 웹 브라우저를 활용하는 방법을 알아봅시다.

##### 참고 API Reference

[WebViewComponent](/apiReference/Components/WebViewComponent)

# WebViewComponent 소개

엔티티에 **WebViewComponent**를 추가하면 월드에 웹 브라우저를 배치할 수 있습니다. 먼저 **WebViewComponent**의 프로퍼티를 살펴봅시다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16903331826638ab8d0e6040e4a46848cae80cc1028fe.png)

| 프로퍼티 | 설명 |
| --- | --- |
| ClickingEnabled | 웹 뷰에서 클릭을 가능하게 할지 여부입니다. |
| HoveringEnabled | 마우스를 웹 뷰 위에 올려놓았을 때 웹 요소와 상호작용 가능 여부를 설정합니다. |
| ScrollingEnabled | 웹 뷰에서 스크롤 가능 여부를 설정합니다. |
| DragMode | DragToScroll | 드래그 시 스크롤로써 동작합니다. <br> 따라서 스크롤바를 드래그해도 스크롤바를 직접 조종하는 식으로 동작하지 않고 그냥 페이지에서 드래그를 시작하듯 동작합니다. <br> 데스크톱에서 스크롤바를 드래그하는 것과 같이 동작하게 하려면 DragMode로 DragWithinPage를 사용해야 합니다. |
| DragWithinPage | 페이지 내에서 드래그하면 일반적으로 웹페이지에서 마우스로 드래그하듯이 작동합니다. |
| Disabled | 드래그가 되지 않습니다. |
| DragThreshold | 드래그할 때 클릭으로 인식하지 않게 만들기 위한 임곗값입니다. 수치가 매우 높으면 드래그가 클릭으로 인식될 수 있습니다. |
| PixelPerUnit | 1 Unit 당 표시될 픽셀의 수입니다. <br>100 ~ 500까지의 값을 사용합니다. <br>수치가 크면 더 많은 콘텐츠를 보여줄 수 있으나 웹 요소들이 작게 보입니다. |
| ScrollSensitivity | 마우스 휠로 페이지를 스크롤 할 때 얼마나 많이 스크롤 될지 결정합니다. |
| Url | 웹 페이지의 주소입니다. <br>Url을 변경하면 해당 웹 페이지를 로드합니다.<br> 빈 문자열이나 유효하지 않은 형태의 주소를 입력하면 작동하지 않습니다. |
| SortingLayer | 2개 이상의 Entity가 겹쳤을 때 Sorting Layer에 따라 보이는 우선순위가 결정됩니다. |
| OrderInLayer | 같은 Layer 내의 우선순위를 결정합니다. 수가 클수록 앞에 보입니다. |
| IgnoreMapLayerCheck | SortingLayer에 Map Layer 이름을 지정했을 때 자동 치환을 수행하지 않습니다. |

> **더 알아보기** 1 Unit은 월드 내의 거리 단위입니다. WorldPosition의 (0,0) ~ (1,0)까지의 거리가 1 Unit입니다.

# 월드에 웹 브라우저 배치하기

월드에 웹 브라우저를 배치하면 월드의 특정 위치에 브라우저를 보여줄 수 있습니다. ![webview](https://mod-file.dn.nexoncdn.co.kr/bbs/1659077818567422ad8f56f884d0286111efe8a38b2ed.gif)

1. **Hierarchy** 탭에서 원하는 맵을 선택한 뒤 콘텍스트 메뉴를 엽니다. **Create Entity - Create Empty**를 선택해 **EmptyEntity**를 생성합니다.
2. 프로퍼티 에디터에서 **EmptyEntity**에 **TransformComponent**를 추가합니다.
3. 프로퍼티 에디터에서 **EmptyEntity**에 **WebViewComponent**를 추가하고 원하는 Url을 입력합니다.
4. **WebViewComponent**의 **SortingLayer** 프로퍼티를 **Layer1**로 변경합니다.
5. 엔티티의 크기를 적절하게 조절한 후 ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 눌러 테스트해 봅시다. 월드의 특정 위치에 웹 브라우저가 보이는 것을 확인할 수 있습니다.

# UI로 웹 브라우저 배치하기

UI로 웹 브라우저를 배치하면 화면의 특정 위치에 항상 웹 브라우저가 보이도록 할 수 있습니다. ![webviewui](https://mod-file.dn.nexoncdn.co.kr/bbs/165931683546031588f00cec548c0b1707a90878786ab.gif)

1. **Hierarchy - ui** 아래에서 원하는 UI 그룹의 콘텍스트 메뉴를 엽니다. **Create Entity - Create UIEmpty**를 선택해 **UIEmpty**를 생성합니다.
2. 프로퍼티 에디터에서 **UIEmpty**에 **WebViewComponent**를 추가하고 원하는 Url을 입력합니다.
3. 엔티티의 크기를 적절하게 조절한 후 ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 눌러 테스트해 봅시다. 화면의 특정 위치에 웹 브라우저가 보이는 것을 확인할 수 있습니다.

# 함수 활용 예시

## 키 입력으로 웹 브라우저 제어

키 입력을 통해 웹 브라우저를 제어하는 예제를 살펴봅시다.

1. **Workspace - MyDesk**에 새 스크립트 컴포넌트를 추가하고 이름으로 **WebViewTest**를 입력합니다.
2. 원하는 엔티티의 프로퍼티 에디터에서 **WebViewTest** 스크립트 컴포넌트를 추가합니다. **WebViewComponent**도 추가합니다.
3. 아래와 같이 키보드의 특정 키를 눌렀을 때 웹 브라우저를 제어하는 스크립트를 작성해봅시다. **WebViewTest** 스크립트에 **KeyDownEvent**를 추가하고 다음과 같이 작성합니다.```
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local key = event.key
    ---------------------------------------------------------

    if key == KeyboardKey.Backspace then
    	self.Entity.WebViewComponent:GoBack()
    	-- Backspace : 뒤로 가기
    end

    if key == KeyboardKey.Alpha0 then
    	self.Entity.WebViewComponent:GoForward()
    	-- 0 : 앞으로 가기
    end

    if key == KeyboardKey.Alpha5 then
    	self.Entity.WebViewComponent:Reload()
    	-- 5 : 페이지 새로 고침
    end

    if key == KeyboardKey.Equals then
    	self.Entity.WebViewComponent:ZoomIn()
    	-- = : 화면 확대
    end

    if key == KeyboardKey.Minus then
    	self.Entity.WebViewComponent:ZoomOut()
    	-- - : 화면 축소
    end

    if key == KeyboardKey.Home then
    	self.Entity.WebViewComponent:Scroll(Vector2(0, -100))	
    	-- Home : 페이지 시작 지점으로 이동
    end

    if key == KeyboardKey.End then
    	self.Entity.WebViewComponent:Scroll(Vector2(0, 100))	
    	-- End : 페이지 끝 지점으로 이동
    end
}
```
4. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 스크립트에서 지정한 키를 입력하여 각 기능을 사용해봅시다.

## 클릭한 좌표 기록

웹 브라우저에서 클릭한 지점의 좌표를 로그로 남겨봅시다. **WebViewClickedEvent**를 활용하면 클릭한 지점의 **normalizedPosition**을 확인할 수 있습니다. **normalizedPosition**이란 웹 뷰를 하나의 평면 좌표계라고 했을 때 왼쪽 상단을 (0,0), 오른쪽 하단을 (1,1)로 표현한 위치를 말합니다. 화면의 정중앙 좌표는 (0.5,0.5) 입니다. ![normalizedPosition](https://mod-file.dn.nexoncdn.co.kr/bbs/1659333200156ced814fff9734a89a53c313e6f386874.png)

1. **WebViewTest** 스크립트에 **WebViewClickedEvent**를 추가하고 다음과 같이 작성합니다.```
Event Handler:
[self]
HandleWebViewClickedEvent(WebViewClickedEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: WebViewComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local NormalizedPosition = event.NormalizedPosition
    ---------------------------------------------------------

    log("Clicked: ("..NormalizedPosition.x..", "..NormalizedPosition.y..")")
}
```
2. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 테스트해 봅시다. 웹 뷰의 특정 지점을 클릭하면 해당 위치의 **normalizedPosition** 좌표를 로그로 확인할 수 있습니다. ![log](https://mod-file.dn.nexoncdn.co.kr/bbs/16593302650606bb94d2db1ca44a5882d429e6338bc84.png)

Update 2025-11-17 PM 08:14


# 엔티티의 위치, 크기, 회전 조정

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

**TransformComponent** 구성과 사용 방법을 설명합니다. 좌표 개념을 이해하고, 엔티티의 이동, 회전, 크기 조절을 할 수 있습니다.

# 엔티티 변형 방법

엔티티를 변형하는 방법은 두 가지입니다. 크리에이터의 선호에 따라 사용할 수 있습니다.

- 프로퍼티 에디터에서 **TransformComponent** 프로퍼티 값을 변경합니다.
- **Scene**에서 엔티티를 선택, 드래그하거나 핸들러를 이용해 조정합니다.

# 좌표 이해하기

**TransformComponent**를 사용하기 위해 먼저 좌표 개념을 살펴보겠습니다. **World**에 배치한 엔티티는 좌표를 기반으로 '위치, 크기 회전'을 조정할 수 있습니다. X 축은 좌우, Y 축은 상하, Z 축은 앞뒤를 의미하는 좌표 축입니다. 증감 값은 음수와 양수로 표현합니다. ![Transform01](https://mod-file.dn.nexoncdn.co.kr/bbs/1637114783017401b498e2b214c02a549e756b19f3bb3.png) X, Y, Z 축은 3D 게임에서 주로 이용하는 개념입니다. 메이플스토리 월드는 2D 모델을 사용하기 때문에 엔티티 상태 변화를 위해 세 축을 다 사용하지는 않습니다. **Position**과 **Scale**은 X, Y 값을 가장 많이 사용하며, Z 값은 2D 엔티티에서는 필요할 때 사용합니다. 여러 엔티티가 겹쳐 있으면 Z 값이 클수록 앞에, 작을수록 뒤에 놓여 마치 레이어 순서처럼 보입니다. **회전**은 오직 Z 축을 기준으로 움직입니다. 그러므로 **Position, Scale**과 다르게 **ZRotation/WorldZRotation**으로 독립적으로 명명되어 하나의 값만 입력할 수 있습니다. 사용 빈도를 표로 구분하면 아래와 같습니다.

|  | PositionWorldPosition | Scale | ZRotationWorldZRotation |
| --- | --- | --- | --- |
| **X** | ● | ● | X |
| **Y** | ● | ● | X |
| **Z** | ▲ | ▲ | ● |

#### Z 값 사용

**Position**과 **Scale**의 Z 값을 사용하는 일이 드문 이유는 2D 이미지를 사용하기 때문입니다. 2D는 면이기에 면적만 변형이 가능합니다. 앞뒤로 튀어나온 부피가 없으므로 Z 값을 변경해도 변화가 없습니다. 그러나 여러 개의 엔티티가 겹쳐져 있을 때, Z 값을 조정해 레이어의 순서를 바꾸듯 순번에 영향을 줄 수 있습니다. ![transform02](https://mod-file.dn.nexoncdn.co.kr/bbs/1637114865603b3dbe59028114cbc95e80edb39e3d4aa.png) **Rotation**에서 Z 값만 사용하는 이유 또한 2D 이미지이기 때문입니다. 눈앞에서 종이의 윗부분을 잡고 돌린다고 상상해 봅시다. 처음에는 제대로 된 이미지가 보이다가 어느 순간 종이의 얇은 단면만 보일 것입니다. 이를 화면에 적용한다면 Y축을 기준으로 도는데, 이미지가 옆으로 줄어들다 이미지가 일그러질 것입니다. 올바른 회전이라 볼 수 없기 때문에 사용하지 않습니다.  Z축을 기준으로 회전하면 이미지가 훼손되지 않고 올바르게 회전합니다. 화면에서는 마치 좌우로 돌리는 것처럼 보일 수 있으나 이 역시 2D 이미지이기 때문입니다. ![transform04](https://mod-file.dn.nexoncdn.co.kr/bbs/16371150089380390a89a833549279015e3acd4cd728d.png)

# 위치 변경하기

1. 배치한 엔티티를 선택해 프로퍼티 에디터를 활성화합니다.
2. **TransformComponent**에서 **Position의 X, Y 값**을 변경합니다.
3. **Scene**에서 엔티티를 선택한 후, 원하는 위치로 이동합니다.

#### X 값 변경 예시

**Position X**값에 **4**를 입력하면, 오른쪽으로 엔티티가 이동합니다. ![transform50](https://mod-file.dn.nexoncdn.co.kr/bbs/163711505255438094dc5f40847b980a0ec74bf336520.png)

#### Y 값 변경 예시

**Position Y**값에 **3**을 입력하면, 위로 엔티티가 이동합니다. ![transform52](https://mod-file.dn.nexoncdn.co.kr/bbs/163711533385082094259354448c59298d1f60f084bad.png)

#### Z 값 변경 예시

**Position Z**값에 각 **1**과 **2**를 입력하면, 적은 숫자가 앞에 배치됩니다. ![50](https://mod-file.dn.nexoncdn.co.kr/bbs/1637129854895b7a5e5c04c754a389026df1017ff4c2f.png)

> **Tip. 엔티티 순서 변경** **SpriteRendererComponent**의 **OrderInLayer**를 사용해 순서를 변경하는 것이 가장 바람직합니다.

# 크기 조정하기

- 프로퍼티 에디터에서 **Scale**의 **X, Y**값을 변경합니다.
- **Scene**에서 활성화된 핸들러를 움직입니다.

#### X 값 변경 예시

**Scale**의 **X**값을 늘리면 좌우로 크기가 늘어납니다. ![53](https://mod-file.dn.nexoncdn.co.kr/bbs/163712981670835563d7a4c624c498e242240e3b8a9c4.png)

#### Y 값 변경 예시

**Scale**의 **Y**값을 늘리면 상하로 크기가 늘어납니다. ![54](https://mod-file.dn.nexoncdn.co.kr/bbs/1637129906868ea6b4f61f3b34d25835aa40b8cd54d67.png)

#### X, Y 값 변경 예시

**Scale**의 **X, Y**값에 **4**를 입력하면 기존 대비 비례하게 4배 커집니다. ![55](https://mod-file.dn.nexoncdn.co.kr/bbs/163712992630702c9e1c108bb41f1920d778f71388559.png)

# 회전

**WorldZRotation**과 **ZRotaion**은 값을 상호 교환합니다.

#### 방법 1

**TransformComponent**의 **ZRotation** 값을 **45**로 변경합니다. 엔티티가 반시계 방향으로 45도 회전된 것을 확인합니다. ![70](https://mod-file.dn.nexoncdn.co.kr/bbs/1637129956129332db21c233f45dba0e6741eff67ec52.png)

#### 방법 2

1. **Scene**에서 엔티티를 선택, 핸들러를 활성화합니다.
2. 핸들러 박스의 모서리 쪽으로 마우스를 움직입니다.
3. 커서가 ![CursorRotate](https://mod-file.dn.nexoncdn.co.kr/bbs/163452377985689268fa2aa5c412989c41cbb81e3e13f.jpg) 모양으로 바뀌면 원하는 방향으로 엔티티를 돌립니다.![transformrotate](https://mod-file.dn.nexoncdn.co.kr/bbs/163538582711066d4943dd3814f5fa29565c837aa53a4.gif)

# TransformComponent의 함수 활용

#### Translate 함수

`Translate` 함수는 엔티티 위치를 이동시킬 때 사용합니다. 엔티티 위치를 원점으로 삼아 상대적으로 입력한 값만큼 이동합니다. 다음은 게임을 실행했을 때 엔티티가 이동하는 예시 코드입니다.

```
void OnBeginPlay()
{
    self.Entity.TransformComponent:Translate(4,5)  -- 배치된 엔티티 위치를 기준으로 X 좌표를 4, Y 좌표를 5만큼 이동합니다.
    log("move on")  --  이동이 되면 콘솔 창에 Move On을 출력합니다.
}
```

해당 스크립트를 엔티티에 추가하여 정상 동작하는지 확인합니다. 타일에 가까이 배치한 고양이 오브젝트는 게임 실행 시 **입력한 좌표 값만큼 이동**했습니다. ![transformgif](https://mod-file.dn.nexoncdn.co.kr/bbs/16353203939604dd5bf2ec48549a2880226e944ec5021.gif)

#### Rotate 함수

`Rotate` 함수는 엔티티를 반시계 방향으로 회전 시킬 때 사용합니다. 엔티티가 배치된 위치에서 입력한 값만큼 왼쪽(반시계 방향)으로 회전합니다. 다음은 게임을 실행했을 때 엔티티가 회전하는 예시 코드입니다.

```
void OnBeginPlay()
{
    self.Entity.TransformComponent:Rotate(6) -- 배치된 엔티티 위치를 기준으로 6만큼 반시계 방향으로 회전합니다.
    log("Move On") -- 실행이 완료되면 콘솔 창에 Move On을 출력합니다.
}
```

해당 스크립트를 엔티티에 추가하여 정상 동작하는지 확인합니다. 타일과 수평으로 배치한 고양이 오브젝트는 게임 실행 시 **반시계 방향으로 6만큼 회전**했습니다. ![transformgif02](https://mod-file.dn.nexoncdn.co.kr/bbs/163532046690887f78a7c6d9549fe8eb9b63f036d6060.gif)

Update 2025-11-20 PM 02:03


# 엔티티 구간 이동시키기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

엔티티에 동작을 만드는 세 가지 **Tween Component**의 개념을 이해합니다. 컴포넌트를 이용해 크리에이터가 원하는 엔티티 운동 방향과 폭을 조정할 수 있습니다.

##### 참고 가이드

[엔티티의 위치, 크기, 회전 조정](/docs?postId=82)

# Tween Component 소개

**Tween Component**를 이용하여 엔티티에 운동성을 만들고, 세부 설정을 조정할 수 있습니다. 운동 성질에 따른 세 가지 컴포넌트가 있으며, 상황에 맞게 단독으로 사용하거나 조합하여 사용할 수 있습니다.

**Tween Component** 종류는 다음과 같습니다.

| Tweener | 운동 형태 |
| --- | --- |
| TweenFloatingComponent | 원점을 기준으로 부유 운동 |
| TweenLineComponent | 원점에서 목적지까지의 선형운동 |
| TweenCircularComponent | 원점을 중심으로 원운동 |

> **Tip.** 복수의 컴포넌트를 적용하면, 하나의 컴포넌트만 동작하거나 오작동하는 버그가 생길 수 있습니다. 엔티티에 Tween 컴포넌트 중 하나만 사용할 것을 권장합니다.

# TweenFloatingComponent

**TweenFloatingComponent**는 엔티티를 제자리에서 떠다니는 듯한 움직임을 만들 때 사용합니다. 엔티티의 원점 기준으로 상하로 움직입니다. 진폭과 사이클 시간을 조정하여 이동 거리와 속도를 조절할 수 있습니다. ![tween01](https://mod-file.dn.nexoncdn.co.kr/bbs/16351333195647fd5eb29ccc348b394047a70d19da000.png) **TweenFloatingComponent**의 프로퍼티를 살펴봅시다.

| 이름 | 설명 |
| --- | --- |
| TweenType | Linear가 기본값입니다. 부유운동방식 종류별 설명은 하단의 참고자료를 참고하세요. |
| OneCycleTime | 진폭 값을 왕복하는 시간입니다. 입력값이 커질수록 느리게 운동합니다. |
| Amplitude | 엔티티의 원점으로부터 위아래로 이동하는 거리를 설정합니다. 입력값이 커질수록 이동 거리가 멀어집니다. |
| AutoStart | 활성화하면 게임 시작 시 자동으로 운동이 시작됩니다. |
| AutoDestroy | 활성화하면 운동이 끝나고 자동으로 해당 컴포넌트가 삭제됩니다. |
| SyncType | 컴포넌트가 동기화되는 곳을 서버와 클라이언트 중 선택합니다.<ul><li>Default: Server에서 동작하며 모든 Client에게 동일하게 보입니다.</li></ul><ul><li>ClientOnly: 해당 Client에서만 동작하고, 보입니다.</li></ul> |

#### 적용하기

1. 엔티티에 **TweenFloatingComponent**를 추가합니다. 프로퍼티 에디터 창에서 **TweenFloatingComponent**의 프로퍼티 값을 각각 다음과 같이 입력합니다.![tween02](https://mod-file.dn.nexoncdn.co.kr/bbs/16462833345885523a1977e4446a99b1974de5d14eb58.png)
2. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 엔티티가 위아래로 떠다니는지 확인합니다.![tween03](https://mod-file.dn.nexoncdn.co.kr/bbs/16351278266829a1fa2002d524f72bbeedbf7d481793b.gif)

> **Tip.** 진폭 1의 값: 육안으로 정확하게 확인이 어려우나, 그리드의 세로 한 칸이 0.6이므로 약 2칸으로 가늠할 수 있습니다.

# TweenLineComponent

원점을 기준으로 목적지까지 선형 운동을 하게 만들 때 사용합니다. 목적지까지 편도, 왕복 운동 여부와 더불어 가·감속, 도달 시 튕김 등 운동 방식을 설정할 수 있습니다. ![tween12](https://mod-file.dn.nexoncdn.co.kr/bbs/1635133344807543aac086f39472eaa343a3655f848d4.png) **TweenLineComponent**의 프로퍼티를 살펴봅시다.

| 프로퍼티 명 | 설명 |
| --- | --- |
| TweenType | 기본값은 Linear입니다. 다른 모양의 운동 방식을 선택할 수 있습니다.<br>선형운동 종류별 설명은 하단의 참고자료를 참고하세요. |
| Duration | 목적지까지 도달하는 데 걸리는 시간을 의미합니다. |
| StopType | 운동 종료 방식을 선택합니다.<ul><li>Oneway : 엔티티가 편도로 움직이며 목적지에 도착 후 운동을 종료합니다.</li><li>OneRoundTrip : 엔티티가 목적지를 반환점으로 삼아 왕복 운동을 합니다. 1회 왕복 후 운동을 종료합니다.</li><li>RepeatRoundTrip : 엔티티가 목적지를 반환점으로 삼아 왕복 운동을 반복합니다.</li></ul> |
| UseReturnTweenType | 활성화하면 엔티티가 반환점을 돌며 별도로 설정한 방식으로 운동합니다. |
| ReturnTweenType | 종료 방식을 OneRoundTrip/RepeatRoundTrip으로 선택한 경우 반환점을 돌아올 때의 운동 방식을 설정합니다.<br>리턴운동 종류별 설명은 하단의 참고자료를 참고하세요. |
| ReturnDuration | 목적지에서 원점으로 이동하는 데 걸리는 시간을 의미합니다. |
| DestinationCoordinateType | 엔티티가 운동할 때 목적지를 인식하는 방식입니다.<ul><li>Relative : 목적지 위치를 상대 좌표로 인식합니다.</li></ul><ul><li>Absolute : 목적지 위치로 입력한 값을 절대 좌표로 인식합니다.</li></ul> |
| Positions | 운동 방향의 목적지를 여러 개 추가할 수 있습니다. 목적지 개수는 ![TabScene](https://mod-file.dn.nexoncdn.co.kr/bbs/163452458863504f49c7a23aa4a41af56b5b4611a6daf.png) Scene에서 별도로 표시되지 않습니다.<br>Size : 목적지 개수를 의미합니다. 0부터 시작하며 Size에 입력한 값만큼 목적지가 추가됩니다.<br>[ 숫자 ] : 목적지의 위치를 X, Y 좌표로 입력합니다. [1] 의 좌표가 엔티티의 첫 번째 목적지이며 다음 수를 향해 이동합니다. |
| Interpolation | 점들의 보간 방식을 결정합니다. 점이 2개 이상일 경우 유효하게 동작합니다.<ul><li>None: 기본값으로 보간하지 않습니다.</li><li>SplineTypeA : SplineTypeA 형태의 보간을 합니다. 중간 점의 경우 반드시 해당 점을 지나지 않을 수 있습니다.</li></ul> *보간: 점과 점을 연결한 직선을 따라 엔티티가 이동할 경우 움직임이 부드럽지 않습니다. 이를 보완하기 위해 곡선으로 완만하게 만들어 움직임을 부드럽게 만드는 것을 뜻합니다. |
| AutoStart | 활성화하면 게임 시작 시 자동으로 운동이 시작됩니다. |
| AutoDestroy | 활성화하면 운동이 끝나고 자동으로 해당 컴포넌트가 삭제됩니다. |
| SyncType | 컴포넌트가 동기화되는 곳을 서버와 클라이언트 중 선택합니다.<ul><li>Default: Server에서 동작하며 모든 Client에게 동일하게 보입니다.</li><li>ClientOnly: 해당 Client에서만 동작하고, 보입니다.</li></ul> |

#### 적용하기

1. 엔티티에 **TweenLineComponent**를 추가하고 다음과 같이 설정합니다.![tween04](https://mod-file.dn.nexoncdn.co.kr/bbs/1646283379788c89d5799ffb74e478c8d62d6db6be1e2.png)
2. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다.![tween05](https://mod-file.dn.nexoncdn.co.kr/bbs/1635128047869e1e7391ce85e4e7989395243e2590395.gif)

# TweenCircularComponent

원점을 기준으로 원형 운동을 하게 만들 때 사용합니다. 회전 수, 속도, 반경을 설정할 수 있습니다.

**TweenCircularComponent**의 프로퍼티를 살펴봅시다.

| 프로퍼티 명 | 설명 |
| --- | --- |
| Radius | 원점을 기준으로 입력한 값만큼 멀어져 원운동을 합니다.<br>숫자가 클수록 중심에서 멀어집니다. |
| Speed | 입력한 숫자가 클수록 엔티티가 빠르게 원운동을 합니다. |
| LookAtCenter | 활성화하면 엔티티 사각형 테두리 윗변이 중심점을 바라보고 회전합니다. |
| Degree | 입력한 각도만큼 회전하고 멈춥니다. 0을 입력하면 멈추지 않고 계속 원운동을 합니다. |
| IsClockwise | 어느 방향으로 회전할지 정의합니다. true인 경우 시계 방향으로 회전합니다. |
| AutoStart | 활성화하면 게임 시작 시 자동으로 운동이 시작됩니다. |
| AutoDestroy | 활성화하면 운동이 끝나고 자동으로 해당 컴포넌트가 삭제됩니다 |
| SyncType | 컴포넌트가 동기화되는 곳을 서버와 클라이언트 중 선택합니다.<ul><li>Default: Server에서 동작하며 모든 Client에게 동일하게 보입니다.</li><li>ClientOnly: 해당 Client에서만 동작하고, 보입니다.</li></ul> |

#### 적용하기

1. 엔티티에 **TweenCircularComponent**를 추가하고 다음과 같이 설정합니다. ![tween06](https://mod-file.dn.nexoncdn.co.kr/bbs/164628347830889af06e47ea34c718e77f29897772157.png)
2. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다.**Radius** 값만 입력하면, 엔티티는 반경을 따라서만 회전합니다.**LookAtCenter**을 적용한다면 엔티티 사각형 테두리 윗변이 회전 반경에 붙어 회전 기준점을 바라보며 회전합니다.

| 기본 회전 | LookAtCenter 적용 |
| --- | --- |
| ![tween07](https://mod-file.dn.nexoncdn.co.kr/bbs/1635132897859b8a88490ede14cf3ab4961b279af2fbc.png) | ![tween08](https://mod-file.dn.nexoncdn.co.kr/bbs/16370579280376c43e57eec704eaea6bac377ce481b5c.png) |
| ![tween09](https://mod-file.dn.nexoncdn.co.kr/bbs/16351329567296ac3abbf46b64488b31bd416bd566412.gif) | ![tween10](https://mod-file.dn.nexoncdn.co.kr/bbs/16351329728073d33972360c648cd9e11a4c70eb1c05f.gif) |

# 참고자료 - Ease Type

장난감의 태엽을 감아 지면에 놓았을 때의 모습을 관찰한 기억을 떠올려봅시다. 멈춘 상태에서 천천히 움직이기 시작해 일정한 속도로 이동하다가 점점 느려지며 멈추는 모습을 관찰 할 수 있을 것입니다. 일상에서 만나는 사물은 대부분 속도를 시시각각 바꾸며 움직입니다. 그래서 계속 똑같은 속도로 움직이는 로봇은 오히려 어색하게 보입니다. 메이플스토리 월드에서는 엔티티가 자연스럽게 움직이도록 엔티티의 운동 속도와 반동을 다르게 설정할 수 있습니다. 메이커에서 지원하는 타입은 10가지이며, 각 3가지 변형이 있습니다. 아래 표를 참고하여 적절하게 이용하시길 바랍니다.

종류: **Quad, Expo, Cubic, Quart, Quint, Circ, Sine, Elastic, Bounce, Back**

변형

- **Ease Out** : 빠르게 움직이기 시작해서 마지막에 감속하며 목적지에서 멈춥니다
- **Ease In** : 느리게 움직이기 시작하다 가속하며 목적지에서 멈춥니다
- **Ease In-Out** : 느리게 움직이기 시작해 중간 구간에서 빠르게 움직이다, 감속하며 목적지에서 멈춥니다.

![easetype](https://mod-file.dn.nexoncdn.co.kr/bbs/1635132999893719a42ed301645e8afcf19bb1a302ea9.png)

Update 2025-11-20 PM 02:03


# 텔레포트

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

특정 시간마다 캐릭터를 다른 맵으로 이동시키는 기능을 만들어 보면서 `TeleportService`의 `TeleportToEntityPath` 함수 사용법을 알아봅시다.

##### 참고 API Reference

[TeleportService](/apiReference/Services/TeleportService)

# 이동할 맵 만들기

먼저 캐릭터가 이동할 맵을 만듭니다.

1. **Window - Map List** 창을 엽니다. ![Teleport_1](https://mod-file.dn.nexoncdn.co.kr/bbs/168775942033420815d67e57a4a5e8089b084e57856fa.png)
2. **Map List** 창에서 **[새 맵 만들기]** 버튼을 클릭합니다. 텔레포트로 3개 맵을 순환하도록 만들 것이므로 2개의 새 맵을 추가합니다. ![Teleport_2](https://mod-file.dn.nexoncdn.co.kr/bbs/163462014875719559f9f4a96453990420dbbb5e5acc2.png)
3. 이동했을 때 쉽게 알아볼 수 있도록 각 맵을 특색 있게 꾸밉니다. 그리고 각 맵으로 텔레포트했을 때, 목적지 역할을 할 엔티티를 하나씩 배치합니다. | **맵** | **맵 생성 예시** |
| --- | --- | | map01 | ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/165665674992362b0791572c143caac4932432ffabccd.png) | | map02 | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16566567844498a1bd211546447a397a044a8bc9c5df1.png) | | map03 | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1656656814159bbb5a8e0966b4ae388dda9382e40ec95.png) |
4. 목적지 엔티티의 경로를 확인합니다. **Hierarchy**에서 각 엔티티의 콘텍스트 메뉴를 열고 **Copy Entity Path**를 클릭해 경로를 복사한 뒤 따로 기록합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16862103427568f6a56e7203741289157a083b3cd4c20.png) 이 예제에서 사용한 목적지 엔티티 경로는 다음과 같습니다. | **맵** | **목적지 엔티티 경로** |
| --- | --- | | map01 | /maps/map01/object-19_1 | | map02 | /maps/map02/object-6_1 | | map03 | /maps/map03/object-42_1 |

# 텔레포트 기능 만들기

스크립트를 통해 텔레포트 기능을 만듭니다. 새 스크립트 컴포넌트를 만든 뒤 캐릭터에 추가합니다.

1. **Workspace - MyDesk** 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭해 새 컴포넌트를 추가합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1687756376627c84b1418872c42a2bb42529622985e1f.png)
2. 컴포넌트 이름을 **Teleport**로 설정합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1635423340528786df9745a5e455c96c59ebc7d949ce9.png)
3. **Workspace - DefaultPlayer**에 **Teleport** 컴포넌트를 추가합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1635423349810751f20bc31d24e4aa10027ab4d58f36e.png)

이제 본격적으로 스크립트를 작성해 봅시다.

1. **Teleport** 스크립트를 엽니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/163542336059313a91256a8d64ff6bfb60b3534702e55.png)
2. `OnUpdate` 함수를 추가하고 다음과 같이 작성합니다.```
[server only]
void OnUpdate(number delta)
{
    --프로퍼티 동기화가 필요 없으므로 _T 프로퍼티를 활용
    if self._T.accTime == nil then self._T.accTime = 0 end
    if self._T.teleportCnt == nil then self._T.teleportCnt = 0 end

    --테이블 타입의 프로퍼티를 선언, 각 맵에 배치한 목적지 엔티티의 Path 입력
    if self._T.destinationTable == nil then
        self._T.destinationTable = {}
        self._T.destinationTable[1] = "/maps/map01/object-19_1"
        self._T.destinationTable[2] = "/maps/map02/object-6_1"
        self._T.destinationTable[3] = "/maps/map03/object-42_1"
    end

    self._T.accTime = self._T.accTime + delta

    --3초마다 캐릭터를 다른 맵으로 이동
    if self._T.accTime >= 3 then
        self._T.accTime = 0
        self._T.teleportCnt = self._T.teleportCnt + 1
        local destinationNum = self._T.teleportCnt % 3 + 1

    --TeleportService의 TeleportToEntityPath 함수 사용
    --이동시킬 엔티티와 목적지 엔티티의 Path를 매개 변수로 넘겨줌
        _TeleportService:TeleportToEntityPath(self.Entity, self._T.destinationTable[destinationNum])
    end
}
```
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 캐릭터가 3초마다 다른 맵으로 이동하는 것을 확인합니다. ![teleport](https://mod-file.dn.nexoncdn.co.kr/bbs/16566569336433dc028f996c541839f32ad85efbd8755.gif)

Update 2025-11-17 PM 08:14


# 월드 워프하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

TeleportService의 함수를 활용해 월드에서 다른 월드로 이동할 수 있습니다.

# 다른 월드로 이동하기

TeleportService는 월드의 유저를 특정 장소로 이동시킬 때 사용할 수 있을 뿐 아니라, 접속 중인 월드에서 다른 월드로 이동시킬 수 있습니다. 접속 중인 월드와 이동할 월드가 공개 출시된 상태여야 이동이 가능합니다. 이 특성으로 인해 제작 중에는 워프를 테스트할 수 없습니다.

| 현재 월드 | 이동할 월드 | 워프 여부 |
| --- | --- | --- |
| 공개 | 공개 | **◯** |
| 비공개 | 공개 | **◯** |
| 공개 | 비공개 | X |
| 비공개 | 비공개 | X |

유저를 다른 월드로 이동시킬 때는 `WarpUserToWorldAndWait()` 및 `WarpUserToWorldAsync()` 함수를 활용하며 **이동시킬 유저 ID, 이동할 월드 ID** 두 가지가 필요합니다. 다른 월드로 워프할 때 현재 머물던 월드에서 유저가 쌓은 데이터를 이동할 월드에서도 사용하고 싶다면 `WarpUserToWorldAndWait()`를 활용해 유저가 이동할 때 데이터를 함께 전달하고, GetWarpRecord()로 데이터에 접근하고 얻어올 수 있습니다. 자세한 내용은 [TeleportService](/apiReference?postId=315)를 참고하세요.

> **Tip.** 크리에이터가 만든 월드가 아니더라도, 출시된 모든 월드로 워프할 수 있습니다.

# World ID 확인하기

WorldID는 메이플스토리 월드 공식 홈페이지에서 월드 정보 페이지의 URL로 확인할 수 있습니다. URL 끝의 번호가 월드 ID로써 활용할 수 있습니다.

- https://maplestoryworlds.nexon.com/play/**번호**

![WorldID](https://mod-file.dn.nexoncdn.co.kr/bbs/16751471942527842b0f88f594139ad4488f2bce289e0.png)

# 활용 예제

#### 워프시키기

유저가 포탈을 타고 다른 월드로 이동할 수 있게 만들어 봅시다.

![worldwarp](https://mod-file.dn.nexoncdn.co.kr/bbs/1657775410700475de8c715464f52919606dd284b6f7e.gif)

1. 새로운 ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/Ect.png) Warp 컴포넌트를 생성하고, 포탈에 추가합니다.
2. 프로퍼티에 WorldId를 추가하고, 월드 ID를 프로퍼티 에디터 창에서 입력합니다.![warp](https://mod-file.dn.nexoncdn.co.kr/bbs/16577946836778dbd808244d6421e99a67c482d4aa1b8.png)
3. 아래와 같이 포탈 이벤트가 발생할 때 지정한 월드로 이동할 수 있게 작성합니다.```
Property:
[Sync]
string WorldId = ""

Method:
[server]
void Warp(string userId)
{
    local warpDataTable = {}
    warpDataTable.userId = userId

    local serializedData = _UtilLogic:TableToString(warpDataTable)

    _TeleportService:WarpUserToWorldAndWait(userId, self.WorldId, serializedData)
}

Event Handler:
[self]
HandlePortalUseEvent(PortalUseEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: PortalComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local PortalUser = event.PortalUser
    ---------------------------------------------------------

    self:Warp(PortalUser.Name)
}
```

#### 워프로 월드에 입장했는지 확인하기

이동한 월드에서 입장한 유저가 워프로 입장한 것인지 `GetWarpRecord()`를 활용해 확인할 수 있습니다.

1. 새로운 스크립트 컴포넌트를 생성하고, ![common](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_asset_no.png) Common에 추가합니다.
2. 월드에 입장한 유저가 워프로 입장했는지 확인할 수 있도록 아래와 같이 작성합니다.```
Event Handler:
[server only] [service: UserService]
HandleUserEnterEvent(UserEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    -- local ProfileCode = event.ProfileCode
    local UserId = event.UserId
    ---------------------------------------------------------

    local warpRecord = _TeleportService:GetWarpRecord(UserId)

    -- 일반적인 월드 입장이라면, GetWarpRecord() 함수는 nil을 반환합니다.
    if warpRecord == nil then 
        return
    end
}
```

#### 워프해 온 월드 확인하기

`GetWarpRecord()`를 활용해 워프로 이동한 유저가 어떤 월드에서 온 것인지 확인할 수 있습니다.

1. 새로운 스크립트 컴포넌트를 생성하고, ![common](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_asset_no.png) Common에 추가합니다.
2. 워프로 이동한 유저가 어떤 월드로부터 왔는지 확인할 수 있도록 아래와 같이 작성합니다.```
Event Handler:
[server only] [service: UserService]
HandleUserEnterEvent(UserEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    -- local ProfileCode = event.ProfileCode
    local UserId = event.UserId
    ---------------------------------------------------------

    local warpRecord = _TeleportService:GetWarpRecord(UserId)
    if warpRecord == nil then
        return
    end

    local currentWorldId = warpRecord.CurrentWorldId
    local prevWorldId = warpRecord.PreviousWorldId -- 이전 월드를 확인할 수 있습니다.
}
```

#### 다른 월드에 데이터 전달하기

유저의 데이터를 이동할 월드로 전달할 수 있습니다.

1. 새로운 스크립트 컴포넌트를 생성합니다.
2. 맵에 포탈을 추가한 뒤, 만든 스크립트 컴포넌트를 포탈에 추가합니다.
3. 아래와 같이 `WarpUserToWorldAndWait()`와 `UtilLogic`을 활용해 다른 월드에 데이터를 전달할 수 있게 작성합니다.```
Property:
[Sync]
string WorldId = ""

Method:
[server]
void Warp(string userId)
{
    local warpDataTable = {}
    warpDataTable.testData = "test"

    local warpData= _UtilLogic:TableToString(warpDataTable)

    _TeleportService:WarpUserToWorldAndWait(userId, self.WorldId, warpData)
}

Event Handler:
[self]
HandlePortalUseEvent(PortalUseEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: PortalComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local PortalUser = event.PortalUser
    ---------------------------------------------------------

    self:Warp(PortalUser.Name)
}
```

#### 이전 월드에서 전달한 데이터 얻어오기

이전 월드에서 전달한 값을 받을 수 있습니다.

1. 새로운 스크립트 컴포넌트를 생성하고, ![common](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_asset_no.png) Common에 추가합니다
2. 아래와 같이 `WarpUserToWorldAndWait()`와 `UtilLogic`을 활용해 작성합니다.```
Event Handler:
[server only] [service: UserService]
HandleUserEnterEvent(UserEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    -- local ProfileCode = event.ProfileCode
    local UserId = event.UserId
    ---------------------------------------------------------

    local warpRecord = _TeleportService:GetWarpRecord(UserId)
    if warpRecord == nil then
        return
    end

    local warpDataTable = _UtilLogic:StringToTable(warpRecord.Data)
    log(warpDataTable.testData)
}
```

##### 참고 가이드

- [텔레포트](/docs/?postId=59)

Update 2025-11-17 PM 08:14


# 특정 월드 인스턴스로 워프하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=25%EB%B6%84&amp;color=green)

# 학습 과정 소개

`WorldInstanceService`를 활용해 현재 월드 인스턴스Id와 생성된 다른 월드 인스턴스들의 상태를 알 수 있습니다. 또한 `TeleportService`를 활용해 플레이어를 특정 월드 인스턴스로 워프시킬 수 있습니다.

##### 참고 가이드

[월드 인스턴스](/docs/?postId=984) [월드 인스턴스 통신](d/ocs/?postId=999) [월드 워프하기](/docs/?postId=743)

##### 참고 APIReference

[TeleportService](/apiReference?postId=315) [WorldInstanceService](/apiReference?postId=1034) [WorldInstanceInfo](/apiReference?postId=1128)

# WorldInstanceId 알아보기

#### WorldInstanceId

**WorldInstanceId**란 [월드 인스턴스](/docs/?postId=984)가 생성될 때 발급되는 고유한 값으로 월드 인스턴스를 구분하기 위해 사용합니다. 예를 들어, 월드A의 월드 인스턴스가 30개 생성되면 월드 인스턴스마다 WorldInstanceId가 생성되어 총 30개의 WorldInstanceId가 있습니다.

현재 유저가 접속한 월드 인스턴스의 Id를 알 수 있는 두 가지 방법이 있습니다.

1. `WorldInstanceService`의 `WorldInstanceId` 프로퍼티를 활용해 현재 접속한 월드 인스턴스의 WorldInstanceId를 알 수 있습니다.
2. `WorldInstanceService`의 `GetWorldInstanceInfoPagesAndWait()`, `GetWorldInstanceInfoPagesAsync()`를 활용해 Page 단위로 WorldInstanceInfo를 조회할 수 있습니다.

#### WorldInstanceInfo

**[WorldInstanceInfo](/apiReference/Misc/WorldInstanceInfo)**는 각 월드 인스턴스의 정보를 가지고 있습니다. WorldInstanceInfo의 프로퍼티는 아래와 같습니다.

- **Id**: 월드 인스턴스마다 가지고 있는 고유한 값입니다.
- **MaxUserCount**: 월드 인스턴스에 입장할 수 있는 최대 인원수입니다.
- **CurrentUserCount**: 현재 월드 인스턴스에 입장한 유저의 수입니다.

#### WorldInstanceInfoPages

**[WorldInstanceInfoPages](/apiReference/Misc/WorldInstanceInfoPages)**월드 인스턴스 관련 정보를 조회하기 위한 객체입니다. `GetCurrentPageDatas()`, `MoveToNextPageAndWait()` 함수를 사용해 데이터 목록을 가져오거나, 다음 페이지로 이동시킬 수 있습니다.

# 월드 인스턴스 워프하기

**TeleportService**의 `WarpUserToWorldInstanceAndWait()`, `WorldUserToWorldInstanceAsync()` 함수를 활용해 유저를 다른 월드 인스턴스로 워프시킬 수 있습니다.

플레이어를 워프시키기 위해선 워프시킬 유저의 **UserId**와 워프할 월드 인스턴스의 **WorldInstanceId**가 필요합니다. 플레이어가 워프를 시도하는 시점의 최신 월드 인스턴스들의 정보를 조회해 다른 월드 인스턴스로 이동할 수 있습니다. 이동 시 필요한 최신 WorldInstanceInfo 정보는 WorldInstanceService의 함수 `GetWorldInstanceInfoPagesAndWait()` 및 `GetWorldInstanceInfoPagesAsync()` 활용하여 Page 단위로 WorldInstanceInfo를 조회할 수 있습니다. 단, 이때 이동 가능한 월드 인스턴스는 유저가 접속한 월드 내에서만 가능합니다.

다른 월드 인스턴스로 워프할 때 유저가 지금까지 쌓아온 데이터를 함께 전달하려면 `WarpUserToWorldAndWait()`를 활용합니다. 전달 받은 데이터는 `GetWarpRecord()`로 접근해 얻어올 수 있습니다. 자세한 내용은 [TeleportService](/apiReference?postId=315)를 참고하세요.

> **Tip.** **공개 상태로 출시된 월드**에서만 월드 인스턴스 워프가 가능합니다. 비공개 월드에서는 월드 인스턴스 워프가 불가합니다. **제작 중인 상황**에서는 월드 인스턴스 워프 테스트를 할 수 없습니다. 출시된 월드에서 월드 인스턴스 워프가 작동하는지 확인해야 합니다.
> **더 알아보기** `WarpUserToWorldAndWait`, `WarpUserToWorldAsync`는 WorldId로 월드를 워프합니다. 이때 워프 대상인 월드는 유저가 있는 월드가 아닌 제2, 3의 월드가 대상이며, 옮겨갈 월드 인스턴스를 지정할 수 없습니다. 또한 이동 가능한 월드 인스턴스가 없는 경우, 새로운 인스턴스를 생성해 워프합니다.

#### 워프가 불가능한 월드 인스턴스

워프를 시도한 월드 인스턴스로 이동할 수 없는 경우가 발생할 수 있습니다. 워프에 실패할 경우 플레이어에게 실패 메시지 화면이 뜨고 월드의 로비 화면으로 돌아갑니다. 워프를 시도했던 월드 인스턴스로는 돌아갈 수 없습니다. 월드 인스턴스 워프에 실패하는 이유는 월드 인스턴스의 상태가 끊임없이 변화하기 때문입니다. 월드 인스턴스의 정원이 모두 찼을 수도 있고, 월드 인스턴스가 은퇴 준비 상태이기 때문에 더 이상 새로운 유저를 받지 않을 수도 있습니다.

# 활용 예시

#### 워프하기

```
[server]
void WarpToAnotherWorldInstance (string userId, string worldInstanceId)
{
   local warpData = {}
   local serializedData = _UtilLogic:TableToString(warpData)
   
   _TeleportService:WarpUserToWorldInstanceAndWait(userId, worldInstanceId, serializedData)
}
```

#### 월드 인스턴스 정보 페이지 단위로 조회하기

`GetWorldInstanceInfoPagesAndWait()` 함수를 활용해 월드 인스턴스 정보를 페이지 단위로 조회하는 예제입니다.

```
    local result, pages = _WorldInstanceService:GetWorldInstanceInfoPagesAndWait()
    
    while true do
    
       --GetCurrentPageDatas()로 현재 페이지의 목록을 가져올 수 있습니다.
    	local datas = pages:GetCurrentPageDatas() 
    	
    	for _, data in pair(datas) do
    		log(data.Id)
    	end
        
       --IsLastPage 프로퍼티를 통해 현재 페이지가 마지막 페이지인지 확인할 수 있습니다.
    	if pages.IsLastPage == true then 
    		break
    	end
    	
    	--MoveToNextPageAndWait()로 다음 페이지로 넘어갈 수 있습니다.
    	pages:MoveToNextPageAndWait() 
    	
    end
```

`GetWorldInstanceInfoPagesAsync()` 함수를 활용해 월드 인스턴스 정보를 페이지 단위로 조회하는 예제입니다.

```
    local callback = function (result, pages)
    
    	while true do
    		local datas = pages:GetCurrentPageDatas()
    		
    		for _, data in pair(datas) do
    			log(data.Id)
    		end
    
    		if pages.IsLastPage == true then
    			break
    		end
    
    		pages:MoveToNextPageAndWait()
    	end
    end
    
    _WorldInstanceService:GetWorldInstanceInfoPagesAsync(callback)
```

Update 2025-11-20 PM 02:03


# 엔티티의 생성과 삭제, 유효성 체크

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

엔티티의 생성과 삭제는 월드를 제작하면서 가장 많이 사용하는 기능입니다. 이번 과정에서는 엔티티 생성과 삭제 방법, 그리고 엔티티 존재 여부를 확인하는 유효성 체크 기능을 살펴봅니다.

# 엔티티 생성

**SpawnService**는 엔티티 생성 함수를 제공합니다. 주요 엔티티 생성 함수인 `SpawnByEntity`와 `SpawnByModelId`를 알아보겠습니다.

## SpawnByEntity

엔티티를 바탕으로 새로운 엔티티를 생성합니다.

#### 매개 변수

| Parameter | Type | Description |
| :---: | :---: | --- |
| entity | Entity | 복제할 엔티티를 지정합니다. |
| name | string | 생성할 엔티티의 이름을 설정합니다. |
| spawnPosition | Vector3 | 엔티티가 생성될 위치 좌표를 설정합니다. |
| parent<br>(Optional) | Entity | 생성된 엔티티의 부모가 될 엔티티를 넣어줍니다. |
| includeChild<br>(Optional) | boolean | 복제할 엔티티의 하위 엔티티도 함께 복제할 것인지 설정합니다. |

#### 반환값

- 스폰 성공하면 **Entity**를 반환합니다.
- 스폰 실패하면 **nil**을 반환합니다.

#### 사용 예시

간단하게 맵에 배치된 엔티티와 동일한 엔티티를 생성하는 방법을 알아봅시다.

1. **Preset List**에서 복제할 엔티티를 맵에 배치합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16602756252223e544189296248be9e622a6f6aede534.png)
2. 새 스크립트 컴포넌트 **SpawnManager**를 생성합니다. **SpawnManager** 스크립트를 더블클릭하여 스크립트 에디터를 열고 `SpawnByEntity` 함수를 작성합니다.```
void SpawnByEntity()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/monster-8") -- 배치된 엔티티 우클릭 - Copy Entity Path를 선택해 Path를 가져옵니다.
    local name = entity.Name .. "Copy" -- 생성될 엔티티 이름 설정
    local spawnPosition = Vector3(0,0,0) -- 생성될 위치 설정

    local spawnEntity = _SpawnService:SpawnByEntity(entity,name,spawnPosition)
    if isvalid(spawnEntity) == false then 
        log("Spawn Failed")
    end
}
```
3. 작성이 완료되었으면 `OnBeginPlay` 함수를 추가하고 다음과 같이 작성합니다.```
[server only]
void OnBeginPlay()
{
    self:SpawnByEntity()
}
```
4. **SpawnManager** 스크립트 컴포넌트를 **common**에 추가합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1659601195286fbb9556ae01c4adb8b44b90ab8e68840.png)
5. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 맵에 배치했던 것과 같은 엔티티가 생성되는지 확인합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1655870326527ec7ce48fd9b74ea799d7072cf1ac7f5f.png)

## SpawnByModelId

#### 설명

**Workspace**에 추가한 모델 중 한 가지 모델을 지정하여 엔티티로 생성합니다.

#### 매개 변수

| Parameter | Type | Description |
| :---: | :---: | --- |
| id | string | 워크스페이스에 추가된 모델 중 새로 생성할 엔티티의 템플릿이 될 Entry ID를 넣어줍니다.<br>Entry ID는 **Workspace - 모델(생성할 엔티티의 템플릿이 되는) - Copy Entry ID**를 선택해 가져올 수 있습니다. |
| name | string | 생성할 엔티티의 이름을 설정합니다. |
| spawnPosition | Vector3 | 엔티티가 생성될 위치 좌표를 설정합니다. |
| parent | Entity | 생성된 엔티티의 부모가 될 엔티티를 넣어줍니다. |

#### 반환 값

- 스폰 성공하면 **Entity**를 반환합니다.
- 스폰 실패하면 **nil**을 반환합니다.

#### 사용 예시

1. **Preset List**에서 원하는 모델의 콘텍스트 메뉴를 연 뒤, **Add to Workspace**를 눌러 **Workspace**에 모델을 추가합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/165995860982314bcc1601e8c44d885b2067b34ea32f3.png)
2. 추가한 모델의 콘텍스트 메뉴에서 **Copy Entry ID**를 눌러 **Entry ID**를 클립보드에 복사합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1687760366731d075f28ddc3b4f14ac0791f36257437a.png)
3. **SpawnManager** 컴포넌트를 열고 `SpawnByModelId` 함수를 생성합니다.```
void SpawnByModelId()
{
    local id = "maplestorymonster$0108737afb9548309c03795430b20c05" -- Copy Entry ID를 눌러 복사했던 ID를 붙여넣습니다. 앞에 "model://"은 제거합니다.
    local name = "SpawnedEntity" -- 생성될 엔티티 이름 설정
    local spawnPosition = Vector3(0,0,0) -- 생성될 위치 설정
    local parent = _EntityService:GetEntityByPath("/maps/map01") --생성될 엔티티의 부모 엔티티

    local spawnedEntity = _SpawnService:SpawnByModelId(id, name, spawnPosition, parent)
    if isvalid(spawnedEntity) == false then
        log("Spawn Failed")
    end
}
```
4. `OnBeginPlay` 함수를 아래와 같이 수정합니다.```
[server only]
void OnBeginPlay()
{
    -- self:SpawnByEntity()
    self:SpawnByModelId()
}
```
5. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 **Workspace**의 모델과 동일한 엔티티가 생성되는지 확인합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1655816153693283ae21166b6476ea65044a4ffde1a21.png)

# 엔티티 제거

메이플스토리 월드에서는 엔티티를 제거할 수 있는 `_EntityService:Destroy`와 `Entity:Destroy` 두 가지 방법을 제공합니다. `_EntityService:Destroy`는 매개 변수로 넘겨 받은 엔티티를, 그리고 `Entity:Destroy`는 **Destroy**를 호출한 엔티티 자신을 삭제합니다. 따라서 두 함수는 대상만 다를 뿐 삭제 동작은 동일합니다.

## Destroy

#### 매개 변수

| Parameter | Description |
| :---: | --- |
| entity | 제거 대상이 되는 엔티티를 넣어 줍니다. |

#### 사용 예시

**SpawnService**의 스폰 기능을 통해 엔티티를 생성하고, 생성된 후 3초 후에 제거되도록 합니다. 예제는 위 엔티티 생성에서 사용한 **SpawnManager** 스크립트 컴포넌트를 활용합니다.

1. 프로퍼티를 추가하고, 타입과 이름을 다음과 같이 설정합니다.```
Property:
[none]
any SpawnedEntity = nil
```
2. `SpawnByModelId` 함수를 다음과 같이 수정합니다.```
void SpawnByModelId()
{
    local id = "maplestorymonster$0108737afb9548309c03795430b20c05"
    local name = "SpawnedEntity"
    local spawnPosition = Vector3(0,0,0)
    local parent = _EntityService:GetEntityByPath("/maps/map01")

    -- 아래 부분을 수정합니다.
    self.SpawnedEntity = _SpawnService:SpawnByModelId(id, name, spawnPosition, parent)
    if isvalid(self.SpawnedEntity) == false then
        log("Spawn Failed")
    end
}
```
3. `OnUpdate` 함수를 추가하고 다음과 같이 작성합니다. 엔티티 생성 3초 후 해당 엔티티를 삭제하는 스크립트를 작성합니다.```
[server only]
void OnUpdate(number delta)
{
    if isvalid(self.SpawnedEntity) == false then
        return
    end

    if self._T.time == nil then
        self._T.time = 0
    end

    self._T.time = self._T.time + delta

    if self._T.time >= 3 then
        _EntityService:Destroy(self.SpawnedEntity)
    end
}
```
4. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 엔티티가 생성되고 3초 뒤 사라지는 것을 확인합니다
  > **Tip** `Entity:Destroy`를 활용해 엔티티를 삭제할 수도 있습니다. `Entity:Destroy`를 사용한 스크립트는 다음과 같습니다.```
[server only]
void OnUpdate(number delta) 
{
    if isvalid(self.SpawnedEntity) == false then
        return
    end

    if self._T.time == nil then
        self._T.time = 0
    end

    self._T.time = self._T.time + delta

    if self._T.time >= 3 then
    self.SpawnedEntity:Destroy() -- _EntityService:Destroy 대신 Entity:Destroy로 교체.
    end
}
```

# 엔티티 유효성 체크

엔티티가 생성 또는 삭제될 때, 엔티티의 상태를 확인합니다. 보통 **엔티티의 nil 체크**를 하는데, **삭제 대기 중** 같은 상태에서는 원하는 값을 제대로 얻지 못할 수도 있습니다. 이럴 때 엔티티 유효성 체크 기능을 사용합니다. 글로벌 함수인 `isvalid`를 통해 엔티티의 유효성을 체크할 수 있습니다.

## isvalid

`isvalid` 함수는 **엔티티가 현재 삭제 대기 중**인지 또는 **이미 삭제되었는지**를 확인하여 **true** 또는 **false** 값을 반환합니다.

#### 매개 변수

| Parameter | Description |
| :---: | --- |
| entity | 유효성 체크 대상이 되는 엔티티를 넣어줍니다. |

#### 반환 값

- 매개 변수로 넘겨진 엔티티가 존재하면 **true**를 반환합니다.
- 엔티티가 nil이거나 삭제 대기 중, 또는 삭제된 엔티티라면 **false**를 반환합니다.

#### 사용 예시

위 `Destroy` 함수 예제에 이어서 엔티티 삭제 전후로 `isvalid` 함수가 어떤 값을 반환하는지 확인하고 실제 사용법을 살펴봅니다.

1. **SpawnManager** 스크립트 컴포넌트의 `OnUpdate` 함수를 다음과 같이 수정합니다.```
[server only]
void OnUpdate(number delta)
{
    if isvalid(self.SpawnedEntity) == false then
        return
    end

    if self._T.time == nil then
        self._T.time = 0
    end

    self._T.time = self._T.time + delta

    if self._T.time >= 3 then
        local isvalidValue = isvalid(self.SpawnedEntity)
        log("Before deletion : "..tostring(isvalidValue))
        self.SpawnedEntity:Destroy()
        isvalidValue = isvalid(self.SpawnedEntity)
        log("After deletion : "..tostring(isvalidValue))
    end
}
```
2. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 테스트합니다. 콘솔 창에서 엔티티 삭제 전후 로그를 확인합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1655869031532a1ede31bc9bd46d8b521d0e7b328442f.png)
  > **Tip** 유효성 체크는 글로벌 함수인 `isvalid`를 주로 이용하지만, `_EntityService:IsValid(entity)` 함수 또한 동일한 기능을 수행합니다. 따라서 위 스크립트를 아래와 같이 수정해도 결과는 같습니다.```
 [server only]
 void OnUpdate(number delta)
 {
     if isvalid(self.SpawnedEntity) == false then
         return
     end

     if self._T.time == nil then
         self._T.time = 0
     end

     self._T.time = self._T.time + delta

     if self._T.time >= 3 then
         local isvalidValue = _EntityService:IsValid(self.SpawnedEntity)
         log("Before deletion : "..tostring(isvalidValue))
         self.SpawnedEntity:Destroy()
         isvalidValue = _EntityService:IsValid(self.SpawnedEntity)
         log("After deletion : "..tostring(isvalidValue))
     end
}
```

Update 2025-11-20 PM 02:03


# 엔티티를 탐색하는 EntityService

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 제작하다 보면 특정 엔티티를 탐색하여 받아오거나, 혹은 관련 있는 여러 엔티티를 한 번에 받아야 하는 상황이 자주 발생합니다. 이럴 때 [**EntityService**](/apiReference/Services/EntityService)를 활용할 수 있습니다. **EntityService**는 엔티티 탐색, 삭제, 유효성 체크 등의 기능을 제공하고 있습니다. 이번 과정에서는 **EntityService**에서 제공하는 기능의 사용법을 하나씩 알아보도록 하겠습니다.

**테스트 환경** ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16862117142285e8a5ff6889342debf36acfcd7fdccf4.png) **common**에 컴포넌트를 생성한 뒤 예제 코드를 넣고 테스트 해주시길 바랍니다.

# Entity 탐색 함수

**EntityService**에서는 8개의 엔티티를 탐색하는 함수를 제공합니다. 각 함수는 월드 경로, 엔티티 ID, 모델 ID 등을 매개 변수로 전달 받고, 이를 통해 엔티티를 탐색하여 반환합니다. 각 함수별 기능에 따라 개별 엔티티를 반환하거나 혹은 여러 엔티티를 반환하기도 합니다.

#### GetEntityByPath()

월드 상의 경로(path)와 일치하는 단일 엔티티를 반환하는 함수입니다. 만일 월드 경로가 같은 엔티티가 2개 이상 존재하면 가장 먼저 찾은 엔티티를 반환합니다. 따라서 **GetEntityByPath**는 월드 경로가 유니크한 엔티티를 탐색할 때 사용하는 것을 권장합니다. **worldPath**는 **Hierarchy**의 각 엔티티 콘텍스트 메뉴에서 **Copy Entity Path**로 가져올 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1686210532005a4a5c0075ed74dfd84667cb938b58532.png)

```
void GetEntityByPathExample()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/npc-320_1")
    local uiEntity = _EntityService:GetEntityByPath("/ui/DefaultGroup/Image_1")
    
    log(entity.Name)
    log(uiEntity.Name)
}
```

#### GetEntitiesByPath()

매개 변수로 전달한 월드 경로와 일치하는 모든 엔티티를 반환하는 함수입니다. 만일 찾고자 하는 엔티티가 여러 개이고, 해당 엔티티들이 같은 월드 경로를 갖고 있을 때 사용합니다. 예를 들어 탄막 슈팅 게임에서 생성된 수많은 총알 엔티티와 같이 같은 이름으로 생성된 모든 엔티티를 받아오고 싶을 때 사용하면 효과적입니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16862119603211b489e0a3c2e42dc91e46ea4837b80f8.png)

```
void GetEntitiesByPathExample()
{
    local entityArray = _EntityService:GetEntitiesByPath("/maps/map01/Bullet")
    
    for i, entity in pairs(entityArray) do
        log(entity.Name)
    end
}
```

#### GetEntity()

매개 변수로 받은 엔티티 ID와 일치하는 엔티티를 반환합니다. 위와 같이 같은 이름의 엔티티가 여러 개 있는 상황에서 원하는 엔티티 하나만 받아오고 싶을 때 사용하면 효과적입니다. 엔티티 ID는 **Hierarchy**의 해당 엔티티 콘텍스트 메뉴에서 **Copy Entity ID**로 가져오거나, 스크립트에서 엔티티 ID를 받아올 수도 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16862106228295b326090f635424abcc59cf1e2980a19.png)

```
void GetEntityExample()
{
    local bulletEntity = _EntityService:GetEntityByPath("/maps/map01/Bullet")
    local bulletEntityId = bulletEntity.Id
    
    local bulletEntityById = _EntityService:GetEntity(bulletEntityId)
    
    if bulletEntity == bulletEntityById then
        log(bulletEntity.Id)
    end
}
```

#### GetEntitiesSpawnedByModelId()

모델 ID와 일치하는 모델로부터 생성된 모든 엔티티를 반환합니다. 다음과 같이 수많은 엔티티가 배치된 상황에서 NPC와 같이 동일 모델로부터 생성된 모든 엔티티를 받고 싶을 때 유용하게 사용됩니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1635310632309132b8a9defb34af18a8bd72812a72a56.png)  특정 엔티티에 접근하여 모델을 받은 뒤, 해당 모델로부터 생성된 모든 엔티티를 받을 수 있습니다.

```
void GetEntitiesSpawnedByModelIdExample()
{
    local modelId = _EntityService:GetEntityByPath("/maps/map02/npc-5396_1").Model.BaseModelId
    
    local entities = _EntityService:GetEntitiesSpawnedByModelId(modelId)
    
    for i, v in pairs(entities) do
        log(v.Name)
    end
}
```

#### GetEntitiesSpawnedByModel()

매개 변수로 전달한 모델로부터 생성된 모든 엔티티를 반환합니다. 많은 엔티티가 배치된 상황에서 동일 모델로부터 생성된 모든 엔티티를 받고 싶을 때 유용하게 사용됩니다.

```
void GetEntitiesSpawnedByModelExample()
{
    local model = _EntityService:GetEntityByPath("/maps/map02/npc-5396_1").Model
    
    local entities = _EntityService:GetEntitiesSpawnedByModel(model)
    
    for i, entity in pairs(entities) do
        log(entity.Name)
    end
}
```

#### GetSameModelEntities(Entity entity)

매개 변수로 전달한 엔티티의 원형 모델로부터 생성된 모든 엔티티를 반환합니다.

```
void GetSameModelEntitiesExample()
{
    local templateEntity = _EntityService:GetEntityByPath("/maps/map02/npc-5396_1")
    
    local entities = _EntityService:GetSameModelEntities(templateEntity)
    
    for i, entity in pairs(entities) do
        log(entity.Name)
    end
}
```

#### GetEntityByTag()

매개 변수로 전달한 태그 값과 일치하는 모든 엔티티를 반환합니다. 태그는 **TagComponent**를 통해 설정할 수 있습니다. 한 엔티티에 여러 개의 태그를 설정할 수 있는데, 이중 일치하는 태그가 하나라도 있다면 해당 엔티티를 반환합니다. 만일 다수의 엔티티가 같은 태그로 설정되어 있다면, 가장 먼저 찾은 엔티티만 반환합니다. 따라서 **GetEntityByTag**는 유니크한 태그를 가진 엔티티를 탐색할 때 사용하는 것을 권장합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/168621240536469fbf1de6ee5420083d94f7cf1b1a48c.png)

```
void GetEntityByTagExample()
{
    local entity = _EntityService:GetEntityByTag("FlayingMonster")
    
    log(entity.Name)
}
```

#### GetEntitiesByTag()

매개 변수로 전달한 태그 값과 일치하는 모든 엔티티를 반환합니다. 만일 수많은 엔티티가 있는 상황에서 특정 태그 값으로 설정된 엔티티를 모두 받아오고 싶을 때 사용하면 좋습니다.

```
void GetEntitiesByTagExample()
{
    local monsterEntities = _EntityService:GetEntitiesByTag("Monster")
    
    for i, monsterEntity in pairs(monsterEntities) do
        log(monsterEntity.Name)
    end
}
```

# 엔티티 삭제와 유효성 체크

**EnitiyService**에서는 엔티티를 삭제하는 함수와 엔티티의 삭제 여부, 즉 엔티티가 현재 유효한 상태인지를 체크하는 함수를 함께 제공하고 있습니다.

#### Destroy()

매개 변수로 전달한 엔티티를 삭제합니다.

```
void DestroyExample()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/Monster1_1")
    _EntityService:Destroy(entity)
    
    if isvalid(entity) == false then
        log("Entity is destroyed")
    end
}
```

꼭 `EntityService:Destroy`를 사용하지 않고도, 엔티티의 `Destroy` 함수로 같은 기능을 수행할 수 있습니다.

```
void DestroyExample()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/Monster1_1")
    entity:Destroy()
    
    if isvalid(entity) == false then
        log("Entity is destroyed")
    end
}
```

#### IsValid()

매개 변수로 전달한 엔티티가 현재 삭제되었는지를 확인하는 함수입니다. 물론 해당 엔티티가 존재하는지는 nil로도 확인할 수 있습니다. 하지만 존재했던 엔티티가 삭제되었는지 nil로 확인하는 것은 다소 불안정하기 때문에 nil보다는 `IsValid` 함수로 확인하는 것을 권장합니다.

```
void IsValidExample()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/Monster1_1")
    _EntityService:Destroy(entity)
    
    if _EntityService:IsValid(entity) == false then
        log("Entity is destroyed")
    end
}
```

`EntityService:IsValid`는 `isvalid` 함수로 대체할 수 있습니다.

```
void IsvalidExample()
{
    local entity = _EntityService:GetEntityByPath("/maps/map01/Monster1_1")
    _EntityService:Destroy(entity)
    
    if isvalid(entity) == false then
        log("Entity is destroyed")
    end
}
```

# 엔티티 생성 삭제 이벤트

엔티티를 생성 또는 삭제할 때, **EntityService**에서 엔티티 생성 및 삭제 이벤트가 발생합니다. 각 이벤트 핸들러는 스크립트 에디터의 **Entity Event Handler**에서 추가할 수 있습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16375674646750c2640d5e2294eed9051622d33acc09f.png)  이벤트 핸들러를 추가한 뒤 이벤트 센더가 **EntityService**인지 확인합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1637567490394c7e585c8bc1e4288a36d0cd99d7aa9dc.png)

#### EntityCreateEvent

엔티티가 생성될 때 발생하는 이벤트입니다. **Entity Event Handler**에서 핸들러를 추가할 수 있습니다. 이벤트 핸들러의 매개 변수로 이벤트가 전송되며, 이벤트에는 생성된 엔티티가 정보가 포함되어 있습니다.

```
Method:
[server only]
void OnBeginPlay()
{
    local monsterTemplate = _EntityService:GetEntityByPath("/maps/map01/monster-1")

    -- "spawnedMonster"라는 이름의 몬스터 엔티티 스폰
    _SpawnService:SpawnByEntityTemplate(monsterTemplate, "spawnedMonster", Vector3(0,0,0), true, true, true, true)
}

Event Handler:
[service: EntityService]
HandleEntityCreateEvent (EntityCreateEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    
    -- OnBeginPlay에서 생성한 엔티티만 출력하도록 합니다.
    if Entity.Name ~= "spawnedMonster" then
    	return	
    end
    
    log(Entity.Name) -- 'spawnedMonster'로 출력되는지 확인
}
```

#### EntityDestroyEvent

엔티티가 삭제될 때 발생하는 이벤트입니다. **Entity Event Handler**에서 핸들러를 추가할 수 있습니다. 이벤트 핸들러의 매개 변수로 이벤트가 전송되며, 이벤트에는 삭제 대기 중인 엔티티가 정보가 포함되어 있습니다.

```
Method:
[server only]
void OnBeginPlay()
{
    local monsterTemplate = _EntityService:GetEntityByPath("/maps/map01/monster-1")
    
    -- "spawnedMonster"라는 이름의 몬스터 엔티티 스폰
    local spawnedEntity = _SpawnService:SpawnByEntityTemplate(monsterTemplate, "spawnedMonster", Vector3(0,0,0), true, true, true, true)
    
    local callBack = function()
    _EntityService:Destroy(spawnedEntity)
    end
    
    _TimerService:SetTimerOnce(callBack, 5) -- 5초 뒤 스폰한 엔티티를 삭제합니다.
}
    
Event Handler:
[service: EntityService]
HandleEntityCreateEvent(EntityCreateEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    
    -- OnBeginPlay에서 생성한 엔티티만 출력하도록 합니다.
    if Entity.Name ~= "spawnedMonster" then
    	return	
    end
    
    log("CreatedEntity : "..Entity.Name) -- 'CreatedEntity : spawnedMonster'로 출력되는지 확인
}

[service: EntityService]
HandleEntityDestroyEvent(EntityDestroyEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    
    -- OnBeginPlay에서 생성한 엔티티만 출력하도록 합니다.
    if Entity.Name ~= "spawnedMonster" then
    	return	
    end
    
    log("DestroyedEntity : "..Entity.Name) -- 'DestroyedEntity : spawnedMonster'로 출력되는지 확인
}
```

Update 2025-11-17 PM 08:14


# 유저 엔티티를 찾아주는 UserService

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

`UserService`를 통해 상황별로 **UserEntity**를 받는 방법을 알아봅니다. 간단한 스크립트 예제를 통해 `UserService`가 제공하는 기능을 알아보겠습니다.

# 들어가기에 앞서

다음 가이드를 먼저 학습하면 본 과정을 이해하는 데 많은 도움이 됩니다. [서버와 클라이언트](/docs?postId=207) [실행 제어](/docs?postId=210) [Event System](/docs?postId=73) [Entity Event System](/docs?postId=176)

# 예제 진행 준비

먼저 **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭하여 새 스크립트 컴포넌트를 생성한 뒤 이름을 **Test**로 변경합니다. 그리고 **Test** 컴포넌트를 **Hierarchy - Common** 엔티티에 추가합니다. ![UserService_2](https://mod-file.dn.nexoncdn.co.kr/bbs/1659503134261e00f6eb7162b47738b3b6a65843ebbf6.png)  이후 **Test** 컴포넌트를 더블 클릭하여 스크립트 에디터를 엽니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1635462948231d6af9c28df8e41f599fc4b0a19942bd9.png)  이제 예제를 진행하면서 `UserService`를 알아봅시다.

# 유저 입장/퇴장 이벤트

월드에 유저가 들어오거나 나갈 때, `UserService`에서 입장/퇴장 이벤트가 발생합니다. 스크립트 컴포넌트에 이벤트 핸들러를 추가하여 유저 입장/퇴장 시점에 별도 처리를 추가할 수 있습니다.

### UserEnterEvent

유저가 월드에 입장했을 때 발생하는 이벤트입니다. 스크립트 컴포넌트에서 이벤트 핸들러를 추가해서 유저가 입장했을 때의 처리를 추가할 수 있습니다.

다음은 유저가 월드에 입장했을 때, 입장한 유저의 **UserId**를 로그로 출력하는 예제입니다. 이를 통해 **UserEnterEvent** 핸들러를 추가하고 활용하는 방법을 알아보겠습니다. 다음과 같은 방법으로 **UserEnterEvent** 핸들러를 추가할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/163697876177574026aa5b0a140b5a611de58c3191e29.png)  추가한 핸들러에는 매개 변수로 **event**가 들어오고 이를 통해 현재 게임에 입장한 **UserId**를 받습니다. 다음과 같이 코드를 작성하면, 유저가 게임에 입장할 때마다 **UserId**를 콘솔 창에 출력합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    -- 입장 유저의 UserId를 콘솔 창에 출력
    log("User Enter! : "..UserId)
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 아래와 같이 새 클라이언트를 추가합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/163546298427140ee964bea9b4eaaa80eab3d2d65555d.png)  새 유저가 게임에 입장했을 때 콘솔 창에 로그가 출력됩니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1672227283289a41676c3ff0c4a90907a28f386e37728.png)

### UserLeaveEvent

유저가 월드에서 퇴장했을 때 발생하는 이벤트입니다. 다음은 유저가 월드에서 퇴장했을 때, 퇴장한 유저의 **UserId**를 콘솔 창에 출력하는 예제입니다. **UserLeaveEvent** 핸들러를 추가하고 다음과 같이 코드를 작성합니다.

```
Event Handler:
[service: UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    -- 퇴장 유저의 UserId를 콘솔 창에 출력
    log("User Leave! : "..UserId) 
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 유저가 퇴장할 때 출력되는 로그를 확인해야 하므로 클라이언트를 추가합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/163546298427140ee964bea9b4eaaa80eab3d2d65555d.png)  새 유저가 들어온 뒤, 추가된 클라이언트를 다시 종료하여 새 유저를 퇴장시킵니다. 그리고 유저가 퇴장할 때 아래와 같이 로그가 출력되는 것을 확인합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/167222742821522c171b011e14d8783129decfdaa0f35.png)

# 유저 접속 끊김/재접속 이벤트

유저의 네트워크가 불안정하면 접속이 끊길 수 있습니다. 또한 다시 재접속할 수도 있습니다. 이와 같이 접속 끊김/재접속 이벤트가 `UserService`에서 발생합니다. 스크립트 컴포넌트에서 해당 이벤트 핸들러를 추가하여 유저의 접속 끊김 또는 재접속 시점에 별도 처리를 추가할 수 있습니다.

### UserDisconnectEvent

유저의 네트워크 접속이 불안정하여 끊겼을 때 발생하는 이벤트입니다. 스크립트 컴포넌트에서 해당 이벤트 핸들러를 추가하여 접속이 끊겼을 때 처리를 추가할 수 있습니다.

다음은 접속이 끊긴 **UserId**와 시간을 출력하는 예제입니다. 이벤트 핸들러에 **UserDisconnectEvent**를 추가하고 아래와 같이 작성해 봅시다.

```
Event Handler:
[service: UserService]
HandleUserDisconnectEvent (UserDisconnectEvent event)
{
    -- Parameters
    local DisconnectMapName = event.DisconnectMapName
    local TimeNetworkClosed = event.TimeNetworkClosed
    local UserId = event.UserId
    --------------------------------------------------------
    log("UserDisconnectEvent : "..UserId.." : "..DisconnectMapName.." : "..tostring(TimeNetworkClosed))
}
```

위와 같이 작성하면 유저의 접속이 끊겼을 때 콘솔 창에 로그가 출력됩니다. ![disconnect](https://mod-file.dn.nexoncdn.co.kr/bbs/1672228212685cf51c1549431482d912ea1a35a6926f5.png)

### UserReconnectEvent

유저가 재접속했을 때 발생하는 이벤트입니다. 스크립트 컴포넌트에서 해당 이벤트 핸들러를 추가하여 재접속이 발생했을 때의 처리를 추가할 수 있습니다.

다음은 재접속한 **UserId**와 재접속 시간을 출력하는 예제입니다. 이벤트 핸들러에 **UserReconnectEvent**를 추가하고 아래와 같이 작성해 봅시다.

```
Event Handler:
[service: UserService]
HandleUserReconnectEvent (UserReconnectEvent event)
{
    -- Parameters
    local ReconnectMapName = event.ReconnectMapName
    local TimeNetworkClosed = event.TimeNetworkClosed
    local UserId = event.UserId
    --------------------------------------------------------
    log("UserReconnectEvent : "..UserId.." : "..ReconnectMapName.." : "..tostring(TimeNetworkClosed))
}
```

위와 같이 작성하면 유저가 재접속했을 때 콘솔 창에 로그가 출력됩니다. ![reconnect](https://mod-file.dn.nexoncdn.co.kr/bbs/16722281637717ebb64a50b5841c290651809013e8fb8.png)

> **더 알아보기** 접속 끊김 및 재접속 상황을 일반적으로 테스트하기는 어렵습니다. 위의 예제와 같이 코드를 작성하면 로그를 남길 수 있다는 점을 참고하기 바랍니다.

# 게임에 참여 중인 모든 유저 엔티티 받아오기

### UserEntities

**UserService**는 게임에 참여 중인 모든 유저 엔티티를 받아오는 **UserEntities** 프로퍼티를 제공합니다. **UserEntities**는 사전(Dictionary) 타입입니다. **Key - Value** 값으로 **UserId - MODEntity**를 반환합니다. 다음은 유저가 게임에 들어올 때마다 모든 플레이어를 순회하며 **Entity Name**을 출력하는 예제입니다. 위의 **UserEnterEvent**를 다음과 같이 수정합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    --UserService로 모든 유저를 Dictionary로 받음
    local AllUserEntitiesDic = _UserService.UserEntities                    
    for userId, playerEntity in pairs(AllUserEntitiesDic) do
        --모든 유저를 순회하며 userId와 Entity.Name을 출력
        log("userId : playerEntity = "..userId.." : "..playerEntity.Name)
    end
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 콘솔 창에 **Key** 값인 **UserId**와 **MODEntity.Name**이 출력됩니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/167221497602480f42eb437ee456fa0b18f0d9e7192a3.png)  클라이언트 추가 버튼을 눌러 봅시다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/163546298427140ee964bea9b4eaaa80eab3d2d65555d.png)  새 유저가 게임에 입장할 때마다 게임에 참여 중인 모든 유저를 순회하며 **UserId**와 **MODEntity.Name**이 출력됩니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1672228433360de5251fa28be4d35b3717ba6ad4d5ce6.png)

# 게임에 참여 중인 모든 유저 정보 받아오기

### Users

**UserService**는 게임에 참여 중인 모든 유저 정보를 받아오는 **Users** 프로퍼티를 제공합니다. **Users**는 모든 유저의 **UserId, 프로필 이름(Nickname), 프로필 코드**를 반환합니다. 다음은 유저가 게임에 들어올 때마다 모든 유저를 순회하며 유저 정보를 출력하는 예제입니다. 위의 **UserEnterEvent**를 다음과 같이 수정합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    local users = tostring(#_UserService.Users).."\n"
    for i, j in pairs(_UserService.Users) do
     users = users..j.UserId.." "..j.Nickname.." "..j.ProfileCode.."\n"
    end
    
    log(users)
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 콘솔 창에 **유저 수, UserId, 프로필 이름, 프로필 코드**가 출력됩니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/16841317926502cfd39a5736348c085c6ed944866d293.png)

클라이언트 추가 버튼을 누르고 새 유저가 게임에 입장할 때마다 모든 유저 정보가 출력되는 것을 확인합니다. ![002](https://mod-file.dn.nexoncdn.co.kr/bbs/16841318084419983ed6428cd40b18fe37140c1cab7ca.png)

# 게임에 참여 중인 유저 수 가져오기

### GetUserCount()

`GetUserCount()`는 현재 게임에 참여 중인 유저 수를 리턴하는 함수입니다. 다음은 유저가 게임에 들어올 때마다 게임에 참여 중인 모든 유저 수를 출력하는 예제입니다. **UserEnterEvent**를 다음과 같이 수정합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    local userCount = _UserService:GetUserCount()
    log("CurrentUserCount : "..userCount)
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 클라이언트를 추가할 때마다 콘솔 창에 **CurrentUserCount**가 증가합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1672215824554745c215f00d04ee39a610cf32aed3948.png)

# 특정 맵에 있는 모든 유저 받아오기

`UserService`에는 특정 맵에 있는 유저만 받아오는 함수를 제공합니다.

### GetUsersByMapName()

**mapName**을 이용해 특정 맵에 있는 유저 엔티티를 배열로 리턴하는 함수입니다. **mapName**을 스트링으로 넘겨줍니다. 리턴 받은 배열 값은 반복문을 통해 개별 유저 엔티티를 받아올 수 있습니다.  다음은 map01에 있는 모든 유저를 `GetUserByMapName()` 함수로 받아오는 코드입니다. **UserEnterEvent**를 다음과 같이 수정합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    local mapName = _EntityService:GetEntityByPath("/maps/map01").Name
    local playersArr = _UserService:GetUsersByMapName(mapName)
    for index, player in pairs(playersArr) do
        log("PlayerName : CurrentMap = "..player.Name.." : "..player.CurrentMap.Name)
    end
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 유저를 추가할 때마다 map01에 있는 모든 유저의 이름과 현재 위치한 맵 이름이 출력됩니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1672216028360db04c07342b346e986b136760d153527.png)

> **더 알아보기.**  맵과 클라이언트를 추가해서 테스트하면 좀 더 정확한 결과를 얻을 수 있습니다. 맵 생성과 포탈 연결 방법은 [맵 생성과 관리](https://mod-developers.nexon.com/docs?postId=61) 를 참고하세요. 1. map02를 추가하고, map01과 map02가 연결된 포탈을 추가해 줍니다. ![UserService_22](https://mod-file.dn.nexoncdn.co.kr/bbs/16346262603985e23a20893c549ff9c1f1994e4cb9b3e.png) 2. 플레이 중 클라이언트 셋을 더 추가하고, 유저 둘은 map01에, 나머지 둘은 map02에 위치시켜 줍니다. ![UserService_23](https://mod-file.dn.nexoncdn.co.kr/bbs/1634626281994fff64361306f49d1ac1da0670453e014.png) 3. 유저가 각기 다른 맵에 들어가 있는 상황에서 유저를 하나씩 추가해 봅니다. 유저가 추가될 때마다 map01에 있는 유저들의 이름과 위치한 맵 이름이 출력되는 것을 확인합니다. ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/167222862898698a874a1c74848cda4a51f1960180331.png)

### GetUsersByMapComponent()

`GetUsersByMapComponent()` 역시 특정 맵에 있는 유저 엔티티를 얻어오는 함수입니다. 특정 맵의 **mapId**가 아닌 **mapComponent**를 매개 변수로 넘겨줍니다.  다음은 map01에 있는 모든 유저를 `GetUsersByMapComponent()`로 받아오는 코드입니다. **UserEnterEvent**을 다음과 같이 수정합니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    -- map01의 컴포넌트를 받음
    local mapComponent = _EntityService:GetEntityByPath("/maps/map01").MapComponent    
    -- mapComponent를 매개 변수로 넘겨 map01에 있는 유저를 배열로 받음
    local playersArr = _UserService:GetUsersByMapComponent(mapComponent)
    for index, player in pairs(playersArr) do
       log("PlayerName : CurrentMap = "..player.Name.." : "..player.CurrentMap.Name)         
    end
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 유저를 추가할 때마다 map01에 있는 모든 유저의 이름과 현재 위치한 맵 이름이 출력됩니다. ![26](https://mod-file.dn.nexoncdn.co.kr/bbs/16722287638923d83b1cd8b494f378f926520c621dce8.png)

# UserId를 이용해 플레이어 엔티티 받아오기

### GetUserEntityByUserId()

`GetUserEntityByUserId()`는 유저 아이디를 통해 해당 플레이어 엔티티를 리턴하는 함수입니다.  게임을 제작하다 보면 **UserId**만 알고 있는 상태에서 해당 아이디의 플레이어 엔티티를 받아와야 할 때가 있습니다. **UserEntities**로 모든 유저를 받아온 다음, 하나씩 순회하면서 같은 아이디의 엔티티를 찾을 수도 있겠지만, 매번 모든 유저를 순회하며 찾는 것은 상당히 비효율적입니다.  `GetUserEntityByUserId()`는 이런 상황에서 사용할 수 있는 함수입니다. 유저의 아이디만 매개 변수로 넘겨주면 되기 때문에 원하는 유저 엔티티를 쉽게 받을 수 있습니다. 다음은 게임에 입장한 **UserId**를 통해 유저 엔티티를 받아 이름을 출력하는 코드입니다.

```
Event Handler:
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    local EnterdPlayerEntity = _UserService:GetUserEntityByUserId(UserId)
    log("EnterdPlayerEntityName : "..EnterdPlayerEntity.Name)  
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 클라이언트를 추가할 때마다 새로 들어온 유저의 이름이 출력됩니다. ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/1672228927792d3bae34457444e4c80d92776b8025571.png)

# 내 플레이어 받아오기 (클라이언트 전용)

### LocalPlayer

**LocalPlayer**는 클라이언트에서 내 유저 엔티티를 얻을 수 있는 프로퍼티입니다. 특정 클라이언트에서 내 캐릭터라는 개념은 클라이언트에서만 유효합니다. 그러므로 서버에서는 사용할 수 없고 반드시 클라이언트에서만 사용할 수 있습니다.  **UserEnterEventType**은 서버에서만 발생하기 때문에, 클라이언트에서 실행할 수 있는 함수를 하나 추가하여 유저가 게임에 들어올 때마다 내 캐릭터의 이름을 출력하는 코드를 작성해 줍니다.

```
Method: 
[client]
void PrintLocalPlayerName()
{
    -- 클라이언트에서의 내 유저를 받아옴
    local MyPlayer = _UserService.LocalPlayer   
    log("MyPlayerName : "..MyPlayer.Name)
}
Event Handler: 
[service: UserService]
HandleUserEnterEvent (UserEnterEvent event)
{
    -- Parameters
    local UserId = event.UserId
    --------------------------------------------------------
    --이벤트가 서버에서 발생하기 때문에, LocalPlayer를 받아올 수 있는 클라이언트 함수 호출
    self:PrintLocalPlayerName()
}
```

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 어떤 유저가 들어오든, 현재 클라이언트의 내 캐릭터 이름이 출력됩니다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/1672229156613a492a8ce464c496ab49c4a0fb15c5779.png)

> 더 알아보기 클라이언트 공간, 서버 공간에서의 함수 실행은 [실행 제어](https://mod-developers.nexon.com/docs?postId=210)를 참고하세요.

Update 2025-12-02 PM 03:52


# 다른 위치로 이동하는 포탈 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드나 하나의 맵 안에서 이동하는 포탈을 만들어 간단하게 플레이어 아바타가 맵을 이동하게 만들 수 있습니다. [PortalComponent](/apiReference/Components/PortalComponent) 사용 방법을 알아보겠습니다.

# 포탈 만들기

[PortalComponent](/apiReference/Components/PortalComponent)는 동일한 포탈 컴포넌트를 가진 엔티티를 목적지로 설정하고, 플레이어 아바타가 포탈 영역에서 특정 동작을 수행하면(키 입력) 목적지로 이동할 수 있는 기능입니다. 이동 가능한 포탈로 만드는 엔티티는 눈에 잘 띄는 스프라이트를 사용하는 것이 좋습니다. 주로 빛나는 원이나, 특정 그림을 반복적으로 사용해 유저가 쉽게 타 엔티티와 구별할 수 있게 하는 것이 좋습니다.

#### 포탈 모델을 이용해 만들기

**Preset List - Portal**을 선택해 **Scene**에 배치합니다. 포탈 모델에는 **PortalComponent**가 포함되어 있습니다.![101](https://mod-file.dn.nexoncdn.co.kr/bbs/1663915370804d5440d19b5644734bd933e7778f83708.png)

#### 직접 포탈 만들기

1. 크리에이터가 제작한 스프라이트를 사용한 엔티티나 MSW 리소스를 활용한 엔티티를 배치합니다.
2. 프로퍼티 에디터 창을 열어 **PortalComponent**를 추가합니다. ![portal03](https://mod-file.dn.nexoncdn.co.kr/bbs/16877649298670292c6aaa1a24154979d84844e1418f3.png) ![portal04](https://mod-file.dn.nexoncdn.co.kr/bbs/1634802949512ccfae4badddf4a9b94e54c465e52fe6a.png)

# 포탈 목적지 정하기

**PortalComponent**를 가진 엔티티를 목적지로 정할 수 있습니다. 목적지는 한 곳만, 단방향으로 설정할 수 있습니다.

1. 2개 이상의 포탈을 설치합니다.![portal05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634802987275d1041c5e61784d01aa9e0f46471e9154.png)
2. **PortalComponent - PortalEntityRef**를 누르고 목적지인 포탈을 선택합니다.![portal06](https://mod-file.dn.nexoncdn.co.kr/bbs/1634803045300b9122896120d423ea925ee9a2a3f89c2.png)
3. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 이동을 확인합니다![portal4_1](https://mod-file.dn.nexoncdn.co.kr/bbs/16348033108010ff14400fad74976a47ac11befbe43e3.gif)

> **Tip.** 포탈 경로는 ![workspace_world](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520188174b448bb50e5c64320bb3c882a5b438d6d.png)World에 배치한 다음, **저장(Ctrl + S) 또는 ![Common_SoundPlay](https://mod-file.dn.nexoncdn.co.kr/bbs/1635317657654c59c47ffc44d414db579b8d2fc0715a8.png) 테스트 실행 후** 갱신됩니다. 갱신하지 않으면, 설치한 포탈 경로가 나오지 않으므로 반드시 저장 또는 테스트를 실행해주세요.

# 양방향 이동 포탈 만들기

두 개의 포탈을 서로 연결해 양방향으로 이동할 수 있게 만들 수 있습니다. 맵 내 이동과 다른 맵으로 이동이 가능합니다.

#### 맵 내 양방향 포탈

1. 각각의 위치에 포탈을 배치합니다.
2. 각각의 **PortalComponent - PortalEntityRef**에서 목적지를 선택합니다.![portral11](https://mod-file.dn.nexoncdn.co.kr/bbs/163480347290834c9258780db465485f2abcf0bc3c64c.png)
3. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 이동을 확인합니다.![portalediting6](https://mod-file.dn.nexoncdn.co.kr/bbs/16348058145167aaa89d461ff4c1c8946f863262bd401.gif)

#### 맵을 이동하는 양방향 포탈

1. 다른 맵에 포탈을 각각 배치합니다.
2. **PortalComponent - PortalEntityRef**를 누르고 목적지를 선택합니다.![portal12](https://mod-file.dn.nexoncdn.co.kr/bbs/1634804528834453c58fe14e24cc8adb4ab9e4a3e0a5b.png)
3. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 이동을 확인합니다.![portal55](https://mod-file.dn.nexoncdn.co.kr/bbs/16348062106844c69bcbaa6df4e4e9f3a6cd65394b137.gif)

# 포탈 영역 정하기

스프라이트 크기와 관계없이 포탈로 인식하는 범위를 설정할 수 있으며, Box Size와 Box Offset은 연동되어 있습니다. ![portal07](https://mod-file.dn.nexoncdn.co.kr/bbs/1634804632410373ff4eeb66a406facf39bb888857a1d.png)

- BoxCollider: 포탈 범위 편집 기능을 활성화합니다.
- BoxOffset: 포탈로 인식하는 범위입니다.
- BoxSize: 포탈 박스 크기를 변경합니다.

1. **Box Collider - Edit**를 눌러 포탈을 편집 가능한 상태로 활성화합니다.편집 가능한 상태가 되면 영역이 빨간색으로 변합니다.![portal10](https://mod-file.dn.nexoncdn.co.kr/bbs/16348046753553247448f7d1e4b83add5fac2e7b76e80.png)
2. X, Y값을 직접 변경하거나, 박스 핸들러를 잡아당겨 원하는 크기로 변경합니다.![portalboxsize](https://mod-file.dn.nexoncdn.co.kr/bbs/1634804819824c51759c6a62848348bb5f7f339bbf701.gif)
3. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 바뀐 포탈 범위를 확인합니다. 포탈 스프라이트보다 박스 범위를 크게 설정했기 때문에 포탈 옆에서도 이동이 가능합니다.

| 기본 박스 설정 | 박스 사이즈 변경 후 |
| --- | --- |
| ![portal33](https://mod-file.dn.nexoncdn.co.kr/bbs/16348050501643cf72b5f23084b3794b9a405f1cbeceb.gif) | ![portal22](https://mod-file.dn.nexoncdn.co.kr/bbs/1634805074080dd3861e6a9bc4ec89beff04deb974bf0.gif) |

Update 2025-11-20 PM 02:03


# 공격과 피격

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리에서 플레이어는 모험가가 되어 메이플 세계를 탐험하고 몬스터를 만나 전투를 합니다. 전투 과정에서 다른 몬스터를 공격하거나 피격당합니다. 메이플스토리뿐만 아니라 다양한 게임에서 공격과 피격은 중요한 개념입니다. 이번 과정에서는 공격과 피격을 구현하는 방법을 학습합니다.

##### 참고 가이드/레퍼런스

[AttackComponent](/apiReference/Components/AttackComponent) [HitComponent](/apiReference/Components/HitComponent) [충돌 그룹 만들기](/docs?postId=754) [엔티티의 충돌](/docs/?postId=175) [엔티티의 상태 제어하기](/docs/?postId=686) [플레이어 설정과 제어](/docs/?postId=547)

# AttackComponent 알아보기

메이플스토리 월드에서는 기본적으로 `Ctrl` 키를 누르면 공격 애니메이션이 재생되지만, 직접적인 공격이 가해지지 않습니다. 이 애니메이션이 재생될 때 실제로 타격이 되게 하려면, **AttackComponent**를 활용해야 합니다. 게임에서는 한 플레이어가 다양한 공격을 할 수 있고, 공격 방식마다 공격 범위를 다르게 설정할 수 있습니다. 공격을 구현할 때는 `AttackComponent`를 활용해 제작합니다.

#### 공격 범위 설정

AttackComponent의 `Attack()`과 `AttackFrom()` 두 가지 함수를 활용해 공격 범위를 설정할 수 있습니다.

- `Attack()`: 캐릭터 위치를 기준으로 공격 범위를 설정합니다. 공격 범위 형태는 shape 타입으로 설정합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16621061020831776c9b26fd14098bed69cf25a44963f.png)
- `AttackFrom()`: 월드 좌표를 기준으로 사각형 공격 범위를 설정합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/166210611645871cd92bfcd6640b6b83e6fce31be8829.png)
- `AttackFast()`: 반환 값이 없는 Attack 함수입니다. 캐릭터 위치 기준 불필요한 table 객체 생성을 줄일 수 있습니다. 공격 범위 형태는 shape 타입으로 설정합니다.

#### 대미지 설정

대미지는 `CalcDamage()` 함수로 만들 수 있습니다. 크리티컬 공격의 대미지는 `CalcCritical()` 함수를 사용해 공식을 만들어 활용할 수 있습니다. 이때 `GetCriticalDamageRate()` 함수를 활용해 크리티컬 공격을 할 때 기본 대미지 대비 몇 배의 대미지를 줄 것인지 정할 수 있습니다.

# HitComponent 알아보기

엔티티가 피격 당하기 위해서는 `HitComponent`가 있어야 합니다. `HitComponent`는 엔티티의 충돌체 모양, 크기, 충돌체 그룹을 설정할 수 있습니다. `AttackComponent`의 함수를 활용해 공격 했을 때 유효한 공격 범위 안에 `HitComponent`를 가진 엔티티가 있다면, 그 엔티티는 피격 처리 대상이 됩니다. `HitComponent`가 엔티티가 피격 대상인지 판단하고, 엔티티가 받을 최종 대미지를 결정합니다.

# 공격과 피격 관계

공격과 피격을 유기적으로 구성하기 위해서는 `AttackComponent`, `HitComponent`를 모두 사용해야 합니다. 권투 경기에서도 상대가 공격을 완전히 회피하거나, 최소한의 타격만 받을 때가 있습니다. 이처럼 공격은 성공했지만, 실제 타격 결과와 다른 다양한 경우의 수를 처리하고 싶다면, 두 컴포넌트에서 각각 공격과 피격을 구현해야 합니다.

#### 공격 대상 판단하기

크리에이터의 공격 제작 방식에 따라 `IsAttackTarget()` 함수를 활용해 피격 대상을 선정할 수 있습니다. `IsAttackTarget()` 함수는 공격자가 공격 박스에 포함되지 않도록 처리되어 있으므로, 공격자가 타격을 받지 않게 처리할 필요가 없습니다. **Entity** 타입의 `defender` 매개변수는 충돌한 엔티티가 공격 대상인지 판단할 수 있는 엔티티 정보를 받습니다. 함수의 리턴값이 **false**면 **AttackComponent**에서 적합한 공격 대상으로 판별하고 이후 판단을 **HitComponent**에 넘깁니다. 만약 공격자도 공격 대상에 포함시키고 싶다면, 아래와 같이 리턴값을 **true**로 변경합니다.

```
override boolean IsAttackTarget(Entity defender)
{
    return true
}
```

공격과 피격은 다음과 같이 실행됩니다. 먼저 공격한 엔티티의 `AttackComponent`의 `IsAttackTarget()` 함수에서 공격에 실패했을 경우 **false**, 성공했을 경우 **true**를 반환합니다. **false**는 공격 실패로 이후 절차를 중단합니다. 무조건 타격을 주고 싶은 경우 **true**로 반환하면 됩니다. 이 경우 피격자의 `IsHitTarget()`은 호출되지 않고 무조건 대미지를 줍니다.

피격자의 `HitComponent`의 `IsHitTarget()`이 피격 여부를 판단합니다. `HitComponent` 에서 공격 받은 대미지와 피격자의 회피율 등을 계산해 최종 대미지를 계산합니다. 피격자의 `IsHitTarget()`이 **true**를 반환하면 대미지를 피격자에게 적용합니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/16621062233862d80a40f725a44b2bd383f597906dca9.png)

#### 대미지 계산

대미지 값은 공격자의 **AttackComponent**의 `CalcDamage()` 함수를 이용합니다. 이 함수로 공격 대미지를 반환합니다. 피격자의 **HitComponent**의 `OnHit()` 함수는 `CalcDamage()`의 값을 매개 변수로 전달받을 수 있습니다. 전달받은 값은 그대로 사용할 수도 있고, `OnHit()` 함수에서 추가 계산을 거쳐 최종 대미지 값을 계산할 수도 있습니다. 예를 들어 전달된 공격자의 대미지와 방어자의 회피율 값을 계산해 `OnHit()` 함수가 최종 대미지를 리턴 값으로 냅니다.

![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1662106244457dbfb15dbce134b3c8acc56b4dd23dfc8.png)

#### HitEvent

`OnHit()` 함수는 호출될 때 **HitEvent**를 발생시킵니다. 만약 몬스터로부터 100번 공격 당했을 때의 특별한 처리를 하고 싶다면, 이벤트 발생 횟수를 확인해 구현할 수 있습니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/166210626375732ffa55d90e0452ab96703bf0137e84a.png)

# 예제

`Ctrl`키를 눌러 몬스터를 공격하고, 몬스터는 공격 당할 때마다 일정 비율로 크기가 커질 수 있도록 만들어봅시다.

#### 플레이어 공격 구현

1. **Workspace - BaseEnvironment - NativeScripts - Component - AttackComponent**를 선택합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1687765469788eef28e43cf6e478aadce01fbf58c566b.png)
2. 콘텍스트 메뉴에서 **Extend**를 눌러 컴포넌트를 확장합니다. 확장한 컴포넌트의 이름을 **CharacterAttack**으로 변경합니다.
3. **CharacterAttack** 컴포넌트를 더블 클릭하여 스크립트 에디터를 엽니다.
4. **Method**에서 새로운 함수를 추가하고, 이름을 **NormalAttack** 으로 변경합니다.
5. `Attack` 함수에서 사용할 공격 범위를 정의하고, 매개변수로 전달받을 수 있도록 아래와 같이 작성합니다.```
Method:
void NormalAttack()
{
	local attackSize = Vector2(1, 1)
	local attackOffset = Vector2(0,0)

	self:Attack(attackSize, attackOffset, nil)
}
```
6. 플레이어의 행동 변화를 받을 수 있도록 **Event Handler**에 **PlayerActionEvent**를 추가하고 다음과 같이 작성합니다. 플레이어가 `ctrl` 키를 누를 때마다 `NormalAttack()` 함수를 호출합니다.```
Event Handler:
[self]
HandlePlayerActionEvent(PlayerActionEvent event) 
{
	--------------- Native Event Sender Info ----------------
	-- Sender: PlayerControllerComponent
	-- Space: Server, Client
	---------------------------------------------------------

	-- Parameters
	local ActionName = event.ActionName
	-- local PlayerEntity = event.PlayerEntity
	---------------------------------------------------------

	if ActionName == "Attack" then
		self:NormalAttack()
	end
}
```
  > **Tip** Parameters의 `local ActionName = event.ActionName` 주석을 해제해 활용할 수 있습니다.
7. **DefaultPlayer**에 **CharacterAttack** 컴포넌트를 추가합니다.
8. 맵에 몬스터를 배치하고, [시작]을 눌러 몬스터를 공격할 수 있는지 확인합니다.

# 공격 대미지 계산

`AttackComponent`의 `CalcDamage()` 함수를 활용해 공격 받은 대미지 값을 계산하고 출력할 수 있습니다. 이 함수는 충돌이 발생했을 때 대미지를 반환합니다.

1. **CharacterAttack**컴포넌트에 `CalcDamage()` 함수를 추가합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635473274032dd346b758c4743be834dcc36af950302.png)
2. 공격 대미지 값을 아래와 같이 100으로 작성합니다.```
override int CalcDamage(Entity attacker, Entity defender, string attackInfo)
{
	return 100
}
```
3. [시작]을 누르고 몬스터를 공격하면 **100**의 대미지가 발생하는지 확인합니다.

# 몬스터 피격 구현

**AttackComponent**를 가진 엔티티가 **HitComponent**를 가진 엔티티를 공격하면, 별다른 추가 처리를 하지 않아도 엔티티는 피격 당하게 됩니다. 이 경우 추가 처리가 없기 때문에 기본값인 1로 대미지 스킨이 재생됩니다. 피격을 구현할 때는 공격량 그대로 대미지로 받을 수도 있지만, 공격과 다른 공식을 함께 사용해 피격량을 계산할 수도 있습니다. 예를 들어 100의 공격력으로 공격했지만 몬스터의 방어력이 높은 경우 절반의 공격만 유효하게 처리할 수 있습니다. 이번에는 아래 두 가지를 구현해 피격 당하는지를 확인하고, 최종 피격량을 계산해봅시다.

- 공격받은 대미지를 20으로 변경합니다.
- 공격받을 때마다 사이즈가 커집니다.

1. **Workspace - BaseEnvironment - NativeScripts - HitComponent**를 선택하고 **콘텍스트 메뉴- Extend**를 선택해 컴포넌트를 확장합니다.
2. 이름을 **MonsterHit**으로 변경합니다. ![19-2](https://mod-file.dn.nexoncdn.co.kr/bbs/16353330342954504d937277b4fada89371a5e3da7faa.png)
3. **Workspace - BaseEnvironment - NativeModel**에서 **MoveMonster** 모델을 선택합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1635473322027345d4d4d82df42d283fe2d7c9ef91747.png)
4. 프로퍼티 에디터에서 **HitComponent**의 **콘텍스트 메뉴 - ![Common_menu](https://mod-file.dn.nexoncdn.co.kr/bbs/163453706197553d527cb3ea34392bc2829f15976f3d8.png) - Remove Component**를 눌러 기본 **HitComponent**를 모델에서 삭제합니다. 기본 HitComponent와 확장한 HitComponent를 함께 사용하면 오류가 발생할 수 있기 때문입니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16353328810860b81ed55939d474aaaea5cd238480c92.png)
  > **Tip** 이미 맵에 배치한 몬스터는 모델 프로퍼티 변경 사항이 적용되지 않으므로 삭제 후, 재배치해야 합니다.
5. 배치한 몬스터에 **MonsterHit** 컴포넌트를 추가합니다.
6. **MonsterHit**컴포넌트에 `OnHit()` 함수를 추가합니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/163547333521453f7d5d7ff6a4e20bd2f5c20a78ea254.png)
7. 함수 내 기본 문구 중 **damage** 값을 **20**으로 변경합니다. 공격 받는 대미지 값을 결정합니다.```
method:
override void OnHit(Entity attacker, int damage, boolean isCritical, string attackInfo, int hitCount)
{
	__base:OnHit(attacker,20,isCritical,attackInfo,hitCount)
}
```
8. 피격 당한 몬스터의 사이즈가 커지도록 `OnHit()` 함수에 아래 내용을 추가합니다. **HitEvent**가 발생할 때마다 **TransformComponent.Scale** 값을 1.3배씩 증가시킵니다.```
method:
override void OnHit(Entity attacker, int damage, boolean isCritical, string attackInfo, int hitCount)
{
	__base:OnHit(attacker,20,isCritical,attackInfo,hitCount)

	local scale = self.Entity.TransformComponent.Scale
	scale = scale * 1.3
	self.Entity.TransformComponent.Scale = scale
}
```
9. [시작]을 눌러, 공격 때마다 공격당한 몬스터의 크기가 커지면서 대미지 값이 **20**으로 출력되는지 확인합니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1662107300698572fbabb48b54d5d92f06e1ae6487794.png)

Update 2025-12-03 PM 03:40


# 엔티티의 상태 제어하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=40%EB%B6%84&amp;color=green)

# 학습 과정 소개

[StateComponent](/apiReference/Components/StateComponent)와 StateType의 개념을 알아보고, 엔티티의 상태에 따라 애니메이션이 재생되는 과정을 이해해봅시다.

# State, StateComponent 알아보기

**State**는 어떤 엔티티가 특정한 상태에 있는 것을 말합니다. 서 있는 상태, 엎드린 상태, 공격 상태 등 크리에이터에 따라 다양한 상태를 정의할 수 있습니다. 월드에서 내 캐릭터가 가만히 서 있는 것이 당연하게 느껴질 수 있지만 이는 캐릭터의 State가 "서 있는 애니메이션을 재생하는 상태"인 **IDLE**로 정의되어 있기에 가능한 것입니다. 이처럼 상태에 맞는 애니메이션을 재생하려면 [StateAnimationComponent](/apiReference?postId=367)를 활용해야 합니다.  State 이름은 영어 대문자로 지어야 합니다. 물론 영어 소문자를 사용하더라도 `AddState()`와 같은 함수를 호출할 때 자동으로 대문자로 바뀌어 등록되지만, 동작이 예상과 달라질 수 있으므로 대문자로 짓도록 합니다.

> **Tip.** StateAnimationComponent는 monster, npc에게만 적용할 수 있습니다.

StateComponent는 엔티티에 상태를 부여하고, 상태끼리의 관계를 정의하는 역할을 합니다. 기본적으로 **IDLE, DEAD** 상태를 갖고 있으므로 크리에이터가 새로운 상태를 추가하려면 두 개의 기본 상태를 염두에 두고 활용해야 합니다. StateComponent는 다른 컴포넌트와 함께 있을 경우 자동으로 추가되는 State가 있습니다. 예를 들어 DefaultPlayer에는 여러 상태를 담당하는 PlayerControllerComponent가 기본으로 포함되어 있기 때문에 특정 키를 누르면 상태가 변하고, 그 상태와 연결된 애니메이션(앉기, 걷기 등)이 자동으로 재생됩니다.

#### StateComponent와 특정 컴포넌트의 관계

StateComponent는 특정 컴포넌트와 함께하면 자동으로 새로운 상태가 추가되거나 기본 상태들을 처리할 수 있게 됩니다. 자동으로 추가되는 상태들은 특정 키 입력 혹은 특정 조건을 만족할 때 해당하는 State로 전이되어 동작을 수행하거나 애니메이션을 재생할 수 있게 합니다. 엔티티가 특정 상태일 때 사용자가 정의한 행동을 수행하게 하고, StateAnimationComponent를 함께 사용해 애니메이션 클립을 재생할 수 있게 할 수 있습니다.

- PlayerComponent와 함께 있을 때는 **DEAD**를 처리하거나 부활 처리를 할 수 있습니다.
- PlayerControllerComponent가 함께 있을 때는 **MOVE, CLIMB, LADDER, CROUCH, JUMP, FALL, ATTACK, ATTACK_WAIT, SIT**이 추가됩니다.
- AIChaseComponent 및 AIWanderComponent와 함께 있을 때는 **MOVE**가 추가됩니다. 엔티티를 움직이는 키 입력이 있을 때 MOVE 상태로 전이해 걷는 애니메이션이 재생됩니다.

#### 상태 전이와 이벤트 발생

어떤 상태에서 다음 상태로 변하는 것을 상태 전이(Transition)라 합니다. 상태 전이가 발생할 때 다양한 이벤트가 발생하고, 이를 활용해 특정 엔티티가 상태 전이를 감지할 수 있습니다. 이벤트는 상태 전이가 발생하기 이전의 상태와 현재 상태(바뀐 상태)의 정보를 갖고 있습니다. 아래와 같은 상황에서 이벤트가 발생합니다.

- StateComponent의 상태가 전이되면, [StateChangeEvent](/apiReference/Events/StateChangeEvent)가 함께 발생합니다.
- StateComponent가 **DEAD** 상태에 진입하면 [DeadEvent](/apiReference/Events/DeadEvent)가 발생합니다.
- DefaultPlayer에 StateComponent와 PlayerComponent가 함께 있다면, `PlayerComponent:Respawn()` 함수를 호출할 때 [ReviveEvent](/apiReference/Events/ReviveEvent)가 발생합니다.
- HitComponent는 HitEvent를 발생시키므로 StateComponent는 엔티티에서 발생한 HitEvent를 받아 HIT으로 상태 전이합니다. HIT 상태가 된 뒤 0.5초 후에 IDLE로 자동 전이됩니다.
- AttackComponent는 피격 대상을 검색할 때 `IsAttackTarget()` 함수를 호출합니다. 이때 피격 대상에 해당하는 엔티티의 State가 DEAD라면 false를 반환합니다.

# StateType

사용자 정의 State를 만들 때 사용합니다. StateType에서 상태 진입 및 퇴장 시 사용자가 정의한 행동을 수행하게 하거나, 상태 종료 조건을 정의할 수 있습니다. 원하는 상태가 여러 개라면 그 상태마다 새로운 ![StateType](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_state_type.png) **StateType**을 만들어 활용하는 것을 권장합니다. 물론 If문을 사용해 StateType 하나에 여러 개의 상태를 추가해 사용할 수도 있습니다. 하지만 제작 중 다른 상태를 추가, 삭제하는 경우까지 고려한다면, 상태 별로 StateType을 만드는 것이 더 효율적입니다. 예를 들어 새로운 나만의 몬스터를 만들기 위해 StateType을 만든다면, StateComponent의 기본 상태인 IDLE, DEAD를 제외한 다수의 새로운 StateType을 만들어 관리하는 것이 좋습니다. 추가한 새로운 StateType의 이름은 크리에이터가 만든 StateType의 type이 됩니다.

StateType은 상태를 정의하는 타입이므로 스크립트 컴포넌트와 같이 엔티티에 직접 추가하는 형태로 사용할 수 없습니다. StateType은 StateComponent의 `AddState()` 함수 호출 시 자동으로 할당됩니다. 스크립트 에디터 창에서 상태의 동작에 대해 정의한 후 해당 StateType을 사용하고 싶은 엔티티의 스크립트 컴포넌트 중 하나에 `StateComponent:AddState()`를 사용해 해당 StateType을 추가해야 합니다.

`OnEnter()` `OnUpdate()` `OnExit()` `OnConditionCheck()`에서 크리에이터가 만드는 StateType이 어떻게 작동할 것인지 정의할 수 있습니다.

- **OnEnter()**: 상태에 처음 진입할 때의 동작을 실행합니다.
- **OnUpdate()**: 상태가 유지되는 동안의 동작을 실행합니다.
- **OnExit()**: 상태가 변경될 때 실행됩니다.
- **OnConditionCheck(string nextStateName)**: 상태 전이 조건을 지정합니다. nextStateName 매개 변수를 사용해 연결된 상태에 따라 다른 결괏값을 반환할 수 있습니다.
  - nextStateName으로 분기할 수 있고, true일 때 상태 전이가 이뤄집니다.

#### StateType 만들기

**MyDesk - Create Scripts - Create StateType**을 눌러 새로운 ![StateType](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_state_type.png) StateType을 생성하고, 상태를 정의합니다. `OnConditionCheck()`를 활용해 상태 전이 조건을 만들 수 있습니다. 아래와 같이 **MoveDown** StateType을 만들고 아래의 예시 코드처럼 활용할 수 있습니다.

```
Method:
void OnUpdate()
{
    self.ParentComponent.Entity.TransformComponent:Translate(0, -0.01)
}
    
boolean OnConditionCheck(string nextStateName)
{
    local rotationAngle = self.ParentComponent.Entity.TransformComponent.Rotation.z
    if rotationAngle ~= 0 and rotationAngle % 90 == 0 then
        return true
    else
        return false
    end
}
```

#### 상태 추가하기

`StateComponent:AddState(string stateName, Type stateType)`를 사용해 아래의 예시 코드처럼 엔티티에 상태를 추가할 수 있습니다.

```
self.Entity.StateComponent:AddState("MOVEUP", MoveUp)
```

#### 전이될 상태 정의하기

`StateComponent:AddCondition(string stateName, string nextStateName, boolean reverseResult = false)`를 사용해 현재 상태에서 넘어갈 다음 상태를 입력해 연결합니다. 아래의 예시 코드처럼 작성하면 **MOVEDOWN**에서 **MOVEUP**로의 상태 전이를 설정할 수 있습니다.

```
self.Entity.StateComponent:AddCondition("MOVEDOWN", "MOVEUP", false)
```

#### 상태 전이 조건 삭제

`StateComponent:RemoveCondition(string stateName, string nextStateName)`을 사용해 현재 상태에서 다음 상태로 가는 조건을 삭제합니다. 아래와 같이 작성하면 위에서 `AddCondition()`으로 추가했던 조건(**MOVEDOWN**에서 **MOVEUP**로 상태 전이)을 삭제합니다.

```
self.Entity.StateComponent:RemoveCondition("MOVEDOWN", "MOVEUP")
```

# 활용 예시

플레이어의 공격에 상태가 변하는 나무 상자를 만들어봅시다. 기본 상태인 IDLE, DEAD와 크리에이터가 만든 새로운 BROKEN 상태를 함께 활용합니다. 상태마다의 특정 애니메이션, 스프라이트를 추가해 상태 변화를 직관적으로 확인할 수 있습니다. 이 예시는 IDLE → BROKEN → DEAD → IDLE로 상태 전이하며, 상태마다 다른 스프라이트, 애니메이션을 연결해 재생하게 됩니다.

![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16559702783894245b9b6f57f41bc80bea36df066edd1.gif)

> **Tip.** 만들기 - 새로 만들기 - **기본** 템플릿을 사용해 플레이어의 기본 공격, 피격을 구성합니다. 해당 템플릿의 DefaultPlayer에 ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) PlayerHit, ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png) PlayerAttack 컴포넌트가 있는지 확인합니다.

애니메이션, 스프라이트 RUID 목록

- IDLE: b871399ae18d41c4b76c2ae79feefa7d
- BROKEN: 76815f621e354f57b5adb5b9faaf9eb3
- 사과: 014e7c98ad374cf49e7bf7ea72844241

1. Workspace - MyDesk - Create Model을 눌러 **![Model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model_Box**를 생성합니다. TransformComponent, SpriteRendererComponent, StateComponent, HitComponent를 추가합니다. 상자 RUID(b871399ae18d41c4b76c2ae79feefa7d)를 SpriteRendererComponent의 SpriteRUID에 추가합니다. ![modelbox](https://mod-file.dn.nexoncdn.co.kr/bbs/165596740975009ece0c49b59481fa2b86a0d736f770d.png)
2. Workspace - MyDesk - Create Model을 눌러 **![Model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model_Apple**을 생성합니다. TransformComponent, SpriteRenderComponent를 추가합니다. 사과 RUID(014e7c98ad374cf49e7bf7ea72844241)를 SpriteRendererComponent의 SpriteRUID에 추가합니다. ![modelapple](https://mod-file.dn.nexoncdn.co.kr/bbs/16559673922967908df7d77a04ff2b354bcb7740742da.png)
3. MyDesk - Create Scripts - Create StateType를 눌러 **![StateType](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_state_type.png) BrokenBox**를 생성합니다. 새로운 BrokenBox에서 Broken 상태에 진입했을 때의 동작을 아래와 같이 작성합니다. `SpawnService:SpawnByModelId()`에서 불러올 모델의 ID는 Model_Apple입니다.```
Property:
boolean exitFlag = false
number timerId = 0

Method:
void OnEnter()
{
    self.exitFlag = false
    self.timerId = _TimerService:SetTimerOnce(function() self.exitFlag = true end, 1.1)

    local spriteRenderer = self.ParentComponent.Entity.SpriteRendererComponent
    spriteRenderer.SpriteRUID = "76815f621e354f57b5adb5b9faaf9eb3"  --BROKEN RUID

    _TimerService:SetTimerOnce(function() 
    	_SpawnService:SpawnByModelId("model://4ac51a4c-ecf6-4ddf-b32a-516fc66234be", "Item", self.ParentComponent.Entity.TransformComponent.Position + Vector3(0,0.12,0), self.ParentComponent.Entity.Parent) 
    end, 0.21) 

    -- Model_Apple's model ID
}
```
4. `OnConditionCheck()`에서 다음 상태로 넘어갈 때와 상태가 종료될 때를 아래와 같이 작성합니다.```
boolean OnConditionCheck(string nextStateName)
 {
     return self.exitFlag
 }

 void OnExit()
 {
     self.ParentComponent.Entity.SpriteRendererComponent.SpriteRUID = "b871399ae18d41c4b76c2ae79feefa7d" --IDLE RUID
     _TimerService:ClearTimer(self.timerId)
 }
```
5. 새로운 **ItemBoxComponent**를 생성하고, **![Model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model_Box**에 추가합니다. **BROKEN** 상태를 새롭게 추가하고, BROKEN에서 DEAD로 상태 전이를 추가합니다.```
Method:
[server only]
void OnBeginPlay()
{
    local state = self.Entity.StateComponent

    state:AddState("BROKEN", BrokenBox)
    state:AddCondition("BROKEN", "DEAD")
}
```
6. **ItemBoxComponent**에서 상태가 변경될 때 발생하는 StateChangeEvent를 활용해 상자가 재등장하는 타이밍과 상태 전이 시의 엔티티 변화를 아래와 같이 작성합니다.```
Event Handler:
[self]
HandleStateChangeEvent(StateChangeEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: StateComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    -- local CurrentStateName = event.CurrentStateName
    -- local PrevStateName = event.PrevStateName
    ---------------------------------------------------------

    -- There's no BROKEN state on client side of StateComponent.
    if self:IsServer() then
    	if CurrentStateName == "HIT" then
    		self.Entity.StateComponent:ChangeState("BROKEN")
    	elseif CurrentStateName == "DEAD" then
    		_TimerService:SetTimerOnce(function() self.Entity.StateComponent:ChangeState("IDLE") end, 5)
    	end
    else
    	if CurrentStateName == "IDLE" then
    		self.Entity.SpriteRendererComponent.Color.a = 1
    	end
    end
}
```
7. 애니메이션 재생이 끝난 후 보이지 않게 하고 싶다면 **ItemBoxComponent**에서 SpriteAnimPlayerEndEvent를 활용해 마지막 프레임을 투명하게 처리할 수 있습니다.```
[self]
HandleSpriteAnimPlayerEndFrameEvent(SpriteAnimPlayerEndFrameEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ClimbableSpriteRendererComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Sender: SpriteRendererComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local FrameIndex = event.FrameIndex
    -- local ReversePlaying = event.ReversePlaying
    -- local TotalFrameCount = event.TotalFrameCount
    -- local AnimPlayer = event.AnimPlayer
    ---------------------------------------------------------

    if TotalFrameCount > 1 then
    	self.Entity.SpriteRendererComponent.Color.a = 0 
    end
}
```

> **더 알아보기** 이 예제처럼 사과가 튀어 오르는 느낌을 주고 싶다면, Modle_Apple에 새로운 스크립트 컴포넌트를 추가하고, `TweenLogic:MakeTween()`을 활용해 보세요.

##### 참고 가이드

- [아바타 애니메이션 제어하기](/docs/?postId=545)

Update 2025-11-17 PM 08:14


# 플레이어 설정과 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

Player 모델에는 캐릭터의 초기 속성을 만들 때도 유용하게 사용하지만, 캐릭터를 이동시키거나, 상태를 제어할 때 유용하게 사용할 수 있습니다. PlayerComponent와 PlayerControllerComponent의 개념을 알아보고, 액션과 상태 애니메이션의 관계를 파악해 크리에이터의 의도에 따라 플레이어가 동작할 수 있게 만들어봅시다.

# PlayerComponent 개념

**PlayerComponent**는 다른 엔티티와 다르게 플레이어만이 가지고 있는 특성을 모아 놓은 컴포넌트입니다. 대표적으로 플레이어끼리 타격을 줄 수 있는 PVP 모드 기능이 있습니다. PlayerComponent의 함수는 플레이어를 제어하기 위해 사용합니다. 플레이어를 죽게 만들거나, 플레이어를 다른 맵 혹은 특정 지점으로 옮길 수 있습니다. Player 모델에 PlayerComponent가 포함되어 있지 않으면, 플레이어로 인식하지 못합니다. Player에게만 사용하는 컴포넌트인 특성을 활용해 Player를 식별할 때 PlayerComponent를 기준으로 삼을 수 있습니다. 예를 들어, PlayerComponent가 있는 엔티티를 특정 위치로 이동시키거나, 추가 조건을 붙여 죽음 상태로 만들 수 있습니다.

#### 주요 프로퍼티 소개

| 프로퍼티 | 설명 |
| --- | --- |
| MaxHp | Player의 최대 체력을 정할 수 있습니다. 기본 값은 1000입니다.<br> 이 값은 UI 상태 창 모델의 HP와 연동되어, 변경한 값이 UI 모델에 반영됩니다. |
| PVPMode | 활성화 시 플레이어끼리 타격을 줄 수 있습니다. |
| RespawnDuration | 플레이어가 죽은 후 다시 맵에 리스폰될 때까지 걸리는 시간을 정합니다. 기본값은 5초입니다. |
| Enable | 컴포넌트의 활성/비활성 상태를 설정할 수 있습니다. |
| Nickname | Player가 웹에서 정한 닉네임을 의미합니다. Player 모델에서 NameTagComponent가 있다면 플레이어의 닉네임이 보입니다.<br> 프로퍼티 에디터 창에서 노출되지 않으며, 스크립트 작성 시 활용할 수 있습니다. |
| RespawnPosition | 플레이어가 리스폰될 위치를 정할 수 있습니다. 위치를 지정하지 않은 경우, SpawnLocation의 위치, 맵 진입 시점의 위치를 순차적으로 따라 설정됩니다.<br> 프로퍼티 에디터 창에서 노출되지 않으며, 스크립트 작성 시 활용할 수 있습니다. |
| RespawnTime | 플레이어가 다시 맵에 진입하기까지 걸리는 시간을 의미합니다. 프로퍼티 에디터 창에서 노출되지 않으며, 스크립트 작성 시 활용할 수 있습니다. |
| UserId | 플레이어의 고유 식별자입니다. Client 실행제어 함수의 targetUserId 매개 변수에 사용할 수 있습니다. |

# PlayerControllerComponent 개념

**PlayerControllerComponent**는 입력에 따라 액션을 수행하고, 특정 조건을 처리합니다.예를 들어, 공격 키를 눌렀을 때 특정 애니메이션을 재생하는 액션을 연결하면 공격 키가 입력되었을 때마다 작동합니다. 그러나 사다리에 매달려 있을 때는 사다리에 매달린 애니메이션이 재생되는 중이므로 공격 애니메이션은 재생되지 않게 해야 오르는 동작이 어색하지 않습니다. 그러므로 사다리에 플레이어가 매달려 있을 때, '공격 키를 눌러도 공격 액션이 재생되지 않는다'란 조건을 추가할 수 있습니다.

기본 Player 모델에는 PlayerControllerComponent와 StateComponent 모두 기본으로 포함되어 있으나, 크리에이터의 필요에 따라 둘 중 하나를 지운다면 정상 동작하지 않습니다. PlayerControllerComponent가 StateComponent를 참조하고 있기 때문입니다. 그러므로 PlayerControllerComponent가 정상적으로 작동하기 위해선 Player 모델에 StateComponent가 함께 있어야 합니다.

> **Tip.** PlayerControllerComponent에서 입력, 액션, 조건을 처리했을 때 애니메이션 재생은 StateStringToAvatarActionComponent에서 처리하게 됩니다. 유저가 키를 눌러 어떤 'Input'이 발생하면, PlayerControllerComponent가 이를 감지하고 맞는 State로 변경하며 Action을 처리합니다. 이후 StateComponent가 State 변경과 동작을 처리하며, StateChangeEvent를 발생시킵니다. AvatarRendererCompoent와 같은 애니메이션 관련 컴포넌트가 이 이벤트를 받아 애니메이션을 재생시키게 됩니다.

#### 프로퍼티 소개

| 프로퍼티 | 설명 |
| --- | --- |
| AlwaysMovingState | 활성화 시 이동 애니메이션이 가만히 있더라도 계속 재생됩니다. |
| FixedLookAt | 값을 변경하면 캐릭터가 방향을 바꾸어도, 캐릭터의 이동 모습은 바뀌지 않습니다.<br> 한 방향만 바라보게 만들 수 있습니다. |
| LookDirectionX | 양수로 값을 변경하면, 캐릭터가 오른쪽을 바라본 상태가 기본이 됩니다. |
| Enable | 컴포넌트의 활성/비활성 상태를 설정할 수 있습니다. |

#### 기본 조작 key, value

메이플스토리 월드에서 기본으로 설정되어 있는 이동과 행동 키입니다. 특별한 조작을 부여하고 싶지 않다면 해당 키를 그대로 사용하면 되고, 특별한 키가 필요할 경우 추가할 수 있습니다.

| key | value |
| --- | --- |
| W, UpArrow | MoveUp |
| A, DownArrow | MoveLeft |
| S, LeftArrow | MoveDown |
| D, RightArrow | MoveRight |
| Space | Jump |
| LeftAlt | Jump2 |
| LeftControl | Attack |
| C | Sit |

> **Tip.** LeftAlt는 Jump로 통합 예정입니다. 제작에 참고해주세요.

# 활용 예시

#### 정해진 시간이 지나면 다른 맵으로 이동시키기

`MoveToMapPosition()`를 이용해 플레이어를 특정 위치로 이동시킬 수 있습니다. 이 기능을 활용해 여러 맵으로 모든 유저를 한 번에 옮겨 새로운 맵에서 새로운 게임을 할 수 있게 합니다.

1. ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png)**MyDesk**에 새로운 PlayerManagement 컴포넌트를 생성하고, ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다.
2. `TimerService`를 이용해 10초를 셀 수 있게 만들고, 10초 뒤 이동할 map의 이름과 그 맵의 위치를 입력합니다. 맵의 이름은 Hierarchy의 이름과 동일해야 합니다.

> **더 알아보기** `TeleportService:TeleportToEntityPath()` 모든 Entity를 옮길 수 있지만, `PlayerComponent:MoveToMapPosition()`는 플레이어에만 활용 가능합니다.

```
Method:
[server only]
void OnBeginPlay()
{
    _TimerService:SetTimerOnce(function()
        for userId, userEntity in pairs(_UserService.UserEntities) do
            userEntity.PlayerComponent:MoveToMapPosition('map02',Vector2(2,2)) 
        end
    end, 10)
 }
```

![MoveToMapPosition](https://mod-file.dn.nexoncdn.co.kr/bbs/1656586279970675fa3b0db73418d92fccc5d03da1a6e.gif)

#### 죽은 자리에서 리스폰 시키기

Player의 리스폰 지점은 SpawnLocation와 맵 진입 시의 위치를 따르지만, 크리에이터가 임의로 플레이 중 죽은 위치에서 바로 리스폰 시킬 수 있습니다.

1. ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png)**MyDesk**에 새로운 PlayerSetting 컴포넌트를 생성하고, ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다.
2. `ConnectEvent`를 이용해 죽었을 때의 위치를 가져와 리스폰 위치로 정합니다.

```
Method:
[client only]
void OnBeginPlay()
{
    self.Entity:ConnectEvent(DeadEvent, function()
        self.Entity.PlayerComponent.RespawnPosition = self.Entity.TransformComponent.Position
    end)
}
```

![RespawnPosition](https://mod-file.dn.nexoncdn.co.kr/bbs/16565863334284c08832fec434f4789427b1b5a33d6ef.gif)

#### 플레이어만 특정 지점으로 옮기기

수많은 엔티티 중 PlayerComponent가 있는 엔티티를 플레이어로 인식해, 특정 지점으로 이동시킬 수 있습니다. 특정 엔티티에 붙은 TriggerComponent가 PlayerComponent를 인식할 수 있게 만듭니다. 이 엔티티는 플레이어만 알아차릴 수 있기 때문에 같은 공간에서 똑같이 움직이는 몬스터 같은 엔티티는 이동시킬 수 없습니다.

1. 플레이어가 부딪칠 수 있는 엔티티를 맵에 배치하고 이름을 **MagicStone**으로 변경한 뒤 TriggerComponent를 추가합니다.
2. 도착지는 특정 엔티티의 경로로 지정하기 위해 맵에 포탈 오브젝트를 추가합니다.
3. ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png)**MyDesk**에 새로운 PlayerMangement 컴포넌트를 생성하고, ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다.
4. 특정 엔티티에 충돌한 엔티티에 PlayerComponent가 있다면, **입력한 경로('maps/map01/portal-3')**로 플레이어를 이동시킵니다.

```
Method:
[server only]
void OnBeginPlay()
{
     local MagicStone = _EntityService:GetEntityByPath('/maps/map01/MagicStone') -- 플레이어와 부딪힐 엔티티의 경로를 입력합니다. 
     MagicStone:ConnectEvent(TriggerEnterEvent, function(event)
        if event.TriggerBodyEntity.PlayerComponent then
            event.TriggerBodyEntity.PlayerComponent:MoveToEntityByPath('/maps/map01/portal-3')
        end
     end)
}
```

![moveentity](https://mod-file.dn.nexoncdn.co.kr/bbs/1656586368440e1c78d968dba467b9b2d5cca978b4996.gif)

#### 특정 조건을 만들어 액션 제한하기

플레이어의 기본 속성에 발동할 수 있게 하는 조건을 추가할 수 있습니다. `AddCondition()` 함수를 사용해 플레이어의 행동을 제약하기 위한 조건을 추가할 수 있습니다. 기본적으로 사용 가능한 공격, 점프 등을 일시적으로 특정 조건을 만족할 때 기능 발동을 제한하거나, 추가 발동 조건을 추가해 색다른 재미를 선사할 수 있습니다.

1. ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png)**MyDesk**에 PlayerSetting 컴포넌트를 생성하고, ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다.
2. Jump 액션이 실행되는 조건을 작성합니다. 10 이상은 Jump가 실행되게 작성하면 반대 조건 또한 성립합니다.
3. space bar를 눌러 점프를 했음에도 점프 동작이 재생되지 않는 것을 확인할 수 있게 log를 추가합니다.

```
Method:
[client only]
void OnBeginPlay()
{
    local playerController = self.Entity.PlayerControllerComponent
    playerController:AddCondition("Jump", function()
        if self.Entity.PlayerComponent.Hp < 10 then
            log("Stop Jumping")
            return false
        end
        return true
    end
}
```

![stopjumping](https://mod-file.dn.nexoncdn.co.kr/bbs/1656586397424b751fb67c7974fe694521961c9a7ecab.gif)

#### 기존 조작키 삭제, 새로운 키 만들기

크리에이터의 기획에 맞게 기존의 키를 삭제하고, 새로운 키로 대체할 수 있습니다. 이 기능을 사용해 W, A, S, D 키 이동을 삭제하고, 새로운 키로 만들 수 있습니다.

1. ![workspace_UserFolder](https://mod-file.dn.nexoncdn.co.kr/bbs/1634600723422190820861d63456fa40e21031bd5ffa2.png)**MyDesk**에 PlayerSetting 컴포넌트를 생성하고, ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다.
2. `RemoveActionKey`를 이용해 왼쪽 Ctrl 키에 연결된 액션을 삭제하고, `SetActionKey`를 이용해 **F 키에 Attack**을 연결하는 스크립트를 작성합니다.

```
Method:
[client only]
void OnBeginPlay()
{
    local playerController = self.Entity.PlayerControllerComponent
    playerController:RemoveActionKey(KeyboardKey.LeftControl)
    playerController:SetActionKey(KeyboardKey.F, "Attack")
}
```

##### 참고 가이드

- [캐릭터 초기 속성 편집](/docs?postId=48)
- [공격과 피격](/docs?postId=206)

Update 2025-11-17 PM 08:14


# 행동 트리를 활용한 AI 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

행동 트리와 BTNodeType 개념을 이해하고, AIComponent를 활용해 Action Node를 생성하는 방법을 알아봅시다. [행동 트리 노드 만들기](/docs?postId=1155)에서 행동 트리 구현 방법과 예제를 소개합니다.

##### 참고 가이드

- [행동 트리 노드 만들기](/docs?postId=1155)

##### 참고 API Reference

- [BTNode](/apiReference?postId=455)
- [AIComponent](/apiReference?postId=361)
- [ParallelNode](/apiReference?postId=456)
- [RandomSelectorNode](/apiReference?postId=457)
- [SelectorNode](/apiReference?postId=458)
- [SequenceNode](/apiReference?postId=459)

# 개념 이해하기

### 유한 상태 기계

**유한 상태 기계** (Finite State Machine, FSM)은 특정 조건과 상황에 따라 유한개의 상태 중 하나의 상태로 전환되거나 해당 상태에 따른 액션을 수행하는 모델입니다. FSM은 상대적으로 쉽게 구성할 수 있고 직관적으로 설계할 수 있습니다. 주로 AI 설계를 위해 사용합니다. FSM은 **상태**(State)와 **전이**(Transition)로 구성되어 있습니다. 상태에 대한 액션 수행 중 특정 조건 만족 시 다음 상태로 전이됩니다. 예를 들어 몬스터가 대기 상태일 때, 플레이어가 몬스터에 접근하면 몬스터가 공격 상태로 변경되어 플레이어를 공격하게 됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168764448031671b4e8e02a4b5cb6a933c7a246c29d.png)

그러나 상태와 액션이 다양해지고 복잡해질수록 각 상태의 연결과 유지 보수 부담이 커집니다. 또한 규모가 커질수록 상태의 흐름을 파악하기 어려울 뿐 아니라 상태의 흐름을 재사용할 수 없습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/171687700691298cc5dc178a644d7863dd656f705c7f6.png)

### 계층적 유한 상태 기계

**계층적 유한 상태 기계**(Hierarchical Finite State Machines, HFSM)는 FMS 단점을 보완하기 위해 여러 개의 상태와 전이를 모듈화한 개념입니다. HFSM은 상태 변화의 흐름을 모듈화해 재사용할 수 있고 현재 상태가 어디서부터 진행되었는지 쉽게 파악할 수 있습니다. 그러나 개별 상태의 재사용이 어려운 단점이 있습니다. 각 하위 상태는 특정 상태에서부터 전이되어야 한다는 조건으로 인하여 다른 그룹에서 개별 상태로 접근을 할 수 없습니다. 예를 들어 'HIT' 상태일 때, 'HIT'은 'IDLE' 상태의 하위일 수도 있고 'BATTLE' 상태의 하위일 수도 있습니다. 그러므로 'IDLE' 상태와 'BATTLE' 상태 하위의 'HIT' 상태를 각각 추가해야 합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168770274270c242d640e824e7a8de6e55f9e475212.png)

### 행동 트리

**행동 트리**(Behaviour Tree, BT)는 노드라 불리는 개별 단위의 집합입니다. 상태와 전이로 구성된 유한 기계 상태와 달리 행동 트리의 각 노드는 개별 로직으로 모듈화되어 있습니다. 상황과 목적에 따라 재사용이 가능합니다. 또한 각 노드가 결합 순서에 따라 순차적으로 실행되기 때문에 특정 행동의 연결과 해제가 용이합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168770533307c70cdaacf4741df8155b0d942229b73.png)

# 행동 트리 작동 원리

행동 트리는 프레임마다 Root 노드에서 시작합니다. 그 후 순차적으로 실행됩니다. 실행 순서는 위에서 아래, 왼쪽에서 오른쪽입니다. 부모 노드가 자식 노드를 실행하며 실행 순서는 각 부모에 등록된 순서대로 실행됩니다. 부모 노드는 종류에 따라 자식 노드 실행 조건을 달리하며, 조건에 부합할 때 부모가 가진 자식 노드를 모두 순차적으로 실행합니다. 예를 들어 부모 노드에 자식 노드 A, B, C가 순차적으로 등록된 경우 A가 가장 좌측에, 노드 C가 가장 우측에 배치됩니다. 부모 노드 실행 시 자식 노드는 A, B, C 순으로 실행됩니다. 이때 자식 노드 A가 자식 노드 D, F를 갖고 있다면 A의 자식 노드 D, F를 모두 실행한 후 노드 B가 실행됩니다.

모든 노드는 실행 시 상태 값인 [**BehaviourTreeStatus**](/apiReference/Enums/BehaviourTreeStatus)를 반환합니다. 반환하는 값은 총 세 가지로 **Running, Success, Failure**입니다. 각 부모 노드는 자식 노드가 반환하는 값에 따라 다음 자식 노드를 실행할지 결정합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/171774458675144ffe3ccb3334751afda1dcf151b5387.png)

# 행동 트리 노드 알아보기

행동 트리는 행동을 정의하는 **Action Node**와 행동의 흐름을 제어하는 **Composite Node**로 구성됩니다. Action Node는 BTNodeType을 활용해 크리에이터가 직접 만들어 사용해야 하며, Composite Node는 메이플스토리 월드에서 제공하고 있습니다.

## Action Node

**Action Node**는 엔티티의 행동을 정의합니다. Leaf Node로도 불리며, 자식 노드를 갖지 않는 특징이 있습니다. Action Node는 엔티티의 실질적인 행동 또는 행동의 조건 등을 정의합니다. 각 행동과 조건은 별도의 Action 노드로 정의하며, 각 노드는 Composite의 자식 노드로 등록합니다. 예를 들어 몬스터가 '대기' 상태에 있을 때, '공격' 상태에 있을 때의 행동을 정의할 수 있습니다.

## Composite Node

**Composite Node**는 흐름을 제어하는 노드로 여러 개의 자식 노드를 가질 수 있습니다. 자식 노드가 Success 또는 Failure를 반환하면 일정한 규칙에 따라 다음 자식 노드의 실행 여부를 결정합니다. Composite Node는 4가지 종류가 있으며, 노드마다 자식 노드 실행 방법, 상태 값을 부모로 반환하는 규칙이 다릅니다.

- **Sequence Node, Selector Node, Random Selector Node, Parallel Node**

#### Sequence Node

**Sequence Node**는 자식 노드를 순서대로 실행하다가 자식 노드가 Failure를 반환하면 실행을 멈추고 부모 노드에 Failure를 반환합니다. 모든 자식 노드가 Success를 반환하면 부모 노드에 Success를 반환합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1719214998441707cc625005241ec8bef19f44d51277a.png)

#### Selector Node

**Selector Node**는 자식 노드를 순서대로 실행하다가 자식 노드가 Success를 반환하면 실행을 멈추고 부모 노드로 Success를 반환합니다. 모든 자식 노드가 Failure를 반환하면 부모 노드에 Failure를 반환합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168858785873218b87041fd46df9756a267a30ce29e.png)

#### RandomSelector Node

**RandomSelector Node**는 자식 노드 중 하나를 무작위로 선택해 실행합니다. 자식 노드가 Success를 반환하면 Success를, Failure를 반환하면 Failure를 부모 노드에 반환합니다. RandomSelector Node는 난수를 뽑아 해당 난수가 속한 범위의 확률을 가진 노드를 선택합니다. 예를 들어 아래 그림과 같이 RandomSelector Node에 자식 노드의 선택될 확률이 0.2(20%), 0.3(30%), 0.5(50%)일 때, 난수가 0.4로 결정되면 Action2 노드가 실행되고 0.9로 결정되면 Action3 노드가 실행됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17192150545723d6a5611d3c24cf5b75b12d37935a549.png)

#### Parallel Node

**Parallel Node**는 모든 자식 노드를 실행해 모든 자식 노드가 Success를 반환한 경우 Success를 부모 노드에 반환합니다. 반면 자식 노드 중 하나라도 Failure를 반환한 경우 Failure를 부모 노드에 반환합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/171774512352277dc3a613298479ab8ac9fb4f430a259.png)

## Decorator Node

**Decorator Node**는 하나의 자식을 가지며, 자식을 실행할지 말지 결정하거나 반환 값을 가공할 수 있습니다. Composite Node, Action Node를 자식으로 가질 수 있습니다. 메이플스토리 월드는 크리에이터가 Decorator Node를 제작할 수 있도록 제공하고 있습니다. Decorator Node는 부모 노드와 자식 노드 A의 중간에서 위치하며, 조건에 따라 노드 A를 실행할지 여부를 결정합니다. 또한 A 노드가 반환한 값 대신 다른 값을 부모에게 전달할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17177451607950c32f6a27e8d4ffd8c5c67eb1aeefb69.png)

# 여러 프레임 동안 동작하는 노드

자식 노드가 Success 또는 Failure를 반환하면 부모 노드는 다음 자식 노드를 실행합니다. 그러나 자식 노드가 Running을 반환하면 부모 노드는 Running을 반환했던 자식 노드를 다음 프레임에 다시 실행합니다. 이 특성을 활용해 여러 프레임 동안 동작하는 노드를 만들 수 있습니다. 아래 그림과 같이 자식 노드 A, B, C가 있을 때 Sequence Node와 Selector Node의 경우 B 노드가 Running을 반환하는 동안 C 노드를 실행하지 않습니다. RandomSelector Node는 선택된 노드를 계속 실행합니다. Parallel Node는 자식 노드를 동시에 실행하는 특징으로 인해 노드 A, B, C 모두 실행하고, 다음 프레임에서는 노드 중 Running을 반환했던 노드 A, B만 실행되고 노드 C는 실행되지 않습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1716887214774390c0a3ef79d41519e77b73dcc166b9b.png)![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1716887242595459c3c005ce24bdfab35c3742a2d36a1.png)

노드의 특성을 활용해 일정 시간 동안 대기하는 Wait 노드를 아래와 같이 만들 수 있습니다.

```
Property:
[None]
number Time = 2
[None]
number ElapsedTime = 0
 
Method:
void OnInit()
{
    -- Running을 반환하는 동안 OnInit()이 호출되지 않습니다.     

    self.ElapsedTime = 0
}
 
any OnBehave(number delta)
{
    -- Time만큼 시간이 흐를 때까지 Running을 계속 반환해 다음 자식 노드가 실행되지 않게 합니다.
    -- Running을 반환하는 동안 OnBehave()가 계속 호출됩니다.

    self.ElapsedTime += delta
    if self.ElapsedTime < self.Time then
        return BehaviourTreeStatus.Running
    end

    return BehaviourTreeStatus.Success
}
```

# Action Node의 생성과 기능 정의

메이플스토리 월드에서는 BTNodeType을 활용해 Action Node를 만들 수 있습니다. BTNodeType에 노드의 행동을 정의하고 AIComponent로 노드 객체를 생성하여 사용할 수 있습니다.

## BTNodeType에 정의하기

BTNodeType은 기본 이벤트 함수로 `OnInit()`과 `OnBehave()`를 제공합니다. 기본 이벤트 함수에 노드의 행동을 정의합니다.

#### OnInit()

`OnInit()`는 `OnBehave()`호출 전에 실행되는 함수입니다. 노드가 실행될 때마다 호출되지만, **Running**을 반환한 경우 다음 프레임에서는 `OnInit()`가 호출되지 않습니다.

#### OnBehave()

`OnBehave()`는 해당 Action 노드가 실행될 때마다 1회씩 호출되는 메소드로 **BehaviourTreeStatus** 값을 반드시 반환해야 합니다. AI의 행동이나 행동의 조건을 정의할 때 사용하는 메소드이므로 Action 노드 타입에 반드시 추가해야 합니다. 매개 변수 프레임 당 시간인 **delta**를 활용해 이동이나 시간 측정과 같은 기능을 구현할 때 활용할 수 있습니다.

```
Property : 
[Sync]
number Num = 0

Method: 
void OnBehave(number delta)
{
	self.Num = self.Num + delta
	
	if self.Num >= 3 then
		self.Num
		return BehaviourTreeStatus.Success
	else	
		return BehaviourTreeStatus.Running
	end
}
```

## Action Node 생성하기

AI로 사용할 엔티티에는 **AIComponent 또는 확장한 AIComponent**가 포함되어 있어야 합니다. AIComponent는 BTNodeType에서 정의된 내용으로 Action Node를 별도의 객체로 생성하거나, 만들어진 행동 트리의 최상위 노드를 Root 노드로 설정하여 엔티티에 AI를 부여하기 때문입니다. Action Node를 만들 때는 AIComponent의 `CreateNode()`, `CreateLeafNode()`를 활용해 Action Node를 생성할 수 있습니다.

#### CreateNode()

**BTNodeType**으로 노드 객체를 생성할 때는 **AIComponent**의 `CreateNode()` 함수를 활용합니다. 매개 변수로 생성될 BTNodeType과 이름을 전달합니다.

```
local node = self.Entity.AIComponent:CreateNode("NewBTNode", "actionNode")
```

#### CreateLeafNode()

간단한 Action Node를 만들고 싶을 때는 아래와 같이 직접 함수를 전달하는 방법으로 노드의 행동을 정의할 수 있습니다. `CreateLeafNode()`는 `CreateNode()`와 달리 BTNodeType이 필요하지 않습니다. 매개 변수로 객체로 생성될 노드의 이름, 노드 실행 시 호출될 함수를 전달합니다.

```
local func = function() 
    log("ActionNode!") 
    return BehaviourTreeStatus.Success
end

local printLogNode = self.Entity.AIComponent:CreateLeafNode("NodeInstanceName", func)
```

Update 2025-11-17 PM 08:14


# 행동 트리 노드 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

행동 트리를 만드는 데 사용하는 노드에 대해 알아보고, 직접 예제를 따라하며 행동 트리에 따라 움직이는 AI 몬스터를 만들어 봅시다.

##### 참고 가이드

- [행동 트리를 활용한 AI 만들기](/docs?postId=562)

##### 참고 API Reference

- [BTNode](/apiReference?postId=455)
- [AIComponent](/apiReference?postId=361)
- [ParallelNode](/apiReference?postId=456)
- [RandomSelectorNode](/apiReference?postId=457)
- [SelectorNode](/apiReference?postId=458)
- [SequenceNode](/apiReference?postId=459)

# 행동 트리 만들기

#### Composite Node 생성

Composite Node 객체는 각 노드의 생성자를 통해 생성할 수 있습니다. Composite Node의 생성자는 다음과 같습니다.

| Node | Constructor |
| --- | --- |
| Sequence | SequenceNode(string name = "SequenceNode") |
| Selector | SelectorNode(string name = "SelectorNode") |
| RandomSelector | RandomSelectorNode(string name = "RandomSelectorNode") |
| Parallel | ParallelNode(string name = "ParallelNode") |

```
[server only]
void OnBeginPlay()
{
	local seqNode = SequenceNode("sq")
	local selNode = Selector("sel")
	local randomNode = RandomSelector("rand")
	local prNode = Parallel("pr")
}
```

#### AttachChild()

Composite Node는 자식 노드를 가질 수 있습니다. 자식 노드를 만들 때는 `AttachChild()`를 활용합니다. Composite Node는 Action Node, Composite Node도 자식으로 가질 수 있으며 이를 이용해 복잡한 트리 구조를 형성할 수 있습니다.

#### AttachChildAt()

트리 구조는 자식 노드를 실행할 때 자식 노드로 등록된 순서를 따르므로 등록 순서를 유의해야 합니다. 노드의 실행 순서를 변경 방법은 두 가지입니다. 첫 번째로 코드상에서 순서를 변경합니다. 두 번째로 `AttachChildAt()` 함수를 활용합니다.

`AttachChildAt()`는 등록 순서와 관계없이 특정 위치에 노드를 등록할 수 있습니다. `AttachChildAt()` 함수의 기본 사용 방식은 `AttachChild()`와 동일합니다. 차이점은 두 번째 매개 변수로 노드가 위치할 순서를 넘겨주는 것입니다. 순서는 0부터 시작하며, 이미 등록된 노드와 같은 위치에 새 노드를 등록하면 기존 노드의 위치가 하나씩 뒤로 밀려납니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168956058276319a1ddbdab49bdb2588b236c875a84.png)

```
[server only]
void OnBeginPlay()
{
	--CREATE NODE
	local sequence = SequenceNode("sq")
	local actionA = self:CreateNode("ActionA")
	local actionB = self:CreateNode("ActionB")
	local actionC = self:CreateNode("ActionC")
	local actionD = self:CreateNode("ActionD")
	
	--SET TREE
	sequence:AttachChild(actionA)
	sequence:AttachChild(actionB)
	sequence:AttachChild(actionC)
	sequence:AttachChildAt(actionD,1)
}
```

#### Node 제거하기

이미 등록된 자식 노드를 제거할 때는 `DetachChild()`, `DetachChildAt()`를 활용합니다.

- `DetachChild()`는 매개 변수로 떼어낼 자식 노드 객체를 넘겨 자식 노드를 제거합니다.
- `DetachChildAt()`은 떼어낼 자식 노드 객체의 위치를 넘겨 자식 노드를 제거합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168956211348925ff93ffd347379cb977b79e710f7c.png)

```
[server only]
void OnBeginPlay()
{
	--CREATE NODE
	local sequence = SequenceNode("sq")
	local actionA = self:CreateNode("ActionA")
	local actionB = self:CreateNode("ActionB")
	local actionC = self:CreateNode("ActionC")
	
	--SET TREE
	sequence:AttachChild(actionA)
	sequence:AttachChild(actionB)
	sequence:AttachChild(actionC)
	
	--DETACH NODE
	sequence:DetachChildAt(1)
	sequence:DetachChild(actionC)
}
```

#### Root Node 설정

**Root Node**는 `SetRootNode()`를 사용합니다. 매개 변수로 Root 노드가 노드를 최상위 노드로 넘겨줍니다. 최상위 노드를 Root 노드로 설정함으로써 엔티티에 AI를 부여하고 행동 트리를 작동시킬 수 있습니다.

```
[server only]
void OnBeginPlay()
{
	--CREATE NODE
	local sequence = SequenceNode("sq")
	local actionA = self:CreateNode("ActionA")
	local actionB = self:CreateNode("ActionB")
	local actionC = self:CreateNode("ActionC")
	
	--SET TREE
	sequence:AttachChild(actionA)
	sequence:AttachChild(actionB)
	sequence:AttachChild(actionC)
	
	--SET ROOT NODE
	self:SetRootNode(sequence)
}
```

#### Decorator Node 생성

Decorator Node는 BTNodeType을 활용해 생성할 수 있습니다. 새 BTNodeType을 생성하고, 프로퍼티로 any 타입의 **Child** 또는 **child**를 추가해 Decorator Node로 만들 수 있습니다. 자식 노드를 실행하고 싶을 때는 `Behave()` 함수를 호출합니다.

```
Property: 
[None]
any Child = nil

Method: 
any OnBehave(number delta)
{
	if self.Child == nil then
		return BehaviourTreeStatus.Failure
	end
	
	local result = self.Child:Behave(delta)
	
	if result == BehaviourTreeStatus.Success then
		return BehaviourTreeStatus.Failure
	
	elseif result == BehaviourTreeStatus.Failure then
		return BehaviourTreeStatus.Running
	else
		return BehaviourTreeStatus.Success
	end
}
```

생성된 Decorator BTNodeType의 객체 노드 생성과 자식 노드 할당은 아래와 같이 할 수 있습니다.

```
[server only]
void OnBeginPlay()
{
	local aiComponent = self.Entity.AIComponent
	
	local childNode = aiComponent:CreateLeafNode("childNode", function(delta) return BehaviourTreeStatus.Success end)
	local decorator = self:CreateNode("Decorator")
	decorator.Child = childNode
}
```

#### 행동 트리 완성

Root Node 설정까지 마치면, 만든 행동 트리를 기반으로 AIComponent가 동작합니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1645011460737db32f055d8984de6a762c4129e12207c.png)

```
[server only]
void OnBeginPlay()
{
	--CREATE COMPOSITE NODE
	local sequence = SequenceNode("Sequence")
	local sequenceA = SequenceNode("SequenceA")
	local sequenceB = SequenceNode("SequenceB")
	local sequenceC = SequenceNode("SequenceC")
	local selectorA = SelectorNode("SelectorA")
	local randomSelectorA = RandomSelectorNode("RandomSelectorA")
	local parallelA = ParallelNode("ParallelA")
	local parallelB = ParallelNode("ParallelB")
		
	--CREATE ACTION NODE
	local actionA1 = self:CreateNode("ActionA", "ActionA1")
	local actionA2 = self:CreateNode("ActionA", "ActionA2")
	local actionB1 = self:CreateNode("ActionB", "ActionB1")
	local actionB2 = self:CreateNode("ActionB", "ActionB2")
	local actionC1 = self:CreateNode("ActionC", "ActionC1")
	local actionC2 = self:CreateNode("ActionC", "ActionC2")
	local actionD1 = self:CreateNode("ActionD", "ActionD1")
	local actionD2 = self:CreateNode("ActionD", "ActionD2")
	local actionE = self:CreateNode("ActionE", "ActionE")
	local actionF = self:CreateNode("ActionF", "ActionF")
	local actionG = self:CreateNode("ActionG", "ActionG")
	
	--SET TREE
	sequence:AttachChild(sequenceA)
	sequence:AttachChild(parallelA)
	sequenceA:AttachChild(randomSelectorA)
	sequenceA:AttachChild(actionA1)
	parallelA:AttachChild(sequenceB)
	parallelA:AttachChild(actionB1)
	parallelA:AttachChild(selectorA)
	randomSelectorA:AttachChild(sequenceC)
	randomSelectorA:AttachChild(actionA2)
	sequenceB:AttachChild(actionB2)
	sequenceB:AttachChild(actionC1)
	selectorA:AttachChild(parallelB)
	selectorA:AttachChild(actionD1)
	sequenceC:AttachChild(actionC2)
	sequenceC:AttachChild(actionD2)
	parallelB:AttachChild(actionE)
	parallelB:AttachChild(actionF)
	parallelB:AttachChild(actionG)
}
```

# 행동 트리 활용 예제

AIComponent와 BTNodeType을 활용해 일정 범위 내에서 플레이어를 감지하고, 배회하는 AI 몬스터를 만들어 봅시다. 이 예제의 주요 구현 요소는 세 가지입니다.

- 플레이어가 멀리 있을 때 몬스터는 무작위 방향으로 이동하며 배회합니다.
- 일정 거리 안으로 플레이어가 들어오면 몬스터는 플레이어를 추적합니다.
- 플레이어가 멀어지면 몬스터는 추적을 그만두고 다시 주위를 배회합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17168958937950674e59a9a8744ca81444187e01c8e85.png)

## 사전 준비

1. **RectTile** 모드로 전환하고, 타일을 배치합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1717483867395248704741b464dfa9bbf21b93f26f45e.png)
2. **Workspace - MyDesk - Create Material**을 선택해 새로운 Alert 머티리얼을 추가합니다.
  - Shader: Rainbow
  - Blend: 0.5
  - Rotate: 0
  - Spread: 0.25
  - TimeOffset: 0
  - TimeScale: 1![Material](https://mod-file.dn.nexoncdn.co.kr/bbs/1717483885157c4309e9ef2e34691a871092dd75b1906.png)
3. **Preset List - Monster - monster2358** 프리셋을 추가합니다. 프리셋의 컴포넌트 중 TransformComponent, StateAnimationComponent, SpriteRendererComponent만 남겨 놓은 뒤 아래 3개 컴포넌트를 추가합니다.
  - StateComponent, MovementComponent, KinematicbodyComponent

![monster](https://mod-file.dn.nexoncdn.co.kr/bbs/17174839092271a14772637854b71abaf190445ea359b.png)

## AIPatrolComponent 만들기

1. **Workspace - BaseEnvironment - NativeScripts - Component - AIComponent**를 선택해 Extend합니다. 이름을 **AIPatrolComponent**로 변경합니다.
2. 맵에 배치한 몬스터에 AIPatrolComponent를 추가합니다. ![AIPatrolComponent](https://mod-file.dn.nexoncdn.co.kr/bbs/1717488266930702706135fff47409f16850ee919f377.png)
3. `DrawRange()` 함수를 추가합니다. **PolygonRendererComponent**를 활용해 몬스터가 플레이어를 감지할 수 있는 범위를 보여줄 수 있도록 아래와 같이 작성합니다.```
Property:
[None]
number DetectionRange = 5

Method:
[server only]
void DrawRange()
{
    ---@type PolygonRendererComponent
    local polygon = self.Entity:AddComponent("PolygonRendererComponent")
    polygon.Color = Color(0, 1, 0, 0.25)

    local res = 24
    local radius = self.DetectionRange
    for i = 1, res do
        local rad = 2 * math.pi * (i / tonumber(res))
        local x = math.cos(rad) * radius
        local y = math.sin(rad) * radius
        polygon.Points:Add(Vector2(x, y))
    end
}
```
4. `Flip()` 함수를 생성합니다. 몬스터의 이동 방향에 따라 몬스터의 스프라이트를 좌우 반전할 수 있도록 아래와 같이 작성합니다.```
[server only]
void Flip()
{
    local kb = self.Entity.KinematicbodyComponent
    local sprite = self.Entity.SpriteRendererComponent

    if kb.MoveVelocity:Magnitude() > 0 then
        if kb.MoveVelocity.x < 0 then
            sprite.FlipX = false
        else
            sprite.FlipX = true
        end
    end
}
```
5. `DetectPlayer()` 함수를 생성하고, 플레이어와의 거리를 감지할 수 있도록 아래와 같이 작성합니다. 플레이어와의 거리가 Range 이하면 플레이어 엔티티를 메모리에 기록하고, 거리가 Range 이상이면 플레이어 엔티티를 메모리에서 제거합니다. 감지한 플레이어는 **ActionFollow, DecoHasTarget, DecoHasNoTarget**에서 사용합니다.```
[server only]
void DetectPlayer()
{
    local target = nil
    local minDist = self.DetectionRange
    local myPos = self.Entity.TransformComponent.WorldPosition:ToVector2()

    local users = _UserService.UserEntities
    for userId, user in pairs(users) do
        local userPos = user.TransformComponent.WorldPosition:ToVector2()
        local dist = userPos:Distance(myPos)
        if dist < minDist then
            target = user
            minDist = dist
            break
        end
    end

    if target == nil then
        self:SetMemory("PlayerInRange", nil)
    else
        self:SetMemory("PlayerInRange", target)
    end
}
```
6. `OnUpdate`를 추가하고, `DetectPlayer()`, `Flip()` 함수를 호출하도록 아래와 같이 작성합니다.```
void OnUpdate(number delta)
{
    self:DetectPlayer()
    self:Flip()
}
```
7. `OnBeginPlay`를 추가하고, `DrawRange()` 함수를 호출하도록 아래와 같이 작성합니다.```
void OnBeginPlay()
{
    self:DrawRange()
}
```
8. `Memory` 프로퍼티를 추가합니다.```
Property:
[None]
table Memory = {}
```
9. `SetMemory()` 함수를 생성하고 value를 key에 저장하도록 아래와 같이 작성합니다.```
[server only]
void SetMemory(string key, any value)
{
    self.Memory[key] = value
}
```
10. `GetMemory()`를 생성하고, key에 저장된 value를 얻도록 아래와 같이 작성합니다.```
[server only]
any GetMemory(string key)
{
    return self.Memory[key]
}
```

## BTNodeType 만들기

BTNodeType을 활용해 아래의 트리 구조를 만들어 봅시다. 예제에서 만들 BTNodeType은 총 8개입니다. 이 노드들이 서로 동작하며 맵에서 움직이고, 플레이어를 추적하게 됩니다.

1. **Workspace - MyDesk - Create Scripts - BTNodeType**을 선택해 새로운 8개의 BTNodeType을 만듭니다. 8개의 BTNodeType은 아래와 같이 각기 다른 역할을 합니다.

| 노드 | 설명 |
| --- | --- |
| ActionChangeStateAlert | 몬스터의 머티리얼을 변경합니다. 감지 범위는 빨간색으로 변경됩니다. |
| ActionChangeStateCalm | 몬스터의 머티리얼을 원래대로 되돌립니다. 감지 범위를 나타내는 원의 색상을 초록색으로 변경합니다. |
| ActionFollow | 플레이어를 추적합니다. |
| ActionMoveRandom | 무작위 방향으로 이동합니다. |
| ActionStop | 정지합니다. |
| ActionWait | 일정 시간 동안 대기합니다. |
| DecoHasNoTarget | 감지된 플레이어가 없으면 자식 노드를 실행하고, 있으면 Failure를 반환하는 Decorator입니다. |
| DecoHasTarget | 감지된 플레이어가 있으면 자식 노드를 실행하고, 없으면 Failure를 반환하는 Decorator입니다. |

#### ActionChangeStateAlert

**ActionChangeStateAlert**에 몬스터의 외형이 Rainbow 머티리얼로 변경되고, 감지 범위인 PolygonRendererComponent의 색상이 변경될 수 있도록 아래와 같이 작성합니다.

```
Method:
any OnBehave(number delta)
{
    local sprite = self.ParentAI.Entity.SpriteRendererComponent
    local polygon = self.ParentAI.Entity.PolygonRendererComponent

    if sprite == nil or polygon == nil then
        return BehaviourTreeStatus.Failure
    end

    sprite:ChangeMaterial("material://EntryID")
    polygon.Color = Color(1, 0, 0, 0.25)

    return BehaviourTreeStatus.Success
}
```

#### ActionChangeStateCalm

몬스터의 감지 범위에 플레이어 엔티티가 없을 때 감지 범위는 초록색, 몬스터의 머티리얼을 꺼진 상태가 될 수 있도록 아래와 같이 작성합니다.

```
Method:
any OnBehave(number delta)
{
    -- 몬스터의 외관을 변경합니다.
    -- 스프라이트의 머티리얼을 기본 머티리얼로, 폴리곤 렌더러의 색상을 초록색으로 변경합니다.

    local sprite = self.ParentAI.Entity.SpriteRendererComponent
    local polygon = self.ParentAI.Entity.PolygonRendererComponent

    if sprite == nil or polygon == nil then
        return BehaviourTreeStatus.Failure
    end

    sprite:ChangeMaterial(nil)
    polygon.Color = Color(0, 1, 0, 0.25)

    return BehaviourTreeStatus.Success
}
```

#### ActionFollow

범위 안에 플레이어가 들어왔을 때 플레이어를 추적할 수 있도록 아래와 같이 작성합니다. 감지된 플레이어를 확인하기 위해 `AIPatrolComponent:GetMemory()`를 사용합니다.

```
Method:
any OnBehave(number delta)
{
    ---@type AIPatrolComponent
    local parentAI = self.ParentAI
    local transform = parentAI.Entity.TransformComponent
    local target = parentAI:GetMemory("PlayerInRange")

    if target == nil then
        return BehaviourTreeStatus.Failure
    end

    local diff = target.TransformComponent.WorldPosition - transform.WorldPosition
    diff = diff:ToVector2()
    local dist = diff:Magnitude()

    if dist > 0 then
        local dir = diff:Normalize()
        local movement = self.ParentAI.Entity.MovementComponent
        movement:MoveToDirection(dir, 0)
        return BehaviourTreeStatus.Running
    end

    return BehaviourTreeStatus.Success
}
```

#### ActionMoveRandom

몬스터가 다양한 방향으로 이동할 수 있도록 아래와 같이 작성합니다.

```
Property:
[None]
Vector2 MoveDirection = Vector2(0,0)
[None]
number MoveTime = 0
[None]
number ElapseTime = 0

Method:
void OnInit()
{
    -- 실행할 때마다 이동 방향과 시간을 새롭게 결정합니다.

    local randomX = _UtilLogic:RandomDouble() - 0.5
    local randomY = _UtilLogic:RandomDouble() - 0.5
    
    self.MoveDirection = Vector2(randomX, randomY):Normalize()
    self.MoveTime = _UtilLogic:RandomDouble() * 2 + 2
    self.ElapsedTime = 0
    
    local movement = self.ParentAI.Entity.MovementComponent
    movement:MoveToDirection(self.MoveDirection, 0)
}

any OnBehave(number delta)
{
    -- OnInit()에서 결정된 방향과 시간만큼 이동합니다.
    -- 플레이어와 닿으면 success를 반환합니다.
    
    local movement = self.ParentAI.Entity.MovementComponent
    
    self.ElapsedTime += delta
    
    if self.ElapsedTime >= self.MoveTime then
        movement:MoveToDirection(Vector2.zero, 0)
        return BehaviourTreeStatus.Success        
    end

    return BehaviourTreeStatus.Running       
}
```

#### ActionStop

몬스터가 움직임을 정지할 수 있도록 아래와 같이 작성합니다.

```
Method:
any OnBehave(number delta)
{
    -- 정지합니다.
    local movement = self.ParentAI.Entity.MovementComponent

    if movement ~= nil then
        movement:Stop()
    end

    return BehaviourTreeStatus.Success
}
```

#### ActionWait

일정 시간 동안 동작을 멈추고 대기합니다. 일정 시간이 경과하기 전까지 Running을 반환하고, 시간이 경과하면 Success를 반환하도록 아래와 같이 작성합니다.

```
Property:
[None]
number ElapsedTime = 0
[None]
number Time = 0

Method:
void OnInt()
{
    self.ElapsedTime = 0
}

any OnBehave(number delta)
{
    self.ElapsedTime += delta

    if self.ElapsedTime >= self.Time then
        return BehaviourTreeStatus.Success
    else
        return BehaviourTreeStatus.Running
    end
}
```

#### DecoHasNoTarget

감지된 플레이어가 없으면 자식 노드를 실행하고, 있으면 Failure를 반환할 수 있도록 아래와 같이 작성합니다.

```
Property:
[None]
any Child = nil

Method:
any OnBehave(number delta)
{
    ---@type AIPatrolComponent
    local parentAI = self.ParentAI
    local target = parentAI:GetMemory("PlayerInRange")

    if target == nil then
        return self.Child:Behave(delta)
    else
        return BehaviourTreeStatus.Failure
    end
}
```

#### DecoHasTarget

감지된 플레이어가 있으면 자식 노드를 실행하고, 없으면 Failure를 반환할 수 있도록 아래와 같이 작성합니다.

```
Property:
[None]
any Child = nil

Method:
any OnBehave(number delta)
{
    ---@type AIPatrolComponent
    local parentAI = self.ParentAI
    local target = parentAI:GetMemory("PlayerInRange")

    if target == nil then
        return BehaviourTreeStatus.Failure
    else
        return self.Child:Behave(delta)
    end
}
```

## 행동 트리 만들기

1. **AIPatrolComponent**에 새로운 `CreateBehaviourTree()` 함수를 추가합니다. 트리 구조를 생성할 수 있도록 아래와 같이 작성합니다.```
[server only]
void CreateBehaviourTree()
{
    local root = SelectorNode("Root")

    local seqAttack = SequenceNode("Attack")
    local actAlertState = self:CreateNode("ActionChangeStateAlert", "ChangeState: Alert")
    local actFollow = self:CreateNode("ActionFollow", "Follow")

    seqAttack:AttachChild(actAlertState)
    seqAttack:AttachChild(actFollow)

    local decoHasTarget = self:CreateNode("DecoHasTarget", "HasTarget (Attack)")
    decoHasTarget.Child = seqAttack

    local seqPatrol = SequenceNode("Patrol")
    local seqMove = SequenceNode("Move")
    local actCalmState = self:CreateNode("ActionChangeStateCalm", "ChangeState: Calm")
    local actStop = self:CreateNode("ActionStop", "Stop")
    local actMoveRandom = self:CreateNode("ActionMoveRandom", "MoveRandom")
    local actWait = self:CreateNode("ActionWait", "Wait")
    actWait.Time = 3

    seqMove:AttachChild(actWait)
    seqMove:AttachChild(actMoveRandom)

    local decoHasNoTarget = self:CreateNode("DecoHasNoTarget", "HasNoTarget (Move)")
    decoHasNoTarget.Child = seqMove

    seqPatrol:AttachChild(actCalmState)
    seqPatrol:AttachChild(actStop)
    seqPatrol:AttachChild(decoHasNoTarget)

    root:AttachChild(decoHasTarget)
    root:AttachChild(seqPatrol)

    self:SetRootNode(root)
}
```
2. `OnBeginPlay()`함수에서 `CreateBehaviourTree()` 함수를 호출하도록 아래와 같이 수정합니다.```
void OnBeginPlay()
{
    self:CreateBehaviourTree()
    self:DrawRange()
}
```

Update 2025-11-17 PM 08:14


# 동적으로 맵 생성, 파괴하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

맵을 동적으로 생성, 파괴하는 방법을 알아봅시다.

##### 참고 가이드

- [월드 인스턴스](/docs?postId=984)
- [인스턴스 맵 만들기](/docs/?postId=540)
- [DynamicMapService](/apiReference/Services/DynamicMapService)
- [DynamicMapResultCode](/apiReference/Enums/DynamicMapResultCode)

# 원본 맵

원본 맵이란 크리에이터가 메이커에서 생성한 맵으로, 스크립트로 별도의 호출을 하지 않아도 월드 입장 시 자동으로 생성되는 맵을 의미합니다. 동적 맵 생성 시 원본 맵으로 사용할 수 있는 맵은 룸의 타입에 따라 달라집니다. 정적 룸에서는 정적 맵만 원본 맵으로 사용할 수 있고, 인스턴스 룸에서는 인스턴스 맵만 원본 맵으로 사용할 수 있습니다.

#### 원본 맵의 초기 상태

원본 맵의 초기 상태란 월드 입장 시 자동으로 생성된 가장 첫 시점의 맵 상태를 의미 합니다. 맵을 동적으로 생성하는 시점의 원본 맵 상태와 상관없이 동적 맵은 늘 항상 원본 맵의 초기 상태와 동일하게 생성됩니다.

# 동적 맵

동적 맵이란 월드 플레이 중 동적으로 생성되는 맵을 의미합니다. 예를 들어 크리에이터가 만드는 월드에 따라 한 맵에 특정 인원만 입장하는 동일한 형태의 맵이 필요할 수 있습니다. 이때 메이커에서 제작한 맵을 복사해 필요한 맵의 수만큼 미리 생성할 수도 있습니다. 그러나 맵의 개수가 늘어날수록 월드 서버에 부담이 되고, 월드 로딩 속도가 느려질 수 있습니다. 이때 DynamicMapService를 활용하면 필요한 때에만 생성할 수 있어 월드를 효율적으로 제작하는데 도움이 됩니다.

# 동적 맵 생성

맵을 동적으로 생성할 때는 `CreateDynamicMap()` 함수를 사용합니다. 이 함수로 맵을 생성하면 원본 맵에 속한 모든 컴포넌트의 `OnBeginPlay()`이 호출된 이후 결괏값으로 [DynamicMapResultCode](/apiReference/Enums/DynamicMapResultCode)를 반환합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1757313592097179ef701cdbc4f06847445e16dbe93dd.png) 동적 맵을 사용하는 맵의 경우 `OnBeginPlay()`에서 실행에 시간이 오래 걸리는 작업이 수행되지 않도록 주의해야 합니다. 실행 시간이 오래 걸리는 경우 서버 성능에 악영향을 끼칠 수 있기 때문입니다. 또한 동적 맵을 생성할 때 `OnBeginPlay()`에서 동적 맵을 생성하지 않도록 유의해야 합니다. `OnBeginPlay()`에서 동적 맵을 생성할 경우 재귀 호출로 인해 동적 맵이 무한히 반복적으로 생성되어 오류가 발생할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17573136093876287b8a065484a47ae8ebb646ea7a3f7.png)

> **Tip.** 동적 맵 생성 시 맵의 속성을 변경할 수 없습니다. 정적 룸의 정적 맵은 오직 정적 맵으로만 생성되고, 인스턴스 맵은 인스턴스 맵으로만 동적으로 생성됩니다.

#### 동적 맵 생성 시 유의 사항

`DynamicMapService`로 동적 맵을 생성할 때의 기준은 원본 맵의 초기 상태입니다. 메이커에서 제작한 맵의 모습이 아래와 같다면 동적으로 생성되는 맵은 늘 아래 상태로 생성됩니다. 월드에서 처음 생성된 원본 맵의 데이터가 변경되었다 하더라도 그 변경된 데이터는 새롭게 생성될 동적 맵에 반영되지 않고 초기 상태로 생성됩니다.

| 초기 상태 | 플레이 중인 원본 맵 |
| --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1756980791490973aeecd2496440faba844a80585270c.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1756980818537570eca05f30a4376ba796d157114aeb7.png) |

동적 맵을 생성 하면 아래와 같이 초기 상태로 생성됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1756980791490973aeecd2496440faba844a80585270c.png)

# 동적 맵과 프로퍼티 타입

동적 맵을 생성할 때 경로를 사용하는 타입의 프로퍼티가 초기 상태에 있다면, 절대 경로 대신 상대 경로를 사용해야 합니다. 상대 경로를 사용해야 하는 프로퍼티 타입은 아래와 같습니다.

- **Entity, Component, EntityRef, ComponentRef**

예를 들어 아래 그림과 같이 원본 맵에서 Portal A의 목적지는 Portal B, Portal B의 목적지는 Portal A로 지정했다고 생각해 봅시다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1756980939504b01e26564c99479094d726cf011279f4.png)

동적 맵의 특성은 원본 맵의 초기 데이터를 그대로 복제하는 것이므로 동적 맵 생성 시 문제가 발생하게 됩니다.새로 생성된 동적 맵에서도 경로가 동일한 절대 경로로 유지되므로 새롭게 생성된 동적 맵에서 Portal A로 이동하면 DynamicMap1(원본 맵)의 Portal B로 이동하게 됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/175730580015799115a0e1bf842aa88bf70fb01616fe8.png)

이 문제는 `OnBeginPlay()`와 같은 특정 시점에서 참조 대상을 직접 지정해 대응할 수 있습니다. 예를 들어 `PortalComponent`를 **Extend**해 포털의 목적지를 상대 경로로 지정할 수 있습니다.

```
Property:
[None]
string PortalEntityPath = "nil"

Method:
void OnBeginPlay()
{
	local fullPath = self.Entity.CurrentMap.Path .. "/" .. self.PortalEntityPath
	local targetEntity = _EntityService:GetEntityByPath(fullPath)
	
	if targetEntity == nil or targetEntity.PortalComponent == nil then
	    log_warning("Target entity is invalid. path : " .. fullPath)
		return
	end
	self.PortalEntityRef = targetEntity
}
```

# 동적 맵 제거

동적 맵을 제거할 때는 `DestroyDynamicMap()` 함수를 사용합니다. 동적 맵에 유저가 없을 경우만 제거가 가능합니다. 동적 맵 제거 함수를 실행하면 [DynamicMapResultCode](/apiReference/Enums/DynamicMapResultCode)로 결괏값을 반환합니다.

Update 2025-11-17 PM 08:14


# 월드 인스턴스 통신

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

`WorldInstanceService`와 `WorldInstanceSharedMemory`를 활용해 월드 인스턴스끼리 데이터를 공유하고 이벤트를 보내는 방법에 대해 알아봅시다. 월드 인스턴스와 룸 개념은 [월드 인스턴스](/docs?postId=984), [인스턴스 맵 만들기](/docs/?postId=540) 가이드를 참고하세요.

> **Tip.** 룸끼리의 통신을 구현하고 싶다면 `RoomService`의 동일한 함수명을 사용해보세요.

# WorldInstanceSharedMemory

월드 인스턴스끼리 직접적으로 통신을 할 수 없기에 서로의 데이터를 공유하기 위해서는 [WorldInstanceSharedMemory](/apiReference/Misc/WorldInstanceSharedMemory)를 사용해야 합니다. WorldInstanceSharedMemory는 공유 변수들의 모임으로, 실시간으로 변화하는 특정 공유 변수의 값을 읽고 쓸 수 있습니다. WorldInstanceSharedMemory의 특징은 **휘발성**입니다. 사용하는 월드 인스턴스가 없다면 WorldInstanceSharedMemory는 사라집니다.

> **Tip.** 룸끼리의 통신이 필요한 경우 `RoomService` 와 `RoomSharedMemory`를 활용합니다.

#### 공유 변수

**공유 변수**는 월드 인스턴스끼리 공유하는 값입니다. WorldInstanceSharedMemory의 어떤 데이터를 변경했다고 하면, 공유 변수의 값을 변경했다는 의미입니다. 아래는 WorldInstanceService와 WorldInstanceSharedMemory를 사용해 공유 변수를 다양하게 활용하는 예제입니다.

```
-- WorldInstanceSharedMemory를 얻어옵니다.
local getMemResultCode, mem = _WorldInstanceService:GetSharedMemory("MemoryName")
 
-- 공유 변수 var1을 생성합니다.
local createVarResult = mem:CreateVariableAndWait("var1", "value1")
log (createVarResult.Info.Name)        -- var1
log (createVarResult.Info.Value)       -- value1
 
-- 공유 변수 var1을 조회합니다.
local getVarResult = mem:GetVariableAndWait("var1")
log (getVarResult.Info.Name)           -- var1
log (getVarResult.Info.Value)          -- value1
 
-- 공유 변수 var1의 값을 value2로 수정합니다.
local keyInfo = SharedVariableKeyInfo("var1", nil)
local updateVarResult = mem:UpdateVariableAndWait(keyInfo, "value2")
log (updateVarResult.Info.Value)       -- value2
 
-- 공유 변수 var1을 삭제합니다.
local deleteVarResultCode = mem:DeleteVariableAndWait("var1")
 
-- WorldInstanceSharedMemory를 삭제합니다. 남아 있던 모든 공유 변수도 함께 삭제됩니다.
local deleteMemResultCode = _WorldInstanceService:DeleteSharedMemoryAndWait("MemoryName")
```

#### 공유 변수 참조

월드 인스턴스가 공유 변수를 생성, 조회, 수정을 하면 해당 공유 변수를 참조한 상태가 됩니다. 한 번 특정 공유 변수를 참조한 월드 인스턴스는 공유 변수가 삭제될 때까지 계속 참조 상태를 유지합니다. 만약 어떤 공유 변수를 여러 월드 인스턴스에서 참조하고 있을 때 특정 월드 인스턴스에서 해당 공유 변수를 삭제해버리면 다른 월드 인스턴스에서 공유 변수를 사용할 수 없게 됩니다. 이처럼 한 곳에서 데이터를 삭제했지만 전체 월드 인스턴스에게 영향을 주는 사고를 방지하기 위해 메이플스토리 월드는 WorldInstanceSharedMemory 공유 변수를 바로 삭제하기 보다 참조를 해제하는 방식을 권장합니다. 모든 월드 인스턴스에서 공유 변수 참조를 해제할 경우 자동으로 해당 공유 변수가 삭제됩니다.

```
-- 공유 변수 var1의 참조를 해제합니다.
local releaseVarResult = mem:ReleaseVariableAndWait("var1")
 
-- WorldInstanceSharedMemory 내 모든 공유 변수의 참조를 해제합니다.
local releaseMemResultCode = _WorldInstanceService:ReleaseSharedMemoryAndWait("MemoryName")
```

#### WorldInstanceSharedMemory 일괄 요청

**Batch 접두사**가 붙은 함수로 공유 변수의 생성, 조회, 수정 등을 일괄 요청할 수 있습니다. 여러 변수를 처리해야 할 때 사용하면 효율적입니다.

```
local code, mem = _WorldInstanceService:GetSharedMemory("MemoryName")
 
local nameValues = { ["b_var1"] = "b_value1", ["b_var2"] = "b_value2", ["b_var3"] = "b_value3" }
local results = mem:BatchCreateVariableAndWait(nameValues)
 
log (results["b_var1"].Info.Value)        -- b_value1
log (results["b_var2"].Info.Value)        -- b_value2
log (results["b_var3"].Info.Value)        -- b_value3
```

#### ETag

**ETag**는 공유 변수의 데이터가 최신 상태인지 확인하기 위해 필요합니다. ETag는 식별자입니다. 데이터를 생성 또는 수정하거나, 기록을 조회할 때마다 새로운 ETag를 발급합니다. 발급한 ETag는 데이터의 버전을 기록하고, 비교하는데 사용합니다. ETag를 사용하는 이유는 여러 월드 인스턴스에서 하나의 공유 변수를 사용하면 어떤 데이터가 최신 데이터인지, 수정되었는지 알기 어렵기 때문입니다. 또한 여러 월드 인스턴스에서 공유 변수에 접근하므로 예기치 못하게 데이터를 덮어 쓸 수 있기 때문입니다.

공유 변수와 ETag는 함께 사용하는 쌍으로써, 공유 변수의 값을 수정한다면 공유 변수 이름, 값과 더불어 ETag를 함께 요청에 담아 보내야합니다. 이때 요청에 포함된 ETag와 최신 ETag가 서로 다르다면 공유 변수의 값은 수정되지 않습니다. 다만, 크리에이터의 의도에 따라 ETag 확인 과정을 생략할 수 있습니다. 이때는 nil 혹은 빈 문자열을 입력해 무조건적으로 확인 과정을 생략하며 공유 변수 값을 수정합니다.

아래 코드는 ETag를 사용하는 예시입니다.

```
local code, mem = _WorldInstanceService:GetSharedMemory("MemoryName")
  
-- current.Info.ETag 에는 최신 ETag가 담겨 있습니다.
local current = mem:GetVariableAndWait("varname")
  
-- keyInfo에 최신 ETag를 담아 보내야만 공유 변수가 수정됩니다. 다른 값을 담으면 수정되지 않습니다. 단, 빈 문자열이나 nil을 담으면 무조건 공유 변수가 수정됩니다.
local keyInfo = SharedVariableKeyInfo(current.Info.Name, current.Info.ETag)
 
-- 공유 변수 수정 성공 시, updated.Info.ETag에는 새롭게 발급받은 최신 ETag가 담겨 있습니다.
local updated = mem:UpdateVariableAndWait(keyInfo, "new value")
 
-- ETag 불일치로 인해 공유 변수 수정 실패 시, SharedMemoryResultCode.PreconditionFailed 오류 코드가 반환됩니다.
if updated.Code == SharedMemoryResultCode.PreconditionFailed then
    error ("ETag Mismatch.")
end
```

# WorldInstanceService

`WorldInstanceService`의 함수를 활용해 월드 인스턴스끼리 데이터를 공유하거나, 이벤트를 전달할 수 있습니다. WorldInstanceService로 WorldInstanceSharedMemory를 얻을 수 있습니다. 얻은 WorldInstanceSharedMemory로 공유 변수를 생성 또는 수정할 수 있습니다. ![WorldInstanceService01](https://mod-file.dn.nexoncdn.co.kr/bbs/1679450541490552c575873394cd49aedb25f7cf2f979.png)

# 월드 인스턴스끼리 이벤트 전송과 수신

`RequestSendEventToAllWorldInstancesAndWait()`, `RequestSendEventToAllWorldInstancesAsync()` 함수를 활용해 다른 모든 월드 인스턴스로 이벤트를 전송할 수 있습니다. 특정 월드 인스턴스에만 이벤트를 전송하고 싶은 경우 `RequestSendEventToWorldInstanceAndWait()` 혹은 `RequestSendEventToWorldInstanceAsync()`를 활용합니다.

#### 이벤트 전송

다른 월드 인스턴스로 이벤트를 보내기 위해서는 **월드 인스턴스 Id**를 사용해야 합니다. 월드 인스턴스 Id는 `WorldInstanceService.WorldInstanceId`로 알 수 있습니다.

```
-- MyWorldInstanceEvent 이벤트를 모든 월드 인스턴스에 전송합니다.
local evt = MyWorldInstanceEvent()
local code = _WorldInstanceService:RequestSendEventToAllWorldInstancesAndWait(evt)
 
if code ~= SendEventRequestResultCode.OK then
     error ("_WorldInstanceService:RequestSendEventToAllWorldInstancesAndWait failed.")
end
```

#### 이벤트 수신

크리에이터가 `WorldInstanceService`에 이벤트 핸들러를 연결해야 이벤트를 수신할 수 있습니다. 이벤트 발생 공간은 서버입니다.

```
Event Handler:
[service: WorldInstanceService]
HandleMyWorldInstanceEvent(MyWorldInstanceEvent event )
{
    log ("Receive MyWorldInstanceEvent.")
}
```

# WorldInstanceService 제한 사항

**WorldInstanceService**를 사용할 때는 아래의 제한 사항을 염두에 두고 사용해야 합니다.

#### 작명 규칙

WorldInstanceMemory와 공유 변수 이름은 아래 문자로만 작명할 수 있습니다. 최소 1글자 이상의 이름이어야 하며, 최대 100글자 이름일 수 있습니다.

- **알파벳 대,소문자**
- **숫자**
- **공백**
- **_ , -**

#### 수량 및 용량 제한

- 한 월드 당 생성 가능한 WorldInstanceSharedMemory는 최대 **100개**입니다.
- 하나의 공유 변수에 저장할 수 있는 최댓값은 **80,000 bytes**입니다.
- 공유 메모리 하나의 총 용량은 **80MiB**를 넘을 수 없습니다.
- 전송할 이벤트 프로퍼티의 총 용량은 **80,000 byte**를 넘을 수 없습니다.

#### 사용량 제한

- 월드의 생성된 모든 월드 인스턴스에서 분당 최대 WorldInstanceSharedMemory 함수 호출 횟수는 **1,000회**입니다.
  - Batch 함수 호출 한 번으로 100개의 공유 변수의 값을 변경한다면 함수 호출 횟수는 100회입니다.
  - 10개의 월드 인스턴스에서 동시에 100번 호출하면 호출 횟수는 1,000회입니다.
- 월드 인스턴스 간 최대 이벤트 전송 횟수는 분당 **1,000회**입니다.

# 활용 예제

월드 인스턴스끼리 서로의 이벤트를 감지하는 예제입니다.

1. Workspace - MyDesk - Create Scripts - Create EventType - 새로운 **MyUserEnterEvent**를 생성합니다.
2. **MyUserEnterEvent**에 프로퍼티를 추가합니다.```
Property:
string WorldInstanceId = ""
string Nickname = ""
```
3. Workspace - MyDesk - Create Scripts - Create Logic - 새로운 **MyUserEnterLogic**를 생성합니다.
4. **MyUserEnterLogic**의 Entity Event Handler에서 [+]를 눌러 **UserEnterEvent**를 추가합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16794535826480d4537b7507743b7be90ce6f1e6666b7.png) 새로운 유저가 월드 인스턴스에 입장하면 모든 월드 인스턴스에 이벤트를 전달하도록 아래와 같이 작성합니다.```
Event Handler:
[Service: UserService]
HandleUserEnterEvnet(UserEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------

    local worldInstId = _WorldInstanceService.WorldInstanceId
    local user = _UserService:GetUserEntityByUserId(UserId)
    local nickname = user.PlayerComponent.Nickname

    local evt = MyUserEnterEvent(worldInstId, nickname)
    _WorldInstanceService:RequestSendEventToAllWorldInstancesAndWait(evt)
}
```
5. Entity Event Handler에서 [+]를 눌러 **MyUserEnterEvent**를 추가합니다. self를 **service**로 변경합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1679453622421b14075cdc1894563be692c22e59996f5.png)
6. ![open](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_open_folder.png)을 눌러 **WorldInstanceService**를 지정합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16794536057958e520b24e60e46ad8b842e580a652971.png) 어떤 월드 인스턴스에서 유저가 입장했는지 알 수 있도록 아래와 같이 작성합니다.```
[service: WorldInstanceService]
HandleMyUserEnterEvent(MyUserEnterEvent event)
{
    -- Parameters
    local WorldInstanceId = event.WorldInstanceId
    local Nickname = event.Nickname
    ---------------------------------------------------------

    local currWorldInstId = _WorldInstanceService.WorldInstanceId

    if currWorldInstId == WorldInstanceId then
    	log ("User '" .. Nickname .. "' has entered this world instance.")
    else
    	log ("User '" .. Nickname .. "' has entered another world instance.")
    end
}
```
7. 월드를 출시해 서로 다른 월드 인스턴스에서 입장하는지 로그를 확인할 수 있습니다. 메이커에서 확인하면 모두 같은 월드 인스턴스로 입장합니다.

Update 2025-11-20 PM 02:03


# 인스턴스 맵 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 제작하다 보면 특정한 유저만 입장할 수 있는 특수 던전 같은 별도의 공간을 만들고 싶을 때가 있습니다. 이때 `RoomService`를 활용할 수 있습니다 다른 유저들과 분리할 수 있는 별도의 공간을 만들고, 유저를 이동시키는 `RoomService`를 알아봅시다. 인스턴스 맵을 활용하기 위해 정적 룸, 정적 맵 개념을 함께 설명합니다.

# 정적 룸

하나의 월드에는 하나의 **정적 룸(Static Room)**이 있습니다. 정적 룸에는 정적 맵이 생성됩니다. 유저는 정적 맵 간 이동을 자유롭게 할 수 있습니다.

# 정적 맵

**정적 맵(Static Map)**은 월드 인스턴스 안에 생성됩니다. 월드에서 크리에이터가 제작하는 맵의 기본 값은 정적 맵입니다. 월드가 생성될 때 정적 맵도 함께 생성됩니다.

# 인스턴스 룸

**인스턴스 룸(Instance Room)**은 **인스턴스 맵**을 담는 바구니입니다. 크리에이터는 인스턴스 룸에 특정 인스턴스 맵들을 담아 생성할 수 있습니다. 각기 다른 인스턴스 룸이라도 동일한 구성의 인스턴스 맵들로 룸을 꾸릴 수 있습니다. 만약 동일한 인스턴스 맵 구성으로 룸을 구성했다면 key를 사용해 서로 다른 인스턴스 룸으로 구별하기 때문입니다.

또한 각기 다른 인스턴스 룸들을 동시에 생성하는 것도 가능합니다. 이미 생성된 인스턴스 룸이 있다면, 새로운 유저가 정적 룸에 접속했더라도 생성된 인스턴스 룸에게 아무 영향도 끼치지 않습니다. 인스턴스 룸을 생성하고 유저를 인스턴스 룸으로 이동시킨 뒤에는 해당 인스턴스 룸의 정보만 불러오기 때문입니다.

유저를 인스턴스 룸의 인스턴스 맵으로 보내기 위해서는 정적 룸의 정적 맵을 우선 거쳐야만 합니다. 인스턴스 룸에서 벗어나 다시 정적 맵으로 돌아갈 때 돌아갈 정적 맵을 MapName으로 정할 수 있습니다. 돌아갈 정적 맵을 정하지 않았다면 시작 맵으로 돌아가게 됩니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/167220613027481fbeaab9552405b9d54bf9c2d7e9ed3.png)

#### Key

동일한 인스턴스 맵으로 구성되었지만 다른 인스턴스 룸을 만들 수 있기 때문에 인스턴스 맵을 구별하기 위해서는 **식별 키**가 필요합니다. **Key**는 조작 용도로 사용합니다.

# 인스턴스 맵

맵의 기본값은 정적 맵입니다. 크리에이터가 특정 맵을 인스턴스 맵으로 사용하고자 한다면, Map의 **MapComponent**의 **InstanceMap** 프로퍼티가 **true**여야 합니다.

# RoomService

`RoomService`는 인스턴스 룸을 생성, 파괴하거나 유저를 특정 인스턴스 룸으로 옮길 수 있습니다. 자세한 내용은 [RoomService](/apiReference/Services/RoomService)를 참고하세요.

#### 인스턴스 룸으로 이동

유저는 하나의 인스턴스 룸 안에 생성된 인스턴스 맵 사이를 이동할 수 있습니다. 그러나 인스턴스 룸에서 다른 인스턴스 룸으로는 이동할 수 없습니다. 또한 정적 룸과 인스턴스 룸 사이를 `RoomService`를 통하지 않고는 이동할 수 없습니다. 예를 들어 인스턴스 맵에 정적 맵으로 이동할 수 있는 포탈을 만들었더라도 이동할 수 없는 것이 정상입니다. 아래의 도식을 살펴보겠습니다. 정적 룸에 생성된 Map 01, 02, 03 내에서 유저는 자유롭게 이동이 가능합니다. 만약 정적 맵인 Map01에서 Instance Room A로 특정 유저들을 이동시킬 때는 `RoomService:MoveUsersToInstanceRoom()`을 사용합니다. Instance Room A로 이동한 유저들은 룸에 생성된 인스턴스 맵인 map 04, 05, 06, 07내에서 이동할 수 있습니다. 그러나 Instance Room A에서 곧장 Instance Room B로 이동할 수 없습니다. Instance Room A에서 InstanceRoom B로 이동하고 싶다면 정적 맵 map 01으로 돌아간 뒤 `MoveUsersToInstanceRoom()`을 통해 다른 인스턴스 룸으로 이동해야 합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/167514939683374cba8eb14d44671bed868c1e16516a3.png)

#### 인스턴스 룸에서 데이터 접근

정적 룸과 인스턴스 룸은 별도의 공간이므로 서로의 데이터에 접근할 수 없습니다. 따라서 Service, Logic과 같은 엔트리들은 공간마다 존재합니다. 하나의 월드에서는 하나의 DataStorage를 사용합니다. 따라서 정적 룸과 생성된 인스턴스 룸 모두 동일한 하나의 DataStorage를 사용하는 점을 염두에 둬야 합니다.

# 활용 예시

대기실에 모인 인원 중 Ready 버튼을 누른 3명만 게임이 진행될 맵으로 이동하게 만들어봅시다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16728923078067133fe9f934c494fb88daec6cd7da953.png) ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1672892340962e23f260871484cac83c21fcfefaadb2c.gif)

#### 준비

이 예제에서는 시작 맵을 인스턴스 맵으로 보내는 정적 룸, 돌아오는 정적 룸으로 활용합니다.

1. 대기 맵과 인스턴스 맵을 만듭니다.
  - 정적 맵 이름: waitingmap
  - 인스턴스 맵 이름: dungeon ![instancemaps](https://mod-file.dn.nexoncdn.co.kr/bbs/1638498213055cf9e5651d3744ef987655fc87ef9add2.png)
2. dungeon 맵을 인스턴스 맵으로 사용하기 위해 프로퍼티 에디터 창에서 **MapComponent의 InstanceMap 프로퍼티**를 ![Editbox_Check](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176407708cb3de01eaaf48a68ab2dd6fe1b1183f.png)활성화합니다.![InstanceMap](https://mod-file.dn.nexoncdn.co.kr/bbs/1679381963752d7fcf722dd3543888ed05edabe847044.png)
3. ![Tool_UI](https://mod-file.dn.nexoncdn.co.kr/bbs/163453120840744616a62243642e889159a68a78a56c2.png)UI 에디터 - 좌측 기본 도구 - ![button](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_button.png) 버튼을 활용해 Ready 버튼을 **DefaultGroup**에 생성합니다. ![instance05](https://mod-file.dn.nexoncdn.co.kr/bbs/1638498359187950b047e63934e33a1a76ac3dbef58cf.png)

> **Tip** RoomService를 테스트하려면 여러 명의 유저가 필요합니다. ![Common_SoundPlay](https://mod-file.dn.nexoncdn.co.kr/bbs/1635317657654c59c47ffc44d414db579b8d2fc0715a8.png)[시작]을 누르고, ![Common_MultiPlayer](https://mod-file.dn.nexoncdn.co.kr/bbs/163453813155295c09654c5824a6d825788e3d97c4b7d.png)멀티 플레이어 추가 버튼을 필요한 유저 수만큼 눌러 추가합니다.

#### 인스턴스 룸 생성

`GetOrCreateInstanceRoom()` 함수를 활용해 인스턴스 룸을 생성합니다.

1. **GameManager 스크립트 컴포넌트**를 생성하고, **waitingmap**에 추가합니다.![instance02](https://mod-file.dn.nexoncdn.co.kr/bbs/1638498169847ea785d529504411b94811514d2fe0c42.png)
2. **GameManager 스크립트 컴포넌트**에 인스턴스 룸을 만드는 스크립트를 아래와 같이 작성합니다.```
Property:
[None]
integer roomIdx = 0

Method:
any GetOrCreateInstanceRoom ()
{
    -- RoomService를 이용해 Instance Room을 생성하고 roomIdx를 1 올려줍니다.
    -- roomIdx를 Instance Room을 만드는 키로 사용해 매번 새로운 InstanceRoom이 만들어지게 합니다.
    local instanceRoom = _RoomService:GetOrCreateInstanceRoom("DungeonMap"..tostring(self.roomIdx))
    self.roomIdx = self.roomIdx + 1
    return instanceRoom
}
```

#### 특정 인스턴스 룸으로 이동시키기

게임이 진행될 인스턴스 룸에 입장할 수 있는 유저를 정하는 조건을 만들어 유저를 이동시켜봅시다. 조건은 크리에이터의 기획에 따라 달라질 수 있습니다. 예시는 **'Ready' 버튼을 3명 이상의 유저가 누르면** 새로운 인스턴스 룸으로 이동시킵니다.

1. **GameManager 스크립트 컴포넌트**에 주기적으로 유저의 Ready 상태를 확인해, 인스턴스 룸으로 이동시키는 스크립트를 작성합니다.```
Property:
[None]
number checkReadyPlayerTimer = 0
[None]
integer playerNumPerGame = 0

Method:
[server only]
void OnUpdate(number delta)  
{
    self.checkReadyPlayerTimer = self.checkReadyPlayerTimer + delta
    -- 일정한 주기로 Ready 상태가 된 플레이어를 체크합니다.
    if self.checkReadyPlayerTimer >= 5.0 then
        self.checkReadyPlayerTimer = 0.0

        -- Ready 상태인 플레이어 수와 이름을 가져옵니다.
        local readyPlayerNum = 0
        local readyPlayers = {}
            for k, v in pairs(_UserService.UserEntities) do
            if v.Player.isReady == true then
                readyPlayerNum = readyPlayerNum + 1
                readyPlayers[#readyPlayers+1] = v.Name
            end
        end

        -- Ready 상태인 플레이어 수가 미리 설정한 값 이상일 경우 해당 플레이어들을 새로운 Instance Room으로 보내주는 로직을 실행합니다.
        if readyPlayerNum >= self.playerNumPerGame then

            -- 만들어야 할 Instance Room 개수만큼 반복합니다.
            for i = 1, math.floor(readyPlayerNum / self.playerNumPerGame) do

                -- Instance Room을 생성합니다.
                local instanceRoom = self:GetOrCreateInstanceRoom()
                local toSendPlayers = {}

                -- 각 Instance Room에 배치해 줄 플레이어들을 가져옵니다.
                for j = 1, self.playerNumPerGame do
                    local idx = (i-1) * self.playerNumPerGame + j
                    toSendPlayers[#toSendPlayers+1] = readyPlayers[idx]
                end

                -- 가져온 플레이어들의 정보를 이용해 해당하는 Instance Room으로 보내줍니다.
                _RoomService:MoveUsersToInstanceRoom(instanceRoom.InstanceKey, toSendPlayers)
            end
        end
    end
}
```
2. **waitingmap**의 프로퍼티 에디터 창에서 GameManager의 **playerNumPerGame에 3**을 입력합니다. ![instance14](https://mod-file.dn.nexoncdn.co.kr/bbs/1638779042401ec936b5ae88046b085ded53f0bae7132.png)
3. **ReadyButton** 스크립트 컴포넌트를 생성하고 **Ready UI 버튼**에 추가합니다.유저가 준비 상태가 되면 서버에 해당 유저가 준비되었다는 정보를 보내줍니다.```
Property:
[None]
boolean isReady = false

Event Handler:
[client only] [Entity: UIButton(/ui/DefaultGroup/UIButton)] 
HandleButtonClickEvent(ButtonClickEvent event) 
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------

    -- 버튼이 눌렸을 때 해당 플레이어가 Ready 상태일 경우 Ready 상태를 취소하고, UI의 Text를 수정한 뒤 서버에 알립니다.
    if self.isReady  == true then
        self.isReady = false
        self.Entity.TextComponent.Text = "Ready"
        _UserService.LocalPlayer.Player:OnCancelReady()
    -- 버튼이 눌렸을 때 해당 플레이어가 Ready 상태가 아닐 경우, Ready 상태로 만들어주고, UI의 Text를 수정한 뒤 서버에 알립니다.
    else
        self.isReady = true
        self.Entity.TextComponent.Text = "Cancel"
        _UserService.LocalPlayer.Player:OnReady()
    end
}
```
4. **Player 스크립트 컴포넌트**를 생성하고 ![workspace_MyAvatar](https://mod-file.dn.nexoncdn.co.kr/bbs/16346008379922a9b756c3912461db7195808cb554abd.png) DefaultPlayer에 추가합니다. 플레이어의 ready 정보를 서버로 동기화시켜 유저의 상태를 확인합니다.```
Property:
[None]
boolean isReady = false
[None]
number roomIdx = 0
[None]
any readyButton = nil

Method:
[client only]
void OnBeginPlay() 
{
    wait(1)
    self.readyButton = _EntityService:GetEntity("Entity ID") -- readyButton의 Entity ID를 입력합니다.
    -- Instance Room으로 이동하면 Ready 버튼이 보이지 않도록 합니다.
    if _UserService.LocalPlayer.CurrentMapName == "dungeon" then
        self.readyButton.Enable = false
    end  
}

[server]
void OnReady() 
{
    self.isReady = true
}

[server] 
void OnCancelReady()
{
    self.isReady = false
}
```

#### 정적 룸으로 이동시키기

게임이 끝난 맵의 유저는 `MoveUsersToStaticRoom()` 함수를 활용해 정적 룸으로 돌아가게 만듭니다. 돌아갈 정적 맵을 지정하지 않으면 시작 맵으로 돌아갑니다.

- **InstanceGameManager 스크립트 컴포넌트**를 생성, 작성한 뒤 dungeon 맵에 스크립트 컴포넌트를 추가합니다.```
Method:
[server only]
void OnBeginPlay()
{
    local playFunc = function()
        local users = {}
        -- 현재 룸에 존재하는 플레이어들을 가져옵니다.
        for k, v in pairs(_UserService.UserEntities) do
            users[#users+1] = v.Name
        end
        -- 해당 플레이어들을 정적 룸으로 돌려보냅니다.
        _RoomService:MoveUsersToStaticRoom(users)
    end

    -- 게임이 시작되고 10초가 지난 후 playFunc 함수가 실행되도록 합니다.
    _TimerService:SetTimerOnce(playFunc, 10.0)
}
```

##### 참고 가이드

- [유저 엔티티를 찾아주는 UserService](/docs?postId=60)
- [엔티티를 탐색하는 EntityService](/docs?postId=201)
- [월드 인스턴스](/docs?postId=984)

Update 2025-11-17 PM 08:14


# RoomService를 활용해 룸끼리 통신하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

RoomService를 활용해 하나의 월드 인스턴스 안에 있는 정적 룸과 인스턴스 룸끼리 통신을 할 수 있습니다. 이 가이드는 예제 위주로 진행되며, 기본 개념은 [WorldInstanceService](/apiReference?postId=1034)와 동일합니다. [월드 인스턴스](/docs/?postId=984), [월드 인스턴스 통신](/docs/?postId=999), [인스턴스 맵 만들기](/docs/?postId=540) 가이드를 먼저 학습하기를 권장합니다.

# RoomService로 통신

정적 룸과 인스턴스 룸은 직접적으로 통신을 할 수 없기에 서로 이벤트나 데이터를 공유하기 위해선 [RoomService](/apiReference?postId=1032)의 함수를 사용해야 합니다. RoomService는 인스턴스 룸을 생성하고, 유저를 이동시킬 수 있습니다. 더불어 같은 공유 메모리를 활용해 같은 월드 인스턴스 내의 룸끼리 상태를 공유하는 것도 가능합니다. 공유 메모리를 사용할 때는 `GetSharedMemory()` 함수를 활용해 새로 생성하거나, 얻어올 수 있습니다. 공유 메모리를 삭제할 때는 `DeleteSharedMemoryAndWait()` 또는 `DeleteSharedMemoryAsync()` 함수를 사용합니다.

# 정적 룸과 인스턴스 룸의 통신

정적 룸에서 인스턴스 룸 상태를 실시간으로 확인하는 예제를 만들어 봅시다. 8초마다 인스턴스 룸의 상태를 게임 중과 대기 중으로 바꾸어 봅시다. 바뀌는 인스턴스 룸의 상태를 조회해 정적 룸과 공유해 정적 룸에서 인스턴스 룸의 상태를 확인할 수 있습니다. 이 예제는 2개의 Logic과 Event Type을 사용합니다.

![Example](https://mod-file.dn.nexoncdn.co.kr/bbs/1681289120098258bc9cbd81049859f1cb80d6adf314f.gif)

#### 사전 준비

1. 두 개의 맵이 필요합니다. 하나는 정적 맵으로 사용하고, 다른 하나는 인스턴스 맵으로 사용합니다.
  - **map01**: Static Map
  - **map02**: Instance Map
  > **Tip.** MapComponent의 InstanceMap를 활용해 인스턴스 맵으로 지정할 수 있습니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681288311051aad86e9170a64def8052f805cdc11628.gif)
2. **[UI] - DefaultGroup**에 [버튼] UI 2개를 추가하고 각각 **Btn_Enter, Txt_RoomState**로 이름을 변경합니다.
  - Btn_Enter![Btn_Enter](https://mod-file.dn.nexoncdn.co.kr/bbs/16813830576229c09ca4ff95f4e91950f82bcb34765bd.png)
  - Txt_RoomState![Txt_RoomState](https://mod-file.dn.nexoncdn.co.kr/bbs/1681383449551f8ad79acbf0c47d097d10110033af6fc.png)

#### 룸 상태 표시

1. **Workspace - MyDesk의 콘텍스트 메뉴에서 Create Scripts - Create Logic**을 선택해 새로운 **StaticRoomLogic**을 만듭니다.
2. 새로운 **ButtonEnter** 프로퍼티를 추가하고, 반환 타입을 Entity로 변경합니다. **Btn_Enter**을 연결합니다.```
Property:
[None]
Entity ButtonEnter = /ui/DefaultGroup/Btn_Enter
```
3. 정적 룸에서만 인스턴스 룸으로 갈 수 있는 버튼이 보이게 아래와 같이 작성합니다.```
Method:
[client only]
void OnBeginPlay()
{
    -- 정적 룸에서만 입장 버튼 엔티티를 활성화합니다.
    if _RoomService:IsInstanceRoom() == true then
    	self.ButtonEnter.Enable = false
    else
    	self.ButtonEnter.Enable = true
    end
}
```
4. **Workspace - MyDesk의 콘텍스트 메뉴에서 Create Scripts - Create Logic**을 선택해 새로운 **InstanceRoomLogic**을 만듭니다.
5. 아래와 같이 프로퍼티 2개를 추가합니다.```
Property:
[Sync]
boolean IsPlaying = false
[None]
Entity TextRoomState = /ui/DefaultGroup/Txt_RoomState
```
6. **InstanceRoomLogic**에 **OnBeginPlay** 함수를 추가합니다. 인스턴스 룸의 상태를 보여주는 버튼만 보일 수 있게 아래와 같이 작성합니다.```
Method:
[client only]
void OnBeginPlay ()
{
    -- 인스턴스 룸에서만 상태 엔티티를 활성화 합니다.
    if _RoomService:IsInstanceRoom() == true then
    	self.TextRoomState.Enable = true
    else
    	self.TextRoomState.Enable = false
    end
}
```

#### 인스턴스 룸 상태 표시

InstanceRoomLogic의 IsPlaying 프로퍼티 값에 따라 버튼의 내용이 바뀔 수 있도록 만들어 봅시다. 정적 룸과 인스턴스 룸에서 로직은 별도로 실행되므로 인스턴스 룸의 변경된 IsPlaying 값을 정적 룸에 전달해야 합니다. 아래 그림과 같이 IsPlaying 값을 전달할 수 있도록 UI를 변경하는 코드를 작성해 봅시다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/168119241933126ff4ac0778142d291c516d5db5bd7d9.png)

1. StaticRoomLogic에 `OnUpdate`를 추가합니다.```
[client only]
void OnUpdate(number delta)
{
    -- 정적 룸에서만 실행합니다.
    if _RoomService:IsInstanceRoom() == true then
    	return
    end

    -- 인스턴스 룸의 상태를 확인하고 버튼 상태를 갱신합니다.
    local isPlaying = _InstanceRoomLogic.IsPlaying
    self:UpdateButton(isPlaying)
}
```
2. 새로운 `UpdateButton` 함수를 추가하고, boolean 타입의 **isPlaying** 매개 변수를 추가합니다. isPlaying 상태에 따라 버튼에 표시되는 문구가 바뀔 수 있도록 아래와 같이 작성합니다.```
[client]
void UpdateButton(boolean isPlaying)
{
    if isPlaying == true then
        local text = "입장 불가 <color=red>(게임 중)</color>"
        self.ButtonEnter.TextComponent.Text = text
        self.ButtonEnter.ButtonComponent.Enable = false
    else
        local text = "입장 <color=lime>(대기 중)</color>"
        self.ButtonEnter.TextComponent.Text = text
        self.ButtonEnter.ButtonComponent.Enable = true
    end
}
```
3. **InstanceRoomLogic**에 **OnUpdate** 함수를 추가합니다.```
[client only]
void OnUpdate(number delta)
{
    -- 인스턴스 룸에서만 실행합니다.
    if _RoomService:IsInstanceRoom() == false then
    	return
    end

    -- 룸 상태를 확인하고 텍스트를 갱신합니다.
    self:UpdateText(self.IsPlaying)
}
```
4. **InstanceRoomLogic**에 **UpdateText** 함수를 추가합니다. boolean 타입의 isPlaying 매개 변수를 추가합니다.```
[client only]
void UpdateText(boolean isPlaying)
{
    if isPlaying == true then
    	local text = "<color=red>게임 중</color>"
    	self.TextRoomState.TextComponent.Text = text
    else
    	local text = "<color=lime>대기 중</color>"
    	self.TextRoomState.TextComponent.Text = text
    end
}
```

#### 인스턴스 룸 입장

입장 버튼을 누른 플레이어가 인스턴스 룸에 입장할 수 있게 아래와 같이 작성합니다.

1. **StaticRoomLogic**에 새로운 **EnterInstanceRoom**을 추가합니다. Add Parameter를 누른 뒤, string 타입의 userId 매개 변수를 추가합니다. `RoomService`를 활용해 인스턴스 룸의 key를 가져오고, 유저를 해당 인스턴스 룸으로 보낼 수 있게 아래와 같이 작성합니다.```
[server]
void EnterInstanceRoom(string userId)
{
    local roomKey = "ExampleRoom"
    local mapName = "map02"

    _RoomService:GetOrCreateInstanceRoom(roomKey)
    _RoomService:MoveUserToInstanceRoom(roomKey, userId, mapName)
}
```
2. Event Handler에 **ButtonClickEvent**를 추가합니다. **entity**로 변경하고, **Btn_Enter**를 연결합니다. 아래와 같이 정적 룸에서 `EnterInstanceRoom` 함수가 실행되도록 작성합니다.```
Event Handler:
[entity: Btn_Enter(/ui/DefaultGroup/Btn_Enter)
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------

    -- 정적 룸에서만 실행합니다.
    if _RoomService:IsInstanceRoom() == true then
    	return
    end

    local me = _UserService.LocalPlayer
    self:EnterInstanceRoom(me.Name)
}
```

#### 인스턴스 룸 상태를 정적 룸에 공유

새로운 이벤트를 생성하고, 그 이벤트를 사용해 인스턴스 룸의 상태를 정적 룸에 공유하게 만들어 봅시다.

1. **Workspace - MyDesk의 콘텍스트 메뉴에서 Create Scripts - Create Event**를 선택해 새로운 **RoomStateChangedEvent**를 생성합니다.
2. boolean 타입의 **IsPlaying** 프로퍼티를 추가합니다.```
Property:
boolean IsPlaying = false
```
3. **InstanceRoomLogic**을 열고, 이벤트 핸들러에 **RoomBeginEvent**를 추가합니다. 서버에서 8초에 한 번씩 인스턴스 룸의 **IsPlaying** 상태를 변경하도록 작성합니다. IsPlaying 상태를 정적 룸으로 전송하기 위해 `RoomService:RequestSendEventToRoomAndWait()` 함수를 사용합니다.```
Event Hanlder:
[service: RoomService]
HandleRoomBeginEvent(RoomBeginEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: RoomService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    ---------------------------------------------------------

    -- 인스턴스 룸이 생성될 때 최초 한 번 수행하기 위해 RoomBeginEvent를 이용합니다.

    -- 인스턴스 룸에서만 실행합니다.
    if _RoomService:IsInstanceRoom() == false then
        return
    end

    -- 서버는 8초에 한 번씩 플레이 상태를 바꿔줍니다.
    local timerFunc = function()
        self.IsPlaying = not self.IsPlaying

        -- 이벤트를 사용해 인스턴스 룸에서 정적 룸으로 IsPlaying 값을 전송합니다.
        local evt = RoomStateChangedEvent()
        evt.IsPlaying = self.IsPlaying
        _RoomService:RequestSendEventToRoomAndWait(evt, _RoomService.StaticRoomKey)
    end

    _TimerService:SetTimerRepeat(timerFunc, 8)
}
```
4. **InstanceRoomLogic**에 **RoomStateChangedEvent**를 추가합니다. [self]를 눌러 [service]로 변경한 뒤 RoomService를 연결합니다. 정적 룸이 수신한 IsPlaying 값을 저장할 수 있도록 아래와 같이 작성합니다.```
[service: RoomService]
HandleRoomStateChangedEvent(RoomStateChangedEvent event)
{
    -- Parameters
    local IsPlaying = event.IsPlaying
    ---------------------------------------------------------

    -- 이벤트는 서버에서 발생합니다.
    -- 정적 룸에서만 실행합니다!
    if _RoomService:IsInstanceRoom() == true then
    	return
    end

    -- 정적 룸은 인스턴스 룸으로부터 수신한 IsPlaying 값을 저장합니다.
    self.IsPlaying = IsPlaying
}
```
5. **RoomEndEvent**를 추가합니다. 인스턴스 룸이 파괴될 때 IsPlaying 상태를 초기화할 수 있도록 아래와 같이 작성합니다.```
[service: RoomService]
HandleRoomEndEvent(RoomEndEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: RoomService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    ---------------------------------------------------------

    -- 인스턴스 룸에서만 실행합니다.
    if _RoomService:IsInstanceRoom() == false then
    	return
    end

    -- 인스턴스 룸이 파괴될 때 상태를 초기화합니다.
    self.IsPlaying = false
    local evt = RoomStateChangedEvent()
    evt.IsPlaying = self.IsPlaying
    _RoomService:RequestSendEventToRoomAndWait(evt, _RoomService.StaticRoomKey)
}
```

# 공유 메모리 활용

위에서 만든 예제 월드에서 새로운 UI를 추가하고, 해당 인스턴스 룸에 입장했을 때 공유 메모리 내용이 나타나도록 만들어 봅시다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16812899032225448790431404595a01853837b8e53a1.png)

1. 텍스트 UI를 DefaultGroup에 추가하고 **Txt_RoomTitle** 이름으로 설정합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1681289321574fd8a803ee75f4db9a94e2109a6a1acd2.png)
2. **InstanceRoomLogic**에 새로운 Entity 타입의 **TextRoomTitle** 프로퍼티를 추가합니다. Txt_RoomTitle UI를 연결합니다.```
Property:
[None]
Entity TextRoomTitle = /ui/DefaultGroup/Txt_RoomTitle
```
3. 인스턴스 룸에 입장하면 Txt_RoomTitle UI가 활성화 되도록 **InstanceRoomLogic**의 OnBeginPlay에 아래와 같이 작성합니다.```
Method:
[client only]
void OnBeginPlay()
{
    if _RoomService:IsInstanceRoom () == true then
        self.TextRoomState.Enable = true
        self.TextRoomTitle.Enable = true
    else
        self.TextRoomState.Enable = false
        self.TextRoomTitle.Enable = false
    end    
}
```
4. **InstanceRoomLogic**에 string 타입의 **Title** 프로퍼티를 추가합니다.```
Property:
[Sync]
string Title = ""
```
5. 룸 이름이 나타날 수 있게 **InstanceRoomLogic**의 **UpdateText** 함수 가장 마지막 줄에 아래 코드를 추가합니다.```
self.TextRoomTitle.TextComponent.Text = self.Title
```
6. 인스턴스 룸을 생성하기 전, 공유 메모리에 룸 이름을 저장해야 합니다. 이를 위해 **StaticRoomLogic**의 **EnterInstanceRoom** 함수에서 `local mapName = "map02"` 밑에 아래 내용을 추가합니다.```
local roomTitleVarName = "roomTitle"
local roomTitle = "Hello, MapleStory Worlds!"

-- 공유 메모리를 얻어옵니다.
local code, mem = _RoomService:GetSharedMemory(roomKey)

if code ~= SharedMemoryResultCode.OK then
	error ("Failed to GetSharedMemory.")
	return
end

-- 'roomTitle'이라는 이름의 변수에 룸 제목을 저장합니다.
local setResult = mem:SetVariableAndWait(roomTitleVarName, roomTitle)

if setResult.Code ~= SharedMemoryResultCode.OK then
	error ("Failed to SetSharedVariableAndWait.")
	return
end
```
7. **InstanceRoomLogic**에서 새로운 **ReadTitleFromSharedMemory** 함수를 추가합니다.```
[server only]
void ReadTitleFromSharedMemory()
{
    local memKey = "ExampleRoom"
    local varName = "roomTitle"

    local code, mem = _RoomService:GetSharedMemory(memKey)

    if code ~= SharedMemoryResultCode.OK then
    	error ("Failed to GetSharedMemory.")
    	return
    end

    local getResult = mem:GetVariableAndWait(varName)

    if getResult.Code ~= SharedMemoryResultCode.OK then
    	error ("Failed to GetSharedVariableAndWait.")
    	return
    end

    self.Title = getResult.Info.Value

    -- 더 이상 사용하지 않는 공유 메모리는 삭제합니다.
    -- 공유 메모리를 삭제하면 내부의 모든 변수도 함께 삭제됩니다.
    _RoomService:DeleteSharedMemoryAndWait(memKey)
}
```
8. 공유 메모리에서 제목을 읽어오도록 **HandleRoomBeginEvent**의 마지막 부분에 아래 내용을 추가합니다.```
-- 공유 메모리에서 제목을 읽어옵니다.
self:ReadTitleFromSharedMemory()
```

# RoomSharedMemory 제한 사항

RoomSharedMemory를 사용할 때는 아래의 제한 사항을 염두에 두고 사용해야 합니다.

#### 작명 규칙

RoomSharedMemory와 공유 변수 이름은 아래 문자로만 작명할 수 있습니다. 최소 1글자 이상의 이름이어야 하며, 최대 100글자 이름일 수 있습니다.

- **알파벳 대,소문자**
- **숫자**
- **공백**
- **_, -**

#### 수량 및 용량 제한

- 한 월드 당 생성 가능한 RoomSharedMemory는 최대 100개입니다.
- 하나의 공유 변수에 저장할 수 있는 최댓값은 80,000 bytes입니다.
- 공유 메모리 하나의 총 용량은 80MiB를 넘을 수 없습니다.
- 전송할 이벤트 프로퍼티의 총 용량은 80,000 byte를 넘을 수 없습니다.

Update 2025-11-17 PM 08:14


# 엔티티의 충돌

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

충돌 이벤트와 충돌 처리 방법에 대해 알아봅시다.

##### 참고 가이드

[Event System](https://mod-developers.nexon.com/docs?postId=73) [Entity Event System](https://mod-developers.nexon.com/docs?postId=176)

# 충돌

**충돌**이란 충돌체를 포함하는 엔티티'의 충돌 영역이 서로 교차하는 것을 말합니다. 엔티티에 [TriggerComponent](/apiReference/Components/TriggerComponent)나 [HitComponent](/apiReference/Components/HitComponent)를 추가하면 충돌체가 자동 생성됩니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16353017504515017d335b5e44a63aff4b6c8e8019ea6.png)

# 충돌체 편집

충돌체의 크기, 위치, 형태 같은 속성들은 충돌체를 제어할 수 있는 컴포넌트들의 프로퍼티로써 편집할 수 있습니다. 대표적으로 [TriggerComponent](/apiReference/Components/TriggerComponent)와 [HitComponent](/apiReference/Components/HitComponent)입니다. **TriggerComponent**는 **충돌 범위**를 설정할 때 충돌체를 사용하며, **HitComponent**는 **피격 범위**를 설정할 때 충돌체를 사용합니다.

#### 편집 활성화

프로퍼티 에디터에서 **[Edit]** 버튼을 눌러 편집을 활성화 할 수 있습니다. 활성화되면 충돌 영역 색상이 초록색으로 변경됩니다.

| 충돌체 편집 비활성화 | 충돌체 편집 활성화 |
| --- | --- |
| ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1647419996497c2317d38c37c4266a041e44a7962be00.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16474200145049bb170d059a94a9ebe454f0c79ede8e6.png) |
| ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1650933070591cc3f53205067484db1c6e758a07eda52.png) | ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1650933106203672a48645eb14948b2f02f2b115be9ff.png) |

#### 크기 편집

편집이 활성화되면 포인트를 잡아당겨 원하는 크기로 편집할 수 있습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1647420159680d2bd972d40cd407cbacb51c32f411bdd.png)

#### 오프셋 편집

충돌체의 포인트를 드래그해 **ColliderOffset**을 설정할 수 있습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1647420135543c8ede53b0cf54ae9bb8ab318c12134e9.png)

# ColliderType

충돌체의 형태는 **Box, Circle, Polygon** 세 가지가 있습니다.

#### Box

충돌체를 사각형 형태로 설정합니다. X는 가로 크기, Y는 세로 크기입니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16751561869387728a07df928485bafa17874b7bedb30.png)

#### Circle

충돌체를 원 형태로 설정합니다 CircleRadius은 반지름 값입니다. CircleRadius 값으로 원의 크기를 설정할 수 있습니다. ![9-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1675156219035249c8c3667a646f8bfbc7b128c1fe38d.png)

#### Polygon

충돌체를 다각형으로 설정합니다. PolygonPoint를 필요한만큼 추가해 크리에이터가 원하는 충돌체 모양을 만들 수 있습니다. ![9-2](https://mod-file.dn.nexoncdn.co.kr/bbs/16792881867493ee65f9122fe47dfbb775527e2ea19ff.png)

# TransformComponent와 충돌체

충돌체는 **TransformComponent**의 **Scale**, **Rotation** 값에 영향을 받습니다.

- **Scale** 값만큼 엔티티 크기가 바뀌면 충돌체 크기도 바뀝니다.
- **Rotation** 값만큼 엔티티가 회전하면 충돌체도 회전합니다.

아래는 엔티티가 충돌을 감지했을 때 노란색으로 변화되는 예시입니다. **Transform**의 **Scale**, **Rotation** 값이 변경되어 다른 엔티티와 충돌할 때마다 노란색으로 바뀝니다.

**Transform.Scale 변화 예시**

**Transform.Rotation 변화 예시**

모든 엔티티는 계층구조로 구성되므로 **확장된 엔티티의 TransformComponent**는 항상 **상위 엔티티의 TransformComponent**에 영향을 받습니다. 이와 마찬가지로 충돌체도 **상위 엔티티의 TransformComponent**에 영향을 받습니다. 상위 엔티티가 만들고, 그 엔티티를 확장한 엔티티를 4개 만들어 어떤 영향을 받는지 살펴보겠습니다. 아래와 같이 상위 엔티티를 회전시키면 4개의 확장 엔티티도 회전하며 또 다른 엔티티와 충돌하는 것을 볼 수 있습니다.

# 충돌 이벤트 이후 액션 추가

충돌 이벤트 이후 액션은 **Entity Event System**을 활용하거나, **확장된 TriggerComponent** 활용합니다. 월드에 **TriggerComponent**를 포함하는 A와 B, 두 엔티티가 있다고 가정해 봅시다. A와 B가 부딪히면 충돌 이벤트가 발생합니다. 그러나 이후 특별한 변화가 일어나지 않을 것입니다. 충돌 이벤트 발생을 한 뒤 일어날 추가 액션이 없기 때문입니다. **TriggerComponent**를 활용하면 충돌 이벤트가 발생할 때 일어날 액션을 추가할 수 있습니다. 예를 들어 A와 B가 충돌하면 A와 B의 체력을 깎는다거나, A와 B 중 하나를 없앨 수도 있습니다.

![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16577114595706becd45fb94840138cab4a6fe2e3fe39.png)

# Event System 활용

#### 구조

충돌 이벤트가 발생할 때 액션을 수행할 핸들러(또는 리스너)를 엔티티에 추가합니다. 이후 엔티티의 **TriggerComponent**에 충돌 이벤트가 발생하면 핸들러의 함수를 호출하는 구조입니다. 이 구조가 작동되려면 엔티티에 **TriggerComponent**와 **스크립트 컴포넌트**(리액터)를 추가해야 합니다. 예를 들어 A와 B 엔티티가 충돌할 때 A와 B의 HP를 깎고 싶다면, A와 B에 **TriggerComponent**와 스크립트 컴포넌트를 각각 추가해야 합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16576992810031fa86f8de6174662a433379786472c6b.png)

#### 핸들러 추가

액션을 수행할 **핸들러**는 스크립트 컴포넌트(리액터)의 **Event Handler**로 추가할 수 있습니다. 스크립트 컴포넌트를 열고 **Event Handler**의 **[+]** 버튼을 눌러 **핸들러**를 추가합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16371497834354f1e725c0f9b43adaf67a6a4a2d8f782.png)

검색창에 **Trigger**를 입력하면 다음과 같이 충돌 이벤트 핸들러가 검색됩니다. 수행할 액션의 목적에 맞는 핸들러를 선택합니다. 각 Event의 각 발생 시점을 참고해 필요한 Event를 적절하게 사용합니다.

- **TriggerEnterEvent**: 엔티티가 처음 충돌할 때 1회 발생합니다.
- **TriggerStayEvent**: 엔티티가 충돌 중이면, 프레임마다 발생합니다.
- **TriggerLeaveEvent**: 엔티티가 충돌했다가 충돌이 끝날 때 1회 발생합니다.

![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16371497944331ae1049930a9446d8f30d3edc24f8530.png)

#### 충돌 이벤트 센더 설정

핸들러를 선택하면 함수가 추가됩니다. 핸들러 상단에서 센더를 설정할 수 있습니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/16371498027637a7ba3588b494f30a2dfca16bedba70e.png)

해당 스크립트 컴포넌트(리액터)를 포함하고 있는 엔티티의 충돌 이벤트를 받으려면 센더를 **self**로 설정합니다. 다른 엔티티의 충돌 이벤트를 받으려면 센더를 **entity**로 설정하고 원하는 엔티티를 지정합니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/163714981203633674070dae14e1180ec0cc07e6c07ec.png)

#### 핸들러 구성

이벤트가 발생하면 핸들러가 호출되고, 매개 변수에 충돌 이벤트가 들어옵니다. 매개 변수에 들어온 이벤트에는 **해당 이벤트가 발생한 엔티티**와 **충돌한 상대 엔티티 정보**가 들어있습니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1637149819634e9577aefddb043fda7e86ea02bae286e.png)

# 확장 TriggerComponent 활용

#### 구조

**TriggerComponent**에는 엔티티에 충돌 이벤트가 발생했을 때 호출되는 자체 함수가 있습니다. 이 함수를 활용하여 엔티티 충돌 이벤트 이후의 액션을 추가할 수 있습니다. 하지만 **TriggerComponent**의 함수를 직접 편집할 수 없습니다. 그러므로 **TriggerComponent**를 확장한 컴포넌트에서 해당 함수를 편집해 충돌 처리를 추가해야 합니다. 확장된 컴포넌트는 원본 컴포넌트의 기능을 포함하고 있으므로, 엔티티에는 **확장된 TriggerComponent**만 추가하면 됩니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1657699624889b386c531319b425d99274f1b11566ce2.png)

#### TriggerComponent 확장하기

**Workspace**에서 **TriggerComponent**를 검색하여 선택합니다. 콘텍스트 메뉴에서 **Extend**를 선택하면 **MyDesk** 폴더에 **TriggerComponent**의 확장 컴포넌트가 생성됩니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1687754755702bcecc1f59a204f3ca931773a1849464d.png)

#### 함수 오버라이드

다른 스크립트 컴포넌트와는 달리, 확장된 **TriggerComponent**에는 몇 가지 함수를 오버라이딩할 수 있습니다. 이 함수들은 충돌 이벤트가 발생할 때 호출되는 것입니다. 이 함수를 추가하면 해당 함수의 정의부를 편집하여 오버라이딩할 수 있습니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1637149832831df2bfe1ef6384f3184ef8f84be296356.png)

오버라이딩할 수 있는 함수는 총 세 가지입니다. 다음은 함수별 호출 시점입니다.

- **OnEnterTriggerBody** :엔티티 간 충돌이 처음 발생했을 때 1회 호출됩니다.
- **OnStayTriggerBody**: 엔티티 간 충돌이 발생한 뒤, 두 엔티티가 겹쳐있는 동안 프레임마다 호출됩니다.
- **OnLeaveTriggerBody**: 엔티티 간 충돌이 종료될 때 1회 호출됩니다.

#### 매개 변수

매개 변수에 충돌 이벤트가 들어옵니다. 이벤트에는 엔티티와 충돌한 상대 엔티티 정보가 포함되어 있습니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16371498432816cef0f0507714aac9e2f70d25fb3a5ea.png)

Update 2025-11-17 PM 08:14


# 충돌 그룹 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

충돌 그룹을 만들고, 엔티티끼리의 충돌 여부를 설정하는 방법을 알아봅시다. 충돌 그룹을 사용해 특정 그룹끼리만 충돌할 수 있거나, 충돌을 무시할 수 있게 만들 수 있습니다.

# 충돌 그룹 기능

충돌 그룹은 메이플스토리 월드에 있는 여러 가지 충돌체를 특정 그룹 단위로 묶고, 그룹 간에 충돌 발생을 제어할 수 있는 기능입니다. 기본 충돌 그룹은 **Default, TriggerBox, HitBox**가 있으며 크리에이터가 만든 충돌 그룹을 포함해 **최대 15개**까지 만들 수 있습니다.

- **Default** : 충돌 그룹을 지정할 때 기본으로 지정되는 그룹, 충돌 그룹을 찾을 수 없을 때 **Default**로 지정됩니다.
- **TriggerBox** : **TriggerComponent**에 기본으로 지정되는 충돌 그룹
- **HitBox** : **HitComponent**에 기본으로 지정되는 충돌 그룹

충돌 그룹을 사용하면, 스크립트마다 충돌을 감지하는 컴포넌트를 사용해 충돌 감지 조건을 작성하지 않아도 되므로 최적화된 월드를 만드는 데 도움이 됩니다.

![ex](https://mod-file.dn.nexoncdn.co.kr/bbs/16587411005021f66cd226b1743c290d9e27eadfba017.png)

만약 **TriggerEnterEvent**을 활용해 플레이어가 아이템을 주울 수 있게 하려면 아래와 같은 조건을 작성해야 합니다. 하지만 충돌 그룹을 활용하면 아래의 조건을 작성할 필요가 없습니다. 엔티티마다 다른 충돌 그룹을 지정하고 두 그룹끼리만 충돌하도록 설정하면 되기 때문입니다.

```
Event Handler:
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    if not TriggerBodyEntity.PlayerComponent then
        return
    end
}
```

또한, 원하는 그룹끼리만 충돌할 수 있는 특성을 활용해 물리 시스템에 충돌 그룹을 적용할 수 있습니다. 물리에 대한 자세한 내용은 [물리 적용하기](/docs?postId=757)를 참고하세요.

#### 충돌체

충돌체(Collider)는 엔티티가 충돌을 발생시키기 위해 필요합니다. 충돌체는 원형(Circle), 사각형(Box) 형태를 사용할 수 있습니다. 크리에이터가 생성한 엔티티에 충돌체 크기와 오프셋 위치를 조정할 수 있습니다. 자세한 내용은 [엔티티의 충돌](/docs/?postId=175)을 참고하세요.

![ColliderType](https://mod-file.dn.nexoncdn.co.kr/bbs/1658731042366f8819537a3d742f99d669f5070219681.png)

#### 충돌 그룹 생성, 삭제

1. **Panels - Collision Groups**를 선택합니다. ![panel](https://mod-file.dn.nexoncdn.co.kr/bbs/165879872581169fd5a2cac2641078636ce0eb587c817.png)
2. **[Add Collision Group]** 버튼을 눌러 새로운 충돌 그룹을 생성하고, 이름을 변경합니다. ![AddCollision](https://mod-file.dn.nexoncdn.co.kr/bbs/16584743118836fa224b41e3445d79cdc7f15cf2a3886.png)
3. 오른쪽의 **[-]** 버튼을 클릭하여 충돌 그룹을 삭제할 수 있습니다.

#### 충돌 그룹 지정하기

충돌을 발생시키거나, 감지하는 컴포넌트마다 충돌 그룹을 지정할 수 있습니다. 대표적으로 **TriggerComponent, HitComponent, PhysicsColliderComponent**에서 충돌 그룹을 사용합니다. 이 중 **HitComponent**에서 충돌 그룹을 지정하는 방법을 살펴봅시다.

1. 충돌 그룹을 설정할 엔티티에 **HitComponent** 혹은 **확장한 HitComponent**를 추가합니다.
2. **CollisionGroup** 프로퍼티에서 충돌 그룹을 지정합니다.  ![CollisionPlayer](https://mod-file.dn.nexoncdn.co.kr/bbs/16644408634092cedbdbd0396471b85eb4a2b71e7547c.png)

> **Tip.** **CollisionGroup** 옆 ![openpanel](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_open_collision.png) **[패널 열기]** 버튼을 눌러 **CollisionGroup** 패널을 열 수 있습니다.

#### 충돌 그룹 매트릭스

충돌 그룹 매트릭스(Matrix)는 충돌 그룹끼리의 충돌을 허용할지 말지를 결정할 때 사용합니다. 충돌 그룹을 생성하면 매트릭스에 자동으로 새로운 충돌 그룹이 생성됩니다. 충돌 그룹끼리의 충돌 허용 여부는 체크 박스를 선택해서 간단하게 설정할 수 있습니다. 매트릭스에 적힌 충돌 그룹끼리의 관계를 확인하고 충돌을 허용하고 싶다면 체크 박스를 ![checkbox](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/checkbox.png) 활성화합니다.

1. **Panels - Collision Groups - Matrix**를 선택합니다.![Matrix](https://mod-file.dn.nexoncdn.co.kr/bbs/1658474513854b268965254e847a4933ae4b9a65b9c19.png)
2. 가로 세로의 그룹명을 확인한 뒤 충돌을 허용하면 체크 박스를 ![checkbox](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/checkbox.png) 활성화합니다.

# 활용 예제

플레이어 캐릭터는 떨어진 동전과 충돌할 수 있지만, 몬스터는 충돌할 수 없는 상황을 만들어 봅시다.

![collision](https://mod-file.dn.nexoncdn.co.kr/bbs/165872039921972bcfdc780bd46d3858e48a54e7f080c.gif)

> **Tip.** 예제에 설명되지 않은 Player와 Monster의 공격과 피격 구현은 **만들기 - 새로 만들기 - 기본**에서 확인할 수 있습니다. ![new](https://mod-file.dn.nexoncdn.co.kr/bbs/1663811465383f02d22699b7c4a378f4de49425cc96ec.png)

1. 새로운 충돌 그룹 **Player, Monster, Item**을 생성하고, 아래처럼 매트릭스를 설정합니다. ![CollisionMatrix](https://mod-file.dn.nexoncdn.co.kr/bbs/1658799000407ba127c7e1c444484b8b1c91e8a0892cf.png)
2. **DefaultPlayer**에서 **TriggerComponent**와 **PlayerHit**의 **CollisionGroup**을 **Player**로 지정합니다. ![PlayerCollision](https://mod-file.dn.nexoncdn.co.kr/bbs/16587303515703643b6e021f0420084a25b41f08825ea.png)
3. **Preset List - Monster**에서 원하는 모델을 선택하고 콘텍스트 메뉴를 열어 **Add to Workspace**를 누릅니다.
4. 선택한 Monster 모델에서 **TriggerComponent, HitComponent**의 **CollisionGroup**을 **Monster**로 변경합니다. ![monster](https://mod-file.dn.nexoncdn.co.kr/bbs/16587300227457fa8146e6bd3466bb179b865a3a40ca1.png)
5. Coin 모델에 **TriggerComponent**를 추가하고 **CollisionGroup**을 **Item**으로 지정합니다. ![itemCollision](https://mod-file.dn.nexoncdn.co.kr/bbs/165873019590583fa187d2e8a4b6ba01551f193284baf.png)
6. 새로운 스크립트 컴포넌트인 **ItemComponent**를 생성하고 Coin 모델에 추가합니다. 아래처럼 **PlayerComponent**와 부딪혔을 때만 코인이 사라질 수 있도록 작성합니다.```
Event Handler:
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    self.Entity:Destroy()
}
```

Update 2025-11-17 PM 08:14


# 물리 사용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드의 맵과 엔티티에 물리 법칙 적용 방법을 알아봅시다. 물리 법칙을 활용해 엔티티가 서로 충돌해 튕기거나, 포물선 운동을 하며 날아가거나, 엔티티가 서로 연결되어 움직이게 하는 등 물리를 활용한 움직임을 다양하게 만들어낼 수 있습니다. [엔티티의 충돌](/docs?postId=175)과 [충돌 그룹 만들기](/docs?postId=754)를 함께 학습하길 권장합니다.

# 맵에 물리 법칙 적용하기

기본 맵은 메이플스토리 맵 구성과 이동 원칙을 따르므로 물리 법칙은 기본 적용되어 있지 않습니다. 그러므로 물리 법칙을 적용하고 싶은 맵에 별도의 설정이 필요합니다. 물리 기능을 맵에서 사용하고 싶다면 반드시 해당 맵에 **![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/move.png) PhysicsSimulatorComponent**를 추가해야 합니다. ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/move.png) PhysicsSimulatorComponent의 Gravity 프로퍼티를 활용해 맵의 중력을 설정할 수 있습니다. Gravity의 x, y 값에 따라 맵의 중력 방향과 힘이 달라집니다. 만약 물리 법칙이 적용되는 모든 엔티티가 중력을 왼쪽 방향으로 작용하는 맵을 만들고 싶다면 x 값을 음수로 지정하고, 중력이 위로 작용하는 맵을 만들고 싶다면 y 값을 양수로 지정합니다. x, y 값을 0으로 설정해 무중력 맵을 만들 수도 있습니다.

1. ![hierachy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png)Hierachy - ![world](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_world_no.png) World - ![maps](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_maps_no.png) maps - ![map](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_map_no.png) map01을 선택합니다.
2. PhysicsSimulatorComponent를 추가하고, Gravity 값을 입력합니다.![simulator](https://mod-file.dn.nexoncdn.co.kr/bbs/16602791075369a9cbb9197f24d2bacf24d88f506eba3.png)

| (-5,-10) | (0,4) |
| --- | --- |
| ![-5](https://mod-file.dn.nexoncdn.co.kr/bbs/1659508219042208f13fd27134e3992c526d914be0b51.gif) | ![+4](https://mod-file.dn.nexoncdn.co.kr/bbs/16595082076157020bb152a804a76b314d6c9eedc6012.gif) |

#### 지면 만들기

기본 월드의 설정은 물리 엔티티들과 상호 작용이 일어나지 않기 때문에 기본 발판도 마찬가지로 물리 엔티티가 충돌하지 않고 뚫고 지나가게 됩니다. 물리 엔티티가 타일에 충돌하게 하려면 ![map](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/map.png) TileMapComponent, ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/Ect.png) CustomeFootholdComponent의 **PhysicsInteractable**를 활성화 합니다. ![map](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/map.png) **TileMapComponent의 PhysicsInteractable**을 활성화 해 물리 엔티티들이 충돌할 수 있는 지면과 벽 같은 역할을 할 수 있게 만들어봅시다.

1. ![hierachy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png)Hierachy - ![world](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_world_no.png) World - ![maps](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_maps_no.png) maps - ![map](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_map_no.png) map01 - ![map](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/map.png) TileMap을 선택합니다.
2. ![mapcomponent](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/map.png)TileMapComponent의 PhysicsInteractable 프로퍼티를 ![checkbox](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/checkbox.png)활성화합니다. ![interactable](https://mod-file.dn.nexoncdn.co.kr/bbs/1659508535605c9a75f4c314346f7a7917c8414ad7f19.png)

| PhysicsInteractable ![checkboxdisable](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/CheckboxOff.png) | PhysicsInteractable ![checkbox](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/checkbox.png) |
| --- | --- |
| ![off](https://mod-file.dn.nexoncdn.co.kr/bbs/16595852217680f7f0463ddd342b1bae1498907fbe9c8.gif) | ![on](https://mod-file.dn.nexoncdn.co.kr/bbs/16595852355591216ebd84358467e8a22501149d7856a.gif) |

# 엔티티에 물리 법칙 적용하기

엔티티에 **PhysicsRigidbodyComponent**를 엔티티에 추가해 엔티티의 물리 타입, 마찰력 등을 조정할 수 있습니다. 이때 **PhysicsColliderComponent**가 함께 추가되며 충돌체의 모양과 크기를 설정할 수 있습니다. 두 컴포넌트를 추가한 엔티티는 충돌할 수 있고, 관련 Event를 발생시킬 수 있습니다. 만약 **PhysicsRigidbodyComponent**를 추가하지 않는다면 질량이 무한히 큰 Static 타입 엔티티가 됩니다. 물리 엔티티는 세가지 타입으로 나뉘며 아래와 같은 특성이 있습니다.

- **Static**: 질량이 무한히 큰 엔티티로 취급되며 Dynamic 타입과 충돌할 수 있습니다. ![static](https://mod-file.dn.nexoncdn.co.kr/bbs/1659576952722cf8c504f8d504c7e9086e3bec94a09c9.gif)
- **Dynamic**: 엔티티가 물리 법칙에 따라 동작합니다. 물리 충돌이 가능한 다른 Entity와 충돌할 수 있습니다. ![dynamic](https://mod-file.dn.nexoncdn.co.kr/bbs/1659576966548ee80da29541e440eac920f8b56b56064.gif)
- **Kinematic**: 질량이 무한히 큰 엔티티로 취급되나 Static 타입과 다르게 속도를 지정해 움직일 수 있습니다 ![kinematic](https://mod-file.dn.nexoncdn.co.kr/bbs/165959362285423ac24e7dcdb4ca6b543886eee581004.gif)

##### 참고 가이드

- [엔티티에 물리 적용하기](/docs?postId=761)
- [다양한 물리 Joint 활용하기](/docs?postId=760)
- [엔티티의 충돌](/docs/?postId=175)

Update 2025-11-17 PM 08:14


# 엔티티에 물리 적용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

물리 법칙을 엔티티에 적용하고 물리 엔티티끼리 충돌할 수 있게 만들어 봅시다. 월드에 물리를 만드는 방법은 [물리 사용하기](/docs?postId=757)를 참고하세요.

# PhysicsRigidbodyComponent

Entity에 PhysicsRigidbodyComponent를 추가하면 Entity가 물리 엔진에 의해 제어됩니다. 또한 엔티티의 저항 계수, 마찰 계수, 질량 등 물리 연산에 영향을 주는 값을 설정할 수 있습니다. Entity가 PhysicsRigidbodyComponent와 PhysicsColliderComponent를 함께 포함하고 있어야 물리 법칙을 따르는 다른 엔티티와 충돌할 수 있습니다. PhysicsRigidbodyComponent의 주요 프로퍼티는 아래와 같습니다.

| 프로퍼티 | 설명 |
| --- | --- |
| BodyType | <ul><li>Static: 질량이 무한히 큰 엔티티로 취급되며 Dynamic 타입과 충돌할 수 있습니다.</li></ul><ul><li>Dynamic: 엔티티가 물리 법칙에 따라 동작합니다. 물리 충돌이 가능한 다른 Entity와 충돌할 수 있습니다.</li><li>Kinematic: 질량이 무한히 큰 엔티티로 취급되나 Static 타입과 다르게 속도를 지정해 움직일 수 있습니다</li></ul> |
| Mass | 질량 값을 설정합니다. Collider의 넓이와 질량의 값을 이용해 밀도 값을 계산합니다. |
| Friction | 마찰 계수를 결정합니다. 값이 작을수록 잘 미끄러집니다. |
| Restitution | Entity의 반발 계수를 설정합니다. 0이면 완전 비탄성 충돌, 1이면 완전 탄성 충돌에 가깝게 충돌합니다. |
| AngularDamping | 엔티티가 원운동을 할 때 각속도(회전 속도)의 변화에 대한 저항 계수를 설정합니다. 값이 클수록 각속도 변화에 더 많은 힘이 필요합니다. |
| LinearDamping | 선형 운동을 할 때 선형 속도 변화에 대한 저항 계수를 설정합니다. 값이 클수록 선형 속도 변화에 더 많은 힘이 필요합니다. |
| CollisionDetectionMode | 물리 충돌의 감지 방식을 설정합니다.<ul><li>Discrete: 충돌을 비연속적으로 확인합니다. 물체의 속도와 크기에 따라 충돌을 감지하지 못할 수 있습니다. 속도가 빠르거나, 크기가 작을수록 충돌을 감지하지 못하고 통과할 가능성이 있습니다.</li><li>Continuous: 충돌을 연속적으로 확인합니다. 물체가 충돌하지 못하고 통과하는 상황을 막습니다. 연산에 더 많은 자원이 필요합니다.</li></ul> |
| FixedRotation | true일 경우 물체가 물리 상호작용에 의한 회전을 하지 않습니다. |
| GravityScale | 엔티티가 PhysiecsSimulatorComponent의 Gravity 값에 영향을 받는 정도를 설정합니다. Gravity 값이 (0,-10)일 때 GravityScale 값이 1이라면 엔티티가 받는 중력 값은 (0,-10)이고,GravityScale 값이 2라면 (0,-20)만큼의 중력을 받게 됩니 |
| SleepingMode | 수면 모드를 설정합니다.<ul><li>StartAwake: 깨어있는 상태로 시작하나, 수면 상태로 전환할 수 있습니다.</li><li>StartAsleep: 수면 상태로 시작하나, 충돌 시 깨어납니다.</li><li>NeverSleep: 수면 상태로 전환되지 않습니다.</li></ul> |

> **더 알아보기**- 반발 계수: 충돌한 두 물체의 충돌 전후 상대 속도의 비 - 비탄성 충돌: 충돌 시 역학적 에너지가 손실됩니다. - 완전 비탄성 충돌: 충돌 시 역학적 에너지가 손실되며 충돌 후 두 물체가 하나가 되어 운동합니다. - 완전 탄성 충돌: 충돌 시 역학적 에너지가 보존되는 충돌입니다.

# 함수 설명

PhysicsRigidbodyComponent 함수에 따라 엔티티에 특정 방향으로 힘을 가해 움직이게 하거나, 원운동(회전운동)을 할 수 있게 만들 수 있습니다. ApplyForce 계열 함수와 ApplyImpulse 계열 함수는 해당 Entity에 대응하는 물리 강체의 질량 값에 영향을 받습니다. SetVelocity 계열의 속도 설정 함수는 질량 값과 관계 없이 속도를 지정할 수 있습니다.

#### 힘을 가하는 함수

`ApplyForce()`, `ApplyTorque()` 함수는 지속적인 힘을 가할 수 있습니다. 특정 Key를 눌러 지속적으로 특정 방향으로 힘 가하고 싶을 때가 해당됩니다. 매개 변수 force는 힘을 의미합니다. 해당 Entity에 대응하는 물리 강체의 질량 값에 영향을 받습니다.

#### 충격량을 적용하는 함수

`ApplyAngularImpulse()`, `ApplyLinearImpulse()` 함수는 일시적으로 짧은 충격을 가할 수 있습니다. 대포 발파, 방망이 휘두르기 같은 짧은 충격을 주는 동작이 해당됩니다. 해당 Entity에 대응하는 물리 강체의 질량 값에 영향을 받습니다. 매개 변수 Impulse는 충격량을 의미하며 일시적으로 짧은 충격을 가할 때 사용합니다.

#### 속도 설정 함수

`SetAngularVelocity()`, `SetLinearVelocity()` 함수는 질량 값과 관계 없이 엔티티의 속도를 설정할 수 있습니다.

# PhysicsColliderComponent

엔티티의 충돌체 크기를 정하고, 오프셋을 설정할 수 있습니다. 주로 **PhysicsRigidbodyComponent**와 함께 사용하지만, PhysicsRigidbodyComponent 없이 사용하는 엔티티는 Static 타입으로 취급됩니다. 충돌체의 타입, 크기, 오프셋 등을 설정하는 방법은 [엔티티의 충돌](/docs/?postId=175)을 참고하세요.

| 프로퍼티 | 설명 |
| --- | --- |
| ColliderType | 분류에 따라 충돌체의 형태를 다르게 설정할 수 있습니다.<ul><li>Circle: 원형 충돌체를 만듭니다.</li><li>Box: 사각형 모양 충돌체를 만듭니다.</li><li>Polygon: 다각형 충돌체를 만듭니다.</li></ul> |
| Collider | Edit 버튼을 눌러, 충돌체 크기를 설정할 수 있습니다. |
| CollisionGroup | 충돌 여부를 결정할 수 있는 충돌 그룹을 설정합니다. 새로운 충돌 그룹을 만들어 설정할 수 있습니다. |
| Density | 연결된 PhysicsRigidbodyComponent의 UseDensity가 true일 경우 사용할 밀도 값을 설정합니다. |
| UseCustomPhysicalProperties | Friction과 Restituion 값이 물리 강체에 적용됩니다. false일 경우 연결된 PhysicsRigidbodyComponent의 값을 사용합니다. |
| EnableContactEvent | PhysicsContactBeginEvent와 PhysicsContactEndEvent 발생 여부를 설정합니다. false일 경우 두 Event가 발생하지 않습니다. |
| IsSensor | true일 경우 물리적인 상호작용이 일어나지 않지만, 충돌 이벤트는 발생합니다. |
| ClientOnly | true일 경우 Client에서 물리 연산이 일어나며, Client 공간에서 함수 사용 및 Property 변경이 가능합니다. 물리 연산 결과가 다른 Clients와 동기화 되지 않습니다. false일 경우 Server 공간에서 함수 사용 및 Property 변경이 가능합니다. 물리 연산 결과가 다른 Clients와 동기화 됩니다. |

#### 실행 공간별 물리 연산 차이

**PhysicsRigidbodyComponent**의 대부분의 Property와 Function은 **PhysicsColliderComponent**의 ClientOnly 프로퍼티의 값에 따라 사용, 접근 가능한 실행 공간이 나뉘게 됩니다. ClientOnly에 따라 각각의 물리 World에서 연산되며, 이에 따라 서로 충돌하거나 영향을 주지 않습니다.

- **ClientOnly가 True일 때**: 해당 Entity의 물리 강체는 Client에서만 생성되고 물리 연산은 각각의 Client에서 계산됩니다. 다른 Client와 결과가 동기화되지 않습니다. Client에서만 관련 함수 사용 및 대부분의 Property 변경이 가능합니다.
- **ClientOnly가 False일 때**: 해당 Entity의 물리 강체는 Server와 Client에서 생성되고 물리 연산 결과에 따른 물리 강체의 위치가 Server 및 모든 Client간 동기화됩니다.Server에서만 관련 함수 사용 및 대부분의 Property 변경이 가능합니다.

# 충돌 그룹 설정하기

충돌 그룹을 설정해 물리 법칙을 적용한 엔티티끼리의 충돌 여부를 크리에이터의 의도에 따라 설정할 수 있습니다. PhysicsColliderComponent의 CollisionGroup을 지정하고, 그룹끼리의 충돌 여부를 선택합니다. 맵에 중력을 만들고, 다양한 탄성력을 가진 Dynatic 타입인 물리 엔티티를 맵의 위쪽에 배치한 후 월드를 시작하면, 엔티티들이 하강하며 부딪혀 서로 튕겨나갑니다. 자세한 충돌 그룹 설정 방법은 [충돌 그룹 만들기](/docs?postId=754)를 확인하세요.

# 활용 예제

PhysicsSimulatorComponent와 TileMapComponent의 PhysicsInteractable를 활용해 월드에 물리를 적용해야 예제를 확인할 수 있습니다.

#### 바닥에 있는 물체 공중으로 던지기

J 키를 눌렀을 때 지면에 배치한 엔티티를 공중으로 던져봅시다. 떠오른 엔티티는 중력을 받아 밑으로 떨어질 것입니다. ![eg1](https://mod-file.dn.nexoncdn.co.kr/bbs/16601123764643cfe3adec2534fb68a22b98573a3713c.gif)

1. PhysicsRigidbodyComponent, PhysicsColliderComponent를 추가한 오브젝트를 씬에 배치합니다.
2. 새로운 스크립트 컴포넌트를 생성한 뒤 아래와 같이 작성해 J를 눌렀을 때 오브젝트가 입력한 위치로 힘을 받아 이동합니다.

```
Method:
void Jump()
{
    self.Entity.PhysicsRigidbodyComponent:ApplyLinearImpulse(Vector2(0,10))
}

Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local key = event.key
    ---------------------------------------------------------
    
    if key == KeyboardKey.J then
        self:Jump()
    end
}
```

#### 충돌 그룹을 활용한 물리 엔티티 충돌

1. PhysicsRigidbodyComponent, PhysicsColliderComponent를 추가한 오브젝트를 여러개 배치하고, 각각의 Mass, Restitution 값을 다르게 설정합니다.
2. CollisionGroup에 새로운 물리 그룹을 추가하고 아래와 같이 서로 충돌할 수 있게 설정합니다. ![collisionmatrix](https://mod-file.dn.nexoncdn.co.kr/bbs/16601112357375799a6ba9d5e4f17b1d7096d2d0e02ba.png)
3. 시작을 눌러 엔티티끼리 충돌하는지 확인합니다. ![eg2](https://mod-file.dn.nexoncdn.co.kr/bbs/16601137220417735c37efe64470ab00e710e1c460242.gif)

##### 참고 가이드

- [물리 사용하기](/docs?postId=757)
- [충돌 그룹 만들기](/docs?postId=754)
- [다양한 물리 joint 활용하기](/docs?postId=760)

Update 2025-11-17 PM 08:14


# 다양한 물리 joint 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

물리를 사용하는 맵에서 특정 엔티티끼리의 운동 방식을 설정하는 방법을 알아봅시다. 다양한 JointComponent를 활용해 다양한 운동을 하는 엔티티를 만들어 월드 제작에 활용할 수 있습니다.

# Joint

Joint란 물리 법칙을 적용한 맵에서 특정 엔티티끼리만 연결해 서로 영향을 주고받을 수 있게 만드는 특정 연결부를 의미합니다. 아래의 그림과 같이 Entity A와 Entity B가 서로 영향을 주고받을 수 있도록 하는 연결부가 바로 Joint입니다. 기준 엔티티인 Entity A에 Joint 연결 위치(LocalAnchor A)를 설정하고 연결할 엔티티(TargetEntityRef)인 Entity B에도 Joint 연결 위치(LocalAnchor B)를 설정하면 Entity A와 Entity B가 연결됩니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1663837353395619ae9a35f0a47a481baf3f797bb5446.png)

Anchor의 위치는 엔티티의 ColliderOffset을 기준으로 떨어진 정도를 설정합니다. 서로 연결된 엔티티는 크리에이터의 의도에 따라 충돌할 수도 있고, 충돌하지 않을 수도 있습니다.

- **Entity A**: JointComponent를 가진 엔티티로 Joint를 추가해 다른 엔티티를 TargetEntityRef로 사용할 수 있습니다.
  - **ColliderOffset**: 엔티티의 PhysicsColliderComponent의 ColliderOffset입니다. LocalAnchor 위치의 원점으로 활용됩니다.
  - **LocalAnchorA**: JointComponent를 가진 Entity A의 Anchor를 설정합니다. Entity A의 ColliderOffset을 원점으로 합니다.
- **Entity B**: Joint를 연결할 엔티티로 Entity A의 JointComponent에서 TargetEntityRef로 지정합니다.
  - **TargetEntityRef**: Joint를 연결할 Entity입니다.
  - **LocalAnchorB**: Joint를 연결할 Entity인 Entity B의 Anchor를 설정합니다. Entity B의 ColliderOffset을 원점으로 합니다.

![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16638373662946c98c73c26ec4d78933f46034b0179c2.png)

#### Anchor

Joint가 동작하는 기준점입니다. 엔티티의 ColliderOffset 위치를 Anchor의 원점으로 삼습니다. 예를 들어 아래 그림처럼 LocalAnchor A, B의 값이 동일하게 (3,0)이라도 기준이 되는 엔티티의 offset이 다릅니다. LocalAnchor는 다른 곳에 위치하고, Entity A, B 동작의 기준점은 지점입니다.

LocalAnchor A의 기준 Offset은 Entity A이고 LocalAnchor B의 기준 Offset은 Entity B입니다.

![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1663839068005e7743548cf8e44349be58cdf0cbf9300.png)

![anchor1](https://mod-file.dn.nexoncdn.co.kr/bbs/16638363593571f7fb2dde7e7440cb0c1b9447f4123e4.gif)

#### Motor

Motor를 사용하면 Entity에 특정 방향으로 운동하도록 힘을 가합니다. RevoluteJointComponent, WheelJointComponent, PrismaticJointComponent에서 사용합니다. 모터를 사용하기 위해 MotorEnable 프로퍼티를 true로 설정하면 목표 속도에 맞게 엔티티가 돕니다. 목표 속도란 MotorSpeed의 값을 의미합니다. 예를 들어 MotorSpeed가 100이고, 속도가 100에 도달한 상태에서 MotorSpeed 값이 10으로 줄게 되면 속도가 감소합니다.

![motor](https://mod-file.dn.nexoncdn.co.kr/bbs/16638363279474aea43c2e0f849e78e12f9371b760269.gif)

# JointComponent 종류

6가지 DistanceJointComponent, RevoluteJointComponent, PrismaticJointComponent, PulleyJointComponent, WeldJointComponent, WheelJointComponent가 있습니다. 종류마다 다른 특성을 가지고 있으므로 크리에이터가 제작하고 싶은 의도에 맞는 JointComponent를 사용해야 합니다.

#### DistanceJointComponent

DistanceJointComponent는 두 엔티티의 거리 관련 제한을 설정합니다. LocalAnchorA, B 사이의 거리(Length)가 일정하게 유지됩니다.

| 주요 프로퍼티 | 설명 |
| --- | --- |
| **Length** | Joint로 연결된 두 Entity가 유지할 거리를 설정합니다. |

![distance](https://mod-file.dn.nexoncdn.co.kr/bbs/1660634671012e4dbb294cfa94678b6af5dfc7804bc7f.gif)

#### RevoluteJointComponent

RevoluteJoint는 엔티티의 회전과 관련된 제한을 설정합니다. UseLimits를 활성화한 후, LowerAngle, UpperAngle를 활용해 회전 각도를 제한할 수 있습니다. 엔티티가 회전할 때는 LocalAnchorA와 B가 만나는 지점을 공통의 Anchor로 사용합니다. 또한 Motor를 사용하면 Anchor를 기준으로 회전하는 힘을 받을 수 있습니다.

| 주요 프로퍼티 | 설명 |
| --- | --- |
| **UseLimits** | 상대적 각도에 제한을 설정할지 여부를 결정합니다. |
| **LowerAngle** | 최소 상대 각도를 설정합니다. Entity의 Local Vector2(1, 0)을 기준으로 합니다. |
| **UpperAngle** | 최대 상대 각도를 설정합니다. Entity의 Local Vector2(1, 0)을 기준으로 합니다. |
| **MotorSpeed** | Motor의 목표 속도를 설정합니다. 양수일 경우 CCW(반시계) 방향으로 회전합니다. |

![revolute](https://mod-file.dn.nexoncdn.co.kr/bbs/1660634686437edf5ce687bf04396952bf91d804c774c.gif)

#### PrismaticJointComponent

PrismaticJointComponent는 엔티티가 축을(LocalAxis) 따라 엔티티가 선형 운동하도록 제한을 설정합니다. LowerTranslation, UpperTranslation 값을 설정해 엔티티가 이동하는 최대, 최소 거리를 제한할 수 있습니다. LocalAxis의 위치는 LocalAnchor를 기준으로 합니다.

| 주요 프로퍼티 | 설명 |
| --- | --- |
| **UseLimits** | 상대적 이동 거리 제한을 둘지 여부를 설정합니다. |
| **LowerTranslation** | 최소 상대적 이동 가능 거리를 설정합니다. |
| **UpperTranslation** | 최대 상대적 이동 가능 거리를 설정합니다. |
| **MotorEnable** | Motor를 사용할지 여부를 설정합니다. True일 경우 연결된 Entity가 LocalAxis 방향의 힘을 받습니다. |
| **MotorSpeed** | Motor의 목표 속도를 설정합니다. MotorEnable이 True여야 동작합니다. |

![primatic](https://mod-file.dn.nexoncdn.co.kr/bbs/16606347060771a318324cf13474ba3e52d4b6f847f92.gif)

#### PulleyJointComponent

PulleyJointComponent는 LocalAnchor와 GroundAnchor 사이의 거리들의 총길이 합이 일정하게 유지됩니다. 특정 엔티티의 선 길이가(Length) 짧아지면 다른 엔티티의 선 길이가 길어지며 선의 총길이는 유지됩니다. 총길이는 Entity A와 GroundAnchorA 사이의 최초 거리 + Ratio * Entity B와 GroundAnchorB 사이의 최초 거리 공식에 따라 정해집니다. 각 **엔티티의 선**은 LocalAnchor와 GroundAnchor 사이의 거리로 GroundAnchor의 원점은 LocalAnchor의 위치입니다. **Ratio**는 Entity와 GroundAnchor 사이의 거리가 줄어드는 비율을 결정합니다. 만약 Ratio가 3일 때 Entity A의 선이 3만큼 줄어든다면, Entity B와의 선은 1만큼 늘어나도 Entity A의 선은 Entity B의 선에 비해 구속력(constraint force)이 1/3입니다.

| 주요 프로퍼티 | 설명 |
| --- | --- |
| **Ratio** | PulleyJoint를 이루는 양쪽 가상의 줄의 구속력 비율을 설정합니다. |

![pulley](https://mod-file.dn.nexoncdn.co.kr/bbs/1660634724636c6a1887dec234a97ad13994d906a7ebc.gif)

#### WeldJointComponent

연결된 엔티티끼리 함께 움직이도록 설정합니다. 마치 꼬챙이에 양 끝을 끼운 것처럼 서로 일정한 거리가 벌어져 있는 상태로 움직입니다. 연결된 엔티티는 상대적 이동 및 회전이 제한됩니다.

![weld](https://mod-file.dn.nexoncdn.co.kr/bbs/1660634741001b728a6793af4499e8f64070bcf551639.gif)

#### WheelJointComponent

WheelJoint는 연결된 엔티티가 바퀴처럼 동작하도록 제한을 설정합니다. Motor를 사용한 TargetEntityRef는 MotorSpeed 값을 목표 속도로 사용합니다.

| 주요 프로퍼티 | 설명 |
| --- | --- |
| **MaxMotorTorque** | 목표 모터 속도에 도달하기 위한 Joint의 모터에 적용할 수 있는 최대 힘을 설정합니다. |
| **MotorEnable** | Motor를 사용할지 여부를 설정합니다. True일 경우 연결된 Entity가 LocalAxis 방향의 힘을 받습니다. |
| **MotorSpeed** | Joint의 목표 모터 속도를 설정합니다. MotorEnable이 True여야 동작합니다. |

![wheel](https://mod-file.dn.nexoncdn.co.kr/bbs/16606347549715160d2650c9c4197a2b2b2ba189ecc6a.gif)

# Joint 추가하기

JointComponent를 추가하는 방법은 모두 동일합니다.

1. PhysicsRigidbodyComponent, PhysicsColliderComponent를 추가한 엔티티를 두 개 생성하고, 배치합니다.
2. 사용하고 싶은 JointComponent를 추가합니다. **Size**에 생성할 Joint 개수를 입력합니다. ![size](https://mod-file.dn.nexoncdn.co.kr/bbs/1690259361892e5e2bdd02e44452fb93da6ac7a30c4d6.png)
3. **TargetEntityRef**로 사용할 엔티티 선택한 후, LocalAnchor A, B의 위치를 설정합니다. ![joint](https://mod-file.dn.nexoncdn.co.kr/bbs/1690259508600e65c1ca226c84bcfbdfa719299acb7a5.png)

# 활용 예제

RevoluteJointComponent를 활용해 공을 튀기는 간단한 게임을 만들어 봅시다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/1660804708258db7c651cc14d4beb87fc23eee95cc3c8.gif)

#### 준비

1. 타일맵모드를 **RectTile**로 변경합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16902702934039459adc7e8234eb4950ba11f2d11493f.png)
2. **Hierachy - World - maps - map01 - PhysicsSimulatorComponent**를 추가합니다.
3. **Hierachy - World - maps - map01 - RectTileMap - RectTileMapComponent - PhysicsInteractable**을 활성화합니다.
4. 공이 이리저리 부딪힐 수 있도록 **Static** 타입 물리 엔티티를 배치합니다. 아래가 뚫린 사다리꼴 모양으로 배치해 봅시다.
  - SpriteRUID: **1ce2eff829ae4346bc89a3f0a357ac0e** ![static](https://mod-file.dn.nexoncdn.co.kr/bbs/169026003093236f6d51367a14dd4a906324c452a0d7d.png)

#### 공 만들기

1. 새로운 **Ball** 모델을 만들고, **PhysicsRigidbodyComponent, PhysicsColliderComponent**를 추가합니다.
  - Ball SpriteRUID: **164e94bea20441adac2af9c6f800bdf3**
2. **PhysicsRigidbodyComponent**의 **BodyType**을 **Dynamic**으로 변경합니다.
3. **PhysicsColliderComponent**의 **ColliderType**을 **Circle**로 변경하고, 스프라이트 크기에 맞게 **CircleRadius**를 조절합니다.
4. 중력을 받아 공이 떨어질 수 있도록, 공중에 배치합니다.

#### 장애물 만들기

1. 새로운 **Obstacle** 모델을 만들고, **PhysicsRigidbodyComponent, PhysicsColliderComponent**를 추가합니다.
  - SpriteRUID: **3ada0e4cc7f44cb988932f1b183ec778**
2. **PhysicsRigidbodyComponent**의 **BodyType**을 **Static**으로 변경합니다.
3. **PhysicsColliderComponent**의 **ColliderType**을 **Circle**로 변경하고, 스프라이트 크기에 맞게 **CircleRadius**를 조절합니다.

#### 레버 만들기

1. 새로운 **LeftEntity, LeftBar** 오브젝트 엔티티를 만들고, **PhysicsRigidbodyComponent, PhysicsColliderComponent**를 추가합니다.
  - LeftEntity SpriteRUID: **e75cac80f719471fa482195531ed57cc**
  - LeftBar SpriteRUID: **0308ac89b10843fcab6384aa43f6ae22**
2. 원형 모양 엔티티에 **RevoluteJointComponent**를 추가하고, **Joint**에 **1**을 입력합니다. TargetEntityRef에 LeftBar를 지정하고, **LocalAnchorB, LowerAngle, UpperAngle, MotorSpeed, UseLimits** 값을 아래와 같이 지정합니다. ![left](https://mod-file.dn.nexoncdn.co.kr/bbs/16902694608421c03f7e8bfc44e6eba274aefaef0bbf7.png)
3. 위의 두 엔티티를 복사해 반대쪽을 만듭니다. ![right](https://mod-file.dn.nexoncdn.co.kr/bbs/1690269890755b731c1c566234f999b810610411cf45f.png)
4. 새로운 **Swing** 스크립트 컴포넌트를 생성하고, **DefaultPlayer**에 추가합니다.
5. N, M을 눌렀을 때 RevoluteJoint의 모터를 사용하고, 떼면 사용하지 않도록 아래와 같이 입력합니다.```
Property:
[Sync]
Entity Left = /maps/map01/LeftEntity
[Sync]
Entity Right = /maps/map01/RightEntity

Method:
[server]
void MoveLeft(boolean enable)
{
    self.Left.RevoluteJointComponent:SetMotorEnable(1, enable)
}

[server]
void MoveRight(boolean enable)
{
    self.Right.RevoluteJointComponent:SetMotorEnable(1, enable)
}

Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------
    if key == KeyboardKey.N then
    	self:MoveLeft(true)
    elseif key == KeyboardKey.M then
    	self:MoveRight(true)
    end
}

[service: InputService]
HandleKeyReleaseEvent(KeyReleaseEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------
    if key == KeyboardKey.N then
    	self:MoveLeft(false)
    elseif key == KeyboardKey.M then
    	self:MoveRight(false)
    end
}
```
6. 시작을 눌러 N, M을 눌렀을 때 막대가 각각 움직이는지 확인합니다.

##### 참고 가이드

- [물리 사용하기](/docs?postId=757)
- [충돌 그룹 만들기](/docs?postId=754)
- [엔티티에 물리 적용하기](/docs?postId=761)

Update 2025-11-17 PM 08:14


# 아이템 생성 및 삭제

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 아이템 생성과 삭제 기능을 알아봅니다. 제작할 예제는 다음과 같습니다.

- 맵에 놓인 아이템을 먹을 때마다 인벤토리에 랜덤한 아이템이 생성
- 아이템을 먹으면, 5초 뒤 아이템이 놓여있던 자리에 다시 생성
- 맵에 놓인 다른 아이템을 먹을 때마다 인벤토리에 있는 모든 아이템 삭제

# 아이템 테이블 만들기

먼저 개별 아이템을 만들어 봅시다. 개별 아이템은 아이템 테이블에서 정의할 수 있습니다. 아이템 테이블은 **DataSet**으로 만듭니다. **Workspace - MyDesk**에서 콘텍스트 메뉴를 열어 **Create DataSet**을 선택합니다. 그리고 이름을 **UserItemDataSet**으로 설정합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1659661729006e5721ddcf57b483b988411014b023136.png)

> **더 알아보기** 아이템을 생성할 때, 아이템 테이블에 정의된 데이터를 넘겨주는데, 만일 아이템 테이블을 다른 이름으로 만들면, 데이터를 넘길 수 없습니다. 따라서 아이템 테이블의 이름은 반드시 **UserItemDataSet**으로 생성합니다.

생성된 **UserItemDataSet**을 더블 클릭하여 데이터 에디터를 엽니다. 우선 컬럼 2개를 추가하고 컬럼 명을 다음과 같이 설정합니다. ![item_3copy](https://mod-file.dn.nexoncdn.co.kr/bbs/163470329201303a32b2e6abd46be91bb61406acce0cc.png)

> **더 알아보기** 아이템에서 **Name, IconRUID, Description**은 꼭 필요한 데이터이므로, 위와 동일한 이름으로 생성하세요.

여기에 제작 중인 게임에 필요한 아이템 관련 데이터들을 추가합니다. 이번 예제에서는 **MaxStackCount, EffectAmount** 컬럼을 추가하겠습니다. ![item_4](https://mod-file.dn.nexoncdn.co.kr/bbs/163470336846867242a6390754c5694eaac3cd773da56.png)  각 컬럼 아래에 아이템을 만들고 데이터를 작성합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1656659510837b79b1579311e41a29c7cfdd31709bde7.png)  아이템 아이콘으로 사용할 이미지를 **Workspace**에 추가합니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/163470407132182780528c94e4a88b622e8d63bf3c3f9.png) ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16347040853985fca895297de463887ac192f38bcdca2.png) ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1634704096454abc93bc20fb14144bdc2ab9d9311482e.png) ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1634704110489ee2e5ad6aa8544abb51ffa5bff0398a2.png) ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1634704122717081685317e9a425d9355cdc45ce05ce6.png)  **Workspace - MyDesk**에서 콘텍스트 메뉴를 열어 **Import From - Import Image**를 선택하고 이미지를 추가합니다. ![ImportImage](https://mod-file.dn.nexoncdn.co.kr/bbs/16878275447201b5a1f02e9c140018a1ed696ef1c8e69.png) ![19-1](https://mod-file.dn.nexoncdn.co.kr/bbs/165665937154925a357cbc58a4577b508c57c30a2c163.png)  이미지 RUID를 아이템 테이블의 **IconRUID**에 입력합니다. 이미지의 RUID는 각 이미지의 콘텍스트 메뉴에서 **Copy RUID**를 클릭해 복사할 수 있습니다. ![copyruid](https://mod-file.dn.nexoncdn.co.kr/bbs/16878279122598c71d67dc23e4ea6981bf22394a22507.png)  복사한 RUID를 아이템 테이블의 **IconRUID**에 붙여넣기 합니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/165665958375411fb5a6f0fd74ab09659dc62686d344d.png)

# ItemType 생성

**Workspace - MyDesk**에서 콘텍스트 메뉴를 열고 **Create Scripts - Create ItemType**을 클릭해 새로운 **ItemType**을 생성합니다. 새 **ItemType**의 이름을 **Potion**으로 설정합니다.

> **Tip** 아래 좌측 예시처럼 제작하는 게임 환경에 따라 개별 아이템 단위로 ItemType을 생성할 수도 있지만, 일반적으로는 우측 예시와 같이 동일한 유형별로 ItemType을 생성하는 것을 추천합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16357553281761f7ea579470447b79b837aeb3f0bc3fa.png) ![7-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635755340293013f41e698e14213b3b7f609fc657fa6.png)

생성한 ItemType인 **Potion**을 열고 포션 타입 아이템에 필요한 프로퍼티를 추가합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/163470344820046b9ef55b9db485495f82429417850eb.png)  `OnCreate()` 함수를 추가한 뒤, 내용을 작성합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16357553544880d1191f6ddc446598724d2fce9e3ef88.png)

```
void OnCreate()
{
    self.Name = self.ItemTableData:GetItem("Name")
    self.MaxStackCount = tonumber(self.ItemTableData:GetItem("MaxStackCount"))
    self.EffectAmount = tonumber(self.ItemTableData:GetItem("EffectAmount"))
    log("Item is Created!")
}
```

> **더 알아보기** 아이템 생성 시 OnCreate가 호출되며, 아이템 테이블의 데이터가 아이템 객체로 넘어옵니다. 아이템 객체로 넘어온 데이터는 self.ItemTableData:GetItem("컬럼명") 형식으로 접근할 수 있습니다.

위에 생성한 ItemType을 복제하여 다음 세 가지 ItemType을 새로 추가합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1687829481362e88637cb403f453e851344c7d782fd0c.png)

# 인벤토리 UI 추가

이번에는 생성된 아이템을 표시할 인벤토리 UI를 추가합니다. 상단 메뉴에 ![ui](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_ui.png) 버튼을 눌러 UI 에디터를 엽니다. **Preset List**에서 **[인벤토리]**, **[버튼모음]** UI를 추가합니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1659959415239e86dd162e65c4b1e82086102ba82efd4.png)  만일 **Inventory** 엔티티의 **UIInventory** 컴포넌트에 **InventoryBtnPath**가 비어있으면, ![Common_menu](https://mod-file.dn.nexoncdn.co.kr/bbs/163453706197553d527cb3ea34392bc2829f15976f3d8.png) 햄버거 메뉴를 열어 **Reset All Properties**를 선택합니다. 그러면 아래와 같이 정상적인 경로가 설정됩니다. ![22-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16373057873214e1d4994f8834292a9904f34fb279d3c.png)

# 아이템 엔티티 배치 및 기능 추가

![ui](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_ui.png)버튼을 눌러 UI 편집모드를 종료하고, 맵에 타일과 아이템 엔티티를 다음과 같이 배치합니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/1637756481320c2e0c4ab0011419b8c001eaa398df0b6.png)  배치한 아이템 엔티티에 기능을 부여할 스크립트 컴포넌트를 생성합니다. 새 스크립트 컴포넌트의 이름을 **GiftBox**로 설정합니다. ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/1656659256401f67aae760e8b43a5b62fb01dcbc612e2.png)  **GiftBox** 스크립트에 **TriggerEnterEvent**를 추가합니다. ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/16347043790103b40809a1bb9400ba0ff2c6ef72bf4ec.png)  그리고 아래와 같이 내용을 작성합니다.

```
[self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    --아이템 엔티티와 충돌한 엔티티의 인벤토리를 받고, 인벤토리가 없으면 리턴합니다.
    local inventory = TriggerBodyEntity.InventoryComponent
    if inventory == nil then return end
     
    --UserItemDataSet에 추가되어 있는 아이템들의 이름과 아이템 타입 명을 Table로 만들어 줍니다.
    local itemNames = {{"RedPotion",Potion},
        {"BluePotion",Potion},
        {"IronSword",Weapon},
        {"IronShield",Armor},
        {"GreenShirts",Clothes}}
     
    --아이템들 중 획득할 아이템을 랜덤으로 선정합니다.
    local index = _UtilLogic:RandomIntegerRange(1,5)
    local getItemName = itemNames[index]
     
    --아이템을 생성하여 충돌한 엔티티의 인벤토리에 넣어줍니다.
    _ItemService:CreateItem(getItemName[2],getItemName[1],inventory)
      
    --충돌한 엔티티의 인벤토리에 아이템이 생성되면, 해당 아이템을 없앤 뒤 5초 후 다시 나타나도록 예약을 걸어둡니다.
    local myEntityPath = self.Entity.Path
    _TimerService:SetTimerOnce(function()
            --Path는 이 컴포넌트가 붙어있는 엔티티의 Path를 넣어줍니다.
            local myEntity = _EntityService:GetEntityByPath(myEntityPath)
            myEntity:SetEnable(true)  
        end, 5)
      
    self.Entity:SetEnable(false)
}
```

**GiftBox** 컴포넌트와 **TriggerComponent**를 맵에 배치한 아이템 엔티티에 추가합니다. ![26](https://mod-file.dn.nexoncdn.co.kr/bbs/1659662714941efaa23b3166645ae97fec8b1f42f581c.png)  ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 누른 뒤 테스트해 봅시다. 아이템 엔티티에 캐릭터가 닿을 때마다 인벤토리 UI에 아이템이 생성되는 것을 확인합니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/165665955361463219cb3037e43e6893464ccb78a94d4.png)

# 아이템 삭제

**Preset List**에서 임의의 엔티티를 배치합니다. ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/1637756501388a259dddae19f4870bed5f7494303f2dc.png)  그리고 **ItemDelete**라는 이름의 스크립트 컴포넌트를 추가합니다. ![29](https://mod-file.dn.nexoncdn.co.kr/bbs/1637756514221ac0df63469bf4810bf3a6c4f7f31222a.png)  **ItemDelete** 스크립트를 열고, **TriggerEnterEvent**를 추가합니다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/163775652372809172ca409f541e295bb35586ee89931.png)  그리고 아래와 같이 내용을 작성합니다.

```
[self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    --Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local inventory = TriggerBodyEntity.InventoryComponent
    local items = inventory:GetItemList()
    
    for index, item in pairs(items) do
    	_ItemService:RemoveItem(item)
    end
}
```

위에서 배치한 엔티티에 **TriggerComponent**와 **ItemDelete** 컴포넌트를 추가합니다. ![32](https://mod-file.dn.nexoncdn.co.kr/bbs/16377565496814502cb717a044fa5be2239c99a623f8b.png)  ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 누른 뒤 테스트해 봅시다. 좌측 엔티티에 캐릭터가 닿을 때마다 인벤토리에 추가된 모든 아이템이 삭제되는 것을 확인합니다.

Update 2025-11-17 PM 08:14


# 배지 등록하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

배지는 크리에이터가 설정한 특정 미션을 달성할 때 이용자가 획득할 수 있는 업적을 의미합니다. 배지는 유저의 달성 목표를 보여주기 위해 사용하거나, 수집 욕구를 촉발해 월드를 끊임없이 즐길 수 있게 만드는 용도로 사용합니다.

# 배지 등록하기

배지를 등록하는 방법은 두 가지입니다. 메이플스토리 월드 [공식 홈페이지](https://maplestoryworlds.nexon.com/) 혹은 메이커 내에서 등록이 가능합니다. 등록 화면과 절차는 동일하므로 크리에이터가 선호하는 곳에서 배지를 등록할 수 있습니다. 배지를 등록할 때는 배지 등급, 획득 시간, 배지 섬네일을 필수 입력해야 하며, 필요에 따라 배지 설명을 추가할 수 있습니다.

![Badge Registration](https://mod-file.dn.nexoncdn.co.kr/bbs/16680711660191aafa3cb845b49caa729a42385bf1ef1.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 배지 등급 | 배지의 등급은 노멀, 레어, 에픽 3가지입니다. 각 등급은 크리에이터가 정의할 수 있습니다. 배지 구분이 어려운 경우 아래와 같은 구분 방식을 참고할 수 있습니다. 배지 등록 시 반드시 이름을 입력해야 합니다.<ul><li>**노멀**: 획득하기 쉬운 난도의 업적일 경우</li><li>**레어**: 도달하기 어려운 난도의 업적일 경우</li><li>**에픽**: 도달하기 매우 어려운 난도의 업적일 경우</li></ul> |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 배지 이름 | 유저에게 보일 배지 이름을 입력합니다. 최대 50자까지 작성할 수 있습니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 획득 기한 | 월드에서 유저가 배지를 획득할 수 있는 기한을 정합니다.<ul><li>**무기한**: 월드에서 배지를 언제든지 획득할 수 있습니다.</li><li>**유기한**: 정해진 기간 내에만 배지를 획득할 수 있게 설정할 수 있습니다. 획득 시작일과 종료일, 시간까지 설정할 수 있습니다. 설정한 획득 시작일이 되면 배지의 상태가 **획득 가능** 상태로 변경되며 배지 획득이 가능해집니다.</li></ul> |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 출시 여부 | 배지의 출시 여부를 설정합니다. 그룹 월드의 경우 그룹장만 출시 여부를 설정할 수 있습니다.<ul><li>**미출시**: 배지를 출시하지 않습니다. 출시한 배지를 미출시 상태로 변경하면 웹 상점 및 월드 상품 리스트에서 제외되고, 판매할 수 없습니다. 이미 배지를 가진 유저의 배지 목록에서도 보이지 않습니다.</li><li>**출시**: 배지를 출시합니다.</li></ul> |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 배지 섬네일 | 유저가 획득하는 배지의 이미지 파일을 업로드할 수 있습니다. 2MB 이하의 jpg, png 파일을 1개만 등록 가능하며 120x120 px 크기의 이미지 사용을 권장합니다. 배지 등록 시 이미지를 반드시 등록해야 합니다. |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 배지 설명 | 유저에게 보일 배지 설명을 입력할 수 있습니다. 설명 입력은 선택 사항입니다. |

#### 웹에서 등록

1. 로그인 후 월드 만들기 선택, 배지를 생성할 월드를 선택합니다.
2. **배지 관리 - 배지 등록**을 선택합니다.
3. 배치 등록 창에서 배지 등급, 이름, 이미지, 획득 기한을 정한 뒤 등록을 누릅니다.
4. 배지 관리 창에서 등록한 배지가 추가되고, 상태가 **미출시**인지 확인합니다.

#### 메이커에서 등록

1. **Panels - Badge Viewer**를 엽니다.
2. 마우스 오른쪽을 눌러 콘텍스트 메뉴를 열고, **Create New Badge**를 선택합니다.
3. 열린 새 창에서 웹에서의 등록과 마찬가지로 배지 등급, 이름, 이미지, 획득 기한을 정한 뒤 등록을 누릅니다.
4. 등록한 배지가 추가되고, 상태가 **미출시**인지 확인합니다.

# 배지 상태

배지의 상태는 총 5개로 구분됩니다. 메이커에서 테스트할 때는 모든 상태에서 획득할 수 있습니다. 월드에서 실제로 획득하기 위해서는 배지의 상태가 **획득 가능**이어야 합니다.

| 이름 | 설명 |
| --- | --- |
| 미출시 | 출시 여부를 '미출시'로 설정한 상태입니다. 판매 기간이 되어도 월드 웹 배지 페이지나 클라이언트 내에서도 노출되지 않고 획득도 불가합니다. 플레이어가 보유한 배지도 리스트에서 확인이 불가합니다. |
| 획득 대기 | 획득 기간의 시작일 이전에 등록이 완료된 상태로 시작일에 맞춰 자동으로 획득 가능 상태로 변경됩니다. 출시 상태로 획득 기간을 지정하면, 획득 시작일에 맞춰 **'획득 가능'**__ 상태로 자동 변경됩니다. |
| 획득 가능 | 배지를 획득할 수 있습니다. 획득 기간을 설정한 경우, 해당 기간에만 배지를 획득할 수 있습니다. |
| 획득 불가 | 획득 가능 기간이 지난 상태로 배지를 획득할 수 없습니다. |
| 제제 중 | 제재 처리된 배지로 출시 여부, 획득 기간 관계없이 획득이 불가능합니다. 크리에이터는 제재 배지를 수정할 수는 있으나, 제재 상태 관련 문의는 고객센터에 문의해야 합니다. |

# 그룹 월드에서 상품 등록

배지 등록, 수정 모두 **그룹장**만 가능합니다.

##### 참고 가이드

- [배지 관리하기](/docs/?postId=663)
- [배지 서비스 활용하기](/docs/?postId=664)

Update 2025-11-17 PM 08:14


# 배지 관리하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

배지 뷰어와 활용 방법, 배지 상태별 기능 제한에 대해 알아봅시다.

# Badge Viewer

메이커에서 배지를 등록하고, 관리할 수 있는 창입니다. 등록한 배지는 배지 등급에 따라 각각의 폴더에 자동으로 분류됩니다. 주요 콘텍스트 메뉴는 아래와 같습니다.

![badgeviewer](https://mod-file.dn.nexoncdn.co.kr/bbs/1664444765338bb3429f3b420435394c759bd538122c7.png)

| 메뉴 이름 | 설명 |
| --- | --- |
| Copy Badge ID | 등록한 배지의 ID를 복사합니다. |
| Copy Badge Thumbnail RUID | 등록한 배지의 섬네일 RUID를 복사합니다. |
| Create New Badge | 새로운 배지를 생성합니다. |
| Edit Badge | 등록한 배지를 수정합니다. |
| Open Badge List(Web) | 생성한 배지들의 상태를 확인할 수 있는 외부 브라우저 창을 엽니다. |
| Refresh Viewer | 배지 목록을 새로고침 합니다. |

등록한 배지에 마우스를 올려 배지 정보를 확인할 수 있습니다. ![Information](https://mod-file.dn.nexoncdn.co.kr/bbs/16681333983706a072184cfb147a29d035c8591a8b10c.png)

# 배지 상태별 기능 제한

배지 상태에 따라 기능이 제한됩니다. 아래의 표를 참고하세요. 전체 배지를 검색할 때 획득 대기 상태인 배지를 노출하지 않으려면, 해당 배지를 미출시 상태로 변경하여 조회되지 않도록 할 수 있습니다.

| 상태 | 월드에서 정보 조회 | 월드에서 배지 노출 | 실제 획득 | 테스트 획득 | 메이커/웹 정보 수정 | 공식 홈페이지 배지 노출 |
| --- | --- | --- | --- | --- | --- | --- |
| **미출시** | 불가 | 노출 안 됨 | 불가 | 가능 | 가능 | 노출 안 됨 |
| **획득 대기** | 가능 | 노출 | 불가 | 가능 | 가능 | 노출 |
| **획득 가능** | 가능 | 노출 | 가능 | 가능 | 가능 | 노출 |
| **획득 불가** | 가능 | 노출 | 불가 | 가능 | 가능 | 노출 |
| **제재 중** | 가능 | 노출 | 가능: 획득 시 제재 중 표시 | 가능: 획득 시 제재 중 표시 | 가능 | 노출 안 됨 |

#### 배지 제재 안내

크리에이터가 제작한 배지는 메이플스토리 월드의 [운영 정책](https://maplestoryworlds.nexon.com/legal/policy)에 따라 제재받을 수 있습니다. 제재받은 배지 이름은 월드 유저에게는 운영정책 위반 명칭으로 변경되어 보이게 됩니다. 더불어 배지 섬네일이 변경됩니다. 배지의 제재 내용은 Badge Viewer의 툴팁에서 확인할 수 있습니다.

제재 상품 관련 문의가 있다면 [고객센터](https://cs.nexon.com/HelpBoard/Nexon?gamecode=363)를 이용해 주세요.

# 메이커와 월드에서 차이

배지를 얻는 환경이 어디인지에 따라 아래와 같은 차이점이 있습니다.

| 항목 | 메이커 | 출시된 월드 |
| --- | --- | --- |
| 배지 획득 정보 | 테스트 플레이 시작 시에는 항상 배지가 없는 것으로 체크됩니다. 테스트 플레이를 종료하면 획득한 배지 정보를 제거합니다. | 한번 획득한 배지의 정보는 변경할 수 없습니다. |
| 배지 조회 | **미출시, 획득 대기, 획득 가능, 획득 불가** 상태에서 모두 조회할 수 있습니다. | **획득 대기, 획득 가능, 획득 불가** 상태에서 조회할 수 있습니다. |
| 획득 가능 상태 | **미출시, 획득 대기, 획득 가능, 획득 불가** 상태에서 모두 획득할 수 있습니다. | **획득 가능** 상태에서 획득할 수 있습니다. |

##### 참고 가이드

- [배지 등록하기](/docs/?postId=656)
- [배지 서비스 활용하기](/docs/?postId=664)

Update 2025-11-17 PM 08:14


# 배지 서비스 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

배지를 웹에서 등록하고, `BadgeService`를 활용해 특정 오브젝트에 닿았을 때 배지를 획득하게 만들어 봅시다. 출시하지 않은 월드에서는 배지를 출시하더라도, 실제로 획득할 수 없음을 유념하세요.

# BadgeService

등록한 배지는 배지 서비스를 통해 활용할 수 있습니다. 배지를 획득한 유저에게는 획득 알림창이 8초 동안 나타나며 배지의 정보가 보입니다. 만약 여러 배지를 연속으로 획득한 경우 알림창은 획득한 순서대로 나타납니다.

# 활용 예시

다른 등급의 배지 3개를 등록하고, 특정 장소에 도착하면 배지를 얻을 수 있게 만들어봅시다.

#### 사전 준비

[배지 등록하기](/docs/?postId=656)를 따라 배지를 등록합니다.

| 배지 정보 | 배지 1 | 배지 2 | 배지 3 |
| --- | --- | --- | --- |
| 배지 등급 | 노멀 | 레어 | 에픽 |
| 배지 이름 | 숲 마을에 도착 | 시계 탑에 도착 | 왕궁 입구 도착 |
| 획득 기간 | 무기한 | 무기한 | 무기한 |
| 배지 썸네일 | ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1646351123383a964ad8465424f30b49639e7ca5c4593.png) | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1646351139128655068f53362491b9a0f7fbcec64136c.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1646351152274a308bfb2c7b84d1bbd0114c87a9d716d.png) |
| 배지 설명 | 숲 마을 입구에 도착하면 받는 배지 입니다. | 마을 중앙에 시계탑에 도착하면 받는 배지 입니다. | 왕궁 입구에 도착하면 받는 배지 입니다. |

#### 배지 지급하기

특정 장소를 지나가는 플레이어에게 배지를 지급해봅시다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/16656410005845099c2a04df946bc8a0c540aedeb76e8.gif)

1. 플레이어 캐릭터가 배지를 획득할 장소 역할을 할 오브젝트를 골라 월드에 배치합니다. ![objet](https://mod-file.dn.nexoncdn.co.kr/bbs/1665631051376747462ce6e7946dd9287caebe3462ee5.png)
2. 오브젝트에 **TriggerComponent**를 추가합니다.
3. Workspace - MyDesk에 새로운 **SendBadgeInfo 컴포넌트**를 생성하고, 배지를 획득하는 장소 오브젝트에 추가합니다. ![SendBadgeInfo](https://mod-file.dn.nexoncdn.co.kr/bbs/16661642796074bf718f61bf849b99b9abace8e97342e.png)
4. 스크립트 에디터를 열어 **SendBadgeInfo 컴포넌트**에 배지 ID를 확인하기 위한 프로퍼티를 추가합니다.```
Property:
[None]
string BadgeInfo = ""
```
5. **Badge Viewer**에서 **Copy Badge ID**를 선택하고, 해당 배지를 얻을 수 있는 엔티티의 **SendBadgeInfo** 컴포넌트의 **BadgeInfo** 프로퍼티에 복사한 ID를 붙여 넣습니다. ![CopyBadgeId](https://mod-file.dn.nexoncdn.co.kr/bbs/16681380690416a3f4b1fc0c147caa8ec9cf7e3c29c02.png)
6. 새로운 **PlayerGetBadge 컴포넌트**를 생성하고 **DefaultPlayer**에 추가합니다. 배지를 수여 받을 유저가 배지가 없는지 확인하고, 배지를 수여할 수 있게 `BadgeService`를 활용해 아래와 같이 작성합니다. ![Player get badge component](https://mod-file.dn.nexoncdn.co.kr/bbs/1665631087798d08c54dcac3a413ca25de89824cfc59d.gif)```
Method:
[server only]
void GetBadge(string BadgeID)
{
    local awardingUserId = self.Entity.PlayerComponent.UserId
    if _BadgeService:AwardBadgeAndWait(awardingUserId, badgeId) then
        self:SendEvent(awardingUserId)
    end        
}

[client]
void SendEvent()
{
    local badgeOpenBtn = _EntityService:GetEntityByPath("/ui/DefaultGroup/BadgeOpenBtn")
    local event = GetBadge()
    badgeOpenBtn:SendEvent(event)
}

Event Handler:
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------

    if TriggerBodyEntity.SendBadgeInfo then
        self:GetBadge(TriggerBodyEntity.SendBadgeInfo.BadgeInfo)
    end
}
```
7. 시작을 눌러 오브젝트에 부딪혔을 때 배지 획득 연출 창이 뜨는지 확인합니다.
  > **Tip.** 배지는 획득 조건을 달성한 유저에게만 지급되어야 하므로 멀티플레이 테스트로 조건이 맞는 유저만 배지를 획득하는지 확인이 반드시 필요합니다.

#### 배지 확인 버튼 만들기

배지 획득 확인창을 여는 버튼을 만들고, 버튼을 누르면 '배지보기'에서 '닫기'로 바뀌게 만들어봅시다. ![Badge Open Button](https://mod-file.dn.nexoncdn.co.kr/bbs/16656390246259091762835cb4ecf871dff47bf226bc9.gif)

1. **UI 에디터 - DefaultGroup - BadgeOpenBtn** 버튼을 배치합니다. ![Button](https://mod-file.dn.nexoncdn.co.kr/bbs/166563113640549e397515a4e40c6b655e7b47579de3f.png)
2. 프로퍼티 에디터에서 TextComponent를 추가하고, **Text**에 **배지 보기**를 입력합니다.
3. 새로운 **BadgeOpenBtn 컴포넌트**를 생성하고, **BadgeOpenBtn**에 추가합니다.
4. 버튼을 클릭할 때 발생하는 ButtonClickEvent를 받아서 BadgeLayer 엔티티의 Enable을 설정하고, 버튼의 Text를 바꿀 수 있도록 아래와 같이 작성합니다.```
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{      
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local Entity = event.Entity
    ---------------------------------------------------------

    local BadgeLayerPanel = _EntityService:GetEntityByPath("/ui/BadgeLayer")

    if BadgeLayerPanel.Enable == false then
        BadgeLayerPanel:SetEnable(true)
        self.Entity.TextComponent.Text = "닫기"
    else
        BadgeLayerPanel:SetEnable(false)
        self.Entity.TextComponent.Text = "배지 보기"
    end
}
```
5. 버튼을 누르면 배지보기가 닫기로 바뀌는지 확인합니다.

#### 배지 확인창 UI 만들기

1. **UI 에디터 - BadgeLayer**를 추가합니다.
2. 이미지와 텍스트를 활용해 배지 정보를 확인할 수 있는 창을 만듭니다. ![badge ui](https://mod-file.dn.nexoncdn.co.kr/bbs/1665631306060d1951767a9be4695ac57542a369e7af1.png)
  > **Tip** BadgeSlot_01 하위에 다른 UI 엔티티를 넣어두어야 합니다.
3. **BadgeViewer**에서 **숲 마을에 도착** 배지를 선택하고, 콘텍스트 메뉴를 열어 **Copy Badge Thumbnail RUID**을 선택합니다. ![copy badge thumbnail RUID](https://mod-file.dn.nexoncdn.co.kr/bbs/16681384258846f8b89ff41024fc79129bd44f8d45828.png)
4. 배지 이미지를 보여줄 이미지 엔티티를 선택하고, **SpriteGUIRendererComponent의 ImageRUID**에 RUID를 붙여 넣습니다. ![Image RUID](https://mod-file.dn.nexoncdn.co.kr/bbs/1665632185530c700ddc5625f484994f1c06880cbc08b.png)

#### 배지 획득 확인창에 배지 정보 가져오기

1. 새로운 **BadgeSlot 컴포넌트**를 생성하고 **BadgeSlot_01**에 추가합니다. ![BadgeSlot](https://mod-file.dn.nexoncdn.co.kr/bbs/16656324011016d410ea46d8b488285c79a14cf05ccec.png)
2. 획득한 배지의 이름, 소유 정보, 설명을 가져올 수 있도록 프로퍼티를 추가합니다.```
Property:
[None]
string BadgeId = "" -- 조회할 배지 ID
[None]
TextComponent BadgeTitle = nil -- 배지 이름
[None]
TextComponent Hasbadge = nil -- 배지 소유 정보
[None]
TextComponent BadgDesc = nil -- 배지 설명
```
  > **Tip** Property의 TextComponent는 ![open](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_open_folder.png) 버튼을 눌러 TextComponent를 선택합니다. ![Text Component](https://mod-file.dn.nexoncdn.co.kr/bbs/1665639334907a1cca5eef1e04d67adad71c5632d75cc.png)
3. `GetBadgeInfoAsync()`를 활용해 배지 정보를 조회하고, 창이 열렸을 때 배지 관련 정보가 **TextComponent**에서 보이도록 아래와 같이 작성합니다.```
Method:
[client only]
void OnBeginPlay()
{
    self.BadgeTitle = self.Entity:GetChildByName("BadgeTitle").TextComponent
    self.HasBadge = self.Entity:GetChildByName("HasBadge").TextComponent
    self.BadgeDesc = self.Entity:GetChildByName("BadgeDesc").TextComponent

    self:BadgeCheck()

    local EventHandler = _EntityService:GetEntityByPath("/ui/DefaultGroup/BadgeOpenBtn")

    EventHandler:ConnectEvent(GetBadge, function()
        self:BadgeCheck()   
    end)
}

[client only]
void BadgeCheck()
{
    local callBack = function(badgeId, badgeInfo)
        if badgeInfo ~= nil then
            self.BadgeTitle.Text = badgeInfo.Name
            self.BadgeDesc.Text = badgeInfo.Description
        end
    end

    _BadgeService:GetBadgeInfoAsync(self.BadgeId, callBack)

    local localUserID = _UserService.LocalPlayer.Name

    if _BadgeService:UserHasBadgeAndWait(localUserID, self.BadgeId) then
        self.HasBadge.Text = "보유 중"
    else
        self.HasBadge.Text = "미보유"
    end
}
```
4. **Badge Viewer**에서 **숲 마을에 도착** 배지를 선택하고, 콘텍스트 메뉴를 열어 **Copy Badge ID**를 선택합니다. ![Copy Badge ID](https://mod-file.dn.nexoncdn.co.kr/bbs/1668138166968773a133ceb174a90a9e80d9d5e6db835.png)
5. **BadgeSlot_01** 프로퍼티 창에서 **BadgeSlot - BadgeId**에 복사한 ID를 붙여 넣습니다.
6. 위의 스크립트에서 작성한 이벤트를 만들기 위해 **MyDesk - Create Script - Create EventType**를 선택해 새로운 **GetBadge** 이벤트를 만듭니다. ![Get Badge Event](https://mod-file.dn.nexoncdn.co.kr/bbs/1665632709258ffdbc73fd6d84d45a2ff7c48dde1f0e9.png)
7. 시작을 눌러 배지를 획득한 후 배지 상태가 변경되는지 확인합니다.

Update 2025-11-17 PM 08:14


# Callback

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

로직은 기본적으로 순차적으로 진행되지만 그렇지 않은 경우도 종종 있습니다. 작업을 순차적으로 진행하는 동기 방식과 그렇게 진행하지 않는 비동기 방식의 차이점을 살펴보고, 비동기 방식을 활용하는데 필요한 Callback에 대해서도 살펴봅시다.

# 동기, 비동기

로직을 처리하는 방식에는 두 가지가 있습니다.

1. 동기(Synchronous)
2. 비동기(Asynchronous)

**동기 방식(Synchronous)**은 로직을 순서대로 처리합니다. 이를 실생활에 대입해봅시다. 톰은 집 대청소를 하는 날입니다. 해야 하는 일은 청소, 설거지 빨래 3가지가 있습니다. 각각 청소 10분, 설거지 30분, 빨래 50분 걸립니다. 동기 방식으로 일하면 톰은 하나의 일을 시작하고, 마친 뒤 다른 일을 시작합니다. 순차적으로 하므로 대청소를 마치는 데 90분이 걸립니다. 동기 방식은 이처럼 이전 작업이 끝날 때까지 대기하고 있다가 그 작업이 끝나고 나면 새로운 작업을 시작합니다. 순차적으로 처리하므로 언제 작업이 끝났을 때를 알 수 있습니다.

![Synchronous](https://mod-file.dn.nexoncdn.co.kr/bbs/165780220427024ff6674499b47f4a10eb5a75b40ffb3.png)

**비동기 방식(Asynchronous)**은 모든 작업을 순차적으로 처리하지 않습니다. 어떤 작업은 별도의 작업으로 처리합니다. 다시 톰의 예시로 돌아가 봅시다. 톰이 비동기 방식으로 일하면 빨래를 세탁기로 하고, 그 시간 동안 청소하고 설거지를 할 수 있습니다. 톰은 병행해서 일을 처리했기 때문에 모든 일을 마치는 데 50분이 걸립니다. 로직 중에는 실제 작업을 수행하는 시간보다 다른 외부 요인으로 인해 시간이 오래 걸리는 경우가 있습니다. 외부 데이터를 주고받거나 다른 IO(Input/Output)를 처리할 때 이런 일이 발생합니다. 메이플스토리 월드에서는 DataStorage가 이와 관련된 API입니다. 이런 경우에 비동기 방식으로 처리하면 불필요한 시간을 줄일 수 있습니다.

![Asynchronous](https://mod-file.dn.nexoncdn.co.kr/bbs/16578022411436d355c98e08c4347ba61fc07dcd12856.png)

#### 함수 동기 방식 알아보기

크리에이터가 사용하고자 하는 함수가 동기로 실행되는지, 비동기로 실행되는지는 함수명의 어미로 쉽게 확인할 수 있습니다. 동기 방식은 Wait이 붙어 있고, 비동기 방식은 Async가 붙어 있습니다.

# Callback

Callback을 알아보기 전에 다시 톰에게 돌아가 봅시다. 톰이 대청소를 끝내기 위해선 세 가지 일을 모두 마친 후 빨래 널기까지 해야 합니다. 톰이 동기 방식으로 일한다면 빨래가 끝난 뒤 빨래를 널 것입니다. 비동기 방식으로 일한다고 해도 빨래가 끝나야 빨래를 널 수 있습니다. 그러나 세탁기가 톰 대신 빨래를 하고 있고, 톰은 다른 일을 하고 있으므로 빨래가 언제 끝나는지 톰이 알 수 없습니다. 세탁기가 톰에게 빨래 완료 알림을 울려 빨래가 다 되었다는 것을 알려줘야 합니다. 이처럼 주요 흐름 외에서 처리한 일의 완료 시점을 알 수 있도록 알림을 울리는 것을 Callback이라 합니다. 비동기 작업은 순차적인 흐름대로 진행되는 것이 아니기에 끝났을 때의 타이밍을 알아야 합니다. 이럴 때 사용하는 것이 'Callback'입니다.

Callback은 처리 완료 알림뿐만 아니라 다른 용도로도 사용할 수 있습니다. 비동기 작업이 끝난 뒤에 실행할 연계 작업을 정의하거나, Callback을 특정 타이밍에 호출하는 것도 가능합니다. 예를 들어, TimerService의 SetTimerRepeat은 주기적인 시간대에 '특정 작업'을 하도록 하는 함수입니다. 이때 '특정 작업'을 Callback으로 지정하면 주기적인 타이밍마다 Callback 함수를 실행하도록 할 수 있습니다.

![callback](https://mod-file.dn.nexoncdn.co.kr/bbs/16578022702296367102f25cb49269dc80e1985bfa959.png)

#### Callback 함수 활용

처리가 완료되었을 때 Callback 함수를 실행하는 예시입니다.

```
Property:
[Sync]
number Power = 0

Method:
[server only]
void OnBeginPlay ()
{
    local data = _DataStorageService:GetGlobalDataStorage("data")
    
    self.Power = 20
    
    local callBack = function (errorcode, key)
        log("Power is saved")
    end
    
    data:SetAsync("Power", tostring(self.Power), callBack)
}
```

> **Tip.** Component의 Function을 Callback으로 사용할 때는 `self:function()`이 아닌 `self.function()`을 사용해야 합니다.

Update 2025-11-17 PM 08:14


# 액션을 예약하고 실행하는 TimerService

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

몬스터가 등장하고 몇 초 뒤 공격을 시작하거나, 몬스터가 죽고 1초 뒤 아이템을 떨어뜨리는 것과 같은 어떤 일(액션)이 일어나는 타이밍을 제어해야 할 때가 있습니다. TimerService를 활용해 쉽고 효율적으로 액션이 일어나는 타이밍을 제어할 수 있습니다. TimerService가 제공하는 기능과 활용법을 알아보겠습니다.

# TimerService 소개

**TimerService**는 원하는 순간에 어떤 액션을 실행하도록 예약하는 편의 기능을 제공합니다. Timer Service를 사용하지 않고 몬스터가 사망하면 보상 아이템이 떨어지는 상황을 만드는 방법 알아봅시다.

![Timeservice01](https://mod-file.dn.nexoncdn.co.kr/bbs/165604735697978e39853991a4feea1e8253e5602185e.png)

몬스터가 죽고 3초 후에 아이템이 등장하는 상황을 만들기 위해서는 아래와 같이 긴 스크립트를 작성해야 합니다. 몬스터가 죽을 때마다 프레임별로 시간을 확인하고, 3초가 지나면 아이템이 등장하도록 해야 하기 때문입니다.

```
Property:
[None]
table DropItemList = {}

Method:
[server only]
void OnBeginPlay()
{
    self.DropItemList = {}
}

[server only]
void OnUpdate(number delta)
{
    for i, dropInfo in pairs(self.DropItemList) do
    	if dropInfo.dropTime < os.clock() then
    		continue
    	end
    	
    	self:DropItem(dropInfo.dropItemArr, dropInfo.itemDropPosition)
    end
}

[sever only]
void OnMonsterDestroy(Entity monsterEntity)
{
    local monsterInfo = monsterEntity.MonsterInfo
    local dropItemArr = monsterInfo.dropItemArr
    local itemDropPosition = monsterEntity.TransformComponent.Position
    
    table.insert(self.DropItemList, {["driopItemArr"] = dropItemArr, ["dropTime"] = os.clock() + 3, ["itemDropPosition"] = itemDropPosition})
    
    _EntityService:Destroy(monsterEntity)
}

[server only]
void DropItem(SyncTable<string> itemArr, Vector3 dropPosition)
{
    for i , itemId in pairs(itemArr) do
    	self:SpawnItem(itemId, dropPosition)
    end
}
```

**TimerService**를 활용하면 보다 간결하게 구현할 수 있습니다. 아이템 드롭을 구현한 CallBack 함수를 TimerService의 `SetTimer()` 함수로 넘겨주고, 몇 초 뒤에 실행할 것인지 설정합니다. 몇 개의 함수와 수십 줄의 코드로 구현해야 할 기능을 CallBack 함수와 `SetTimer()` 함수를 호출해 쉽고 간단하게 구현할 수 있습니다.

```
Method:
[server only]
void OnMonsterDestroy(Entity monsterEntity)
{
    local monsterInfo = monsterEntity.MonsterInfo
    local dropItemArr = monsterInfo.dropItemArr
    local itemDropPosition = monsterEntity.TransformComponent.Position
    
    local dropItem = function()
    	self:DropItem(dropItemArr, itemDropPosition)
    end
    
    _TimerService:SetTimer(self, dropItem, 3, false)
    _EntityService:Destroy(monsterEntity)
}

[server only]
void DropItem(SyncTable<string> itemArr, Vector3 dropPosition)
{
    for i, itemId in pairs(itemArr) do
    	self:SpawnItem(itemId,dropPosition)
    end
}
```

# SetTimer 활용

`SetTimer()`는 예약 함수입니다. 특정 시점에 수행할 액션을 예약할 수 있고, 액션 반복 수행 여부와 반복 주기를 설정할 수 있습니다. 예약한 액션 반복 여부에 따라 매개 변수의 의미와 쓰임새가 달라집니다. `SetTimer()`는 예약 성공 시 integer 타입의 타이머의 id를 반환하고, 예약 실패 시 0을 반환합니다. 매개 변수는 다음과 같습니다.

| 타입 | 매개 변수 | 설명 |
| --- | --- | --- |
| IScriptable | scriptable | 예약할 액션의 소유자를 넘겨줍니다. 액션의 소유자는 로직, 컴포넌트가 될 수 있으며 일반적으로 `SetTimer()`를 호출한 컴포넌트 자신을 넘겨줍니다. |
| func | callback | 몇 초 뒤 수행할 액션을 CallBack 함수로 넘겨줍니다. |
| float | intervalSeconds | <li>**isRepeat 값이 true일 경우**: CallBack 함수를 최초 1회 실행한 후 몇 초 뒤에 재실행할 것인지를 설정합니다.</li><li>**isRepeat 값이 false일 경우**: `SetTimer()`가 호출된 후 몇 초 뒤에 CallBack 함수를 실행할 것인지를 설정합니다.</li> |
| boolean | isRepeat | CallBack 함수를 1회만 실행할 것인지, 반복적으로 실행할 것인지를 설정합니다. <li>**true**: 반복 실행</li><li>**false**: 1회 실행</li> |
| float | startDelaySeconds | 함수 실행 후 몇 초 뒤에 CallBack 함수를 실행할지 설정합니다. isRepeat 값이 true 경우 유효합니다. |

> **주의! `scriptable` 매개 변수에 컴포넌트를 전달하는 경우 callback 실행이 컴포넌트의 EnableInHierarchy에 영향을 받습니다.**

#### 액션 1회 실행

SetTimer가 호출될 때 "SetTimer!"라는 문자열과 함께 해당 코드가 실행된 시간을 출력합니다. 3초 뒤 `SetTimer()`로 넘긴 CallBack 함수가 호출될 때 "CallBack!"이라는 문자열과 함께 코드가 실행된 시간을 1회 출력합니다. ![Timeservice04](https://mod-file.dn.nexoncdn.co.kr/bbs/1656047389794ca939882847b489ebf4ef39fb011ce3d.png)

예시 코드는 다음과 같습니다. CallBack 함수를 넘겨주면서 intervalSeconds을 3초로 설정합니다. 1회만 실행하므로 isRepeat은 false로 설정하고, startDelaySeconds는 무시합니다.

```
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! : "..tostring(os.date()))
    end
 
    log("SetTimer! : "..tostring(os.date()))
    _TimerService:SetTimer(self, callBack, 3, false)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트를 진행합니다. 콘솔 창에 각 문자열과 코드가 실행된 시간을 확인하여 `SetTimer()`가 호출된 3초 뒤 CallBack 함수가 실행되는 것을 확인합니다. 39초에 처음 호출되고, 다음 함수 실행이 42초로 3초 간격을 확인할 수 있습니다.

![TimeService06](https://mod-file.dn.nexoncdn.co.kr/bbs/1656047982444631a010e59c04cc8b5865653b19b0c15.png)

#### 액션 반복 실행

isRepeat을 true로 변경해 반복 실행하게 만듭니다. `SetTimer()`가 호출될 때 "SetTimer!"라는 문자열과 함께 해당 코드가 실행된 시간을 출력합니다.

![TImeService07](https://mod-file.dn.nexoncdn.co.kr/bbs/16560480360032fd64662b6f94dadb45de7c8f185d25a.png)

예시 코드는 다음과 같습니다. 3초마다 `SetTimer()`로 넘긴 CallBack 함수가 호출될 때 "CallBack!"이라는 문자열과 함께 코드가 실행된 시간을 출력합니다.

```
Method:
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! : "..tostring(os.date()))
    end
     
    log("SetTimer! :"..tostring(os.date()))
    _TimerService:SetTimer(self, callBack, 3, true)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트합니다. 콘솔 창의 출력 시간이 3초씩 증가했는지 확인합니다. 1회 실행 때와 달리, "SetTimer!" 와 "CallBack!" 문자열이 처음 출력된 시간이 같습니다. `SetTimer()`를 반복 설정하면 intervalSeconds의 의미가 변경되기 때문입니다. 1회 실행일 때 intervalSeconds의 의미는 `SetTimer()`가 실행된 다음 몇 초 뒤에 CallBack 함수를 실행할 것인지를 의미합니다. 반복 실행일 때는 CallBack 함수는 최초 실행 후 몇 초 뒤에 다시 실행할 것 인지를 의미합니다. 그러므로 `SetTimer()`와 CallBack 함수가 동시에 실행되고, CallBack 함수가 3초마다 재실행됩니다. CallBack 함수를 몇 초마다 실행할 것인지가 중요하다면 intervalSeconds 값만 조절합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1718961812726747d9d0148fd48bf9d9b923748e84c31.png) `SetTimer()`가 호출된 후 몇 초 뒤에 CallBack 함수를 최초로 호출할 것인가를 설정하고자 한다면, `SetTimer()`의 마지막 매개 변수인 startDelaySeconds에 값을 입력합니다. `SetTimer()`가 호출된 후 2초 뒤에 CallBack 함수가 최초로 실행되고, 이후 3초 간격으로 CallBack 함수가 실행됩니다. 다음은 startDelaySeconds 값을 추가한 예시입니다.

```
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! : "..tostring(os.date()))
    end
 
    log("SetTimer! : "..tostring(os.date()))
    _TimerService:SetTimer(self, callBack, 3, true, 2)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트를 진행합니다. 콘솔에 의도대로 시간이 출력되는지 확인합니다. CallBack 함수가 `SetTimer()`가 처음 호출된 후 2초 뒤에 처음 실행되고, 다음부터 3초 간격으로 실행되었는지 확인합니다. ![TimeService11](https://mod-file.dn.nexoncdn.co.kr/bbs/1656048115485a61aa280dea54528905c8da80da35fb7.png)

#### 실행 예약 취소

`SetTimer()`를 통해 특정 액션을 수행하도록 예약을 만들었지만, 특정 조건에 의해 해당 예약을 취소해야 하는 경우가 빈번히 발생합니다. 게임 내에서 스위치를 On 했을 때 3초 후 문이 열리는 장치를 만들었다고 가정해 봅시다. 유저가 스위치를 On 상태로 만들었을 때 3초 뒤에 문이 열리게 됩니다. 문이 열리는 액션을 `SetTimer()`를 이용해 예약했기 때문입니다. 그러나 유저가 문이 열리기 전에 스위치를 Off 상태로 만든다면 `SetTimer()`의 예약을 취소해 Off일 때 문이 열리지 않게 만들어야 합니다.

![TimerService12](https://mod-file.dn.nexoncdn.co.kr/bbs/1656048132717f15c590130b1464c8451382b95717a37.png)

다음은 반복 실행 예제에 `SetTimer()`가 호출된 후, 10초 뒤 실행을 취소하는 `SetTimer()`를 추가한 스크립트입니다.

```
Method:
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! :"..tostring(os.date))
    end
    
    log("SetTimer! :"..tostring(os.date()))
    local timerId = _TimerService:SetTimer(self, callBack, 3, true, 2)
    if timerId == 0 then
        return
    end
    
    local cancelCallBack = function()
        _TimerService:ClearTimer(timerId)
    end
    
    _TimerService:SetTimer(self, cancelCallBack, 10, false)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트합니다. SetTimer!가 처음 출력된 후 10초 후에는 로그가 더 이상 출력되지 않습니다.

> **Tip** 첫 출력 시간은 46초이고, 마지막 출력 시간은 54초로 총 8초 동안의 로그만 나온 이유는 `SetTimer()` 실행 후 10초 뒤에 `ClearTimer()`가 실행됐기 때문입니다. CallBack은 `SetTimer()` 실행 후 2초 뒤에 처음 실행되어, 3초마다 반복 실행되고 있습니다. 54초 이후 다음 CallBack 실행은 57초이지만, 56초에 CallBack을 취소시키므로 57초에 실행할 CallBack이 없습니다. 그러므로 로그는 첫 실행 후 8초 이후부터는 로그가 찍히지 않습니다.

![TImeService14](https://mod-file.dn.nexoncdn.co.kr/bbs/1656048756087cf0360b0140447059661594e84ccd0da.png)

# SetTimer의 파생 기능

사용 목적에 따라 `SetTimerOnce()` 와 `SetTimerRepeat()`를 사용해 액션 예약과 수행 기능을 나누어 사용할 수 있습니다. `SetTimerOnce()`는 1회 액션 예약 시 사용하고, `SetTimerRepeat()`은 반복 액션 수행 시 사용합니다. 기능이 분리된 만큼 전달할 매개 변수 개수도 적어 `SetTimer()`에 비해 간편하게 사용할 수 있습니다.

#### SetTimerOnce

`SetTimerOnce()`는 `SetTimer()`의 isRepeat를 false로 설정한 것과 동일하게 작동합니다. 예약 성공 시 integer 타입의 타이머의 id를 반환하고, 예약 실패 시 0을 반환합니다. 매개 변수는 다음과 같습니다.

| 타입 | 매개 변수 | 설명 |
| --- | --- | --- |
| func | callback | 몇 초 뒤 수행할 액션을 CallBack 형태로 넘겨줍니다. |
| float | delaySeconds | 액션을 예약한 뒤 몇 초 후에 액션을 실행할 것인지를 설정합니다. |

```
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! : "..tostring(os.date()))
    end
 
    log("SetTimer! : "..tostring(os.date()))
    _TimerService:SetTimerOnce(callBack, 3)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트합니다. `SetTimerOnce()`가 호출되고 3초 뒤 액션이 실행된 것을 확인합니다. ![TimeService16](https://mod-file.dn.nexoncdn.co.kr/bbs/1656048219588d8718bc60c154cab8e818e7561f37295.png)

> **주의! `_TimerService:SetTimerOnce(self.Method,1)`와 같이 `callback` 매개 변수에 컴포넌트의 메서드를 직접 전달하는 경우 callback 실행이 컴포넌트의 EnableInHierarchy에 영향을 받습니다.**

#### SetTimerRepeat

`SetTimerRepeat()`는 반복 액션을 예약할 때 사용합니다. `SetTimer()`의 isRepeat를 true로 한 것과 동일합니다. 예약 성공 시 integer 타입의 타이머의 id를 반환하고, 예약 실패 시 0을 반환합니다. 매개 변수는 다음과 같습니다.

| 타입 | 매개 변수 | 설명 |
| --- | --- | --- |
| func | callback | 반복 수행할 액션을 CallBack 형태로 넘겨줍니다. |
| float | intervalSeconds | 몇 초마다 반복 수행할지를 설정합니다. |
| float | startDelaySeconds | 액션을 예약한 다음 몇 초 뒤부터 반복 액션을 수행할지를 설정합니다. |

```
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! : "..tostring(os.date()))
    end
 
    log("SetTimer! : "..tostring(os.date()))
    _TimerService:SetTimerRepeat(callBack, 3, 2)
}
```

시작 ![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 테스트합니다. `SetTimer()`가 호출된 후 2초 뒤에 액션을 최초로 수행되고, 이후 3초 간격으로 액션을 반복 수행하는 것을 확인합니다.

![TimeService18](https://mod-file.dn.nexoncdn.co.kr/bbs/16560482841675f11475a77124fb58840efc33d198675.png)

> **주의! `_TimerService:SetTimerRepeat(self.Method, 1, 1)`와 같이 `callback` 매개 변수에 컴포넌트의 메서드를 직접 전달하는 경우 callback 실행이 컴포넌트의 EnableInHierarchy에 영향을 받습니다.**

#### 예약 취소

`SetTimerOnce()`와 `SetTimerRepeat()`는 예약한 액션을 취소할 수 있습니다. 예약한 액션을 취소할 때는 `ClearTimer()` 함수를 활용합니다. 아래의 예제처럼 10초 뒤 액션 실행을 취소할 수 있습니다.

```
Method:
[server only]
void OnBeginPlay()
{
    local callBack = function()
         log("CallBack! :"..tostring(os.date()))
    end
    
    log("SetTimer! :"..tostring(os.date()))
    local timerId = _TimerService:SetTimerRepeat(callBack, 3, 2)
    if timerId == 0 then
        return
    end
    
    local cancelCallBack = function()
        _TimerService:ClearTimer(timerId)
    end
    
    _TimerService:SetTimerOnce(cancelCallBack, 10)
}
```

처음 로그가 출력된 시점으로부터 10초 뒤부터 로그가 더 이상 출력되지 않는 것을 확인할 수 있습니다.

![TimeService20](https://mod-file.dn.nexoncdn.co.kr/bbs/1656048305326b5db28fd79174da8bec8b26163ab0e74.png)

# 유의 사항

반복 액션 예약을 사용할 때는 적절한 시기에 `ClearTimer()` 함수를 호출하 예약을 취소해야 합니다. 컴포넌트나 로직의 `OnEndPlay` 혹은 예약된 액션의 소유자가 파괴되는 시점에 `ClearTimer()` 함수를 호출하여 예약 취소하는 것을 권장합니다. 예약된 액션이 과도하게 누적될 경우 월드 성능이 하락할 수 있기 때문입니다. 만약 크리에이터가 `ClearTimer()` 함수를 호출하지 않았더라도 월드의 최적화를 위해 예약된 액션의 소유자가 파괴될 경우 내부에서 자동으로 `ClearTimer()` 함수를 시도합니다.

```
Property:
[None]
integer TimerId = 0

Method:
[server only]
void OnBeginPlay()
{
    local callBack = function()
        log("CallBack! :"..tostring(os.date()))
    end

    self.TimerId = _TimerService:SetTimerRepeat(callBack, 3)
}

[server only]
void OnEndPlay()
{
    if self.TimerId > 0 then
        _TimerService:ClearTimer(self.TimerId)
    end
}
```

Update 2025-11-17 PM 08:14


# Event System

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터는 로직을 여러 가지 방법으로 작성할 수 있습니다. 그 방법 중 하나는 **이벤트**를 활용하는 것입니다. 이번 시간에는 메이플스토리 월드의 이벤트 시스템과 여러 이벤트를 다루는 방법을 살펴봅니다.

# 이벤트 기반의 로직 구성

로직을 작성하다 보면 **특정 타이밍에 해야 할 일**이 생깁니다. 그럴 때는 **행위가 일어난 주체**가 무엇을 할 것인지 결정해야 합니다.

예를 들어, 월드에서 캐릭터가 공격받았을 때 아래와 같이 구현한다고 가정해 봅시다.

1. **캐릭터의 HP를 감소시키고**
2. **대미지를 보여주고**
3. **잠깐 캐릭터를 무적으로 만듭니다.**

이렇게 구현하려면 캐릭터가 공격받았을 때 각 기능을 하는 함수를 호출해야 합니다. 여기서 크리에이터가 피격 효과에 특별한 이펙트를 더하려 한다면 **4. 피격 이펙트를 표시한다.** 를 추가하면 됩니다.  이러한 일반 로직은 **행위가 일어난 주체**가 행동을 관리합니다. 하지만 이벤트 기반 로직은 **행동 실행 주체**에서 행동을 관리합니다. 즉, **행위가 일어난 주체**는 행위가 일어났을 때 행동에 필요한 정보와 타이밍만 알려주고, 실제로 무엇을 할지는 각각의 **행동 실행 주체**가 결정합니다.

위의 예로 돌아가 봅시다. 캐릭터가 공격받으면 각각의 함수를 호출하는 것이 아니라 **공격받은 상황**만 이벤트로 만들어 전송합니다. 이벤트를 전송받은 **행동 실행 주체**는 **내부적으로 정해진 행동**(HP 감소, 대미지 보여주기, 잠시 캐릭터를 무적으로 만듦)을 수행합니다. 이처럼 동작하기 위해 **행동 실행 주체**가 해야 할 일은 이벤트 발생 시점을 **구독**하는 것뿐입니다. 피격 이펙트를 추가하려 한다면, 이펙트를 관리하는 곳에서 **공격받은 상황** 이벤트를 추가로 **구독**하면 됩니다.

유명 스트리머의 알림을 받는다고 생각해 봅시다. 해당 스트리머는 어떤 알림이 필요하다고 판단될 때 구독자들에게 알림을 보낼 것입니다. 그 알림을 받고 어떤 행동을 취할지는 각각의 구독자가 결정하는 것입니다.  정리하면 다음과 같습니다.

- **일반 로직**에서는 **행위가 일어난 주체**가 일을 처리한다.
- **이벤트 시스템**에서는 **행동 실행 주체**가 일을 처리한다.

# 이벤트 시스템의 구성

메이플스토리 월드의 이벤트 시스템은 크게 3가지로 구성됩니다.

| 요소 | 설명 |
| :---: | --- |
| 이벤트(Event) | 로직 상에서 어떤 사건의 발생을 의미합니다. <br>이벤트 종류의 식별 정보 및 추가 정보 등을 들고 있는 자료형입니다. |
| 핸들러(Handler) | 이벤트를 받았을 때 처리하는 행동의 주체입니다. <br>Listener, Subscriber 등의 유사 용어가 있습니다. |
| 센더(Sender) | 이벤트를 발송하는 객체입니다. <br>Emitter, Dispatcher 등의 유사 용어가 있습니다. |

학급 전체에 공지문을 우편 배달한다고 가정해 봅시다. 그렇다면 이벤트, 핸들러, 센더는 아래와 같을 것입니다.

- 이벤트 : 공지문
- 핸들러 : 학급의 학생들
- 센더 : 우편배달원

# 이벤트 시스템의 장단점

이벤트 시스템이 일반 로직보다 무조건 좋은 것은 아닙니다. 이벤트 기반 로직은 여러 개발 방식 중 하나이며, 장단점이 모두 존재합니다. 그러므로 크리에이터의 필요에 따라 적절한 로직을 활용하는 것이 좋습니다.

## 장점

- 다른 컴포넌트나 기능에 의존적이지 않습니다. 분산된 구조를 만드는 데 유리합니다.
- 행위가 일어난 주체는 수정하지 않고 행위에 대한 액션만 추가할 수 있습니다.
- 다른 컴포넌트의 정보를 알 필요가 없습니다.

## 단점

- 어떤 사건이 발생했을 때 전체적인 흐름을 파악하기 어렵습니다. 각각 처리하기 때문에 실행 시점에서는 알 수 없기 때문입니다.
- 디버깅이 다소 어려울 수 있습니다.
- 순차 처리가 어려울 수 있습니다.

# 마무리

이번 시간에는 이벤트 시스템의 개념을 살펴보았습니다. 메이플스토리 월드는 Entity Event System을 사용하고 있습니다. Entity Event System은 Entity를 중계소로 이용합니다. [Entity Event System](/docs/?postId=176)에서 자세한 내용을 살펴봅시다.

Update 2025-11-17 PM 08:14


# Entity Event System

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 Entity Event System을 사용해 이벤트를 제어할 수 있습니다. 이번 시간에는 Entity Event System을 이용해 "뱀파이어 vs 헌터"의 게임 요소 중 하나를 만들어봅시다. 다음 가이드를 먼저 학습하면 이번 과정을 이해하는 데 많은 도움이 됩니다. [Event System](https://mod-developers.nexon.com/docs?postId=73)

# Entity Event System

이벤트를 받고 보내려면 먼저 Entity Event System을 이해해야 합니다. 컴포넌트는 엔티티를 중계자로 사용할 수 있습니다. 각각의 컴포넌트는 엔티티를 통해 핸들러를 등록하고 이벤트를 발생시킬 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16560446599253c3fab51c71c43a681173496cc4ee5a4.png)  센더 역시 엔티티를 통해 이벤트를 발생시킵니다. 엔티티는 발생한 이벤트를 핸들러에 전송합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16560447014255f87e1b80f4a4a85b4b4857f01923163.png)  기본적으로는 자기 자신의 엔티티에 이벤트를 연결하지만, 아래 그림처럼 상황에 따라 다른 엔티티에 연결할 수도 있습니다. 특히, 맵 엔티티와 월드 엔티티는 서로 이벤트를 주고받는 경우가 많아 아래와 같은 형태를 자주 사용합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16560447361361ac2b80437934439be6a9a35b95b41e4.png)

# Sunrise Event 생성

이벤트 시스템에는 기본 제공되는 네이티브 형 이벤트가 있습니다. 또한 크리에이터가 직접 이벤트 타입을 선언하거나 Import 할 수도 있습니다. 방법은 아래와 같습니다.

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create EventType**을 클릭합니다. ![eventtype](https://mod-file.dn.nexoncdn.co.kr/bbs/168783084547591cb0c6685e148e799ab7a2caef6d579.png)
2. 새로 만든 이벤트 타입의 이름으로 **SunriseEvent**를 입력합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/163546931602941f745c54cb0488591fd3c1365f6e2e6.png)
3. **SunriseEvent** 스크립트를 연 뒤, 아래와 같이 Property를 추가합니다. **isSunrise**를 통해 해가 뜨고 지는 상태를 **True / False**로 확인할 것입니다.

```
Property:
boolean isSunrise = false
```

# 이벤트를 처리할 컴포넌트와 엔티티 생성

**SunriseEvent**를 이용해 "뱀파이어 vs 헌터" 로직을 만들어보겠습니다. 뱀파이어와 헌터는 일반적인 전투와 움직임을 보이다가 **SunriseEvent**를 받게 됩니다. **Sunrise** 상태일 때, 헌터는 따뜻한 햇볕으로 HP를 회복하고 뱀파이어는 HP가 감소하도록 만들어봅시다.

1. **Sunrise** 상태의 로직을 구현해 봅시다. 먼저 **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭해 신규 스크립트 컴포넌트 2개를 만듭니다. 이름으로 **VampireComponent**와 **HunterComponent**를 입력합니다.
2. 뱀파이어 NPC 엔티티와 헌터 NPC 엔티티를 배치합니다. 예제에서는 **Preset List - NPC**에서 아래 두 개의 NPC를 배치했습니다.
  - **뱀파이어 : npc-3842**
  - **헌터 : npc-4064** ![2-3](https://mod-file.dn.nexoncdn.co.kr/bbs/1637219347748447c4479910f480ba61d509d0dbc2779.png)
3. 배치한 NPC의 이름으로 **Vampire, Hunter**를 입력합니다. ![2-4](https://mod-file.dn.nexoncdn.co.kr/bbs/1659663899996526b6c428aba43aa8c9761a74a10840a.png)
4. 뱀파이어 엔티티에 **VampireComponent**를, 헌터 엔티티에 **HunterComponent**를 각각 추가합니다. ![2-5](https://mod-file.dn.nexoncdn.co.kr/bbs/16372193694020abcd1a02ddd4758985ac713f77e6700.png) ![2-6](https://mod-file.dn.nexoncdn.co.kr/bbs/1637224347613343676d468044fea94a656c843eb9b60.png)

# 핸들러 로직

**HunterComponent**, **VampireComponent** 스크립트를 작성해 봅시다. 우선 두 컴포넌트 모두 **SunriseEvent**를 받도록 해야 합니다.

1. **HunterComponent**, **VampireComponent** 스크립트를 엽니다. **Event Handler**에서 **[+]** 버튼을 누르고, **SunriseEvent**를 추가합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635299466453111917919dd24abc9a26ab0b1e72ebcd.png)
2. **SunriseEvent**의 중계 엔티티를 **map01**으로 설정해야 합니다. 다음과 같이 핸들러 상단의 이벤트 중계자를 **map01**로 설정합니다. ![6-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163721938434624dd2b604ea948219e9049d898cac1f6.png)
3. 이제 각자 받은 **SunriseEvent**를 처리하는 로직을 넣어봅시다. 먼저, 해가 뜨면 헌터의 HP가 증가하도록 **HunterComponent**를 작성합니다.```
Property: 
[Sync]
boolean isSunrise = false
[Sync]
number Hp = 0

Method: 
[server Only]
void OnUpdate(number delta)
{
    if self.isSunrise == true then --해가 떴는지 체크합니다.
        self.Hp = self.Hp + delta --해가 떠 있을 동안 HP가 증가합니다.
        log("Hunter Hp : "..self.Hp) --현재 체력을 Console 창에 표시합니다.
        if self.Hp >= 200 then self.Hp = 200 end --HP가 200까지 증가했다면 증가를 멈춥니다.
    end
}

Event Handler: 
[entity: map01(/maps/map01)]
HandlerSunriseEvent(SunriseEvent event)
{
    -- Parameters
    local isSunrise = event.isSunrise
    self.isSunrise = isSunrise
}
```
4. 해가 뜨면 뱀파이어의 HP는 감소하도록 **VampireComponent**를 작성합니다.```
Property: 
[Sync]
boolean isSunrise = false
[Sync]
number Hp = 0

Method: 
[server Only]
void OnUpdate(number delta)
{
    if self.isSunrise == true then --해가 떴는지 체크합니다.
        self.Hp = self.Hp - delta --해가 떠 있을 동안 HP가 감소합니다.
        log("Vampire Hp : "..self.Hp) --현재 HP를 Console 창에 표시합니다.
        if self.Hp < 0 then self.Hp = 0 end --HP가 0까지 감소했다면 감소를 멈춥니다.
    end
}

Event Handler: 
[entity: map01(/maps/map01)]
HandlerSunriseEvent(SunriseEvent event)
{
    -- Parameters
    local isSunrise = event.isSunrise
    self.isSunrise = isSunrise
}
```
5. 뱀파이어 엔티티와 헌터 엔티티의 프로퍼티 에디터에서 **Hp** 값을 각각 **100**으로 설정합니다. ![10-2](https://mod-file.dn.nexoncdn.co.kr/bbs/163729758603854822aa456724b65952386322fb97f20.png) ![10-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637297514978d0b38497f6764e5a94c193d8f607908a.png)

# 이벤트 발생 로직

특정 시간마다 해가 뜨고 지는 로직을 만들어봅시다.

1. 해가 뜨고 지는 시간을 관리할 스크립트 컴포넌트가 필요합니다. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scrips - Create Component**를 클릭해 새 컴포넌트를 만듭니다. 이름으로 **TimeManager**를 입력합니다.
2. **TimeManager** 스크립트 컴포넌트를 엽니다. `OnUpdate` 함수를 추가하여 해가 뜨고 지는 것을 판단하도록 합니다.```
Property: 
[Sync]
boolean isSunrise = false

Method: 
[server only]
void OnUpdate(number delta)
{
    if self._T.Time == nil then self._T.Time = 0 end
    self._T.Time = self._T.Time + delta

    if self._T.Time >= 5 then --5초마다 번갈아 해가 뜨고 집니다.
        self._T.Time = 0
        if self.isSunrise == true then
            self.isSunrise = false
        else
            self.isSunrise = true --해가 떠 있지 않으면 isSunrise = false입니다.
        end
        log(self.isSunrise)
        self:SendEvent(self.isSunrise)
    end
}

[server]
void SendEvent(boolean isSunrise)
{
    local event = SunriseEvent()
    event.isSunrise = isSunrise
    self.Entity:SendEvent(event)

    self.isSunrise = isSunrise
    self._T.Time = 0
}
```
3. **Hierarchy - map01**의 콘텍스트 메뉴에서 **Add Component**를 클릭합니다. **TimeManager** 컴포넌트를 추가합니다. ![11-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16596640785471f0b99b7de3f40bb9a25f6f76911431d.png) 이제 필요한 스크립트 컴포넌트를 모두 작성했습니다. 주기적으로 해가 뜨고 지는 이벤트를 보내고 받을 수 있습니다.
4. 추가로 헌터의 궁극기인 일출 스킬을 제작해 봅시다. Z 키를 이용해 이벤트를 호출하겠습니다. **HunterComponent**에 **KeyDownEvent**를 추가하고 아래와 같이 작성합니다.```
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event) 
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------------------------------
    if key == KeyboardKey.Z then --Z 키를 누르면 \`일출\` 메시지가 Console 창에 나타납니다.
        log("일출")
        local timeManager = self.Entity.CurrentMap.TimeManager
        timeManager:SendEvent(true) --Timemanager의 Event가 true가 되도록 합니다.
    end
}
```

이제 Z 키를 누르면 해가 뜹니다.

Update 2025-11-17 PM 08:14


# InputService를 활용한 입력과 액션

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

모든 게임은 유저의 입력과 입력에 대한 피드백으로 게임이 진행됩니다. 메이플스토리 월드에서는 InputService를 통해 유저의 입력에 대한 액션을 제어할 수 있습니다. 이번 과정에서는 유저의 입력이 발생했을 때의 액션을 추가하는 방법을 알아보겠습니다.

# 참고 가이드

[Event System](https://mod-developers.nexon.com/docs?postId=73) [Entity Event System](https://mod-developers.nexon.com/docs?postId=176)

# InputService

월드에서 유저가 특정 입력을 하면 **InputService**는 유저의 입력에 대한 이벤트를 발생시킵니다. 발생한 이벤트를 이벤트 핸들러를 통해 특정 액션을 수행하게 할 수 있습니다. 유저의 입력 이벤트는 클라이언트에서만 발생하기 때문에, 각 이벤트 핸들러도 클라이언트에서만 실행됩니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/163762998576261208fbcfa8f4b76a390c160dbc9ed2c.png)

#### 이벤트 핸들러 추가

입력에 관한 이벤트 핸들러는 스크립트 컴포넌트에서 추가할 수 있습니다.

1. 스크립트 컴포넌트를 생성한 뒤 임의의 엔티티에 추가합니다.
2. **Event Handler**에서 [+] 버튼을 눌러 이벤트 탐색 창을 열고, 핸들러에 추가할 이벤트를 찾아 선택합니다. ![3-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163533746207214c17cd195954faa9e175327dfe2d97a.png)
3. 핸들러가 추가되면 이벤트 센더가 **InputService**로 선택되어 있는지 확인합니다. ![4-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635337530912f087a6d685594d2face6f4fd8080cf3a.png)

# 이벤트 종류별 특징

`InputService`에서 제공하는 유저 입력과 관련된 각 이벤트는 유저의 입력 형태에 따라 발생하는 시점과 횟수가 달라집니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/163533908473345305a0d43684fbe93435fb968f297f8.png)

#### KeyDownEvent

`KeyDownEvent`는 키를 눌렀을 때 발생하는 이벤트입니다. `KeyDownEvent`가 발생하면 **HandleKeyDownEvent**가 실행됩니다. `KeyDownEvent`가 핸들러의 매개 변수로 전송되며, 이벤트에는 유저가 입력한 키가 enum으로 넘어오게 됩니다. 다음은 `T` 키를 눌렀을 때 로그를 출력하는 예제입니다.

```
Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    local key = event.key
    ---------------------------------------------------------
    
    if key == KeyboardKey.T then
        log("Press T!")
    end
}
```

![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1687831927516aca6074b6ce04c4cad71ca952bf27f52.png)

이벤트 핸들러를 사용하지 않고 InputService의 `IsKeyPressed()`, `IsAnyKeyPressed()` 함수를 사용해 Key 입력을 제어할 수도 있습니다.

- `IsKeyPressed()`는 키가 눌린 상태면 true를, 키가 눌리지 않은 상태면 false를 반환합니다.
- `IsAnyKeyPressed()`는 어떤 키라도 눌린 상태면 true를, 아무 키도 눌리지 않았으면 false를 반환합니다.

다음은 두 함수를 이용해 키 입력을 확인하는 예제입니다.

```
Method:
[client only]
void OnUpdate(number delta)
{
    local enterKeyPressed = _InputService:IsKeyPressed(KeyboardKey.Return)
    local anyKeyPressed = _InputService:IsAnyKeyPressed()

    if enterKeyPressed == true then
        log ("Enter key pressed.")
    end

    if anyKeyPressed == true then
        log ("Any key pressed.")
    end
}
```

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17435591317669f3c092550504c2bb292862d22f84ade.png)

#### KeyUpEvent

`KeyUpEvent`는 키보드의 키가 눌려있는 상태에서, 키에서 손을 떼었을 때 1회 발생하는 이벤트입니다. `KeyUpEvent`가 발생하면 **HandleKeyUpEvent**가 실행되며 이벤트가 발생할 때 1회 실행됩니다. 핸들러의 매개 변수로 KeyUpEvent가 전송되고 이벤트에는 유저가 입력한 key 값이 `KeyboardKey` 타입의 enum 값으로 포함되어 있습니다. 다음은 `T` 키를 눌렀다가 떼었을 때 로그를 출력하는 예제입니다.

```
[service: InputService]
HandleKeyUpEvent(KeyUpEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    local key = event.key
    ---------------------------------------------------------
    
    if key == KeyboardKey.T then
        log("Release T!")
    end
}
```

![10](https://mod-file.dn.nexoncdn.co.kr/bbs/168783201564551e95fb513c84de492d85265720ecda0.png)

#### KeyHoldEvent

KeyHoldEvent는 키보드의 키가 눌려있는 동안 프레임마다 발생하며, 이벤트가 발생할 때마다 HandleKeyHoldEvent 역시 매번 실행됩니다. KeyHoldEvent가 핸들러의 매개 변수로 전송되며, 다른 이벤트와 마찬가지로 유저가 입력한 키 정보가 포함되어 들어옵니다. 다음은 키를 누르는 동안 로그를 출력하는 예제입니다.

```
[service: InputService]
HandleKeyHoldEvent(KeyHoldEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    local key = event.key
    ---------------------------------------------------------
    
    if key == KeyboardKey.T then
        log("Hold T!")
    end
}
```

![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1687832098369dbf2798f3dbb4658b96fe2923bc09b03.png)

#### KeyReleaseEvent

`KeyReleaseEvent`는 키보드의 키가 눌려있는 상태에 있다가 키에서 손을 떼었을 때 1회 발생하는 이벤트입니다. 이벤트 발생 시 **HandleKeyReleaseEvent**도 함께 실행됩니다. `KeyUpEvent`와 비슷하지만 키가 한 프레임이라도 Hold 되어 있던 상태에서 Release 상태가 되었을 때 액션을 추가하고 싶다면 `HandleKeyReleaseEvent`를 사용합니다. `KeyReleaseEvent`가 핸들러의 매개 변수로 전송되며 유저가 입력한 키 정보가 포함되어 들어옵니다. 다음은 키를 눌렀다가 떼었을 때 로그를 출력하는 예제입니다.

```
[service: InputService]
HandleKeyReleaseEvent(KeyReleaseEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    local key = event.key
    ---------------------------------------------------------
    
    if key == KeyboardKey.T then
        log("Release T!")
    end
}
```

![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1687832181689b1e8caaae89744ebb1237a697880ffb9.png)

#### ScreenTouchEvent

`ScreenTouchEvent`는 화면을 클릭하거나 터치했을 때 1회 발생하는 이벤트입니다. 이벤트 발생 시 **HandleScreenTouchEvent**도 함께 실행됩니다. `ScreenTouchEvent`가 핸들러의 매개 변수로 전송되며, 터치한 위치의 좌표 (Vector2)가 포함되어 있습니다. 다음은 화면을 터치했을 때 터치한 위치의 좌표를 콘솔 창에 출력하는 예제입니다.

```
[service: InputService]
HandleScreenTouchEvent(ScreenTouchEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    
    log("Touch Point : "..tostring(TouchPoint))
}
```

![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1687832268666958cebf85bba4b81954c6b7335523127.png)

#### ScreenTouchHoldEvent

`ScreenTouchHoldEvent`는 화면을 터치하고 있는 동안 프레임마다 발생합니다. 이벤트가 발생할 때마다 **HandleScreenTouchHoldEvent**가 실행됩니다. `ScreenTouchHoldEvent`가 핸들러의 매개 변수로 전송되며, 터치 중인 위치의 좌표 정보가 포함되어 있습니다. 화면을 터치 중일 때 터치한 위치의 좌표를 콘솔 창에 출력하는 예제입니다.

```
[service: InputService]
HandleScreenTouchHoldEvent(ScreenTouchHoldEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    
    log("Touch Point : "..tostring(TouchPoint))
}
```

![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1687832343471d67ee1e1564d4caf9cd6c15c13c8cf10.png)

#### ScreenTouchReleaseEvent

`ScreenTouchReleaseEvent`는 터치를 유지하다가 터치를 종료했을 때 1회 발생하는 이벤트입니다. 이벤트 발생 시 **HandleScreenTouchReleaseEvent** 함께 실행됩니다. `ScreenTouchReleaseEvent`가 핸들러의 매개 변수로 전송되며, 터치를 뗀 위치의 좌표 정보가 포함되어 있습니다. 다음은 마지막으로 터치한 곳의 좌표를 출력하는 예제입니다.

```
[service: InputService]
HandleScreenTouchReleaseEvent(ScreenTouchReleaseEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    
    -- Parameters
    -- local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    
    log("Touch Point : "..tostring(TouchPoint))
}
```

![20](https://mod-file.dn.nexoncdn.co.kr/bbs/168783240469618ce325044bd41799cc760387afe94b9.png)

Update 2025-12-03 PM 03:40


# 멀티 터치

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

멀티 터치 동작은 포인터(예: 손가락) 여러 개가 동시에 화면을 터치하는 것을 말합니다. 이번 과정에서는 예제를 통해 멀티 터치 활용 방법을 알아봅시다.

# 멀티 터치

메이플스토리 월드에서는 `ScreenTouch` 계열 이벤트 또는 `Touch` 계열 이벤트를 통해 멀티 터치를 인식하고 월드 플레이에 활용할 수 있습니다.  아래의 `ScreenTouch` 계열 이벤트는 화면을 터치했을 때 [InputService](/apiReference/Services/InputService)에서 발생합니다.

- [ScreenTouchEvent](/apiReference/Events/ScreenTouchEvent)
- [ScreenTouchHoldEvent](/apiReference/Events/ScreenTouchHoldEvent)
- [ScreenTouchReleaseEvent](/apiReference/Events/ScreenTouchReleaseEvent)

아래의 `Touch` 계열 이벤트는 엔티티에 [TouchReceiveComponent](/apiReference/Components/TouchReceiveComponent)가 있어야 발생합니다.

- [TouchEvent](/apiReference/Events/TouchEvent)
- [TouchHoldEvent](/apiReference/Events/TouchHoldEvent)
- [TouchReleaseEvent](/apiReference/Events/TouchReleaseEvent)

멀티 터치를 사용하는 월드를 제작할 때, 위 내용을 참고하여 원하는 용도에 맞는 이벤트를 활용해 봅시다.

## 예제

**TouchReceiveComponent**를 추가한 엔티티 한 개 또는 여러 개를 터치한 상태로 움직이면 엔티티가 따라서 이동하는 예제를 살펴봅시다.

1. **Preset List - Object**에서 원하는 엔티티 2개를 **Scene**에 배치합니다. 예제에서는 **object-44**와 **object-49**를 사용했습니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1684290735891fcf50ce912fe48cf8999f06b6f04c0b8.png)
2. 본 예제에서는 `TouchEvent`, `TouchHoldEvent`, `TouchReleaseEvent`를 활용할 예정입니다. 이 이벤트들은 엔티티에 **TouchReceiveComponent**가 있어야 발생합니다. 그러므로 두 엔티티(object-44, object-49)에 **TouchReceiveComponent**를 추가합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1684300809932fceceea870bf4bdf8b179f481124f4f8.png)
3. 새 스크립트 컴포넌트 **MultitouchTest**를 생성합니다. 이 컴포넌트를 두 엔티티(object-44, object-49)에 추가합니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16843009914475f72fc6fb811406eac45f2d96ac8d237.png)
4. **MultitouchTest** 스크립트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
SyncTable<integer> index
[None]
any handler = nil
```
5. 이벤트 핸들러에 `TouchEvent`를 추가합니다. 터치가 발생하면 `AddHandler()` 함수를 호출하고 **TouchId**를 넘겨주도록 합니다.```
Event Handler:
[self]
HandleTouchEvent(TouchEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TouchReceiveComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    self:AddHandler(TouchId)
}
```
6. `TouchHoldEvent`도 추가합니다. 터치가 유지될 때도 `AddHandler()` 함수를 호출하고 **TouchId**를 넘겨주도록 합니다.```
Event Handler:
[self]
HandleTouchHoldEvent(TouchHoldEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TouchReceiveComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    self:AddHandler(TouchId)
}
```
7. `AddHandler()` 함수를 추가합니다. 매개 변수로 **integer** 타입의 **touchId**를 추가합니다. `ScreenTouchHoldEvent`와 `Move()` 함수를 연결합니다. 나중에 구독 취소를 하기 위해, 연결한 이벤트의 핸들러는 프로퍼티로 가지고 있도록 합니다.```
Method:
[client]
void AddHandler(integer touchId)
{
    if self.handler ~= nil then
        return
    end

    table.insert(self.index, touchId)
    self.handler = _InputService:ConnectEvent(ScreenTouchHoldEvent, self.Move)
}
```
8. `Move()` 함수를 추가합니다. `Move()`는 `ScreenTouchHoldEvent`의 매개변수를 전달 받기 때문에 **any** 타입의 **screenholdEvent**를 추가합니다. 유저가 엔티티를 터치한 상태로 움직이면 엔티티가 따라서 이동하도록 합니다.```
[client]
void Move(any screenholdEvent)
{
    local touchId = screenholdEvent.TouchId
    local touchPoint = screenholdEvent.TouchPoint

    local string
    for i =1, #self.index do
        if self.index[i] == touchId then
            self.Entity.TransformComponent.WorldPosition = _UILogic:ScreenToWorldPosition(touchPoint):ToVector3()
            break
        end
    end
}
```
9. `TouchReleaseEvent`도 추가합니다. 더 이상 터치한 엔티티가 없을 때 `ScreenTouchHoldEvent`에서 가지고 있던 이벤트 핸들러의 구독을 취소합니다.```
Event Handler:
[self]
HandleTouchReleaseEvent(TouchReleaseEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TouchReceiveComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local TouchId = event.TouchId
    local TouchPoint = event.TouchPoint
    ---------------------------------------------------------
    for i =1, #self.index do
        if self.index[i] == TouchId then
        table.remove(self.index, i)
            if #self.index <= 0 then
                _InputService:DisconnectEvent(ScreenTouchHoldEvent, self.handler)
                self.handler = nil
            end
            break
        end
    end
}
```
10. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. PC 환경에서 엔티티를 마우스로 클릭한 상태로 드래그하면 위치를 이동할 수 있습니다. 모바일 기기의 터치 스크린에서 2개의 엔티티를 동시에 터치하고 이동할 수도 있습니다. ![multitouch](https://mod-file.dn.nexoncdn.co.kr/bbs/16843006146740a5849ed9f2b4aae9ef3d48af36b18d5.gif)

Update 2025-11-17 PM 08:14


# 에디터 서비스의 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 제작하고 테스트 플레이를 시작하면 라이프 사이클에 따라 이벤트 함수를 호출합니다. 이와 다르게 [EditorService](/apiReference/Services/EditorService)는 메이커에서 스크립트 사용을 지원합니다. 크리에이터는 **EditorService**를 이용해 자신이 필요한 제작 도구를 만들 수 있습니다.

# 에디터 서비스 체험하기

EditorService를 활용해 로그를 남겨봅시다.

1. **MyDesk- Create Scripts - Create Component**를 선택하여 스크립트 컴포넌트를 추가하고 이름을 **HelloEditor**로 설정합니다.
2. Event Handler에 **EnterEditorEvent, EnterPlayEvent**를 추가하고 아래와 같이 작성합니다.```
Event Handler:
[service: EditorService]
HandleEnterEditorEvent(EnterEditorEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: EditorService
    -- Space: Editor
    ---------------------------------------------------------

    -- Parameters
    ---------------------------------------------------------
    log("Enter Editor Event")
}

[service: EditorService]
HandleEnterPlayEvent(EnterPlayEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: EditorService
    -- Space: Editor
    ---------------------------------------------------------

    -- Parameters
    ---------------------------------------------------------
    log("Enter Play Event")
}
```
3. **Hierarchy - World - Common**에 HelloEditor 컴포넌트를 추가합니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16456799439142a316dfd3f4d423faf840a94b8681bc1.png)
4. 시작![Tool_Play](https://mod-file.dn.nexoncdn.co.kr/bbs/163453086660754178e0ff96a45c58d1a580a4dfab9d1.png)을 눌러 **EnterPlayEvent**를 호출하며 해당 로그가 출력되는지 확인합니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1687841635285b77ef2ece1e04d24808a25fdba02c8c4.png)
5. 플레이를 종료하고 다시 UI 에디터로 돌아옵니다. 에디터로 돌아왔으므로 **EnterEditorEvent**가 호출됩니다. **EnterEditorEvent**는 아웃 게임에서 최초 에디터 진입 과정에서도 호출됩니다. ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/168784164997278c571c6f54c49a282600c1412e2790d.png)

# 에디터 타입의 UI 사용

UIGroupComponent의 **GroupType**을 변경해 에디터 타입의 UI를 구성할 수 있습니다. 에디터 타입 UI는 월드를 플레이하거나, 월드를 편집 중인 상태에서만 확인 및 기능 작동이 가능합니다. 간단한 예시를 통해 확인해보겠습니다. ![06](https://mod-file.dn.nexoncdn.co.kr/bbs/16560458866694a2f964d7cbb44a1b4e966596d010277.png)

1. UI 에디터를 엽니다. ![07](https://mod-file.dn.nexoncdn.co.kr/bbs/16611491146220ecdd23bd75c4e0b893476b109727246.png)
2. 새로운 UIGroup을 추가합니다. ![08](https://mod-file.dn.nexoncdn.co.kr/bbs/16560459550233fba6f0be20f40b8813dd49b8b984959.png)
3. 추가한 UIGroup을 선택합니다. ![09](https://mod-file.dn.nexoncdn.co.kr/bbs/16560460059060c0a533e60744a3a94c3be9280876c60.png)
4. 프로퍼티 에디터에서 UIGroupComponent의 GroupType을 **EditorType**으로 변경합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1645680750596d7f27d2366374420b79ae4dfd6ef6d7e.png)
5. 새로운 버튼을 추가해봅시다. 좌측 상단의 메뉴에서 버튼을 클릭해 추가하고 버튼의 이름을 **"Btn_EditorTest"**로 변경합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1656046223542857a7fa8661b424a8fb5bbd89e60eb72.png)
6. 씬 화면의 우측 상단에 있는 **[Editor UI]** 버튼을 클릭합니다. 플레이 상태가 아님에도 추가한 버튼이 보입니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1656046080229263374149c6541d9b49665418b2943ec.png) 버튼은 클릭 가능한 상태이므로 클릭 이벤트를 받아 처리하면 버튼을 의도대로 작동시킬 수 있습니다.
7. 앞서 추가한 **HelloEditor** 컴포넌트를 엽니다.
8. Event Handler에서 **ButtonClickEditorEvent**를 추가합니다.
9. 해당 이벤트의 대상을 앞서 추가한 **Btn_EditorTest** 엔티티로 설정합니다.
10. 아래와 같은 형태로 로그 추가 후 스크립트 에디터를 닫습니다.```
[entity] Btn_EditorTest(/ui/UIGroup/Btn_EditorTest)
HandleButtonClickEditorEvent(ButtonClickEditorEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Editor
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    log("Button Click")
}
```
11. 배치한 버튼을 클릭해봅시다. 추가한 로그가 정상적으로 출력됨을 확인할 수 있습니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/168784179772119cec289725b4252b43efb1499f22b93.png)

# 에디터 UI를 이용한 프로퍼티와 엔티티의 배치

스크립트를 이용해 에디터 상태에서 다른 컴포넌트에 접근해 프로퍼티를 수정할 수 있습니다. 이때 월드 플레이 때와는 다른 방식으로 프로퍼티 값이 저장됩니다. 월드 플레이 시에는 플레이 종료 후 메이커로 돌아오며 프로퍼티가 월드 제작 때 설정한 본래 값으로 돌아가지만, 에디터 UI의 경우 플레이를 종료하고 메이커로 돌아오면 변경된 값을 저장합니다. 메이플스토리 월드에서 제공하는 대부분의 API는 에디터 환경에서도 사용할 수 있습니다.

#### 에디터에서 월드 배경 변경

다음은 에디터 상태에서 버튼을 클릭할 때마다 월드의 배경을 변경하는 예시입니다. 월드 배경을 변경한 상태에서 저장하면 월드는 변경된 배경을 유지합니다.

```
Event Handler:
[self]
ButtonClickEditorEvent(ButtonClickEvent event)
{
    self.IsButtonClicked = not self.IsButtonClicked
    
    local backGroundRuid = "000000"
    local backGroundComp = _EntityService:GetEntityByPath("/maps/map01/Background").BackgroundComponent
    
    if self.IsButtonClicked then
        backGroundRuid = "000001"
    end

    backGroundComp:ChangeBackgroundByTemplateRUID(backGroundRuid)
}
```

#### 에디터에서 엔티티 스폰

버튼 클릭 시 에디터 상에 엔티티를 스폰하여 배치할 수도 있습니다. 에디터 상태에서 버튼을 클릭할 때마다 오브젝트를 스폰하는 예시입니다.

```
Event Handler:
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local Entity = event.Entity
    ---------------------------------------------------------
    
    local spawnModelId = "000000"
    local spawnPosition = Vector2(0,0)
     
    _EditorService:SetSelectedModel(spawnModelId)
    _EditorService:CreateSelectedModel(spawnPosition)
}
```

# 에디터 서비스의 이벤트

에디터 서비스는 실제로 월드를 플레이하는 상태가 아니므로 `OnBeginPlay()`나 `OnUpdate()`처럼 라이프 사이클을 사용하지 않습니다. 에디터에서 발생하는 이벤트를 중심으로 스크립트를 제작합니다. 사용 가능한 에디터 서비스의 함수와 이벤트는 API 레퍼런스 사이트에서 확인할 수 있습니다. 대표적인 에디터 서비스의 이벤트로는 **WorldLoadEditorEvent**, **EnterEditorEvent**가 있습니다.

- **WorldLoadEditorEvent**: 에디터 실행 후 월드를 로드하는 과정에서 1회 실행됩니다. 초기화를 시작하기 위한 좋은 이벤트입니다.
- **EnterEditorEvent**: 에디터 실행 후 월드를 최초 로드할 때와 테스트 플레이 종료 시 호출됩니다. 반복적으로 호출됨을 유의해야 합니다.

자주 사용하는 유형의 이벤트는 다음과 같습니다.

| 유형 | 이벤트 |
| --- | --- |
| 에디터 사용 간 특정 지점에 호출되는 이벤트 | EnterEditorEvent<br>WorldLoadEditorEvent<br>EnterPlayEvent |
| 엔티티 선택 관련 이벤트 | EntitySelectEditorEvent<br>EntityDeselectEditorEvent |
| 엔티티의 생성과 삭제 관련 이벤트 | EntityCreateEditorEvent<br>EntityDeleteEditorEvent |
| 마우스로 클릭한 위치 정보를 확인하기 위한 이벤트 | ScreenTouchEditorEvent<br>ScreenTouchHoldEditorEvent<br>ScreenTouchReleaseEditorEvent |
| 버튼 상태를 감지하기 위한 이벤트 | ButtonClickEditorEvent<br>ButtonStateChangeEditorEvent |
| 텍스트 인풋 필드의 상태를 감지하기 위한 이벤트 | TextInputValueChangeEditorEvent<br>TextInputEndEditEditorEvent |

# 편집한 정보 저장

**SpawnService**를 이용해 엔티티 배치하거나 프로퍼티 값을 수정해 변경된 값을 저장할 수 있습니다. 프로퍼티의 값을 수정 및 제어할 수 있다는 의미는 많은 정보를 수정할 수 있다는 의미를 내포하나, 복잡한 정보를 저장하기에는 충분하지 않을 수 있습니다.

**EditorService**는 데이터에 접근하여 값을 읽고 쓸 수 있는 기능을 제공합니다.아래와 같이 데이터를 구성했다고 가정해보겠습니다.

![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16456812592398638debc633f4b4383d1001170926f89.png)

dash의 col3 컬럼의 값을 가져오기 위해 아래와 같이 작성해 활용할 수 있습니다.

```
local data = _DataService:GetTable("CustomEditorData")
local rowCount = data:GetRowCount()
 
for i=1, rowCount do
    local name = data:GetCell(i, "name")
    if name == "dash"then
        local value = data:GetCell(i, "col3")
        log("find value : "..value)
        break
    end
end
```

데이터 서비스의 사용 방법과 기본적으로 동일하게 사용할 수 있으나 데이터를 Set 하는 방법이 다릅니다. 데이터를 Set하기 위해서는 EditorService의 API를 이용해야 합니다. 에디터 서비스에서는 이를 위해 `DataSetInsertRow()`, `DataSetRemoveRow()`, `DataSetSetCell()` 함수를 지원합니다.

아래는 4번째 줄에 데이터를 추가하고 관련 데이터를 세팅하는 예제입니다.

```
local data = _DataService:GetTable("CustomEditorData")
local rowCount = data:GetRowCount()
 
_EditorService:DataSetInsertRow("CustomEditorData")
 
_EditorService:DataSetSetCell("CustomEditorData", rowCount + 1, "name", "skill1")
_EditorService:DataSetSetCell("CustomEditorData", rowCount + 1, "col1", "10")
_EditorService:DataSetSetCell("CustomEditorData", rowCount + 1, "col2", "20")
_EditorService:DataSetSetCell("CustomEditorData", rowCount + 1, "col3", "30")
```

만약 dash의 col2 컬럼 값을 40으로 변경하고 싶다면 다음과 같이 작성합니다.

```
local data = _DataService:GetTable("CustomEditorData")
local rowCount = data:GetRowCount()
 
for i=1, rowCount do
    local name = data:GetCell(i, "name")
    if name == "dash"then
        local value = data:GetCell(i, "col2")
        _EditorService:DataSetSetCell("CustomEditorData", i, "col2", "40")
        break
    end
end
```

Update 2025-11-17 PM 08:14


# TimeSpan으로 시간 표현하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

DateTime을 활용하기 위해선 TimeSpan을 이용해야 합니다. 초, 분, 시간의 단위를 나타냅니다.

# TimeSpan 소개

TimeSpan은 시간 간격을 나타냅니다. 특정 시작점 또는 끝점에 대한 참조 없이 일반적인 간격만을 나타내므로 어떠한 가변적인 연도와 월 단위로 표현할 수 없습니다. TimeSpan은 특정 시점으로부터 다른 특정 시점까지의 시간을 계산할 때 사용할 수 있습니다. 어떤 스테이지를 통과하는 데 걸린 시간을 구하고 싶거나, 시간을 데이터 스토리지에 저장하기 위해 사용할 수 있습니다. 표준 형식 지정자와 사용자 형식 지정자 중 크리에이터의 필요에 맞게 사용할 수 있습니다. 표준 형식 지정자는 "c", "g", "G" 로 각 지정자마다 특정 형식이 정의되어 있습니다. 사용자 형식 지정자는 시간을 표시하는 형식의 자릿수와 표시 방법 등을 크리에이터의 필요에 맞게 사용할 수 있습니다.

# TimeSpan의 생성자

생성자는 보통 큰 시간에서 작은 시간으로 입력하고, 생성자에 따라 문화권을 구분하기도 합니다.

- 예: 시간, 분, 초 / 일, 시간, 분, 초, 밀리초
- **TimeSpan(int elapsed)**: 밀리초 단위의 정수로 객체를 초기화합니다.
- **TimeSpan(int hours, int minutes, int seconds)**: 시간, 분, 초로 객체를 초기화합니다.
- **TimeSpan(int days, int hours, int minutes, int seconds)**: 일, 시간, 분, 초로 객체를 초기화합니다.
- **TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds)**: 일, 시간, 분, 초, 밀리초로 객체를 초기화합니다.
- **TimeSpan(string timeSpanString)**: [ws][-]{ d | [d.]hh:mm[:ss[.ff]] }[ws] 형식의 시간 간격 사양을 문자열로 사용하고, 객체를 초기화합니다.
- **TimeSpan(string timeSpanString, string format)** : [ws][-]{ d | [d.]hh:mm[:ss[.ff]] }[ws] 형식의 시간 간격 사양을 문자열로 사용하고, 객체를 초기화합니다. timeSpanString은 반드시 format 형식과 정확하게 일치해야 하고, format은 표준 서식 지정자, 사용자 지정 서식 지정자를 포함합니다.
- **TimeSpan(string timeSpanString, string format, string cultureName)** : [ws][-]{ d | [d.]hh:mm[:ss[.ff]] }[ws] 형식의 시간 간격 사양을 문자열로 사용하고, 객체를 초기화합니다. timeSpanString은 반드시 format 형식과 정확하게 일치해야 하고, format은 표준 서식 지정자, 사용자 지정 서식 지정자를 포함합니다. cultureName은 format이 표준 지정자일 때 문화권별 정보를 제공합니다. 문화권 이름은 BCP-47의 표준을 따릅니다.

> **Tip** 대괄호 [ ] 안의 요소는 선택적으로 사용할 수 있습니다. 중괄호 { } 사이의 요소는 세로 막대 | 로 구분된 것 중에 선택해 사용합니다.

# 시간 간격 기호

TimeSpan에서 시간을 나타내는 공통 기호입니다.

| 기호 | 설명 |
| --- | --- |
| ws | 공백 |
| ff | 한 자릿수부터 일곱 자릿수로 구성된 초 자릿수 |
| ss | 0부터 59 사이의 초 |
| MM | 0부터 59 사이의 분 |
| hh | 0에서 23 사이의 시간 |
| d | 0부터 10675199 사이의 일 |
| - | TimeSpan 음수를 나타내는 기호 |
| . | 일과 시간을 구분하는 문화권 구분 기호<br>분과 초를 구분하는 문화권 구분 기호 |
| : | 문화권에 민감한 시간 구분 기호 |

# 표준 TimeSpan 서식 지정자

표준 TimeSpan 형식 문자열은 단일 형식 지정자를 사용하여 서식 지정 작업으로 생성되는 TimeSpan 값의 텍스트 표현을 정의합니다.

| 형식 지정자 | 이름 | 설명 |
| --- | --- | --- |
| "c" | 상수 형식 | 문화권을 구분하지 않으며 [-][d'.']hh':'mm':'ss['.'fff] 형식을 사용합니다. |
| "g" | 일반 약식 | 문화권을 구분하며, 필요한 내용을 출력합니다. [-][d':']h':'mm':'ss[.FFF] 형식을 사용합니다. |
| "G" | 일반 긴 형식 | 문화권을 구분하며, 일 수와 소수 7 자리를 출력합니다. [-]d':'hh':'mm':'ss.fff 형식을 사용합니다. |

> **Tip.** 형식 중 [ ] 사이의 기호들은 유효한 값이 있는 경우에만 해당 서식 지정자를 사용합니다.

#### 상수 서식 지정자

상수 서식 지정자 "c"는 문화권을 구분하지 않습니다. 형식은 [-][d'.']hh':'mm':'ss['.'fff] 입니다.

| 기호 | 설명 |
| --- | --- |
| - | 음수를 나타내는 기호 |
| fff | 초의 소수 부분을 나타냅니다. 값 범위는 "001" 부터 "999"까지입니다. |
| ss | "0"부터 "59" 범위의 초를 나타냅니다. |
| mm | "00"부터 "59" 범위의 분을 나타냅니다. |
| hh | "00"부터 "23" 범위의 시간을 나타냅니다. |
| d | 일 수를 나타냅니다. |

```
local timeSpan1 = TimeSpan(7, 45, 16)
local timeSpan2 = TimeSpan(18, 12, 38)
local timeSpanString1 = timeSpan1:ToFormattedString("c")
local timeSpanString2 = timeSpan2:ToFormattedString("c")
local timeSpanString3 = (timeSpan1 + timeSpan2):ToFormattedString("c")
 
log(timeSpanString1) -- 07:45:16
log(timeSpanString2) -- 18:12:38
log(timeSpanString3) -- 1.01:57:54
```

#### 일반 약식 서식 지정자

일반 약식 서식 지정자 "g"는 필요한 내용만 출력하며 문화권을 구분합니다. 형식은 [-][d':']h':'mm':'ss[.FFF] 입니다.

| 기호 | 설명 |
| --- | --- |
| - | 음수를 나타내는 기호 |
| . | 초 소수 구분을 나타냅니다. |
| FFF | 초의 소수 부분을 나타냅니다. |
| ss | "00"부터 "59" 범위의 초를 나타냅니다. |
| mm | "00"부터 "59" 범위의 분을 나타냅니다. |
| hh | "00"부터 "23" 범위의 시간을 나타냅니다. |
| d | 일 수를 나타냅니다. |

```
local timeSpan1 = TimeSpan(7, 45, 16)
local timeSpan2 = TimeSpan(18, 12, 38)
local timeSpanString1 = timeSpan1:ToFormattedString("g")
local timeSpanString2 = timeSpan2:ToFormattedString("g")
local timeSpanString3 = (timeSpan1 + timeSpan2):ToFormattedString("g", "fr-FR")
 
log(timeSpanString1) -- 07:45:16
log(timeSpanString2) -- 18:12:38
log(timeSpanString3) -- 1:1:57:54
```

#### 일반 긴 서식 지정자

일반 긴 서식 지정자 "G"는 항상 일 수와 소수 세 자릿수를 출력하고 문화권을 구분합니다. 형식은 [-]d':'hh':'mm':'ss.fff 입니다.

| 기호 | 설명 |
| --- | --- |
| - | 음수를 나타내는 기호 |
| . | 초 소수 구분을 나타냅니다. |
| fff | 초의 소수 부분을 나타냅니다. |
| ss | "00"부터 "59" 범위의 초를 나타냅니다. |
| mm | "00"부터 "59" 범위의 분을 나타냅니다. |
| hh | "00"부터 "23" 범위의 시간을 나타냅니다. |
| d | 일 수를 나타냅니다. |

```
local timeSpan1 = TimeSpan(7, 45, 16)
local timeSpan2 = TimeSpan(18, 12, 38)
local timeSpanString1 = timeSpan1:ToFormattedString("G")
local timeSpanString2 = timeSpan2:ToFormattedString("G")
local timeSpanString3 = (timeSpan1 + timeSpan2):ToFormattedString("G", "fr-FR")
 
log(timeSpanString1) -- 0:07:45:16.000
log(timeSpanString2) -- 0:18:12:38.000
log(timeSpanString3) -- 1:01:57:54,000
```

# 사용자 지정 TimeSpan 서식 지정자

사용자 지정 형식 문자열은 하나 이상의 사용자 지정 TimeSpan 형식 지정자와 임의 개수의 리터럴로 구성됩니다. TimeSpan 형식 문자열은 생성되는 TimeSpan 값의 텍스트 표현을 정의합니다. 표준 TimeSpan 형식 문자열이 아닌 문자열은 사용자 지정 TimeSpan 형식 문자열로 해석됩니다.

#### "d"

"d" 사용자 지정 형식 지정자는 일 수를 나타내는 값을 출력합니다. 값이 두 자리 이상인 경우에도 전체 일 수를 출력합니다. 값이 0인 경우 지정자는 "0"을 출력합니다. "d" 사용자 지정 형식 지정자만 단독으로 사용하는 경우 표준 형식 문자열로 잘못 해석되지 않도록 "%d"를 지정합니다.

```
local timeSpan = TimeSpan(16, 4, 3, 17, 250)
local timeSpanString = timeSpan:ToFormattedString("%d")
 
log(timeSpanString) -- 16
```

#### "d" - "dddddddd"

"dd", "ddd", "dddd", "ddddd", "dddddd", "ddddddd", "dddddddd" 사용자 지정 서식 지정자는 일 수를 나타내는 값을 출력합니다. 출력 문자열에는 서식 지정자에 "d" 문자 수로 지정된 최소 자릿수가 포함되며 필요에 따라 앞에 0으로 채워집니다. 전체 일 수가 서식 지정자의 "d" 문자 수를 초과할 경우 전체 일 수가 결과 문자열에 출력됩니다.

```
local timeSpan = TimeSpan(365, 21, 19, 45)
  
log(timeSpan:ToFormattedString("dd'.'hh':'mm':'ss")) -- 365.21:19:45
log(timeSpan:ToFormattedString("dddd'.'hh':'mm':'ss")) -- 0365.21:19:45
```

#### "h"

"h" 사용자 지정 형식 지정자는 시간 수를 나타내는 값을 출력합니다. 시간 값이 0-9라면 한 자리 문자열 값을 반환하고, 10-23이면 두 자리 문자열을 반환합니다. "h" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 지정자로 잘못 해석되지 않도록 "%h"를 지정합니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "h" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 시간 수로 해석할 수 있습니다.

```
local timeSpan = TimeSpan(16, 4, 3, 17, 250)
local timeSpanString = timeSpan:ToFormattedString("%h")
 
log(timeSpanString) -- 4
```

#### "hh"

"hh" 사용자 지정 서식 지정자는 시간 수를 나타내는 값을 출력합니다. 시간 값이 0-9라면 출력 문자열 앞에 0이 포함됩니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "hh" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 시간 수로 해석할 수 있습니다.

```
local timeSpan = TimeSpan(365, 3, 14, 45)
  
log(timeSpan:ToFormattedString("dd'.'hh':'mm':'ss")) -- 365.03:14:45
```

#### "m"

"m" 사용자 지정 서식 지정자는 분 수를 나타내는 값을 출력합니다. 분 값이 0-9라면 한 자리 문자열 값을 반환하고, 값이 10-59라면 두 자리 문자열 값을 반환합니다. "m" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 지정자로 잘못 해석되지 않도록 "%m"을 지정합니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "m" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 분 수로 해석할 수 있습니다.

```
local timeSpan = TimeSpan(16, 4, 3, 17, 250)
local timeSpanString = timeSpan:ToFormattedString("%m")
 
log(timeSpanString) -- 3
```

#### "mm"

"mm" 사용자 지정 서식 지정자는 분 수를 나타내는 값을 출력합니다. 분 값이 0-9라면 출력 문자열 앞에 0이 포함됩니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "mm" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 분 수로 해석할 수 있습니다.

```
local timeSpan = TimeSpan(365, 21, 4, 45)
  
log(timeSpan:ToFormattedString("dd'.'hh':'mm':'ss")) -- 365.21:04:45
```

#### "s"

"s" 사용자 지정 서식 지정자는 초 수를 나타내는 값을 출력합니다. 초 값이 0-9라면 한 자리 문자열 값을 반환하고 값이 10-59라면 두 자리 문자열 값을 반환합니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "s" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 초 수로 해석할 수 있습니다. "s"만 단독으로 사용하는 경우 표준 서식 지정자로 잘못 해석되지 않도록 "%s"를 지정합니다.

```
local timeSpan = TimeSpan(16, 4, 3, 17, 250)
local timeSpanString = timeSpan:ToFormattedString("%s")
 
log(timeSpanString) -- 17
```

#### "ss"

"ss" 사용자 지정 서식 지정자는 초 수를 나타내는 값을 출력합니다. 초 값이 0-9라면 출력 문자열 앞에 0이 포함됩니다. 일반적으로 하나의 숫자만 포함하는 문자열은 일 수로 해석됩니다. "ss" 사용자 지정 서식 지정자를 대신 사용하여 숫자 문자열을 초 수로 해석할 수 있습니다.

```
local timeSpan = TimeSpan(365, 21, 4, 5)
  
log(timeSpan:ToFormattedString("dd'.'hh':'mm':'ss")) -- 365.21:04:05
```

#### "f"

"f" 사용자 지정 서식 지정자는 1/10 초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 문자열로 TimeSpan 객체를 생성할 경우 문자열에는 정확히 소수 한 자리가 포함되어야 합니다. "f"만 단독으로 사용하는 경우 표준 서식 지정자로 잘못 해석되지 않도록 "%f"를 지정합니다.

```
local timeSpan = TimeSpan(876)
  
log(timeSpan:ToFormattedString("%f")) -- 8
```

#### "ff"

"ff" 사용자 지정 서식 지정자는 1/100 초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 문자열로 TimeSpan 객체를 생성할 경우 문자열에는 정확히 소수 두 자리가 포함되어야 합니다.

```
local timeSpan = TimeSpan(876)
  
log(timeSpan:ToFormattedString("ff")) -- 87
```

#### "fff"

"fff" 사용자 지정 서식 지정자는 밀리초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 문자열로 TimeSpan 객체를 생성할 경우 문자열에는 정확히 소수 세 자리가 포함되어야 합니다.

```
local timeSpan = TimeSpan(876)
  
log(timeSpan:ToFormattedString("fff")) -- 876
```

#### "F"

"F" 사용자 지정 서식 지정자는 1/10 초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 1/10초 값이 0이라면 결과 문자열에 포함되지 않습니다. 문자열로 TimeSpan 객체를 생성할 경우 1/10초 숫자 표시는 포함되지 않아도 됩니다. "F"만 단독으로 사용하는 경우 표준 서식 지정자로 잘못 해석되지 않도록 "%F"를 지정합니다.

```
local timeSpan = TimeSpan(800)

log(timeSpan:ToFormattedString("%F")) -- 8
```

#### "FF"

"FF" 사용자 지정 서식 지정자는 1/100 초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 1/100초 값이 0이라면 결과 문자열에 포함되지 않습니다. 문자열로 TimeSpan 객체를 생성할 경우 1/100초 숫자 표시는 포함되지 않아도 됩니다.

```
local timeSpan1 = TimeSpan(876)
local timeSpan2 = TimeSpan(800)
  
log(timeSpan1:ToFormattedString("FF")) -- 87
log(timeSpan2:ToFormattedString("FF")) -- 8
```

#### "FFF"

"FFF" 사용자 지정 서식 지정자는 밀리초를 출력합니다. 서식 지정 작업에서 나머지 소수 자릿수는 잘립니다. 밀리초 값이 0이라면 결과 문자열에 포함되지 않습니다. 문자열로 TimeSpan 객체를 생성할 경우 밀리초 숫자 표시는 포함되지 않아도 됩니다.

```
local timeSpan1 = TimeSpan(876)
local timeSpan2 = TimeSpan(800)
  
log(timeSpan1:ToFormattedString("FFF")) -- 876
log(timeSpan2:ToFormattedString("FFF")) -- 8
```

Update 2025-11-17 PM 08:14


# 날짜와 시간 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=40%EB%B6%84&amp;color=green)

# 학습 과정 소개

날짜와 시간을 표현하는 DateTime에 대해 알아보고, 활용할 수 있는 다양한 서식 지정자를 알아봅시다.

# DateTime 알아보기

DateTime은 날짜와 시간으로 표시된 시간을 나타내는 객체입니다. 값 형식은 그레고리력에서 00:00:00(자정), 서기 0001년 1월 1일부터 9999년 12월 31일 오후 11:59:59까지의 값으로 날짜와 시간을 나타냅니다. DateTime은 맵에 입장한 시간이나, 계정이 생성된 날처럼 특정 날짜를 나타내기 위해 사용합니다. DateTime은 활용할 때 주로 시간 값이 필요하기 때문에 TimeSpan과 함께 사용하는 경우가 많습니다.

# DateTime 상수

DateTime의 상수는 값을 따로 할당할 필요 없이 `DateTime.UtcNow`처럼 사용할 수 있습니다.

| 상수 | 설명 |
| --- | --- |
| UtcNow | 현재 날짜와 시간을 UTC로 가져옵니다. |
| MaxValue | DateTime의 최댓값입니다. |
| MinValue | DateTime의 최솟값입니다. |

# DateTime 생성자

생성자는 보통 큰 시간에서 작은 시간으로 입력하고, 생성자에 따라 문화권을 구분하기도 합니다.

| 생성자 | 설명 |
| --- | --- |
| DateTime(int elapsed) | 밀리초 단위의 정수를 UTC로 객체를 초기화합니다. |
| DateTime(int year, int month, int day, int hour, int minute, int second) | 연도, 월, 일, 시간, 분, 초를 UTC로 객체를 초기화합니다. |
| DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) | 연도, 월, 일, 시간, 분, 초, 밀리초를 UTC로 객체를 초기화합니다. |
| DateTime(string dateTimeString) | 문자열로 객체를 초기화합니다. |
| DateTime(string dateTimeString, string format) | 문자열로 객체를 초기화합니다.<br>dateTimeString는 format과 정확하게 일치해야 합니다. format은 표준 날짜 및 시간 서식 지정자 및 사용자 지정 날짜 및 시간 서식 지정자를 포함하는 문자열입니다. |
| DateTime(string dateTimeString, string format, string cultureName) | 문자열로 객체를 초기화합니다.<br> dateTimeString는 반드시 format과 정확하게 일치해야 하고, format은 표준 날짜 및 시간 서식 지정자 및 사용자 지정 날짜 및 시간 서식 지정자를 포함하는 문자열입니다.<br>cultureName은 format에 포함된 서식 지정자에 대한 문화권별 정보를 제공합니다. cultureName은 BCP-47의 표준을 따릅니다. |

# DateTime 프로퍼티

| 프로퍼티 | 설명 |
| --- | --- |
| Elapsed | 밀리초 단위의 정수 |
| Day | 일 |
| Month | 월 |
| Year | 연도 |
| Millisecond | 밀리초 |
| Second | 초 |
| Minute | 분 |
| Hour | 시간 |

# 활용 예시

#### DateTime 저장, 불러오기

DateTime을 정수 타입인 Elapsed로 변환하여 DataStorage에 저장하거나 Elapsed를 불러와서 DateTime을 복구하는 예제입니다.

```
local originDate =  DateTime(2022, 5, 17, 13, 21, 35)
local elapsed = originDate.Elapsed

local dataStorage = _DataStorageService:GetGlobalDataStorage ("dsName")
dataStorage:SetAndWait("date", tostring(elapsed))
 
local errorCode, dateFromDataStorage = dataStorage:GetAndWait("date")
local convertedDate = DateTime(tonumber(dateFromDataStorage))

log(convertedDate)
```

#### 다른 실행 공간으로 DateTime 보내기

DataTime을 DateElapsed를 사용해 다른 실행 공간에서 DateTime을 활용할 수 있습니다.

```
[server only]
void OnBeginPlay()
{
    wait(1)
    local date = DateTime(2022, 5, 17, 13, 21, 35)
    self:ServerToClient(date.Elapsed)
}
 
[client]
void ServerToClient(number dateElapsed)
{
    local date = DateTime(dateElapsed)
    log(date)
}
```

#### DateTime을 Local Time으로 변환

DateTime은 기본적으로 UTC 기준으로 설정됩니다. 이를 로컬 시간으로 변환하려면 실행 제어를 통해 Client 공간으로 이동시킨 후 UtilLogic의 GetLocalTimeForm 메서드로 로컬 시간으로 변환할 수 있습니다.

```
[server only]
void OnBeginPlay()
{
    wait(1)
    local date = DateTime(2022, 5, 17, 13, 21, 35)
    self:ServerToClient(date.Elapsed)
}
[client]
void ServerToClient(number dateElapsed)
{
    local date = DateTime(dateElapsed)
    local localTime = _UtilLogic:GetLocalTimeFrom(date)
    log(localTime)
}
```

#### DateTime에 서식 지정하기

다양한 서식 지정자를 활용해 크리에이터가 원하는 서식을 지정해 사용할 수 있습니다.

```
local date = DateTime(2022, 5, 17, 13, 21, 35)
local dateString = date:ToFormattedString("'연도는 'yyyy ")
log(dateString) -- 연도는 2022
```

# 문자열을 사용한 생성 형식

문자열을 통해 DateTime객체를 생성할 때 다음과 같은 형식을 사용할 수 있습니다. 아래의 다양한 형식처럼 특정 구성 요소만 조합해 사용하고, 다른 구성 요소가 없는 경우에는 특정 시간, 날짜, 일, 연도를 기준으로 하거나, 현재를 기준으로 가정합니다.

#### 날짜와 시간

날짜와 시간을 모두 사용하는 구성 요소입니다.

```
local dateAsString = "08/18/2022 07:22:16" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 07:22:16
```

#### 날짜

날짜만 있는 구성 요소입니다. 시간 구성 요소가 없는 경우에 시간은 00:00:00으로 가정합니다.

```
local dateAsString = "08/18/2022" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 00:00:00
```

#### 월과 연도

월과 연도만 있는 구성 요소입니다. 일을 사용하지 않는 경우에 일 구성 요소는 월의 첫 번째 날로 가정합니다.

```
local dateAsString = "8/2022" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 00:00:00
```

#### 월과 일

월과 일만 있는 구성 요소를 사용합니다. 연도는 사용하지 않는 경우에 연도 구성 요소는 현재 연도로 가정합니다.

```
local dateAsString = "8/18" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 00:00:00
```

### 시간

시간만 있고 날짜 구성 요소가 없는 문자열의 경우 날짜 구성 요소는 현재 날짜로 가정합니다.

```
local dateAsString = "07:22:16" 
local date = DateTime(dateAsString)
log(date) -- 5/9/2022 07:22:16
```

#### 시간과 오전/오후

시간과 오전/오후(AM/PM) 지정자만 있고 날짜 구성 요소가 없는 문자열의 경우 날짜 구성 요소는 현재 날짜를, 시간(분, 초)은 00:00을 가정합니다.

```
local dateAsString = "7 PM" 
local date = DateTime(dateAsString)
log(date) -- 05/09/2022 19:00:00
```

#### ISO 8601 문자열

표준 시간대 정보를 포함하고, ISO 8601을 준수하는 문자열을 사용하는 경우에 DateTime은 기본적으로 UTC로 저장됩니다. 그러므로 UTC로 지정할 경우 시간 값은 유지됩니다.

- 예시: "2022-11-01T19:35:00.000Z"

```
local dateAsString = "2022-08-18T07:22:16.000Z"
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 07:22:16
```

표준 시간대 오프셋 정보를 지정할 경우 오프셋만큼 변경된 UTC 값으로 저장됩니다.

- 예시: "2022-11-01T19:35:00.000-07:00"

```
local dateAsString = "2022-08-18T07:22:16.000-07:00" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 14:22:16
```

#### RFC 1123 시간 형식 문자열

RFC 1123 시간 형식을 준수하는 문자열을 사용할 수 있습니다. 이때 GMT 지정자를 포함해야 합니다.

```
local dateAsString = "Thu, 18 Aug 2022 07:22:16 GMT" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 07:22:16
```

#### 표준 시간대 오프셋 정보

표준 날짜 및 시간 서식 문자열은 단일 문자를 서식 지정자로 사용하여 DateTime 값의 문자열 표현을 정의합니다. 공백을 포함하여 문자를 둘 이상 포함하는 날짜 및 시간 서식은 사용자 지정 날짜 및 시간 서식 문자열로 해석됩니다.

```
local dateAsString = "08/18/2022 07:22:16 -5:00" 
local date = DateTime(dateAsString)
log(date) -- 08/18/2022 12:22:16
```

# 표준 날짜, 시간 서식 지정자

단일 문자를 서식 지정자로 사용해 표준 날짜와 시간의 서식을 DateTime 값의 문자열로 정의하고 사용합니다. 공백을 포함한 두 문자 이상의 날짜 및 시간 서식은 사용자 지정 날짜 및 시간 서식 지정자로 해석되므로 사용 시 공백 유무를 유의해야 합니다.

#### 서식 지정자

표준 서식 지정자들에 대한 간략한 설명입니다. 자세한 설명은 아래 내용을 참고하세요.

| 서식 지정자 | 설명 |
| --- | --- |
| "d" | 간단한 날짜 패턴 |
| "D" | 자세한 날짜 패턴 |
| "f" | 전체 날짜/간단한 시간 패턴 |
| "F" | 전체 날짜/자세한 시간 패턴 |
| "g" | 일반 날짜/간단한 시간 패턴 |
| "G" | 일반 날짜/자세한 시간 패턴 |
| "M", "m" | 월/일 패턴 |
| "O", "o" | 왕복 날짜/시간 패턴 |
| "R", "r" | RFC1123 패턴 |
| "s" | 정렬 가능한 날짜/시간 패턴 |
| "t" | 간단한 시간 패턴 |
| "T" | 자세한 시간 패턴 |
| "u" | 정렬 가능한 UTC 날짜/시간 패턴 |
| "U" | UTC 날짜/시간 패턴 |
| "Y", "y" | 연도 월 패턴 |

#### "d"

"d" 표준 서식 지정자는 특정 문화권의 간단한 날짜 서식 문자열을 나타냅니다. 문화권을 지정하지 않으면 서식 문자열은 **"MM/dd/yyyy"**을 사용합니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("d")) -- 04/10/2022
log(date:ToFormattedString("d", "en-US")) -- 4/10/2022
```

#### "D"

"D" 표준 서식 지정자는 특정 문화권의 자세한 날짜 서식 문자열을 나타냅니다. 문화권을 지정하지 않으면 서식 문자열은 **"dddd, dd MMMM yyyy"**을 사용합니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("D")) -- Sunday, 10 April 2022
log(date:ToFormattedString("D", "pt-BR")) -- domingo, 10 de abril de 2022
```

#### "f"

"f" 표준 서식 지정자는 공백으로 구분된 자세한 날짜("D")와 간단한 시간("t")이 조합된 다양한 패턴의 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"dddd, dd MMMM yyyy HH:mm"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("f")) -- Sunday, 10 April 2022 00:00
log(date:ToFormattedString("f", "pt-BR")) -- domingo, 10 de abril de 2022 00:00
```

#### "F"

"F" 표준 서식 지정자는 특정 문화권의 전체 날짜, 자세한 시간 서식 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"dddd, dd MMMM yyyy HH:mm:ss"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("F")) -- Sundy, 10 April 2022 00:00:00
log(date:ToFormattedString("F", "pt-BR")) -- domingo, 10 de abril de 2022 00:00:00
```

#### "g"

"g" 표준 서식 지정자는 공백으로 구분된 간단한 날짜("d")와 간단한 시간("t")이 조합된 다양한 패턴의 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"MM/dd/yyyy HH:mm"**이고, 문화권을 지정하면 해당 문화권의 일반 날짜("d"), 간단한 시간("t") 서식 문자열을 나타냅니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("g")) -- 04/10/2022 00:00
log(date:ToFormattedString("g", "pt-BR")) -- 10/04/2022 00:00
```

#### "G"

"G" 표준 서식 지정자는 공백으로 구분된 간단한 날짜("d")와 자세한 시간("T")이 조합된 다양한 패턴의 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"MM/dd/yyyy HH:mm:ss"**이고, 문화권을 지정하면 해당 문화권의 간단한 날짜("d"), 자세한 시간("T") 서식 문자열을 나타냅니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("G")) -- 04/10/2022 00:00:00
log(date:ToFormattedString("G", "pt-BR")) -- 10/04/2022 00:00:00
```

#### "O", "o"

"O", "o" 표준 서식 지정자는 왕복 날짜, 시간 서식 지정자입니다. 왕복은 날짜에서 문자열로, 문자열에서 날짜로 변환하고 복구할 수 있는 서식임을 의미합니다. "O", "o" 표준 서식 지정자는 ISO 8601을 준수하는 결과 문자열을 나타냅니다. "O", "o" 표준 서식 지정자는 DateTime 값의**"yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK"** 사용자 지정 서식 문자열에 해당합니다. 다음은 "O", "o" 표준 서식 지정자를 통해 문자열을 만든 다음 다시 날짜 객체로 복원하는 예제입니다.

```
local date = DateTime(2022, 4, 10)
local formattedString = date:ToFormattedString("o")
log(formattedString) -- 2022-04-10T00:00:00.000Z
 
date = DateTime(formattedString)
log(date) -- 04/10/2022 00:00:00
```

#### "R", "r"

"R" 또는 "r" 표준 서식 지정자는 IETF RFC 1123 사양을 기반으로 시간 값에 대한 사용자 지정 서식 문자열을 나타냅니다. (**"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"**) 사용자 지정 서식 문자열에서 작은따옴표는 리터럴에 해당합니다. 작은따옴표는 하이픈, 콜론 및 개발 문자를 구분하는 용도로 사용합니다. 따라서 결과 문자열에 표시되지 않습니다. 시간은 IETF RFC 1123 표준에 따라 UTC로 표시되기 때문에 서식 지정자를 사용하기 전에 값이 UTC인지 확인해야 합니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("r")) -- Sun, 10 Apr 2022 00:00:00 GMT
```

#### "s"

"s" 표준 서식 지정자는 사용자 지정 서식 문자열을 나타냅니다. (**"yyyy'-'MM'-'dd'T'HH':'mm':'ss"**) "s" 서식 지정자는 날짜 및 시간 값에 따라 오름차순 또는 내림차순으로 정렬되는 결과 문자열을 생성하기 위한 서식 지정자입니다. 사용자 지정 서식 문자열에서 하이픈, 콜론 및 개발 문자를 구분하는 작은따옴표는 리터럴에 해당하고, 결과 문자열의 작은따옴표는 표시되지 않습니다. 날짜 및 시간 값은 일관된 형식으로 나타내지만 DateTime의 종류(UTC, Local)에 따라 값을 수정하지는 않습니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("s")) -- 2022-04-10T00:00:00
```

#### "u"

"u" 표준 서식 지정자는 사용자 지정 서식 문자열을 나타냅니다. (**"yyyy'-'MM'-'dd HH':'mm':'ss'Z"**) 사용자 지정 서식 문자열에서 하이픈, 콜론 및 개발 문자를 구분하는 작은따옴표 쌍은 리터럴에 해당하고, 결과 문자열의 작은따옴표는 표시되지 않습니다. 결과 문자열에 시간이 UTC로 표시합니다. 그러나 DateTime의 종류(UTC, Local)에 따라 값을 수정하지는 않으므로 서식 지정자를 사용하기 전에 값이 UTC인지 확인해야 합니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("u")) -- 2022-04-10 00:00:00Z
```

#### "U"

"U" 표준 서식 지정자는 "F" 표준 서식 지정자와 동일한 패턴을 가지지만 "U" 표준 서식 지정자는 DateTime의 값을 UTC로 변환합니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("U")) -- Sunday, 10 April 2022 00:00:00
log(date:ToFormattedString("U", "pt-BR")) -- domingo, 10 de abril de 2022 00:00:00
```

#### "t"

"t" 표준 서식 지정자는 특정 문화권의 간단한 시간 서식 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"HH:mm"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("t")) -- 00:00
log(date:ToFormattedString("t", "en-US")) -- 12:00 AM
```

#### "T"

"T" 표준 서식 지정자는 특정 문화권의 자세한 시간 서식 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"HH:mm:ss"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("T")) -- 00:00:00
log(date:ToFormattedString("T", "en-US")) -- 12:00:00 AM
```

#### "M", "m"

"M" 또는 "m" 표준 서식 지정자는 특정 문화권의 월 서식 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"MMMM dd"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("m")) -- April 10
log(date:ToFormattedString("m", "pt-BR")) -- 10 de abril
```

#### "Y", "y"

"Y" 또는 "y" 표준 서식 지정자는 특정 문화권의 년 월 서식 문자열을 나타냅니다. 문화권을 지정하지 않을 경우 서식 문자열은 **"yyyy MMMM"**입니다.

```
local date = DateTime(2022, 4, 10)
log(date:ToFormattedString("y")) -- 2022 April
log(date:ToFormattedString("y", "pt-BR")) -- abril de 2022
```

# 사용자 지정 날짜 및 시간 서식 지정자

사용자 지정 서식 지정자는 하나 이상의 사용자 지정 날짜 및 시간 서식 지정자로 구성됩니다. 생성되는 DateTime 값의 텍스트 표현을 정의합니다. 표준 날짜 및 시간 서식 지정자가 아닌 문자열은 사용자 지정 날짜 및 시간 서식 지정자로 해석됩니다.

#### 서식 지정자

사용자 지정 서식 지정자들에 대한 간략한 설명입니다. 자세한 설명은 아래 내용을 참고하세요.

| 서식 지정자 | 설명 |
| --- | --- |
| "d" | 1부터 31까지의 일을 나타내는 서식 지정자 |
| "dd" | 01부터 31까지의 일 |
| "ddd" | 요일의 약식 이름 |
| "dddd" | 요일의 전체 이름 |
| "f" | 날짜 및 시간 값의 1/10초 |
| "ff" | 날짜 및 시간 값의 1/100초 |
| "fff" | 날짜 및 시간 값의 1/1000초 |
| "F" | 날짜 및 시간 값의 1/10초. 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다. |
| "FF" | 날짜 및 시간 값의 1/100초. 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다. |
| "FFF" | 날짜 및 시간 값의 1/1000초. 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다. |
| "g", "gg" | 서기 또는 연대 |
| "h" | 1부터 12까지의 시 |
| "hh" | 01부터 12까지의 시 |
| "H" | 0부터 23까지의 시 |
| "HH" | 00부터 23까지의 시 |
| "K" | 시간대 정보 |
| "m" | 0부터 59까지의 분 |
| "mm" | 00부터 59까지의 분 |
| "M" | 0부터 12월까지의 월 |
| "MM" | 01부터 12까지의 월 |
| "MMM" | 월의 약식 이름 |
| "MMMM" | 월의 전체 이름 |
| "s" | 0부터 59까지의 초 |
| "ss" | 00부터 59까지의 초 |
| "t" | AM/PM 지정자의 첫 문자 |
| "tt" | AM/PM 지정자 |
| "y" | 0부터 99까지의 연도 |
| "yy" | 00부터 99까지의 연도 |
| "yyy" | 최소 세 자릿수 연도 |
| "yyyy" | 네 자릿수 연도 |
| ":" | 시간 구분 기호 |
| "/" | 날짜 구분 기호 |
| "string". 'string' | 리터럴 문자열 구분 기호 |
| % | 뒤에 오는 문자를 사용자 지정 서식 지정자로 정의하는 서식 지정자 |

#### "d"

"d" 사용자 지정 서식 지정자는 일을 1부터 31까지의 숫자로 나타냅니다. 일이 한 자릿수인 경우 십의 자리는 생략합니다. 예를 들어, 3일이라면 03이 아니라 3으로 나타납니다. "d"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 9, 19, 27, 15)
log(date:ToFormattedString("%d")) -- 9
```

#### "dd"

"dd" 사용자 지정 서식 지정자는 일을 01부터 31까지의 숫자로 나타냅니다. 일이 한 자릿수인 경우 십의 자리에는 0이 표시됩니다.

```
local date = DateTime(2022, 8, 9, 19, 27, 15)
log(date:ToFormattedString("dd")) -- 09
```

#### "ddd"

"ddd" 사용자 지정 서식 지정자는 요일의 약식 이름을 나타냅니다. 문화권을 지정하면, 문화권에 해당하는 약식 요일이 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15)
log(date:ToFormattedString("ddd")) -- Mon
log(date:ToFormattedString("ddd", "fr-FR")) -- lun.
```

#### "dddd"

"dddd" 사용자 지정 서식 지정자는 요일의 전체 이름을 나타냅니다. 문화권을 지정하면 문화권에 해당하는 요일이 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15)
log(date:ToFormattedString("dddd")) -- Monday
log(date:ToFormattedString("dddd", "fr-FR")) -- lundi
```

#### "f"

"f" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/10 초를 나타냅니다. "f"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%f")) -- 0
```

#### "ff"

"ff" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/100 초를 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("ff")) -- 02
```

#### "fff"

"fff" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/1000 초를 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("fff")) -- 023
```

#### "F"

"F" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/10 초를 나타냅니다. 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다. "F"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%F")) -- empty
```

#### "FF"

"FF" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/100 초를 나타냅니다. 유효 자릿수는 2개이며, 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다. 유효 자릿수가 3개 이상일 경우에도 2개의 유효 자릿수만 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("FF")) -- 02
```

#### "FFF"

"FFF" 사용자 지정 서식 지정자는 날짜 및 시간 값에서 1/1000 초를 나타냅니다. 유효 자릿수는 3개이며, 유효 자릿수가 모두 0이면 아무것도 표시되지 않습니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("FFF")) -- 023
```

#### "g", "gg"

"g" 또는 "gg" 사용자 지정 서식 지정자는 연대를 나타냅니다. 기본적으로 A.D(Anno Domini, 기원후)로 나타납니다. "g" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%g")) -- A.D.
```

#### "h"

"h" 사용자 지정 서식 지정자는 시간을 1부터 12까지의 숫자로 나타냅니다. 시가 한 자릿수인 경우 십의 자리는 표시되지 않습니다. 자정 또는 정오 이후의 총시간을 계산하는 12시간 형식으로 나타냅니다. 자정 이후의 시간과 정오 이후의 시간을 구별할 수 없습니다. "h"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%h")) -- 7
```

#### "hh"

"hh" 사용자 지정 서식 지정자는 시간을 1부터 12까지의 숫자로 나타냅니다. 시가 한 자릿수인 경우 십의 자리에는 0이 표시됩니다. 자정 또는 정오 이후의 총시간을 계산하는 12시간 형식으로 나타냅니다. 자정 이후의 시간과 정오 이후의 시간을 구별할 수 없습니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("hh")) -- 07
```

#### "H"

"H" 사용자 지정 서식 지정자는 시간을 0부터 23까지의 숫자로 나타냅니다. 시가 한 자릿수인 경우 십의 자리는 표시되지 않습니다. 자정 이후의 시간을 계산하는 24시간 형식으로 나타냅니다. "H"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%H")) -- 19
```

#### "HH"

"HH" 사용자 지정 서식 지정자는 0부터 23까지의 숫자로 나타냅니다. 시가 한 자릿수인 경우 십의 자리에는 0이 표시됩니다. 자정 이후의 시간을 계산하는 24시간 형식으로 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("HH")) -- 19
```

#### "K"

"K" 사용자 지정 서식 지정자는 날짜 및 시간 값의 표준 시간대 정보를 나타냅니다. "K" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

- DateTime의 종류가 Local일 경우 이 지정자는 UTC에서의 로컬 오프셋이 포함된 결과 문자열이 출력됩니다.
- DateTime의 종류가 UTC일 경우 결과 문자열에 UTC 날짜를 나타내는 "Z" 문자가 포함되어 출력됩니다.

```
local date = DateTime(2022, 8, 29, 19, 27, 15, 023)
log(date:ToFormattedString("%K")) -- Z
```

#### "m"

"m" 사용자 지정 서식 지정자는 분을 0부터 59까지의 숫자로 나타냅니다. 분은 마지막 시간 이후 경과한 총 분 수를 나타냅니다. 분이 한 자릿수인 경우 십의 자리는 표시되지 않습니다. "m" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("%m")) -- 7
```

#### "mm"

"mm" 사용자 지정 서식 지정자는 분을 00부터 59까지의 숫자로 나타냅니다. 분은 마지막 시간 이후 경과한 총 분 수를 나타냅니다. 분이 한 자릿수인 경우 십의 자리는 0으로 표시됩니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("mm")) -- 07
```

#### "M"

"M" 사용자 지정 서식 지정자는 월을 1부터 12까지의 숫자로 나타냅니다. 월이 한 자릿수인 경우 십의 자리는 표시되지 않습니다. "M" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("%M")) -- 8
```

#### "MM"

"MM" 사용자 지정 서식 지정자는 월을 01부터 12까지의 숫자로 나타냅니다. 월이 한 자릿수인 경우 십의 자리는 0으로 표시됩니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("MM")) -- 08
```

#### "MMM"

"MMM" 사용자 지정 서식 지정자는 월의 약식 이름을 나타냅니다. 문화권을 지정하면 문화권에 해당하는 월의 약식 이름이 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("MMM")) -- Aug
log(date:ToFormattedString("MMM", "it-IT")) -- ago
```

#### "MMMM"

"MMMM" 사용자 지정 서식 지정자는 월의 전체 이름을 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 15, 023)
log(date:ToFormattedString("MMMM")) -- August
log(date:ToFormattedString("MMMM", "it-IT")) -- agosto
```

#### "s"

"s" 사용자 지정 서식 지정자는 초를 0부터 59까지의 숫자로 나타냅니다. 한 자릿수 초인 경우 십의 자리는 표시되지 않습니다. "s" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다. 초는 마지막 분 이후 경과한 총 초 수를 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("%s")) -- 5
```

#### "ss"

"ss" 사용자 지정 서식 지정자는 초를 00부터 59까지의 숫자로 나타냅니다. 한 자릿수 초인 경우 십의 자리는 0으로 표시됩니다. 초는 마지막 분 이후 경과한 총 초 수를 나타냅니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("ss")) -- 05
```

#### "t"

"t" 사용자 지정 서식 지정자는 AM/PM 지정자의 첫 문자를 나타냅니다. AM 지정자는 0:00:00부터 11:59:59.999까지의 모든 시간에 사용되고, PM 지정자는 12:00:00부터 23:59:59.999까지의 모든 시간에 사용됩니다. "t"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("%t")) -- P
```

#### "tt"

"tt" 사용자 지정 서식 지정자는 AM/PM 지정자를 나타냅니다. AM 지정자는 0:00:00부터 11:59:59.999까지의 모든 시간에 사용되고 PM 지정자는 12:00:00부터 23:59:59.999까지의 모든 시간에 사용됩니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("tt")) -- PM
```

#### "y"

"y" 사용자 지정 서식 지정자는 연도를 한자리 또는 두 자리 숫자로 나타냅니다. 연도가 두 자리를 넘으면 끝의 두 자리 숫자만 결과에 나타나고, 연도의 십의 자리가 0인 경우 0은 표시되지 않습니다. 예를 들어 연도가 2008이라면 8만 나타납니다. "y"만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("%y")) -- 22
```

#### "yy"

"yy" 사용자 지정 서식 지정자는 연도를 두 자리 숫자로 나타냅니다. 연도가 두 자리를 넘으면 끝의 두 자릿수만 결과에 나타납니다. 나타나는 연도의 십의 자리가 0이라면 그대로 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("yy")) -- 22
```

#### "yyy"

"yyy" 사용자 지정 서식 지정자는 연도를 최소 세 자리 숫자로 나타냅니다. 연도의 유효 자릿수가 세 자리보다 많더라도 결과 문자열에 포함됩니다. 연도가 세 자릿수 미만인 경우 0을 채워 세 자리로 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("yyy")) -- 2022
```

#### "yyyy"

"yyyy" 사용자 지정 서식 지정자는 연도를 네 자리 숫자로 나타냅니다. 연도가 네 자릿수 미만인 경우 0을 채워 네 자리로 나타납니다.

```
local date = DateTime(2022, 8, 29, 19, 7, 5, 023)
log(date:ToFormattedString("yyyy")) -- 2022
```

#### ":"

":" 사용자 지정 서식 지정자는 시, 분, 초를 구분하는 데 사용되는 시간 구분 기호를 나타냅니다. ":" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
-- today 2022/05/17
 
local date = DateTime("3:32:22", "h:mm:ss")
log(date) -- 05/17/2022 03:32:22
```

#### "/"

"/" 사용자 지정 서식 지정자는 년, 월, 일을 구분하는 데 사용되는 날짜 구분 기호를 나타냅니다. "/" 사용자 지정 서식 지정자만 단독으로 사용하는 경우 표준 서식 문자열로 잘못 해석되지 않도록 앞에 "%" 사용자 지정 서식 지정자를 사용해야 합니다.

```
local date = DateTime("2022/6/21", "yyyy/M/dd")
log(date) -- 06/21/2022 00:00:00
```

Update 2025-11-17 PM 08:14


# 스크린샷과 동적 스프라이트

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 제작할 때 스프라이트가 필요하면 메이플스토리 월드에서 제공하는 것을 선택하거나, 크리에이터가 직접 Import 한 것을 사용할 수 있습니다. 이러한 방법 외에도 월드 플레이 도중 생성된 이미지를 월드에 업로드하고 다른 유저와 공유할 수도 있습니다. 이처럼 메이플스토리 월드에서 플레이 도중 생성되는 이미지를 **동적 스프라이트**라고 합니다. **동적 스프라이트**는 **RawImage**라는 데이터 타입에 담아서 월드에 업로드하고 **RUID**를 발급받아 사용할 수 있습니다.  이번 과정에서는 [ScreenshotService](/apiReference/Services/ScreenshotService)의 `CaptureFullScreenAsPixelDataAndWait()` 함수를 사용해 캡처 결과를 **RawImage** 형태로 반환하는 예제를 살펴보겠습니다. 이 예제를 통해 동적 스프라이트의 활용 방법을 이해할 수 있습니다.

# 월드에 스크린샷 보여주기

특정 키를 눌러 스크린샷을 찍은 뒤 월드의 특정 위치에 보이도록 하는 예제를 살펴봅시다.

1. **Hierarchy - Create Entity - Create Empty**를 클릭해 **EmptyEntity**를 생성합니다. **EmptyEntity**의 이름을 **Frame**으로 지정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1668661121252c9d0293976864189952c8b9700eb8368.png)
2. **Frame** 엔티티의 프로퍼티 에디터에서 **TransformComponent, SpriteRendererComponent**를 추가합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1679371574207593d86d4363d41f990a861fb084b13b7.png)
3. **Frame** 엔티티의 프로퍼티 에디터에서 **SpriteRendererComponent - SpriteRUID**에 원하는 스프라이트를 설정합니다. 예) SpriteRUID : **93c2673261874c76b55459a4add2c382** ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16685976953935f7b707c48a74bd8bf90747904f83a34.png)
4. **Hierarchy - Frame**의 콘텍스트 메뉴에서 **Create Entity as Child - Create Empty**를 클릭하여 하위 엔티티를 생성합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16862000936226739727d0fd544f681d63208b2fcd4e7.png) **EmptyEntity**의 이름을 **Canvas**로 지정합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16686612052390bc3806fb1234ebfbd94ca85473612bc.png)
5. **Canvas** 엔티티의 프로퍼티 에디터에서 **TransformComponent, SpriteRendererComponent**를 추가합니다.
6. **Scene**에서 **Canvas** 엔티티를 드래그하여 **Frame**의 가운데 위치로 이동합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1668598281353fa2830c39674415282afcba0cf2f041f.png)
7. 새 스크립트 컴포넌트를 생성하고 이름을 **SpriteUploadTest**로 설정합니다.
8. **Hierarchy - Common**을 선택한 뒤, 프로퍼티 에디터에서 **SpriteUploadTest** 컴포넌트를 추가합니다.
9. **SpriteUploadTest**를 열고 스크립트 에디터에서 아래와 같이 **Property**를 추가합니다.```
Property:
[None]
Entity FrameEntity = /maps/map01/Frame
[None]
Entity CanvasEntity = /maps/map01/Frame/Canvas
```
10. `OnBeginPlay()` 함수를 추가하고 아래와 같이 작성합니다. `SetSpriteUploadValidationCallback()` 함수는 유저가 업로드 요청을 보냈을 때 허용 여부를 설정합니다. 허용하려면 **true**를, 그렇지 않으면 **false**를 반환하도록 코드를 작성합니다. 이 예제에서는 업로드를 허용해야 하므로 **true**를 반환하도록 합니다.```
Method:
void OnBeginPlay()
{
    if self:IsServer() then
        -- 유저가 업로드 요청을 보냈을 때 이를 허용하기 위해 true로 설정합니다.
        _ResourceService:SetSpriteUploadValidationCallback(function(userId)
            return true
        end)

        return
    end
}
```
11. `CaptureAndUpload()` 함수를 추가하고 아래와 같이 작성합니다.```
[client only]
void CaptureAndUpload()
{
    local frameRUID = self.FrameEntity.SpriteRendererComponent.SpriteRUID

    local sprite = _ResourceService:LoadSpriteAndWait(frameRUID)
    -- frame 엔티티 스프라이트의 가로, 세로 픽셀을 확인합니다.
    local frameWidth = sprite.Width
    local frameHeight = sprite.Height

    -- 촬영한 스크린샷 이미지를 받습니다.
    local error, screenshot = _ScreenshotService:CaptureFullScreenAsPixelDataAndWait()

    -- 스크린샷의 가로, 세로 픽셀을 확인합니다.
    local screenshotWidth = screenshot.Width
    local screenshotHeight = screenshot.Height

    -- 스크린샷의 크기를 변경할 비율을 계산합니다.
    -- Frame 안에 스크린샷이 들어가도록 비율을 살짝 작게 조절합니다.
    local horizontalRatio = frameWidth / screenshotWidth * 0.96
    local verticalRatio = frameHeight / screenshotHeight * 0.67

    -- 스크린샷 이미지를 스프라이트 형태로 업로드 합니다.
    _ResourceService:RequestSpriteUploadAsync(screenshot, function(error, ruid)
    	self.CanvasEntity.SpriteRendererComponent.SpriteRUID = ruid
    	-- 위에서 계산한 비율을 넣어 Canvas의 Scale을 조절합니다.	
    	self.CanvasEntity.TransformComponent.Scale = Vector3(horizontalRatio, verticalRatio, 1)
    end) 
}
```
12. **Event Handler**에 아래와 같이 **KeyDownEvent**를 추가합니다.```
Event Handler:
HandleKeyDownEvent(KeyDownEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------
    -- 키보드에서 1을 누르면 스크린샷을 촬영합니다.
    if key == KeyboardKey.Alpha1 then 
	    self:CaptureAndUpload()
    end
}
```
13. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **1**을 눌러 스크린샷을 찍으면 **Frame** 안에 스크린샷이 나오는 것을 확인합니다. ![RawImage](https://mod-file.dn.nexoncdn.co.kr/bbs/16686484619418af80fe87df5450b86bea39286b9186c.gif)

> **더 알아보기**- 업로드하는 리소스는 3MB를 초과할 수 없습니다. - 업로드는 한 번에 하나만 요청할 수 있습니다. 이전 요청이 완료되기 전에 다시 요청하면 업로드 실패합니다. - 메이커 플레이 중 생성한 스프라이트는 임시 리소스로서, 플레이를 종료하면 사라집니다. - 업로드는 월드 기준 1분 당 5회로 제한됩니다. 월드에 너무 많은 요청이 들어오면 업로드에 실패할 수 있습니다. 여러 클라이언트에서 동시에 요청을 보내지 않도록 주의해야 합니다. - 메이커에서 테스트할 때 가상의 플레이어를 추가하거나 인스턴스 룸을 갔다 오면 경우에 따라 업로드한 스크린샷이 보이지 않을 수 있습니다. 실제 출시된 게임에서는 정상적으로 보입니다.

Update 2025-11-17 PM 08:14


# 스크린샷 촬영 및 공유하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

`ScreenshotService`를 통해 화면을 캡처하고 이미지 파일을 저장하는 방법을 살펴봅시다. 추가로 모바일에서 스크린샷을 저장한 뒤 공유하는 방법도 알아봅시다.

##### 참고 API Reference

[ScreenshotService](/apiReference?postId=807) [MobileShareService](/apiReference/Services/MobileShareService)

# ScreenshotService

`ScreenshotService`를 활용하면 PC나 모바일에서 메이플스토리 월드 스크린샷을 촬영, 저장할 수 있습니다. 또한 `MobileShareService`와 연동하여 스크린샷을 공유할 수 있습니다. `ScreenshotService`에서 제공하는 함수는 용도에 따라 아래와 같이 구분됩니다.

| 함수 | 용도 | 저장 경로 |
| --- | --- | --- |
| CaptureFullScreenToPhotoLibraryAndWait()<br>CaptureScreenRegionToPhotoLibraryAndWait() | 사진 보관함에 스크린샷 저장 | <ul><li>Windows: 내 PC > 사진 > MapleStory Worlds > 월드 ID > fileName.png</li><li>macOS: 홈 > 사진 > MapleStory Worlds > 월드 ID > fileName.png</li><li>Android: 갤러리 - Maplestory Worlds 앨범</li><li>iOS: 사진</li></ul> |
| CaptureFullScreenAsFileAndWait()<br>CaptureScreenRegionAsFileAndWait() | 모바일 공유용 스크린샷 저장<br>(MobileShareService와 연동하여 사용) | <ul><li>Windows: 내 PC > 사진 > MapleStory Worlds > 월드 ID > fileName.png</li><li>macOS: 홈 > 사진 > MapleStory Worlds > 월드 ID > fileName.png</li><li>Android: 내장 메모리 > Android > data > com.nexon.mod > files > MapleStory Worlds > Screenshots > 월드 ID > fileName_*.png</li><li>iOS: 내 파일 > 나의 iPhone > MapleStory Worlds > Screenshots > 월드 ID > fileName_ *.png</li></ul> |

각 함수의 용도 및 저장 경로를 참고하여 함수를 활용해 봅시다.

# 스크린샷 촬영하기

## 전체 화면 촬영

버튼을 눌러 전체 화면 스크린샷을 촬영해 봅시다.

1. UI 에디터에서 ![btn](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_button.png) 버튼을 눌러 새 버튼 **FullScreenBtn**을 만듭니다.
2. **FullScreenBtn**에 **TextComponent**를 추가하고 프로퍼티를 아래와 같이 설정합니다. | Property | Value |
| :---: | :---: | | Text | Full Screen Capture | | FontColor | #ffffff |
3. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Logic**을 클릭해 새로운 로직을 생성합니다. 이름은 **ScreenshotServiceTest**로 변경합니다.
4. 스크립트 에디터에서 **ScreenshotServiceTest**를 열고 이벤트 핸들러에 `ButtonClickEvent`를 추가합니다. 이벤트 센더를 아래와 같이 **Entity**로 설정합니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681187758910df0cdbd4dc784785850f16fb584abbdf.png)  이후 아래와 같이 내용을 작성합니다.```
[entity: FullScreenBtn(/ui/DefaultGroup/FullScreenBtn)]
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    local error, path = _ScreenshotService:CaptureFullScreenToPhotoLibraryAndWait("FullScreen", true)
    log(error, path)

    if error == ScreenshotError.Success then
    	self._T.lastPath = path	
    else
    	_UIToast:ShowMessage("Failed to save! "..tostring(error)..", Path: "..path)
    end
}
```
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 **Full Screen Capture** 버튼을 누르면 전체 화면 스크린샷이 찍히고 이미지가 저장된 경로를 로그에서 확인할 수 있습니다. ![full](https://mod-file.dn.nexoncdn.co.kr/bbs/1681191751073ddae20ad59954d928e4210f758bec775.png)  저장된 FullScreen.png를 확인하면 아래와 같이 전체 화면이 찍힌 것을 확인할 수 있습니다. ![full2](https://mod-file.dn.nexoncdn.co.kr/bbs/16811917796840a7e9d430cf34b7d86aafb09c99c3a8b.png)

## 일부 화면 촬영

버튼을 눌러 일부 화면 스크린샷을 촬영해 봅시다.

1. **FullScreenBtn** 버튼의 콘텍스트 메뉴에서 **Duplicate**를 클릭해 버튼을 복제한 뒤 적당한 위치로 옮깁니다.
2. 복제한 버튼의 이름을 **PartialScreenBtn**으로 변경합니다. **Text**에는 **Partial Screen Capture**를 입력합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16811921606221a01221441844aae815f4af11770bd37.png)
3. 스크립트 에디터에서 **ScreenshotServiceTest**를 열고 이벤트 핸들러에 `ButtonClickEvent`를 추가합니다. 이벤트 센더를 아래와 같이 **Entity**로 설정합니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/168119229553433590599d6bb42e1948da148bef1a832.png)  이후 아래와 같이 내용을 작성합니다.```
[entity: PartialScreenBtn (/ui/DefaultGroup/PartialScreenBtn)]
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    local startPixel = Vector2(600,0)
    local endPixel = Vector2(1100,700)

    local error, path = _ScreenshotService:CaptureScreenRegionToPhotoLibraryAndWait("PartialScreen", startPixel, endPixel)
    log(error, path)

    if error == ScreenshotError.Success then
    	self._T.lastPath = path	
    else
    	_UIToast:ShowMessage("Failed to save! "..tostring(error)..", Path: "..path)
    end
}
```
4. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 **Partial Screen Capture** 버튼을 누르면 일부 화면 스크린샷이 찍히고 이미지가 저장된 경로를 로그에서 확인할 수 있습니다. ![Partial](https://mod-file.dn.nexoncdn.co.kr/bbs/16811926961341471a8a6920248e39480c0ee8bc6852f.png)  저장된 PartialScreen.png를 확인하면 아래와 같이 일부 화면이 찍힌 것을 확인할 수 있습니다. ![Partial2](https://mod-file.dn.nexoncdn.co.kr/bbs/1681192771299639cd1d5758642508dce913d1b6afa73.png)

> **더 알아보기** 일부 화면 촬영 시에는 유저의 스크린 해상도에 따라 촬영되는 화면의 위치가 달라질 수 있습니다. 이 점에 유의하여 일부 화면 촬영 기능을 사용해야 합니다.

# 모바일에서 스크린샷 공유하기

모바일에서 스크린샷 공유하는 방법을 살펴봅시다. 단, PC에서는 공유할 수 없습니다.

1. **FullScreenBtn** 버튼의 콘텍스트 메뉴에서 **Duplicate**를 클릭해 버튼을 복제한 뒤 적당한 위치로 옮깁니다.
2. 복제한 버튼의 이름을 **ShareBtn**으로 변경합니다. **Text**에는 **Share**를 입력합니다. ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/168119541043350d44d07d02c4bb98d2de0b5da0f7266.png)
3. 스크립트 에디터에서 **ScreenshotServiceTest**를 열고 **FullScreenBtn**에 연결한 이벤트를 찾습니다. `CaptureFullScreenToPhotoLibraryAndWait()`을 `CaptureFullScreenAsFileAndWait()`로 수정합니다.```
[entity: FullScreenBtn (/ui/DefaultGroup/FullScreenBtn)]
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    -- 모바일 공유용 스크린샷을 저장하기 위해 아래 함수를 CaptureFullScreenAsFileAndWait()로 수정함.
    local error, path = _ScreenshotService:CaptureFullScreenAsFileAndWait("FullScreen", true)
    log(error, path)

    if error == ScreenshotError.Success then
    	self._T.lastPath = path	
    else
    	_UIToast:ShowMessage("Failed to save! "..tostring(error)..", Path: "..path)
    end
}
```
4. 이벤트 핸들러에 `ButtonClickEvent`를 추가합니다. 이벤트 센더를 아래와 같이 **Entity**로 설정합니다. ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/168119303326810820bf91ef54332aa0488d261883a41.png)  이후 아래와 같이 내용을 작성합니다.```
[entity: ShareBtn (/ui/DefaultGroup/ShareBtn)]
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    local path = self._T.lastPath
    if path ~= "" then
    	local success = _MobileShareService:ShareFileAndWait(path)
    	log("Share : "..tostring(success))
    end
}
```
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 **Full Screen Capture** 버튼을 눌러 스크린샷을 저장합니다. 이후 **Share** 버튼을 누르면 스크린샷을 공유할 수 있습니다.

# 주의사항

스크린샷 파일 저장은 1초에 1번만 가능합니다.

Update 2025-11-17 PM 08:14


# 플레이 화면 녹화 및 공유하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 `ScreenRecordService`를 활용하여 플레이 화면을 녹화하고 파일로 저장할 수 있습니다. 또한 `MobileShareService`를 활용하여 모바일에서 녹화한 영상을 손쉽게 공유할 수도 있습니다. 이번 시간에는 예제를 통해 `ScreenRecordService` 및 `MobileShareService`의 활용 방법을 알아보겠습니다.

##### 참고 API Reference

[ScreenRecordService](/apiReference/Services/ScreenRecordService) [MobileShareService](/apiReference/Services/MobileShareService)

# 녹화 모드

`ScreenRecordService`에서는 아래 4가지 녹화 모드(ScreenRecordMode)를 제공합니다. 각 플랫폼별 제약이 있어 일부 녹화 모드는 모든 플랫폼에서 동작하지 않는 경우도 있습니다. 자세한 내용은 아래 표를 참고해 주시기 바랍니다.

| 녹화 모드 | 설명 | Windows/macOS | iOS | Android |
| :---: | :---: | :---: | :---: | :---: |
| ScreenOnly | 화면만 녹화 | O | O | O |
| ScreenAndGameAudio | 화면 + 게임 소리 녹화 | O | O | O |
| ScreenAndMic | 화면 + 마이크 녹화 | O | O | X <br>(ScreenAndGameAudioAndMic로 대체) |
| ScreenAndGameAudioAndMic | 화면 + 게임 소리 + 마이크 녹화 | X<br>(ScreenAndMic로 대체) | O | O |

> **더 알아보기**- Image, Audio 코덱이 정상적으로 지원되지 않는 기기에서는 녹화할 수 없습니다. - 이런 경우에는 `StartRecordToFileAndWait()`, `StartRecordToPhotoLibraryAndWait()` 함수에서 ScreenRecordStartResult.DeviceNotSupported 반환 값을 받습니다.

# 플레이 영상 녹화하기

`ScreenRecordService`를 활용하여 영상을 녹화하는 예제를 살펴봅시다. **[Record]** 버튼을 누르면 녹화를 시작하고, **[Stop]** 버튼을 누르면 녹화를 종료하고 파일을 저장하겠습니다.

1. UI 에디터로 들어가서 **RecordGroup**이란 이름으로 새로운 UIGroup을 추가합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1678416050163b3c472a5574e427ab4c6c79e5be50684.png)  그리고 **RecordGroup**의 **DefaultShow**를 **true**로 설정합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1678423634296cf0cab991d24471889baefac1f5ee4b5.png)
2. 버튼을 하나 추가한 뒤 이름을 **Btn_Record**로 변경합니다.
3. **Btn_Record**에 **TextComponent**를 추가하고 아래와 같이 프로퍼티를 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| :---: | :---: | :---: | | TextComponent | Text | Record | | FontColor | #FFFFFF |
4. **Btn_Record** 버튼의 콘텍스트 메뉴에서 **Duplicate** 버튼을 눌러 버튼을 복제합니다.
5. 복제한 버튼의 이름을 **Btn_Stop**으로 변경하고, **Text**에는 **Stop**을 입력합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16784163562145cecc803405a4a1aa358ed0dc4280deb.png)
6. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Logic**을 클릭해 새로운 로직을 생성합니다. 이름은 **ScreenRecordServiceTest**로 변경합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1678416161538b4fd072b7b974d418fb80474e83e816a.png)
7. 스크립트 에디터에서 **ScreenRecordServiceTest**를 엽니다.
8. **Property**에 아래 내용을 추가합니다.```
Property:
[None]
string LastRecordedPath = ""
```
9. `Record()` 함수를 추가하고 내용을 작성합니다.```
void Record()
{
    _UIPopup:Open("Do you want to start recording?", function()
	    -- recordMode는 ScreenOnly로, excludeSystemUI 옵션은 false로 설정)
	    local result = _ScreenRecordService:StartRecordToFileAndWait(ScreenRecordMode.ScreenOnly, false)
	    if result == ScreenRecordStartResult.Success then
		    _UIToast:ShowMessage("Start recording")
	    else
		    _UIToast:ShowMessage("Failed : "..tostring(result))	
	    end
	end, function()
		_UIToast:ShowMessage("Canceled")
	end)
}
``` 영상을 녹화할 때는 `StartRecordToFileAndWait()` 또는 `StartRecordToPhotoLibraryAndWait()` 함수를 사용할 수 있습니다. 이때 사용한 함수에 따라 플랫폼 별로 영상 저장 경로가 달라집니다. | 플랫폼 | StartRecordToFileAndWait() 함수 사용 시 저장 경로 | StartRecordToPhotoLibraryAndWait() 함수 사용 시 저장 경로 |
| :---: | :---: | :---: | | Windows | 내 PC > 동영상 > MapleStory Worlds > 월드 ID > MapleStory Worlds_*.mp4 | | macOS | 홈 > 비디오 > MapleStory Worlds > 월드 ID > MapleStory Worlds_*.mp4 | | iOS | 내 파일 > 나의 iPhone > MaplestoryWorlds > MapleStory Worlds > 월드 ID > MapleStory Worlds_*.mp4 | 사진 / 갤러리 | | Android | 내장 메모리 > Android > data > com.nexon.mod > files > MapleStory Worlds > 월드 ID > MapleStoryWorlds_*.mp4 |
10. **Btn_Record** 버튼을 눌러 녹화를 시작할 수 있도록 이벤트 핸들러에 `ButtonClickEvent`를 추가합니다. 이벤트 센더를 아래와 같이 **Entity**로 설정합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1678417754286bb465689e3e44568a5cc351a0e7688c6.png)  이후 아래와 같이 내용을 작성합니다.```
entity Btn_Record(/ui/RecordGroup/Btn_Record)
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    self:Record()
}
```
11. `Finish()` 함수를 추가하고 내용을 작성합니다. 녹화를 종료할 때는 `FinishRecordAndWait()` 함수를 사용합니다. 녹화 파일이 생성되면 저장 경로를 반환합니다.```
void Finish()
{
    _UIToast:ShowMessage("End recording")
    self.LastRecordedPath = _ScreenRecordService:FinishRecordAndWait()
    log("Output : ", self.LastRecordedPath)
}
```
  > **더 알아보기** 단, 윈도우 환경에서는 공유 기능이 없어 `StartRecordToFileAndWait()` 함수를 사용하면 `StartRecordToPhotoLibraryAndWait()` 함수로 대체하여 호출합니다. `StartRecordToPhotoLibraryAndWait()`로 녹화 시작 및 종료했다면, 저장 경로로 빈 값이 반환됩니다.
12. **Btn_Stop** 버튼을 눌러 녹화를 종료할 수 있도록 이벤트 핸들러에 `ButtonClickEvent`를 아래와 같이 추가합니다. 이벤트 센더를 아래와 같이 Entity로 설정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1678417899020da7233c0e9a64655bbfe9fa5cecbfc0e.png)  이후 아래와 같이 내용을 작성합니다.```
entity Btn_Stop(/ui/RecordGroup/Btn_Stop)
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    self:Finish()
}
```
13. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **[Record]** 버튼을 누르면 화면 녹화가 시작되고, **[Stop]** 버튼을 누르면 녹화가 종료되며 파일이 저장됩니다. ![recording](https://mod-file.dn.nexoncdn.co.kr/bbs/1678424192506294a4b8f784946a8aa06241618708fc2.gif) ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1678424210461bbb4c320b08348fab23a6029336dd50a.png)

# UI 가리고 영상 녹화하기

UI를 가리고 영상을 녹화하는 방법을 살펴봅시다.

1. UI 에디터로 들어가서 **DefaultGroup**에 **UIText**를 하나 추가하고 프로퍼티를 아래와 같이 설정합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1678430164183080b4d5df681412da8450337321bb50d.png) | 프로퍼티 | 값 |
| --- | --- | | RectSize | X = 700, Y = 100 | | Text | ScreenRecordService TEST | | FontSize | 50 | | ImageRUID | b9ab8455d5737bf4cb21433f00fdc19d | | Color | A = 100%, #FFFFFF |
2. 스크립트 에디터에서 **ScreenRecordServiceTest**를 엽니다.
3. **Property**에 아래와 같이 내용을 작성합니다.```
Property:
[None]
EntityRef DefaultGroup = /ui/DefaultGroup
```
4. `Record()` 함수를 아래와 같이 수정합니다.```
void Record()
{
    _UIPopup:Open("Do you want to start recording?", function()
		-- 가리려는 UIGroup의 visible을 false로 변경
		self.DefaultGroup.Visible = false
		-- 우측 상단 기본 UI를 숨기기 위해 excludeSystemUI 옵션을 true로 변경
		local result = _ScreenRecordService:StartRecordToFileAndWait(ScreenRecordMode.ScreenOnly, true)
		if result == ScreenRecordStartResult.Success then
		    _UIToast:ShowMessage("Start recording")
		else
		    _UIToast:ShowMessage("Failed : "..tostring(result))	
		end
	 end, function()
		_UIToast:ShowMessage("Canceled")
	 end)
}
```
5. `Finish()` 함수를 아래와 같이 수정합니다.```
void Finish()
{
    _UIToast:ShowMessage("End recording")
    self.LastRecordedPath = _ScreenRecordService:FinishRecordAndWait()
    -- 녹화 종료 후 UI가 다시 보이도록 아래 내용 추가
    self.DefaultGroup.Visible = true
    log("Output : ", self.LastRecordedPath)
}
```
6. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **[Record]** 버튼을 누르면 UI를 숨기고 영상을 녹화할 수 있습니다. 녹화가 종료되면 다시 UI가 보입니다. ![recording2](https://mod-file.dn.nexoncdn.co.kr/bbs/167843224107397026e661dfd4bdeb1e578fabfac9229.gif)

# 모바일에서 녹화 영상 공유하기

`MobileShareService`를 사용하면 녹화한 영상을 모바일에서 공유할 수 있습니다. 공유할 영상은 `StartRecordToFileAndWait()` 함수를 사용해 녹화해야 합니다. 단, 녹화 시간은 최대 2분으로 제한됩니다. 예제를 통해 모바일에서 녹화 영상을 공유하는 방법을 살펴봅시다.

1. **Btn_Record** 버튼의 콘텍스트 메뉴에서 **Duplicate** 버튼을 눌러 버튼을 복제합니다.
2. 복제한 버튼의 이름을 **Btn_Share**으로 변경하고, **Text**에는 **Share**을 입력합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1678757498013b1075f65b0e44c508965220c93cbddda.png)
3. 스크립트 에디터에서 **ScreenRecordServiceTest**를 엽니다.
4. `ShareVideo()` 함수를 추가하고 내용을 작성합니다.```
void ShareVideo()
{
    if self.LastRecordedPath ~= "" then
    	log("FilePath: ", self.LastRecordedPath)
    	local shared = _MobileShareService:ShareFileAndWait(self.LastRecordedPath)
    	if shared then
    		_UIToast:ShowMessage("Share success")
    	else
    		_UIToast:ShowMessage("Share Failed")
    	end
    end
}
```
5. **Btn_Share** 버튼을 눌러 녹화한 영상을 공유할 수 있도록 이벤트 핸들러에 `ButtonClickEvent`를 추가합니다. 이벤트 센더를 아래와 같이 **Entity**로 설정합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1678757658575e7b78c6fa2f843b2ac8e70e29a8e911d.png)  이후 아래와 같이 내용을 작성합니다.```
entity Btn_Stop(/ui/RecordGroup/Btn_Share)
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------
    self:ShareVideo()
}
```
6. 출시한 뒤 모바일에서 의도한 대로 동작하는지 확인합니다. **[Record]** 버튼을 눌러 녹화를 시작한 뒤, **[Stop]** 버튼을 눌러 녹화를 종료하고 **[Share]** 버튼을 눌러 영상을 공유할 수 있습니다. ![share](https://mod-file.dn.nexoncdn.co.kr/bbs/167877261209707c7dda7630d4754b846c68e6b21d002.gif)

# 주의사항

- 마이크가 여러 개라면 사용자에게 마이크 선택권을 제공해야 할 수 있습니다. 그럴 때는 `GetMicrophoneDevicesAndWait()` 함수를 사용해 사용자가 어떤 마이크를 입력할지 선택할 수 있도록 합니다.
- iOS: **설정 - MapleStoryWorlds - 사진 - 사진만 추가** 권한이 있어야 녹화를 진행할 수 있습니다.
- AOS: Android 10 미만을 실행하는 기기에서는 **애플리케이션 정보 - MapleStory Worlds - 저장 공간** 권한이 허용되어야 녹화를 진행할 수 있습니다.

Update 2025-11-17 PM 08:14


# TweenLogic을 활용해 엔티티 제어하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

[TweenLogic](/apiReference?postId=700)을 사용해 엔티티를 확대, 축소, 회전, 이동시킬 수 있습니다. [Tweener](/apiReference?postId=714)를 함께 확인해보세요.

# TweenLogic 개념

**TweenLogic**은 엔티티에 애니메이션 효과를 줄 수 있는 다양한 함수를 제공합니다. 여러 프레임에 걸쳐 Entity의 위치나 크기를 변화시키거나 회전시킬 수 있습니다. 다양한 함수를 사용해 엔티티를 Tween 시켜 애니메이션을 한 번의 함수 호출로 간단하게 만들 수 있습니다.

#### TweenComponent와의 차이

TweenLogic과 TweenComponent들은 월드에서 보기에는 비슷한 동작처럼 보이지만 다른 기능이므로 크리에이터의 제작 계획에 적합한 것을 선택해 사용하면 됩니다. **TweenLineComponent, TweenCircularComponent, TweenFloatingComponent**는 스크립트를 작성하지 않고 엔티티에 애니메이션을 부여하고 싶을 때 사용을 권장합니다. 세 컴포넌트는 네트워크 최적화가 되어있기에 멀티 플레이 환경에서 다수의 엔티티를 Tween 시킬 때 성능 향상을 기대할 수 있기 때문입니다. **TweenLogic**는 동적 트윈이 필요한 경우 사용할 수 있습니다. TweenLogic의 함수들이 반환하는 Tweener 객체에는 Reverse, Delay 기능이 포함되어 있으며, SetOnEndCallback 함수를 통해 Tween 종료 시 수행할 동작을 정의할 수도 있습니다.

#### EaseType

TweenLogic의 함수를 사용할 때 **EaseType**을 설정해 이동 모양을 결정합니다. EaseType 중 원하는 타입을 선택해 엔티티마다 다른 움직임을 만들 수 있습니다. 일정한 시간 동안 같은 위치로 향하는 엔티티가 2개 있더라도 각각 다른 EaseType을 사용했다면 어떤 엔티티는 바닥으로 떨어진 공처럼 통통 튀며 이동하고, 또 다른 엔티티는 느리게 이동하다 점점 빠르게 목적지에 도달하게 됩니다. 예를 들어 TweenLogic의 `MoveTo(Entity entity, Vector2 destination, number duration, EaseType type)` 함수는 특정 지점을 목적지로 지정해 엔티티를 이동시킵니다. 해당 함수를 호출하면, 여러 프레임에 걸쳐 목적지까지 조금씩 이동해 도착합니다. 이때 어떤 **EaseType**을 사용하는지에 따라 엔티티의 이동 모습이 달라집니다. EaseType은 Easing 함수를 이해해야 합니다. Easing 함수의 x 축은 시간, y 축은 이동 위치를 의미합니다. 그러므로 엔티티를 (1,1)에서 (2,2)까지 3초 동안 움직인다고 가정해 x, y축의 원점과 끝값을 알 수 있습니다. x의 원점 값은 0, 끝값은 3이 되고, y축은 이동 위치이기에 원점 값은 (1,1), 끝값은 (3,3)이 됩니다. 이 시간 동안 함수에 따라 다른 모양으로 움직이고, 가속 변화도 달라집니다. Easing 함수 그래프는 [엔티티 구간 이동시키기](/docs/?postId=122)의 참고 자료를 확인하세요.

#### Ease 함수

**Ease 함수**는 Tweener 객체를 생성하지 않으며 프레임마다 자동으로 업데이트되지 않습니다. 그러므로 움직임이 필요하다면 크리에이터가 직접 매 프레임 `Ease()` 함수를 호출해야 합니다. 이에 반해 `MakeTween()`으로 생성되어 Tweener의 `Play()` 함수가 호출된 Tweener 객체나 `PlayTween()`으로 생성되어 자동으로 재생되는 Tweener 객체는 TweenLogic에 의해 매 프레임 자동으로 업데이트됩니다.

아래 함수를 활용해 특정 진행률에서의 반환 값을 구할 수 있습니다. Easing 함수 그래프에서 x축은 Tween의 진행률로 tweenTime을 duration으로 나눈 값입니다. y축은 startValue에서 endValue 사이의 반환 값입니다.

```
number Ease(number startValue, number endValue, number duration, EaseType type, number tweenTime)
```

# TweenLogic 활용하기

#### 이동시키기

`MoveTo()`를 활용해 엔티티를 이동시킬 수 있습니다. ![이동](https://mod-file.dn.nexoncdn.co.kr/bbs/1657616366795ce5a3fc175fa498e8e3a9a096db18941.gif)

1. 새로운 컴포넌트를 생성하고, 특정 엔티티에 추가합니다.
2. 엔티티가 이동할 목적지, 시간, EaseType을 작성합니다.
3. 반환하는 Tweener의 지연 시간, 반복 타입, 횟수, 자동 파괴 여부 처리를 함께 작성합니다. 자동 파괴를 false로 하거나 LoopCount를 -1로 설정해 트윈이 계속 실행되도록 하는 경우 의도치 않게 더 이상 작동하지 않는 Tweener 객체가 쌓일 수도 있습니다. 이러한 Tweener 객체가 지나치게 많아지면 월드에 성능 하락이 생길 수 있으므로 적절한 시기에 tween을 파괴해줘야 합니다. 컴포넌트의 OnEndPlay 혹은 Tween시킬 대상 엔티티가 파괴되는 시점에 Tweener의 Destroy() 함수를 호출하여 파괴하는 것을 권장합니다.```
Property:
[None]
any tween = nil
[Sync]
number LoopCount = 0
[Sync]
number Delay = 0

Method:
[server only]
void OnBeginPlay()
{
    self.tween = _TweenLogic:MoveTo(self.Entity, Vector2(0.5, self.Entity.TransformComponent.Position.y), 4, EaseType.BounceEaseOut)
    self.tween.Delay = self.Delay
    self.tween.LoopCount = self.LoopCount
    self.tween.LoopType = TweenLoopType.PingPong
    self.tween.AutoDestroy = false
}

[server only]
void OnEndPlay()
{
    self.tween:Destroy()
}
```

#### 회전시키기

`RotateTo()`를 활용해 엔티티를 회전시킬 수 있고, `TweenLogic:RotateAroundOffset()`를 활용해 특정 엔티티의 offset을 기준으로 따라다니게 회전시킬 수 있습니다.

1. 새로운 컴포넌트를 생성하고, 특정 엔티티에 추가합니다.
2. **angle**을 360도로 설정해 엔티티가 한 바퀴 돌 수 있게 작성합니다.```
Method:
void OnBeginPlay()
{
    self._T.tween = _TweenLogic:RotateTo(self.Entity, 360, 5, EaseType.Linear)
    self._T.tween.LoopCount = -1 
}

[server only]
void OnEndPlay()
{
    self._T.tween:Destroy()
}
```
3. 컴포넌트를 생성하고, 특정 엔티티에 추가합니다.
4. 프로퍼티에 새로운 **RotateCenter**를 추가하고, 프로퍼티 에디터 창에 중심점으로 삼을 엔티티를 선택합니다.
5. 중심 엔티티를 따라 돌 수 있게 아래와 같이 작성합니다.```
Property:
[Sync]
Entity RotateCenter = nil

Method:
[server only]
void OnBeginPlay()
{
    if self.RotateCenter == nil then
        do return end
    end

    local offset = self.RotateCenter.TransformComponent.Position - self.Entity.TransformComponent.Position
    self._T.tween = _TweenLogic:RotateAroundOffset(self.Entity, 360, offset:ToVector2(), true, 5, EaseType.Linear)
    self._T.tween.LoopCount = -1
}

[server only]
void OnEndPlay()
{
    self._T.tween:Destroy()
}
```

#### 엔티티 크기 변화시키기

`ScaleTo()`를 활용해 엔티티의 크기가 커졌다 작아지게 만들 수 있습니다.

![크기조절](https://mod-file.dn.nexoncdn.co.kr/bbs/1657616386668608a20252d60459599b9d78530594d46.gif)

1. 새로운 컴포넌트를 생성하고, 특정 엔티티에 추가합니다.
2. 엔티티를 확대, 축소하고 싶은 크기를 `Vector2()` 값으로 입력합니다.```
Method:
[server only]
void OnBeginPlay()
{
    local tween = _TweenLogic:ScaleTo(self.Entity, Vector2(2.5, 2.5), 4, EaseType.QuadEaseInOut)
    tween.LoopCount = -1
    tween.LoopType = TweenLoopType.PingPong
}
```

#### 투명도 조절하기

`MakeTween()`에서 **Alpha** 값을 조절해 특정 엔티티가 점점 옅어지게 만들 수 있습니다.

![Alpha](https://mod-file.dn.nexoncdn.co.kr/bbs/16576164032874b4be3d0e5384da9a8858e5d8eacc361.gif)

1. 새로운 컴포넌트를 생성하고, 특정 엔티티에 추가합니다.
2. `MakeTween()`의 startvalue를 SpriteRenderer의 a로 지정하고, endvalue를 0으로 지정해 엔티티가 투명해질 수 있도록 아래와 같이 작성합니다.```
Method:
[server only]
void OnBeginPlay()
{
    local spriteRenderer = self.Entity.SpriteRendererComponent
    local tween -- tweener를 할당할 변수 미리 선언
    local tweenAlpha = function(tweenValue)
        if isvalid(spriteRenderer) == false then
            tween:Destroy()
        end
        spriteRenderer.Color.a = tweenValue
    end

    tween = _TweenLogic:MakeTween(spriteRenderer.Color.a, 0, 0.5, EaseType.Linear, tweenAlpha)
    tween.LoopCount = -1
    tween.LoopType = TweenLoopType.PingPong
    tween.AutoDestroy = false
    tween:Play()

    _TimerService:SetTimerOnce(function() self.Entity:RemoveComponent(SpriteRendererComponent) end, 5)
}
```

# 활용 예제

높은 곳에서 공을 던졌을 때 공이 앞으로 나아감과 동시에 통통 튀게 만들어 봅시다.

![ball](https://mod-file.dn.nexoncdn.co.kr/bbs/165761643870906375319aaf64fcaa084c94c11f7b1b2.gif)

1. 새로운 ![model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model_Ball 모델을 생성합니다. ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/Ect.png) TransformComponent, ![sprite](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/sprite.png) SpriteRendererComponent를 추가하고, 아래의 Ruid를 사용합니다.
  - SpriteRuid: d4dddd1f07d445939433f70cd1aa82fa
2. 새로운 ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/component/Ect.png) BallComponent 생성하고, ![model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model Ball에 추가합니다.
3. 공이 돌면서 날아가게 만들기 위해 `PlayTween()`과 `RotateTo()`를 함께 활용해 아래와 같이 작성합니다.```
Property:
[None]
number posX = 0
[None]
number posY = 0

Method:
[server only]
void OnBeginPlay()
{
    local transform = self.Entity.TransformComponent
    self.posX = transform.Position.x
    self.posY = transform.Position.y

    local yDestination = 0.3
    local tweenDuration = 3

    local xTween = _TweenLogic:PlayTween(self.posX, self.posX + _UtilLogic:RandomIntegerRange(40, 100)/10, tweenDuration, EaseType.CubicEaseOut, function(val) self.posX = val end)
    local yTween1 = _TweenLogic:PlayTween(self.posY, yDestination, tweenDuration, EaseType.BounceEaseOut, function(val) self.posY = val end)

    local rotateTween = _TweenLogic:RotateTo(self.Entity, -1800 * _UtilLogic:RandomIntegerRange(95, 105)/100, tweenDuration, EaseType.QuartEaseOut)
}

[server only]
void OnUpdate(number delta)
{
    --  프레임마다 변경되는 posX, PosY 프로퍼티 값을 TransformComponent.Position에 할당
    local transform = self.Entity.TransformComponent
    transform.Position = Vector3(self.posX, self.posY, transform.Position.z)
}
``` 위의 예시에서 `PlayTween()`은 마지막 매개 변수로 Action tweenFunction를 받고 있습니다. tweenFunction은 매 프레임 호출되고, 매개 변수로 Tween이 시작된 후부터 Ease 결괏값을 받습니다. 만약 Tween이 시작된 후 1.2초가 지났다면 Ease의 결괏값은 Ease(self.posY, yDestination, tweenDuration, EaseType.BounceEaseOut, 1.2)가 됩니다. 그러므로 `function(val) self.posX = val end`는 Ease 함수의 결괏값(val)을 받아 self.posY 프로퍼티에 할당합니다.
  > **더 알아보기** PlayTween을 사용할 때 Vector2를 매개 변수로 받는 PlayTween을 두 번 호출해 하나는 x를, 하나는 y를 조작하게 아래와 같이 구현할 경우 정상 동작하지 않습니다. Vector2는 x, y를 쌍으로 사용하므로 Tween 반환 값을 덮어쓰기 때문입니다.```
-- 공을 (8, 0, 0)의 위치로 던진다고 가정
_TweenLogic:PlayTween(현재위치, Vector3(8, 0, 0), tweenDuration, EaseType.CubicEaseOut, function(val) self.Entity.TransformComponent.Position = val end)
_TweenLogic:PlayTween(현재위치, Vector3(8, 0, 0), tweenDuration, EaseType.BounceEaseOut, function(val) self.Entity.TransformComponent.Position = val end)
```
4. ![component](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_component_no.png)SpawnBallOnAttack 컴포넌트를 생성하고, ![player](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_myavatar_no.png) DefaultPlayer에 추가합니다. 아래와 같이 플레이어가 공격할 때 ![model](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_model_no.png) Model_Ball을 소환하게 작성합니다.```
Event Handler:
[server only] [self]
HandlePlayerActionEvent(PlayerActionEvent event)
{
    -- Parameters
    local ActionName = event.ActionName
    local PlayerEntity = event.PlayerEntity
    --------------------------------------------------------
    if ActionName == "Attack" then
    	local parent = self.Entity.Parent
    	local spawnPosition = self.Entity.TransformComponent.Position + Vector3(0, 0.5, 0)
    	_SpawnService:SpawnByModelId("model://8474ac05-aac0-49bf-a171-84b7d8b9f42c", "Ball", spawnPosition, parent)
    end
}
```

##### 참고 가이드

- [엔티티 구간 이동시키기](/docs/?postId=122)
- [엔티티의 위치, 크기, 회전 조정](/docs/?postId=82)
- [물체의 이동 Ⅰ](/docs/?postId=123)

Update 2025-11-17 PM 08:14


# 플레이어 카메라 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임의 메인 카메라는 항상 플레이어를 따라다닙니다. 메인 카메라를 제어하는 camera 컴포넌트는 MapleStoryPlayer 모델이 가지고 있으며 이 모델의 프로퍼티 에디터나 스크립트를 이용해 주요 값을 수정할 수 있습니다. 이번 과정에서는 Camera 컴포넌트를 프로퍼티 에디터를 통해 수정해보며 전반적인 기능을 알아보는 시간을 가져보도록 하겠습니다.

# Camera 컴포넌트 접근

Workspace에서 DefaultPlayer 모델을 선택합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635470229255887ebcf3484b4ceb8a43d4b77d8af063.png)  프로퍼티 에디터에서 CameraComponent를 확인합니다. CameraComponent에서는 카메라 설정을 위한 여러 프로퍼티를 제공합니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1653012043486ba0619b7c3984494b5a7091c43500689.png)  카메라 컴포넌트에 있는 속성들을 하나씩 살펴보겠습니다.

# DeadZone

아래 영상을 보면 좌, 우로 플레이어 아바타가 조금씩 이동했을 때 카메라가 따라 움직이지 않습니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1657019820558b44468bafaf543d09447717a4987613f.gif)  점프하더라도 Y축으로 플레이어 아바타가 위로 올라갔다 내려오지만, 카메라는 이동하지 않습니다. 이처럼 플레이어 아바타가 DeadZone 에 있는 동안 카메라가 플레이어 아바타의 움직임을 따라가지 않습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/165702062238605bd4be1a9174ee48bc5ce6512c80f0f.png)  만약 DeadZone 값을 0으로 변경하면 아래와 같이 작은 이동에도 카메라가 반응하게 됩니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1657019829316abef7f6dc9b94ec79cc6865a63e25d67.gif)  제작하는 게임에 따라 데드존이 없을 경우 민감한 카메라 움직임으로 게이머의 피로가 높아질 수 있습니다. 하지만 빠른 움직임이 필요한 게임에서 데드존을 크게 설정할 경우 움직임에 대한 체감이 좋지 않을 수 있습니다. 따라서 제작하시는 게임의 성향에 맞춰 이 값을 잘 조정해주시면 게임이 의도하는 체감을 잘 살릴 수 있습니다.

# SoftZone

DeadZone 밖에는 SoftZone 영역이 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1657017680023250571fd27f94d1cbda001a2b372ae8c.png)  플레이어 아바타가 소프트 존에 위치하면 카메라는 플레이어 아바타가 화면 밖으로 벗어나지 않도록 추적하기 시작합니다. 만약 소프트 존 밖으로 이동할 때 카메라는 더 빠른 움직임으로 플레이어 아바타를 따라갑니다.

# Damping

Damping은 플레이어 아바타가 데드존을 이탈하여 카메라의 빠른 움직임을 꺾어 이전과 이후를 부드럽게 이어주는 비율입니다. 이 값이 커지면 카메라가 플레이어 아바타를 추적하는 속도가 부드러워집니다. 극단적인 예시로 앞서 언급한 SoftZone과 Damping 값을 큰 수치로 높이면 플레이어 아바타를 쫓는 속도가 극단적으로 느려져 플레이어 아바타가 카메라를 이탈할 수 있는 상황이 발생합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16570191045568fcfc3ae70714c339d1c00f8769f5b1a.gif)

# CameraOffSet

카메라가 플레이어를 비추는 위치를 수정합니다. 아래 기본값과 수정값의 차이를 보면 쉽게 이해할 수 있습니다. (x값 변경) ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16570177781742ef034f8531742fb95c3726007ac09c2.png)![6](https://mod-file.dn.nexoncdn.co.kr/bbs/165701780364165f094a24a814c2ba6410832691f10d2.png)

# DutchAngle

카메라의 회전 값을 설정합니다. 각도를 입력하며 80을 입력하면 아래와 같이 보입니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16570178319148e3e4420a1164958a85a65787011d4a2.png)

# Screen Offset

CameraOffset과 유사한 형태로 플레이어 아바타를 비추는 지점을 수정할 수 있으나, 이 값은 대상을 기준으로 한 전체 스크린의 비율 값입니다. 0부터 1 사이의 값을 입력할 수 있고, 값이 0.5일 경우 카메라가 중앙에 위치합니다. 예를 들어, X 값으로 0.8을 입력하면 아래와 같이 플레이어 아바타가 화면 오른쪽에 위치하게 됩니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16570178556921cd2a75c27ca4ad1ab666cbadf106ba2.png)

# isAllowZoomInOut

메이커 화면에서는 마우스 휠을 위/아래로 이동할 때 화면을 줌/인 아웃을 할 수 있는데요. 이 값이 True로 설정되어 있으면 플레이 진행 중에 플레이어가 마우스 휠을 이용해 줌 인/아웃 할 수 있습니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/165701854542594cce980f29f4bc9b9c14dc75c766830.gif)

# UseCustomBound

카메라 제한 영역을 직접 정의해서 사용할 지 여부를 설정합니다. **UseCustomBound** 값이 **True**라면 **LeftBottom, RightTop** 프로퍼티를 사용해 카메라 제한 영역을 정의할 수 있습니다. **Collider Edit** 버튼을 누르면 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene에 표시되는 기즈모를 통해 카메라 제한 영역을 시각적으로 확인하거나 핸들러를 통해 손쉽게 영역을 조절할 수 있습니다. ![UseCustomBound](https://mod-file.dn.nexoncdn.co.kr/bbs/16570204046562c59667490614c61917b3a312c8579a5.gif) CameraComponent - UseCustomBound 값이 **False**라면 맵 영역을 카메라 제한 영역으로 사용합니다. 맵 영역은 MapComponent - UseCustomBound 값이 **False**일 경우, 기본 상태로 설정되어 있는 것입니다. 이처럼 맵 영역이 기본 상태일 때는 그 기본을 바탕으로 보정된 영역을 카메라 제한 영역으로 사용하게 됩니다. 하지만 MapComponent - UseCustomBound 값이 **True**라면 크리에이터가 설정한 맵 영역을 카메라 제한 영역으로 사용합니다. 내용을 정리하면 아래와 같습니다.

| 컴포넌트 설정 | 카메라 제한 영역 |
| --- | --- |
| CameraComponent - UseCustomBound - **True** | 크리에이터가 정의한 카메라 제한 영역 사용 |
| CameraComponent - UseCustomBound - **False** <br>MapComponent - UseCustomBound - **True** | 크리에이터가 정의한 맵 영역을 카메라 제한 영역으로 사용 |
| CameraComponent - UseCustomBound - **False**<br>MapComponent - UseCustomBound - **False** | 기본 맵 영역을 바탕으로 보정된 영역을 카메라 제한 영역으로 사용 |

Update 2025-11-17 PM 08:14


# CameraService를 활용한 카메라 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=50%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임을 만들다 보면 카메라가 비추는 대상을 변경하거나 확대, 축소를 이용해 연출해야 할 때가 있습니다. 이번 과정에서는 [CameraService](/apiReference/Services/CameraService)를 통해 타깃 카메라를 제어하는 방법과 카메라 연출 효과에 대해 알아보도록 합니다.

##### 참고 가이드

[엔티티와 컴포넌트 참조](docs?postId=164) [엔티티의 충돌을 감지하는 TriggerComponent](/docs?postId=175) [Event System](/docs?postId=73) [Entity Event System](/docs?postId=176)

# 사전 설정

**CameraService**의 각 기능을 알아보기 위해 다음과 같은 상황을 만들어보겠습니다.

- 캐릭터가 오브젝트에 닿으면 카메라의 타깃이 NPC로 변경되거나 줌인/아웃된다.
- 카메라가 움직이고, 약 5초 후에 다시 원 위치로 돌아온다.
- 타깃 변경, 줌인/아웃 시 Blend 효과를 변경하여 적용한다.

이를 위해선 먼저 다음과 같은 사전 설정이 필요합니다. 맵과 컴포넌트 사전 설정이 필요합니다.

#### 맵 사전 설정

아래와 같이 좌우로 긴 맵을 만들고 좌측 끝에는 SpawnLocation, 우측 끝에는 NPC를 배치합니다. SpawnLocation 옆에 캐릭터가 닿았을 때 카메라 제어의 트리거가 될 수 있는 오브젝트를 하나 배치합니다. SpawnLocation 엔티티는 Preset List의 Special 카테고리에, Object와 NPC은 각각 Object와 NPC 카테고리에서 배치할 수 있습니다. ![cameraservicemapsetting](https://mod-file.dn.nexoncdn.co.kr/bbs/1635747662929b64966a13f79452686e64614e2872887.png)

#### 컴포넌트 사전 설정

위에 배치한 오브젝트와 NPC에 다음과 같이 컴포넌트를 추가합니다.

| 엔티티 | 추가 컴포넌트 |
| --- | --- |
| Object | <ul><li>TriggerComponent</li><li>New Script Component<ul><li>새 스크립트 컴포넌트를 생성하고 이름을 "CameraControl"로 지어 줍니다.</li><li>새 스크립트 컴포넌트를 생성해서 Object에 추가합니다.</li><li>캐릭터가 Object에 닿았을 때의 카메라 연출을 구현합니다.</li></ul></li></ul> |
| NPC | CameraComponent |

**DefaultPlayer**에도 **CameraComponent**가 추가되어 있는지 확인합니다. 만일 캐릭터에 **CameraComponent**가 붙어있지 않다면 추가합니다. ![cameraservice01](https://mod-file.dn.nexoncdn.co.kr/bbs/165966452699771f41d7f09c44b2a9d600a871338c465.png)

다음으로, 오브젝트에 추가했던 스크립트 컴포넌트에 카메라 제어를 구현할 **TriggerEnterEvent**를 추가합니다. 이벤트 센더는 **Self**로 설정합니다. ![CameraService02](https://mod-file.dn.nexoncdn.co.kr/bbs/16878426310085e90821333e043a9917fef09d35f5ba7.png)

# 카메라 타깃 전환

사전 설정을 마쳤으니 본격적으로 **CameraService**의 기능에 대해 알아보겠습니다. 먼저 카메라의 타깃 설정 방법을 알아봅시다.

##### void SwitchCameraTo(CameraComponent cameraToSwitch)

게임을 플레이하면 카메라는 기본적으로 플레이어를 피사체(타깃)로 삼아 계속 플레이어를 따라다니며 화면에 비춥니다.그러나 게임 장르 특성 때문에 혹은 게임의 특별한 연출을 위해서 카메라의 피사체(타깃)를 변경하고 싶을 때 CameraService의 `SwitchCameraTo()` 함수를 활용합니다.

`SwitchCameraTo()` 함수는 카메라의 피사체(타깃)을 변경할 수 있습니다. 기본 피사체인 플레이어에서 벗어나 특정 엔티티로 카메라를 옮기고 싶을 때 `SwitchCameraTo()` 함수를 사용합니다. `SwitchCameraTo()` 함수를 호출하면 **CameraComponent**를 갖고 있는 목표 엔티티의 경로를 받아 카메라의 피사체 대상을 목표 엔티티로 옮깁니다.

아래는 `SwitchCameraTo()` 함수를 활용해 카메라 타깃을 캐릭터에서 NPC로 변경하는 예시 코드입니다. 사전 설정 때 추가한 스크립트 컴포넌트의 **TriggerEnterEvent**에 다음 내용을 추가합니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다.
    --NPC 경로는 배치한 NPC에 따라 달라질 수 있습니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13")
         
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경합니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)   
}
```

카메라가 정상적으로 타깃을 변경하는지 시작을 눌러 확인합니다.

#### number TransitionBlendTime

**TransitionBlendTime**은 **CameraService**에서 제공하는 프로퍼티로 카메라가 목표 피사체로 이동하는데 걸리는 시간을 정할 수 있습니다. **TransitionBlendTime** 시간을 `SwitchCameraTo()` 함수 호출 이전에 설정하면, 설정 시간에 걸쳐 카메라가 목표 피사체로 이동하는 것을 볼 수 있습니다. 따라서 `SwitchCameraTo()` 함수를 호출하기 전에 **TransitionBlendTime에 시간을 설정**하면, **TransitionBlendTime**의 설정 시간 동안 카메라가 전환된 타깃으로 이동하는 것을 볼 수 있습니다. **TransitionBlendTime**에 시간 값을 할당하면, 카메라가 전보다 빠르게 전환되는 예시 코드입니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다. "NPCPath"에 배치한 NPC 엔티티의 경로를 입력합니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13") 
    
    --카메라가 다른 타깃으로 전환되는 시간을 설정합니다. 
    _CameraService.TransitionBlendTime = 1  
    
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경해줍니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)
}
```

시작을 눌러 게임을 테스트합니다.

#### CameraBlendType TranstionBlendType

**TranstionBlendType**은 피사체(타깃)로 전환 시 카메라의 움직임을 제어할 수 있는 프로퍼티입니다. `SwitchCameraTo()` 호출 전에 **TranstionBlendType**에 CameraBlendType의 enum 값을 할당해 타깃 전환 시 블렌드 타입을 변경할 수 있습니다. 아래는 위 예제에서 **TranstionBlendType**에 CameraBlendType.Linear를 할당하는 코드를 추가하여, 카메라의 움직임을 조금 딱딱하게 변경해보도록 하겠습니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다. "NPCPath"는 각자 배치한 NPC엔티티의 경로를 입력합니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13")
         
    --카메라가 다른 타깃으로 전환되는 시간을 설정합니다.
    _CameraService.TransitionBlendTime = 1
         
    --카메라의 움직임을 설정합니다.
    --Linear는 카메라를 일정한 속도로 움직여 화면을 전환합니다. 
    --선형적으로 전환하기 때문에 딱딱하고 기계적인 느낌이 납니다. 
    _CameraService.TransitionBlendType = CameraBlendType.Linear
         
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경합니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)
}
```

시작을 눌러 게임을 테스트합니다. **TransitionBlendType** 설정이 없는 예제와 비교했을 때 다른 움직임을 보이는 것을 확인할 수 있습니다.

###### TransitionBlendType 설정 전

###### TransitionBlendType 설정 후

블렌드 타입은 6가지 타입을 제공하고 있습니다. **TranstionBlendType**의 기본값은 **EaseInOut**으로, 다른 타입 값을 할당하지 않을 때 자동으로 할당됩니다.

| 타입 | 설명 |
| --- | --- |
| Cut | 카메라를 즉시 CameraComponent의 위치로 전환합니다. 화면이 순간 이동 하듯 전환됩니다. TransitionBlendType이Cut일 때 TranstitionBlendTime은 의미가 없습니다. |
| EaseInOut | S모양 커브처럼 전환 시작과 끝을 부드럽게 처리합니다. Blend타입 기본값입니다. |
| EaseIn | 전환 시작 시에는 선형적으로, 끝에는 부드럽게 전환합니다. |
| EaseOut | 전환 시작 시에는 부드럽게, 끝에는 선형적으로 전환합니다. |
| HardIn | 전환 시작 시에는 부드럽게, 끝에는 빠르게 전환합니다. |
| HardOut | 전환 시작 시에는 빠르게, 끝에는 부드럽게 전환합니다. |
| Linear | 일정한 속도로 전환합니다. 선형적으로 전환하기 때문에 딱딱하고 기계적인 느낌이 납니다. |

# Zoom 제어

게임 플레이 중에 카메라 줌 인과 줌 아웃을 제어하는 방법에 대해 알아보겠습니다. 위에서 작성한 코드는 필요하지 않기 때문에 모두 지우고, 아래와 같은 상태에서 시작합니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
}
```

#### void ZoomTo(number percent, number duration)

`ZoomTo()` 함수는 특정 시간 동안 줌 인/아웃을 수행하는 함수입니다. 매개 변수로는 **Percent**와 **Duration**을 받습니다. **Percent**는 변경할 줌 값을 의미하며 호출 시 퍼센트 값을 넘겨줍니다. 현재 줌 값보다 큰 값이 넘어오면 화면을 확대하고(줌 인), 작은 값이 넘어오면 화면을 축소합니다.(줌 아웃) **duration**은 현재 줌 값에서 매개 변수로 넘겨준 값(초)까지 도달하는데 걸리는 시간입니다.

아래는 `ZoomTo()` 함수를 사용해 5초 동안 캐릭터를 확대하는 예시 코드입니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    -- 5초간 줌 값을 150%로 변경합니다.
    _CameraService:ZoomTo(150, 5)
}
```

시작을 눌러 게임을 테스트합니다. 캐릭터가 문에 닿으면 카메라가 캐릭터(타깃)을 중심으로 5초 동안 점점 확대됩니다.

#### void ZoomReset()

`ZoomReset()`는 변경된 줌 값을 초깃값으로 되돌리는 함수입니다. `ZoomReset()`을 사용하면 `ZoomTo()`를 이용해 줌 값을 변경하더라도, 다시 초깃값으로(100%) 맞출 수 있습니다.

`ZoomTo()` 예시에 이어 `ZoomReset()`을 사용해 5초 뒤 줌 값을 100%로 변경하는 예시 코드입니다. 이해를 돕기 위해 **TimerService**를 활용했습니다. [TimerService](/docs?postId=47) 가이드를 참고하세요.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    -- 5초 동안 줌 값을 150%로 변경합니다.
    _CameraService:ZoomTo(150, 5)
     
    -- 줌 인이 끝나고, 5초 뒤 함수 실행을 예약할 수 있는 CallBack함수를 만듭니다.
    -- CallBack함수 안에서 ZoomReset를 호출하도록 합니다.
    local CallBack = function()
        _CameraService:ZoomReset() 
    end
     
    -- TimerService를 활용해 줌 인이 끝나고 5초 뒤에 실행할 CallBack함수를 넘겨줌으로써
    -- CallBack함수 안에 있는 ZoomReset이 실행될 수 있도록 합니다
    _TimerService:SetTimerOnce(CallBack, 10)
}
```

시작을 눌러 게임을 확인합니다. 문에 닿은 후 5초간 150% 확대되었다가, 5초 뒤 다시 원래대로 돌아오는 것을 확인할 수 있습니다.

# 기타 기능

**CameraService**는 주요 기능과 더불어 몇 가지의 유용한 기능을 함께 제공하고 있습니다.

#### Property

**number CurrentZoomRatio (read only)** 현재 카메라의 줌 비율을 퍼센트로 반환하는 프로퍼티로, 기본값은 100입니다. 이 프로퍼티는 읽기 전용이므로, 줌 비율을 설정하고 싶을 땐 `ZoomTo()` 함수를 사용해야합니다.

```
log("zoom : ".._CameraService.currentZoomRatio)  -- 100 출력
```

#### Functions

**CameraComponent GetCurrentCameraComponent()** 현재 카메라가 추적 중인 Entity의 CameraComponent를 가져옵니다.

```
local cameraComponent = _CameraService:GetCurrentCameraComponent()
log(cameraComponent)
```

Update 2025-11-17 PM 08:14


# CameraService를 활용한 카메라 제어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=50%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임을 만들다 보면 카메라가 비추는 대상을 변경하거나 확대, 축소를 이용해 연출해야 할 때가 있습니다. 이번 과정에서는 [CameraService](/apiReference/Services/CameraService)를 통해 타깃 카메라를 제어하는 방법과 카메라 연출 효과에 대해 알아보도록 합니다.

##### 참고 가이드

[엔티티와 컴포넌트 참조](docs?postId=164) [엔티티의 충돌을 감지하는 TriggerComponent](/docs?postId=175) [Event System](/docs?postId=73) [Entity Event System](/docs?postId=176)

# 사전 설정

**CameraService**의 각 기능을 알아보기 위해 다음과 같은 상황을 만들어보겠습니다.

- 캐릭터가 오브젝트에 닿으면 카메라의 타깃이 NPC로 변경되거나 줌인/아웃된다.
- 카메라가 움직이고, 약 5초 후에 다시 원 위치로 돌아온다.
- 타깃 변경, 줌인/아웃 시 Blend 효과를 변경하여 적용한다.

이를 위해선 먼저 다음과 같은 사전 설정이 필요합니다. 맵과 컴포넌트 사전 설정이 필요합니다.

#### 맵 사전 설정

아래와 같이 좌우로 긴 맵을 만들고 좌측 끝에는 SpawnLocation, 우측 끝에는 NPC를 배치합니다. SpawnLocation 옆에 캐릭터가 닿았을 때 카메라 제어의 트리거가 될 수 있는 오브젝트를 하나 배치합니다. SpawnLocation 엔티티는 Preset List의 Special 카테고리에, Object와 NPC은 각각 Object와 NPC 카테고리에서 배치할 수 있습니다. ![cameraservicemapsetting](https://mod-file.dn.nexoncdn.co.kr/bbs/1635747662929b64966a13f79452686e64614e2872887.png)

#### 컴포넌트 사전 설정

위에 배치한 오브젝트와 NPC에 다음과 같이 컴포넌트를 추가합니다.

| 엔티티 | 추가 컴포넌트 |
| --- | --- |
| Object | <ul><li>TriggerComponent</li><li>New Script Component<ul><li>새 스크립트 컴포넌트를 생성하고 이름을 "CameraControl"로 지어 줍니다.</li><li>새 스크립트 컴포넌트를 생성해서 Object에 추가합니다.</li><li>캐릭터가 Object에 닿았을 때의 카메라 연출을 구현합니다.</li></ul></li></ul> |
| NPC | CameraComponent |

**DefaultPlayer**에도 **CameraComponent**가 추가되어 있는지 확인합니다. 만일 캐릭터에 **CameraComponent**가 붙어있지 않다면 추가합니다. ![cameraservice01](https://mod-file.dn.nexoncdn.co.kr/bbs/165966452699771f41d7f09c44b2a9d600a871338c465.png)

다음으로, 오브젝트에 추가했던 스크립트 컴포넌트에 카메라 제어를 구현할 **TriggerEnterEvent**를 추가합니다. 이벤트 센더는 **Self**로 설정합니다. ![CameraService02](https://mod-file.dn.nexoncdn.co.kr/bbs/16878426310085e90821333e043a9917fef09d35f5ba7.png)

# 카메라 타깃 전환

사전 설정을 마쳤으니 본격적으로 **CameraService**의 기능에 대해 알아보겠습니다. 먼저 카메라의 타깃 설정 방법을 알아봅시다.

##### void SwitchCameraTo(CameraComponent cameraToSwitch)

게임을 플레이하면 카메라는 기본적으로 플레이어를 피사체(타깃)로 삼아 계속 플레이어를 따라다니며 화면에 비춥니다.그러나 게임 장르 특성 때문에 혹은 게임의 특별한 연출을 위해서 카메라의 피사체(타깃)를 변경하고 싶을 때 CameraService의 `SwitchCameraTo()` 함수를 활용합니다.

`SwitchCameraTo()` 함수는 카메라의 피사체(타깃)을 변경할 수 있습니다. 기본 피사체인 플레이어에서 벗어나 특정 엔티티로 카메라를 옮기고 싶을 때 `SwitchCameraTo()` 함수를 사용합니다. `SwitchCameraTo()` 함수를 호출하면 **CameraComponent**를 갖고 있는 목표 엔티티의 경로를 받아 카메라의 피사체 대상을 목표 엔티티로 옮깁니다.

아래는 `SwitchCameraTo()` 함수를 활용해 카메라 타깃을 캐릭터에서 NPC로 변경하는 예시 코드입니다. 사전 설정 때 추가한 스크립트 컴포넌트의 **TriggerEnterEvent**에 다음 내용을 추가합니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다.
    --NPC 경로는 배치한 NPC에 따라 달라질 수 있습니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13")
         
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경합니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)   
}
```

카메라가 정상적으로 타깃을 변경하는지 시작을 눌러 확인합니다.

#### number TransitionBlendTime

**TransitionBlendTime**은 **CameraService**에서 제공하는 프로퍼티로 카메라가 목표 피사체로 이동하는데 걸리는 시간을 정할 수 있습니다. **TransitionBlendTime** 시간을 `SwitchCameraTo()` 함수 호출 이전에 설정하면, 설정 시간에 걸쳐 카메라가 목표 피사체로 이동하는 것을 볼 수 있습니다. 따라서 `SwitchCameraTo()` 함수를 호출하기 전에 **TransitionBlendTime에 시간을 설정**하면, **TransitionBlendTime**의 설정 시간 동안 카메라가 전환된 타깃으로 이동하는 것을 볼 수 있습니다. **TransitionBlendTime**에 시간 값을 할당하면, 카메라가 전보다 빠르게 전환되는 예시 코드입니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다. "NPCPath"에 배치한 NPC 엔티티의 경로를 입력합니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13") 
    
    --카메라가 다른 타깃으로 전환되는 시간을 설정합니다. 
    _CameraService.TransitionBlendTime = 1  
    
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경해줍니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)
}
```

시작을 눌러 게임을 테스트합니다.

#### CameraBlendType TranstionBlendType

**TranstionBlendType**은 피사체(타깃)로 전환 시 카메라의 움직임을 제어할 수 있는 프로퍼티입니다. `SwitchCameraTo()` 호출 전에 **TranstionBlendType**에 CameraBlendType의 enum 값을 할당해 타깃 전환 시 블렌드 타입을 변경할 수 있습니다. 아래는 위 예제에서 **TranstionBlendType**에 CameraBlendType.Linear를 할당하는 코드를 추가하여, 카메라의 움직임을 조금 딱딱하게 변경해보도록 하겠습니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    --카메라의 타깃이 될 NPC 엔티티를 받아옵니다. "NPCPath"는 각자 배치한 NPC엔티티의 경로를 입력합니다.
    local NPCEntity = _EntityService:GetEntityByPath("/maps/map01/npc-13")
         
    --카메라가 다른 타깃으로 전환되는 시간을 설정합니다.
    _CameraService.TransitionBlendTime = 1
         
    --카메라의 움직임을 설정합니다.
    --Linear는 카메라를 일정한 속도로 움직여 화면을 전환합니다. 
    --선형적으로 전환하기 때문에 딱딱하고 기계적인 느낌이 납니다. 
    _CameraService.TransitionBlendType = CameraBlendType.Linear
         
    --SwitchCameraTo를 사용해 카메라 타깃을 NPC로 변경합니다.
    --SwitchCameraTo의 매개 변수에 NPC엔티티의 CameraComponent를 넘겨줍니다.
    _CameraService:SwitchCameraTo(NPCEntity.CameraComponent)
}
```

시작을 눌러 게임을 테스트합니다. **TransitionBlendType** 설정이 없는 예제와 비교했을 때 다른 움직임을 보이는 것을 확인할 수 있습니다.

###### TransitionBlendType 설정 전

###### TransitionBlendType 설정 후

블렌드 타입은 6가지 타입을 제공하고 있습니다. **TranstionBlendType**의 기본값은 **EaseInOut**으로, 다른 타입 값을 할당하지 않을 때 자동으로 할당됩니다.

| 타입 | 설명 |
| --- | --- |
| Cut | 카메라를 즉시 CameraComponent의 위치로 전환합니다. 화면이 순간 이동 하듯 전환됩니다. TransitionBlendType이Cut일 때 TranstitionBlendTime은 의미가 없습니다. |
| EaseInOut | S모양 커브처럼 전환 시작과 끝을 부드럽게 처리합니다. Blend타입 기본값입니다. |
| EaseIn | 전환 시작 시에는 선형적으로, 끝에는 부드럽게 전환합니다. |
| EaseOut | 전환 시작 시에는 부드럽게, 끝에는 선형적으로 전환합니다. |
| HardIn | 전환 시작 시에는 부드럽게, 끝에는 빠르게 전환합니다. |
| HardOut | 전환 시작 시에는 빠르게, 끝에는 부드럽게 전환합니다. |
| Linear | 일정한 속도로 전환합니다. 선형적으로 전환하기 때문에 딱딱하고 기계적인 느낌이 납니다. |

# Zoom 제어

게임 플레이 중에 카메라 줌 인과 줌 아웃을 제어하는 방법에 대해 알아보겠습니다. 위에서 작성한 코드는 필요하지 않기 때문에 모두 지우고, 아래와 같은 상태에서 시작합니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
}
```

#### void ZoomTo(number percent, number duration)

`ZoomTo()` 함수는 특정 시간 동안 줌 인/아웃을 수행하는 함수입니다. 매개 변수로는 **Percent**와 **Duration**을 받습니다. **Percent**는 변경할 줌 값을 의미하며 호출 시 퍼센트 값을 넘겨줍니다. 현재 줌 값보다 큰 값이 넘어오면 화면을 확대하고(줌 인), 작은 값이 넘어오면 화면을 축소합니다.(줌 아웃) **duration**은 현재 줌 값에서 매개 변수로 넘겨준 값(초)까지 도달하는데 걸리는 시간입니다.

아래는 `ZoomTo()` 함수를 사용해 5초 동안 캐릭터를 확대하는 예시 코드입니다.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    -- 5초간 줌 값을 150%로 변경합니다.
    _CameraService:ZoomTo(150, 5)
}
```

시작을 눌러 게임을 테스트합니다. 캐릭터가 문에 닿으면 카메라가 캐릭터(타깃)을 중심으로 5초 동안 점점 확대됩니다.

#### void ZoomReset()

`ZoomReset()`는 변경된 줌 값을 초깃값으로 되돌리는 함수입니다. `ZoomReset()`을 사용하면 `ZoomTo()`를 이용해 줌 값을 변경하더라도, 다시 초깃값으로(100%) 맞출 수 있습니다.

`ZoomTo()` 예시에 이어 `ZoomReset()`을 사용해 5초 뒤 줌 값을 100%로 변경하는 예시 코드입니다. 이해를 돕기 위해 **TimerService**를 활용했습니다. [TimerService](/docs?postId=47) 가이드를 참고하세요.

```
[self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    -- 5초 동안 줌 값을 150%로 변경합니다.
    _CameraService:ZoomTo(150, 5)
     
    -- 줌 인이 끝나고, 5초 뒤 함수 실행을 예약할 수 있는 CallBack함수를 만듭니다.
    -- CallBack함수 안에서 ZoomReset를 호출하도록 합니다.
    local CallBack = function()
        _CameraService:ZoomReset() 
    end
     
    -- TimerService를 활용해 줌 인이 끝나고 5초 뒤에 실행할 CallBack함수를 넘겨줌으로써
    -- CallBack함수 안에 있는 ZoomReset이 실행될 수 있도록 합니다
    _TimerService:SetTimerOnce(CallBack, 10)
}
```

시작을 눌러 게임을 확인합니다. 문에 닿은 후 5초간 150% 확대되었다가, 5초 뒤 다시 원래대로 돌아오는 것을 확인할 수 있습니다.

# 기타 기능

**CameraService**는 주요 기능과 더불어 몇 가지의 유용한 기능을 함께 제공하고 있습니다.

#### Property

**number CurrentZoomRatio (read only)** 현재 카메라의 줌 비율을 퍼센트로 반환하는 프로퍼티로, 기본값은 100입니다. 이 프로퍼티는 읽기 전용이므로, 줌 비율을 설정하고 싶을 땐 `ZoomTo()` 함수를 사용해야합니다.

```
log("zoom : ".._CameraService.currentZoomRatio)  -- 100 출력
```

#### Functions

**CameraComponent GetCurrentCameraComponent()** 현재 카메라가 추적 중인 Entity의 CameraComponent를 가져옵니다.

```
local cameraComponent = _CameraService:GetCurrentCameraComponent()
log(cameraComponent)
```

Update 2025-11-17 PM 08:14


# 배경음악 변경하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임에 어울리는 배경음악을 간편하게 넣어봅시다.

# 배경음악 넣기

1. **Preset List - BGM**을 선택합니다. ![bgm1](https://mod-file.dn.nexoncdn.co.kr/bbs/16596847059157420a230623740199887ec4783c6f7db.png)
2. 원하는 배경음악을 클릭합니다.
3. map의 **Property**에 [**SoundComponent**](/apiReference/Components/SoundComponent)가 추가된 것을 확인할 수 있습니다. ![bgm2](https://mod-file.dn.nexoncdn.co.kr/bbs/1686532850382c535b46148644216b06c69ac0e68bf02.png) 제어할 수 있는 프로퍼티에 대한 자세한 내용은 [**SoundComponent**](/apiReference/Components/SoundComponent) 항목을 참고합니다.
4. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 누른 뒤 테스트해 봅시다. 맵에서 배경음악이 재생되는 것을 확인할 수 있습니다.

Update 2025-11-17 PM 08:14


# 효과음 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 입체적으로 만들기 위해 [**SoundComponent**](/apiReference/Components/SoundComponent)와 [**SoundService**](/apiReference/Services/SoundService)를 활용해 음원을 재생하고, 때에 맞게 제어하는 방법을 소개합니다.

# SoundComponent

월드를 더욱 입체적으로 만들기 위해 다양한 소리가 이곳저곳에서 재생되게 만들거나, 플레이어와 특정 엔티티의 거리에 따라 다른 음량으로 들리게 만들 수 있습니다. **SoundComponent**를 활용하면 특정 오브젝트와 상호 작용할 때의 몰입감을 위해 다양한 소리를 삽입하고, 적절하게 재생할 수 있습니다.  엔티티에 **SoundComponent**를 추가하고 소리를 재생, 정지할 수 있습니다. 음원은 **Resource Storage**의 **Audio RUID** 또는 크리에이터가 추가한 음원의 **RUID**를 활용합니다. 제어할 수 있는 프로퍼티에 대한 자세한 내용은 [**SoundComponent**](/apiReference/Components/SoundComponent) 항목을 참고합니다.

## 활용 예시

특정 오브젝트나 몬스터에 다가갈 때 새로운 소리를 재생하여 몰입감을 높여봅시다.

### SetListenerEntity 함수

나만의 특별한 연출을 하고 싶다면, **SoundComponent**와 `SetListenerEntity()`로 특정 엔티티와 거리에 따라 음량을 조정할 수 있습니다. 이 함수를 활용한 컴포넌트를 특정 엔티티에 붙이면, 가까워질수록 음량이 커지고, 멀어질수록 음량이 0에 가까워집니다. 음원이 들리는 지점에 진입하면 다시 소리가 들리지만, 이는 일시 정지 후 재생이 아닌 단순히 음량의 변화로 마지막으로 들은 부분과 바로 이어지지 않습니다. 또한 플레이어가 일반적인 이동이 아닌 텔레포트 등을 통해 이동하면 음량은 즉시 줄어듭니다.

1. 특정 오브젝트에 **SoundComponent**를 추가합니다.
2. **MyDesk**에서 새로운 **ObjectSound** 스크립트 컴포넌트를 생성합니다.
3. `OnBeginPlay()` 함수를 추가한 뒤 아래와 같은 코드를 작성하고, **SoundComponent**를 추가한 엔티티에 함께 추가합니다
4. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 양옆으로 이동하며 음량이 증감하는지 확인합니다.

```
[client only]
void OnBeginPlay()
{
    self.Entity.SoundComponent.AudioClipRUID = "12f37a0d7970482e82ceb45718f92674"
    self.Entity.SoundComponent.Loop = true
    self.Entity.SoundComponent:Play()
    wait(2)
    self.Entity.SoundComponent:SetListenerEntity(_UserService.LocalPlayer)
}
```

### SetCameraAsListener 프로퍼티

**SetCameraAsListener** 프로퍼티를 활용하는 방법도 있습니다. **SoundComponent** 프로퍼티에서 설명했듯이 **SetCameraAsListener**를 활성화하면 화면 중앙과 음원 사이의 거리에 따라 소리 크기를 조절합니다. 간단하게 **SetCameraAsListener** 프로퍼티를 활용하는 방법을 살펴봅시다.

1. **Preset List**에서 아무 맵 오브젝트나 **Scene**에 배치한 뒤 **SpriteRendererComponent - SpriteRUID**에 아래의 **RUID**를 입력합니다.
  - SpriteRUID : **c5cf1b7c8d6447f7979b544e166965fc** ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/167333830964936922246ca3c4abb9779d0b72e0eb37d.png)
2. 오브젝트에 **SoundComponent**를 추가하고 아래와 같이 설정합니다. | 프로퍼티 | 값 |
| --- | --- | | AudioClipRUID | 74222ba4b41d48dd97175fd691124a67 | | HearingDistance | 10 | | PlayOnEnable | true | | SetCameraAsListener | true | | Loop | true |
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 망치질하는 오브젝트에 가까이 가면 효과음이 들리고 멀어질수록 소리가 나지 않습니다.

단, **SetCameraAsListener** 프로퍼티를 활성화했어도 **SetListenerEntity** 함수를 통해 따로 지정한 리스너 엔티티가 있으면 지정한 엔티티가 리스너가 된다는 점을 기억합시다.

# SoundService

크리에이터가 소리를 제어하고 싶은 곳에 `SoundService`를 사용해 필요한 함수를 호출해 사용합니다. 다양한 함수를 사용해 특정 상황에서 음원을 재생하거나 끌 수 있고, 특정 위치에서만 음원이 재생되도록 설정할 수 있습니다. 자세한 함수는 [**SoundService**](/apiReference?postId=316)를 참고하세요.

## 활용 예시

### UI 버튼 효과음 추가

UI 버튼이 눌릴 때마다 특정 효과음이 재생되게 만들 수 있습니다.

1. UI 에디터에서 버튼을 배치합니다.
2. **EffectComponent**란 이름의 새로운 스크립트 컴포넌트를 만들고, 버튼에 추가합니다.
3. 이벤트 핸들러에 **ButtonClickEvent**를 추가해 클릭 이벤트를 감지합니다.
4. 버튼을 누르면 재생될 음원의 **AudioClipRUID**와 음량을 입력합니다.

```
Event Handler:
[client only]
HandleButtonClickEvent(ButtonClickEvent event) 
{
    -- Parameters
    _SoundService:PlaySound("21600ec9d3a04cfeb69c6fe0c50e197c",1)
}
```

### 스킬 이펙트와 효과음

기본 공격 스킬에 이펙트 스킬과 효과음을 추가해 역동적으로 연출할 수 있습니다.

1. **MyDesk**에 새로운 **SkillSound** 스크립트 컴포넌트를 생성하고, **DefaultPlayer**에 추가합니다.
2. 이벤트 핸들러에 **KeyDownEvent**를 추가하고 아래와 같이 내용을 작성합니다.

```
Event Handler:
[clinet only] [service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    -- Parameters
    local key = event.key
    --------------------------------------------------------
    if key == KeyboardKey.LeftControl then
        _SoundService:PlaySound("02fe29e7670c447cb23c4ee4e5bf5674", 0.3)
        _EffectService:PlayEffect("01f39ee5971246ed8306bc471d44a1fd", self.Entity, self.Entity.TransformComponent.Position, 0, Vector3(1,1,1), false)
    end
}
```

Update 2025-11-17 PM 08:14


# 파티클 사용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

파티클이란 눈이나 비, 먼지 같은 다수의 작은 입자를 말합니다. 파티클 컴포넌트를 통해 입자의 속성과 재생 상태를 제어할 수 있습니다. 이번 시간에는 파티클 컴포넌트의 개념과 활용 방법을 살펴봅시다.

##### 참고 API Reference

[BaseParticleComponent](/apiReference/Components/BaseParticleComponent) [AreaParticleComponent](/apiReference/Components/AreaParticleComponent) [BasicParticleComponent](/apiReference/Components/BasicParticleComponent) [SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent) [UIBaseParticleComponent](/apiReference/Components/UIBaseParticleComponent) [UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent) [UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent) [UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent) [ParticleEmitEndEvent](/apiReference/Events/ParticleEmitEndEvent) [ParticleEmitStartEvent](/apiReference/Events/ParticleEmitStartEvent) [ParticleLoopEvent](/apiReference/Events/ParticleLoopEvent) [ParticleService](/apiReference/Service/ParticleService)

# 파티클 사용하기

파티클을 사용해 입자의 다양한 움직임을 표현할 수 있습니다. ![00](https://mod-file.dn.nexoncdn.co.kr/bbs/166330355094795e601dda1164aac848ae79d1496e768.gif)

파티클을 사용하는 방법은 세 가지입니다. 크리에이터가 원하는 방법으로 파티클을 사용할 수 있습니다.

| Preset List에서 배치 | 엔티티에 파티클 컴포넌트 추가 | Workspace에서 추가 |
| --- | --- | --- |
| ![preset](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_asset.png)Preset List - Particle Effect에서 원하는 파티클을 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene에 배치 | 파티클을 생성할 엔티티의 ![property](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_inspector.png) Property에 파티클 컴포넌트 추가 | ![workspace](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_workspace.png)Workspace에서 파티클 모델을 선택해 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene에 배치 |
| ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16606313000388e7d4aa6e5374d6196f17bf2166b1b3e.png) | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16606314685787f65edd3774b494cb32c9f285a4abdbc.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1660285664348a8db102a53b142f9b04a4e043ab2bb09.png) |

# 파티클 컴포넌트의 종류

파티클 컴포넌트는 크게 월드와 UI용으로 구분되며, 총 세 가지의 파티클이 있습니다.

- 월드용 파티클 컴포넌트: [BasicParticleComponent](/apiReference/Components/BasicParticleComponent), [SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent), [AreaParticleComponent](/apiReference/Components/AreaParticleComponent)
- UI용 파티클 컴포넌트: [UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent), [UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent), [UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent)

## BasicParticleComponent

[BasicParticleComponent](/apiReference/Components/BasicParticleComponent)는 일반적인 파티클을 제어하는 컴포넌트입니다. ![basic](https://mod-file.dn.nexoncdn.co.kr/bbs/16633078865839e5488d2c3574197a38db8ff29c04719.png)

| 프로퍼티 | 설명 |
| :---: | --- |
| ParticleType | 생성할 파티클의 타입을 설정합니다. <br> 파티클 타입에 따라 지원되는 프로퍼티가 달라집니다. |
| Color | 렌더링 될 파티클의 색상을 보정합니다. <br> ![color](https://mod-file.dn.nexoncdn.co.kr/bbs/1660286156819e905e8074a604e01800aa653fb244c1c.gif) |
| Loop | 파티클 반복 재생 여부를 설정합니다. |
| ParticleCount | 파티클 입자 개수를 설정합니다. <br> ![count](https://mod-file.dn.nexoncdn.co.kr/bbs/16602820708290573d1ebd7634d4491632ef67088c0f5.gif) |
| ParticleLifeTime | 파티클 입자의 지속 시간을 설정합니다. <br>![life](https://mod-file.dn.nexoncdn.co.kr/bbs/1660282419952c9bc08a01b6040ae929a90ddb867fc96.gif) |
| ParticleSize | 파티클 입자의 크기를 설정합니다. <br>![size](https://mod-file.dn.nexoncdn.co.kr/bbs/16602825979965f0f3af7b4304a6a9d3f220a9f645128.gif) <br> 파티클 전체의 크기를 제어하고 싶다면 TransformComponent의 Scale을 조절해봅시다. |
| ParticleSpeed | 파티클 입자의 속도를 설정합니다. <br>![particlespeed](https://mod-file.dn.nexoncdn.co.kr/bbs/1660284180137e517a7338d2f4482ba095199640f0fc5.gif) |
| PlayOnEnable | 파티클 컴포넌트가 Enable일 때, 파티클을 재생할지 여부를 설정합니다. <br>재생 이후의 반복 여부는 Loop 프로퍼티를 통해 설정해야 합니다. |
| PlaySpeed | 파티클 재생 속도를 설정합니다. <br>PlaySpeed = 0이면 파티클이 일시 정지한 것처럼 보입니다. <br>PlaySpeed는 음수를 지원하지 않으며, 음수는 0과 동일하게 취급됩니다. <br>![playspeed](https://mod-file.dn.nexoncdn.co.kr/bbs/166028475387470172905ee5b4714b327f18bf21dce0c.gif) |
| Prewarm | Enable인 경우 파티클 입자의 최대 개수를 불러와 파티클을 자연스럽게 재생합니다. <br>파티클이 처음 재생되는 순간부터 그전에 이미 파티클이 재생되고 있었던 것처럼 자연스럽게 보이게 됩니다. |
| SortingLayer | 2개 이상의 Entity가 겹쳤을 때 Sorting Layer에 따라 보이는 우선순위가 결정됩니다. |
| OrderInLayer | 같은 Layer 내의 우선순위를 결정합니다. 수가 클수록 앞에 보입니다. |
| IgnoreMapLayerCheck | SortingLayer에 Map Layer 이름을 지정했을 때 자동 치환을 수행하지 않습니다. |
| AutoRandomSeed | 파티클의 입자 방출이 시작될 때마다 랜덤 시드를 새로 생성할지 여부를 설정합니다. |

## SpriteParticleComponent

[SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent)는 스프라이트로 파티클을 만드는 컴포넌트입니다. 예를 들어 **SpriteParticleComponent - SpriteRUID**에 **c4839de6b7be438abf008b5f547cbe98**를 설정하면 아래와 같이 하트 모양의 스프라이트로 파티클이 생성됩니다. ![spritegif](https://mod-file.dn.nexoncdn.co.kr/bbs/1663309554383b08e07180d384167a62f7383bcd4710b.gif) 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| ApplySpriteColor | 파티클이 사용할 Sprite에 Color 프로퍼티를 적용할지 여부를 설정합니다. 프로퍼티가 false일지라도 Color의 투명도 값은 적용됩니다. |
| SpriteRUID | 파티클로 사용할 SpriteRUID를 설정합니다. |

## AreaParticleComponent

[AreaParticleComponent](/apiReference/Components/AreaParticleComponent)는 파티클의 생성 범위를 지정할 수 있는 컴포넌트입니다. 파티클의 생성 범위가 변경되더라도 범위 내에 생성되는 파티클의 개수는 동일합니다. 파티클의 생성 범위를 넓히면서 ParticleCount도 함께 높이면 파티클의 밀도를 이전과 비슷하게 유지할 수 있고, 파티클의 생성 범위만 넓힌다면 파티클의 밀도는 낮아지게 됩니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| Bounds | Edit 버튼을 누르면 Scene에서 AreaOffset과 AreaSize를 조절할 수 있습니다. Edit 할 때 보이는 사각형 범위는 파티클의 존재 범위가 아니라 생성 범위입니다. 생성 이후 파티클의 이동에 따라 사각형 범위를 벗어날 수 있습니다. <br> ![area_bounds](https://mod-file.dn.nexoncdn.co.kr/bbs/166027977616209fce41236a24051a06ec41c99c44699.png) |
| AreaOffset | Entity를 기준으로 생성 범위의 중심점 위치를 설정합니다. |
| AreaSize | 파티클 생성 범위의 너비와 높이를 지정합니다. |

## UIBasicParticleComponent

[UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent)는 일반적인 파티클을 제어하는 컴포넌트입니다. UI에서만 사용 가능합니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| ParticleType | 생성할 파티클의 타입을 설정합니다. <br> 파티클 타입에 따라 지원되는 프로퍼티가 달라집니다. |
| Color | 렌더링 될 파티클의 색상을 보정합니다. |
| LocalScale | 파티클의 크기입니다. |
| PlaySpeed | 파티클 재생 속도를 설정합니다. <br>PlaySpeed = 0이면 파티클이 일시 정지한 것처럼 보입니다. <br>PlaySpeed는 음수를 지원하지 않으며, 음수는 0과 동일하게 취급됩니다. |
| ParticleSize | 파티클 입자의 크기를 설정합니다. |
| ParticleSpeed | 파티클 입자의 속도를 설정합니다. |
| ParticleCount | 파티클 입자 개수를 설정합니다. |
| ParticleLifeTime | 파티클 입자의 지속 시간을 설정합니다. |
| PlayOnEnable | 파티클 컴포넌트가 Enable일 때, 파티클을 재생할지 여부를 설정합니다. <br>재생 이후의 반복 여부는 Loop 프로퍼티를 통해 설정해야 합니다. |
| Loop | 파티클 반복 재생 여부를 설정합니다. |
| Prewarm | Enable인 경우 파티클 입자의 최대 개수를 불러와 파티클을 자연스럽게 재생합니다. <br>파티클이 처음 재생되는 순간부터 그전에 이미 파티클이 재생되고 있었던 것처럼 자연스럽게 보이게 됩니다. |
| AutoRandomSeed | 파티클의 입자 방출이 시작될 때마다 랜덤 시드를 새로 생성할지 여부를 설정합니다. |

## UIAreaParticleComponent

[UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent)는 UI에 파티클의 생성 범위를 설정할 수 있는 컴포넌트입니다. 파티클의 생성 범위가 변경되더라도 범위 내에 생성되는 파티클의 개수는 동일합니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| AreaSize | 파티클 생성 범위를 설정합니다. |
| AreaOffset | Entity를 기준으로 생성 범위의 중심점 위치를 설정합니다. |

## UISpriteParticleComponent

[UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent)는 UI에 스프라이트로 파티클을 만드는 컴포넌트입니다.

| 프로퍼티 | 설명 |
| :---: | --- |
| SpriteRUID | 파티클로 사용할 SpriteRUID를 설정합니다. |
| ApplySpriteColor | 파티클이 사용할 Sprite에 Color 프로퍼티를 적용할지 여부를 설정합니다. 프로퍼티가 false일지라도 Color의 투명도 값은 적용됩니다. |
| LocalScale | 파티클의 크기를 설정합니다. |

Update 2025-11-17 PM 08:14


# 파티클 사용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

파티클이란 눈이나 비, 먼지 같은 다수의 작은 입자를 말합니다. 파티클 컴포넌트를 통해 입자의 속성과 재생 상태를 제어할 수 있습니다. 이번 시간에는 파티클 컴포넌트의 개념과 활용 방법을 살펴봅시다.

##### 참고 API Reference

[BaseParticleComponent](/apiReference/Components/BaseParticleComponent) [AreaParticleComponent](/apiReference/Components/AreaParticleComponent) [BasicParticleComponent](/apiReference/Components/BasicParticleComponent) [SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent) [UIBaseParticleComponent](/apiReference/Components/UIBaseParticleComponent) [UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent) [UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent) [UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent) [ParticleEmitEndEvent](/apiReference/Events/ParticleEmitEndEvent) [ParticleEmitStartEvent](/apiReference/Events/ParticleEmitStartEvent) [ParticleLoopEvent](/apiReference/Events/ParticleLoopEvent) [ParticleService](/apiReference/Service/ParticleService)

# 파티클 사용하기

파티클을 사용해 입자의 다양한 움직임을 표현할 수 있습니다. ![00](https://mod-file.dn.nexoncdn.co.kr/bbs/166330355094795e601dda1164aac848ae79d1496e768.gif)

파티클을 사용하는 방법은 세 가지입니다. 크리에이터가 원하는 방법으로 파티클을 사용할 수 있습니다.

| Preset List에서 배치 | 엔티티에 파티클 컴포넌트 추가 | Workspace에서 추가 |
| --- | --- | --- |
| ![preset](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_asset.png)Preset List - Particle Effect에서 원하는 파티클을 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene에 배치 | 파티클을 생성할 엔티티의 ![property](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_inspector.png) Property에 파티클 컴포넌트 추가 | ![workspace](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_workspace.png)Workspace에서 파티클 모델을 선택해 ![scene](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene.png) Scene에 배치 |
| ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16606313000388e7d4aa6e5374d6196f17bf2166b1b3e.png) | ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16606314685787f65edd3774b494cb32c9f285a4abdbc.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1660285664348a8db102a53b142f9b04a4e043ab2bb09.png) |

# 파티클 컴포넌트의 종류

파티클 컴포넌트는 크게 월드와 UI용으로 구분되며, 총 세 가지의 파티클이 있습니다.

- 월드용 파티클 컴포넌트: [BasicParticleComponent](/apiReference/Components/BasicParticleComponent), [SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent), [AreaParticleComponent](/apiReference/Components/AreaParticleComponent)
- UI용 파티클 컴포넌트: [UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent), [UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent), [UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent)

## BasicParticleComponent

[BasicParticleComponent](/apiReference/Components/BasicParticleComponent)는 일반적인 파티클을 제어하는 컴포넌트입니다. ![basic](https://mod-file.dn.nexoncdn.co.kr/bbs/16633078865839e5488d2c3574197a38db8ff29c04719.png)

| 프로퍼티 | 설명 |
| :---: | --- |
| ParticleType | 생성할 파티클의 타입을 설정합니다. <br> 파티클 타입에 따라 지원되는 프로퍼티가 달라집니다. |
| Color | 렌더링 될 파티클의 색상을 보정합니다. <br> ![color](https://mod-file.dn.nexoncdn.co.kr/bbs/1660286156819e905e8074a604e01800aa653fb244c1c.gif) |
| Loop | 파티클 반복 재생 여부를 설정합니다. |
| ParticleCount | 파티클 입자 개수를 설정합니다. <br> ![count](https://mod-file.dn.nexoncdn.co.kr/bbs/16602820708290573d1ebd7634d4491632ef67088c0f5.gif) |
| ParticleLifeTime | 파티클 입자의 지속 시간을 설정합니다. <br>![life](https://mod-file.dn.nexoncdn.co.kr/bbs/1660282419952c9bc08a01b6040ae929a90ddb867fc96.gif) |
| ParticleSize | 파티클 입자의 크기를 설정합니다. <br>![size](https://mod-file.dn.nexoncdn.co.kr/bbs/16602825979965f0f3af7b4304a6a9d3f220a9f645128.gif) <br> 파티클 전체의 크기를 제어하고 싶다면 TransformComponent의 Scale을 조절해봅시다. |
| ParticleSpeed | 파티클 입자의 속도를 설정합니다. <br>![particlespeed](https://mod-file.dn.nexoncdn.co.kr/bbs/1660284180137e517a7338d2f4482ba095199640f0fc5.gif) |
| PlayOnEnable | 파티클 컴포넌트가 Enable일 때, 파티클을 재생할지 여부를 설정합니다. <br>재생 이후의 반복 여부는 Loop 프로퍼티를 통해 설정해야 합니다. |
| PlaySpeed | 파티클 재생 속도를 설정합니다. <br>PlaySpeed = 0이면 파티클이 일시 정지한 것처럼 보입니다. <br>PlaySpeed는 음수를 지원하지 않으며, 음수는 0과 동일하게 취급됩니다. <br>![playspeed](https://mod-file.dn.nexoncdn.co.kr/bbs/166028475387470172905ee5b4714b327f18bf21dce0c.gif) |
| Prewarm | Enable인 경우 파티클 입자의 최대 개수를 불러와 파티클을 자연스럽게 재생합니다. <br>파티클이 처음 재생되는 순간부터 그전에 이미 파티클이 재생되고 있었던 것처럼 자연스럽게 보이게 됩니다. |
| SortingLayer | 2개 이상의 Entity가 겹쳤을 때 Sorting Layer에 따라 보이는 우선순위가 결정됩니다. |
| OrderInLayer | 같은 Layer 내의 우선순위를 결정합니다. 수가 클수록 앞에 보입니다. |
| IgnoreMapLayerCheck | SortingLayer에 Map Layer 이름을 지정했을 때 자동 치환을 수행하지 않습니다. |
| AutoRandomSeed | 파티클의 입자 방출이 시작될 때마다 랜덤 시드를 새로 생성할지 여부를 설정합니다. |

## SpriteParticleComponent

[SpriteParticleComponent](/apiReference/Components/SpriteParticleComponent)는 스프라이트로 파티클을 만드는 컴포넌트입니다. 예를 들어 **SpriteParticleComponent - SpriteRUID**에 **c4839de6b7be438abf008b5f547cbe98**를 설정하면 아래와 같이 하트 모양의 스프라이트로 파티클이 생성됩니다. ![spritegif](https://mod-file.dn.nexoncdn.co.kr/bbs/1663309554383b08e07180d384167a62f7383bcd4710b.gif) 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| ApplySpriteColor | 파티클이 사용할 Sprite에 Color 프로퍼티를 적용할지 여부를 설정합니다. 프로퍼티가 false일지라도 Color의 투명도 값은 적용됩니다. |
| SpriteRUID | 파티클로 사용할 SpriteRUID를 설정합니다. |

## AreaParticleComponent

[AreaParticleComponent](/apiReference/Components/AreaParticleComponent)는 파티클의 생성 범위를 지정할 수 있는 컴포넌트입니다. 파티클의 생성 범위가 변경되더라도 범위 내에 생성되는 파티클의 개수는 동일합니다. 파티클의 생성 범위를 넓히면서 ParticleCount도 함께 높이면 파티클의 밀도를 이전과 비슷하게 유지할 수 있고, 파티클의 생성 범위만 넓힌다면 파티클의 밀도는 낮아지게 됩니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| Bounds | Edit 버튼을 누르면 Scene에서 AreaOffset과 AreaSize를 조절할 수 있습니다. Edit 할 때 보이는 사각형 범위는 파티클의 존재 범위가 아니라 생성 범위입니다. 생성 이후 파티클의 이동에 따라 사각형 범위를 벗어날 수 있습니다. <br> ![area_bounds](https://mod-file.dn.nexoncdn.co.kr/bbs/166027977616209fce41236a24051a06ec41c99c44699.png) |
| AreaOffset | Entity를 기준으로 생성 범위의 중심점 위치를 설정합니다. |
| AreaSize | 파티클 생성 범위의 너비와 높이를 지정합니다. |

## UIBasicParticleComponent

[UIBasicParticleComponent](/apiReference/Components/UIBasicParticleComponent)는 일반적인 파티클을 제어하는 컴포넌트입니다. UI에서만 사용 가능합니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| ParticleType | 생성할 파티클의 타입을 설정합니다. <br> 파티클 타입에 따라 지원되는 프로퍼티가 달라집니다. |
| Color | 렌더링 될 파티클의 색상을 보정합니다. |
| LocalScale | 파티클의 크기입니다. |
| PlaySpeed | 파티클 재생 속도를 설정합니다. <br>PlaySpeed = 0이면 파티클이 일시 정지한 것처럼 보입니다. <br>PlaySpeed는 음수를 지원하지 않으며, 음수는 0과 동일하게 취급됩니다. |
| ParticleSize | 파티클 입자의 크기를 설정합니다. |
| ParticleSpeed | 파티클 입자의 속도를 설정합니다. |
| ParticleCount | 파티클 입자 개수를 설정합니다. |
| ParticleLifeTime | 파티클 입자의 지속 시간을 설정합니다. |
| PlayOnEnable | 파티클 컴포넌트가 Enable일 때, 파티클을 재생할지 여부를 설정합니다. <br>재생 이후의 반복 여부는 Loop 프로퍼티를 통해 설정해야 합니다. |
| Loop | 파티클 반복 재생 여부를 설정합니다. |
| Prewarm | Enable인 경우 파티클 입자의 최대 개수를 불러와 파티클을 자연스럽게 재생합니다. <br>파티클이 처음 재생되는 순간부터 그전에 이미 파티클이 재생되고 있었던 것처럼 자연스럽게 보이게 됩니다. |
| AutoRandomSeed | 파티클의 입자 방출이 시작될 때마다 랜덤 시드를 새로 생성할지 여부를 설정합니다. |

## UIAreaParticleComponent

[UIAreaParticleComponent](/apiReference/Components/UIAreaParticleComponent)는 UI에 파티클의 생성 범위를 설정할 수 있는 컴포넌트입니다. 파티클의 생성 범위가 변경되더라도 범위 내에 생성되는 파티클의 개수는 동일합니다. 주요 프로퍼티를 살펴봅시다.

| 프로퍼티 | 설명 |
| :---: | --- |
| AreaSize | 파티클 생성 범위를 설정합니다. |
| AreaOffset | Entity를 기준으로 생성 범위의 중심점 위치를 설정합니다. |

## UISpriteParticleComponent

[UISpriteParticleComponent](/apiReference/Components/UISpriteParticleComponent)는 UI에 스프라이트로 파티클을 만드는 컴포넌트입니다.

| 프로퍼티 | 설명 |
| :---: | --- |
| SpriteRUID | 파티클로 사용할 SpriteRUID를 설정합니다. |
| ApplySpriteColor | 파티클이 사용할 Sprite에 Color 프로퍼티를 적용할지 여부를 설정합니다. 프로퍼티가 false일지라도 Color의 투명도 값은 적용됩니다. |
| LocalScale | 파티클의 크기를 설정합니다. |

Update 2025-11-17 PM 08:14


# UI 에디터

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

UI를 편집할 수 있는 UI 에디터와 UI Group에 대해 알아봅시다.

##### 참고 가이드

- [UI 엔티티 제어하기](/docs?postId=1154&amp;version=1)
- [기본 UI 컴포넌트](/docs?postId=744)
- [UI 제작하기](/docs?postId=64)

# UI 에디터 소개

UI 에디터는 UI 엔티티를 구성하고, 메이플스토리 월드에서 제공하는 UI 엔티티를 조합해서 인벤토리나 상점 UI를 제작할 수 있습니다. UI 에디터 구성은 다음과 같습니다.

![uieditor01](https://mod-file.dn.nexoncdn.co.kr/bbs/16596702142238c38fd696f1a48dda868eb9b7368bb50.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![NO01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg) | Preset List | 메이커에서 제공하는 다양한 UI Preset을 활용할 수 있습니다. |
| ![NO_02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg) | UI 경로 정보 | 선택된 UI 엔티티의 경로 정보를 알 수 있습니다.<br>부모 경로 선택 시 해당 엔티티가 선택됩니다. |
| ![NO_03](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg) | 캔버스 | UI 엔티티를 배치하고 편집하는 작업 공간입니다.<br>게임 실행 시 캔버스에 배치된 모습대로 게임 화면에 출력됩니다. |
| ![NO_04](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541326353d8628c1473944497bf376acb7a65ca45.jpg) | 기본 도구 | 이미지나 버튼과 같은 UI 엔티티를 배치할 수 있습니다. |
| ![NO_05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541338689678f574f21e54a6ca533737924124d7e.jpg) | UI Groups 패널 | UIGroup 선택 및 추가/삭제를 할 수 있습니다. |

#### UI 에디터 전환

상단 메뉴에서 **[UI]** 버튼을 눌러 UI 에디터로 전환할 수 있습니다. **Scene** 화면이 UI 에디터용 화면으로 변경됩니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17191966018196e67fe462b44418f8ffd50225816127c.png)

# UIGroup

UIGroup은 **UITransformComponent, UIGroupComponent, CanvasGroupComponent**로 구성되어 있습니다. UIGroup은 일종의 폴더 역할을 하므로, Hierarchy와 UI Groups에서의 순서 영향을 받을 받지 않습니다. UI 에디터를 활성화하면, UI Groups 패널 창은 생성한 UI를 관리할 수 있습니다. 새로운 UI 그룹을 추가하면, Hierarchy, UIGroup에 모두 반영됩니다.

UIGroup에서는 기본적으로 3개의 그룹을 제공합니다.

- **ToastGroup**: 크리에이터의 편의를 위해 제공하는 UI 그룹입니다. UIToast 로직에 연결되어 있습니다.
- **PopupGroup**: 크리에이터의 편의를 위해 제공하는 UI 그룹입니다. UIPopup 로직에 연결되어 있습니다.
- **DefaultGroup:** 항상 활성화된 UI 그룹입니다. 채팅창이나 공격, 점프 같은 필수 버튼이 DefaultGroup에 배치되어 있습니다. 크리에이터의 의도에 따라 다른 그룹을 DefaultGroup로 설정할 수 있습니다.

#### UI Groups 패널

UI Groups 패널에서 제작 중인 UIGroup의 섬네일을 확인할 수 있습니다. 또한 UIGroup 이름을 변경할 수 있습니다. UI Groups에서 변경한 이름은 Hierarchy에도 반영됩니다. 그룹을 선택하면 UI 에디터 화면이 해당하는 그룹으로 변경되어 편집할 수 있습니다.

![112](https://mod-file.dn.nexoncdn.co.kr/bbs/171316272172268387b11bb884f6790635819a8af7021.png)

#### Hierarchy - ui

Hierarchy에서는 UIGroup에 속한 UI 엔티티들을 부모-자식 관계로 확인할 수 있습니다. UI 엔티티의 컴포넌트를 편집하거나, UI 엔티티의 부모-자식 관계를 변경할 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1713249479009dae50f8dd5ba4aa78e16fa684e742644.png)

#### UIGroup 상시 활성화

**UIGroupComponent**의 **DefaultShow** 프로퍼티를 활용해 노출 여부를 설정할 수 있습니다. DefaultShow 프로퍼티를 **true**![Editbox_Check](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176407708cb3de01eaaf48a68ab2dd6fe1b1183f.png)로 설정하면 해당 UIGroup에 속한 UI들은 늘 보이는 상태가 됩니다.

![uieditor17](https://mod-file.dn.nexoncdn.co.kr/bbs/1635153219911450a6374261549e985b5defd8c1ca4fc.png)

# UI 엔티티

UI 엔티티를 생성하는 방법은 두 가지입니다. 기본 UI 엔티티를 사용하거나, UI 프리셋을 사용할 수 있습니다.

#### 기본 UI 엔티티

기본 UI 엔티티는 UI 제작 시 가장 많이 사용하는 기능을 제공합니다. **이미지, 버튼, 스크롤 뷰, 텍스트, 입력 텍스트**로 구성되어 있습니다. 크리에이터는 여러 개의 UI 엔티티를 조합해 새로운 UI를 만들 수도 있습니다. [기본 UI 컴포넌트](/docs?postId=744) 가이드를 참고하세요.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17132470861160af59286c47f4cdfb9012301dfc3d0c1.png)

| 아이콘 | UI 모델 이름 | 기능 설명 | 포함된 컴포넌트 |
| --- | --- | --- | --- |
| ![workspace_image](https://mod-file.dn.nexoncdn.co.kr/bbs/1634599004241e68d5e91df374710866c7f10599d1513.png) | 이미지 | UI에 원하는 이미지를 출력합니다. 주로 아이콘 표시를 위해 사용합니다. | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li></ul> |
| ![UiButton](https://mod-file.dn.nexoncdn.co.kr/bbs/1634524924735d7c5b055209548e4b04c59abb701251d.png) | 버튼 | 클릭/터치 시 특정 액션이나 기능을 수행하도록 합니다. | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li><li>ButtonComponent</li></ul> |
| ![Ui_ScrollRect](https://mod-file.dn.nexoncdn.co.kr/bbs/1634525192881d1b9b9f851554f81b74425ff23f0ef57.png) | 스크롤뷰 | 많은 양의 정보를 리스트 형태 또는 그리드 형태로 정렬합니다. 예) 인벤토리, 상점 | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li><li>ScrollLayoutGroupComponent</li></ul> |
| ![Ui_Text](https://mod-file.dn.nexoncdn.co.kr/bbs/16345252157689279f2e1212f460381577fe950d87703.png) | 텍스트 | UI에 텍스트 표시하기 위해 사용합니다. | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li><li>TextComponent</li></ul> |
| ![Ui_InputField](https://mod-file.dn.nexoncdn.co.kr/bbs/1634525171304460516d8fc894f9f96220ee226cbd934.png) | 입력 텍스트 | 유저가 텍스트를 입력할 수 있습니다. 예) 검색 창, 아이디, 비밀번호 입력 창 | <ul><li>UITransformComponent</li><li>SpriteGUIRendererComponent</li><li>TextComponent</li><li>TextInputComponent</li></ul> |

#### UI Preset

메이플스토리 월드에서는 기능 별 UI를 프리셋으로 제작해 제공하고 있습니다. 프리셋에는 UI와 스크립트가 함께 포함되어 있으므로 프리셋을 배치하면, 포함된 컴포넌트가 MyDesk에 추가됩니다. 프리셋을 배치한 뒤, 제작 중인 월드에 맞게 UI와 스크립트를 수정할 수 있습니다. ![editor04](https://mod-file.dn.nexoncdn.co.kr/bbs/1659670431503beae4f6b1825450e8ee2043e1bcfec10.png)

Update 2025-11-17 PM 08:14


# 기본 UI 컴포넌트

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

컴포넌트를 조합해 다양한 형태의 UI 엔티티를 구성할 수 있습니다. 이번 과정에서는 UI에서 자주 사용하는 기본 컴포넌트에 대해 알아봅니다.

##### 참고 가이드

- [UI 에디터](/docs?postId=120)
- [UI 제작하기](/docs?postId=64)
- [UI 엔티티 제어하기](/docs?postId=1154)

# UITransformComponent

[UITransformComponent](/apiReference/Components/UITransformComponent)는 UI 엔티티에 반드시 포함되어야 하는 기본 컴포넌트입니다. **TransformComponent**와 상당히 유사하지만, 스크린 좌표에서 동작한다는 차이점이 있습니다. 주요 프로퍼티는 다음과 같습니다.

![UITransform](https://mod-file.dn.nexoncdn.co.kr/bbs/1657174537010c416d38c6dbd4357a590984d44bcb9ac.png)

| 번호 | 항목 | 설명 |
| :---: | :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | UI 좌표 | UI의 위치를 설정합니다. 왼쪽의 Anchor Presets 설정에 따라 필요한 Property가 달라집니다.<br>[월드 좌표와 스크린 좌표](/docs/?postId=688)의 Anchor Presets 항목에서 더욱 자세한 내용을 확인할 수 있습니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | UIMode | UI 엔티티가 ![Hierarchy](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_scene_maker.png) Hierarchy에서 UI 아래에 있으면 Screen으로 고정되고, maps 아래에 있으면 World로 고정됩니다. |

# 출력

#### SpriteGUIRendererComponent

[SpriteGUIRendererComponent](/apiReference/Components/SpriteGUIRendererComponent)는 UI에 이미지 리소스를 표시하는 컴포넌트입니다. 이를 활용해 UI에 '무엇'을, '어떤 형태'로 표시할지 설정할 수 있습니다. 주요 프로퍼티는 다음과 같습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1744880492943da5f0130b3564b8fb38d8921f50fe423.png)

| 번호 | 항목 | 설명 |
| :---: | :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | ImageRUID | 화면에 표시할 ImageRUID를 설정합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | Type | 이미지를 표시하는 방식입니다. Simple, Sliced, Tiled, Filled 중에서 선택할 수 있습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | OverrideSorting | SortingLayer와 OrderInLayer를 사용할지를 선택합니다. SpriteGUIRendererComponent가 World - maps 하위의 엔티티에 추가된 경우에만 활성화됩니다. |

그 외의 다른 프로퍼티를 통해 **ImageRUID**에서 설정한 이미지를 어떻게 표시할지 설정할 수 있습니다.

#### TextComponent

[TextComponent](/apiReference/Components/TextComponent)는 UI에 텍스트를 표시하는 컴포넌트입니다. **SpriteGUIRendererComponent**와 같이 사용할 경우 **SpriteGUIRendererComponent**보다 **TextComponent**를 위에 그립니다. UI 엔티티에 **TextComponent**가 포함되어 있으면 엔티티를 더블클릭하여 손쉽게 텍스트를 편집할 수 있습니다. 주요 프로퍼티는 다음과 같습니다.

![text](https://mod-file.dn.nexoncdn.co.kr/bbs/168671067460393c17d7821884fa9a30c00141833b74b.png)

| 번호 | 항목 | 설명 |
| :---: | :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | Font | 어떤 폰트로 표시할지 설정합니다.<br> **Default, Maple, Bazzi, Football** 중에서 선택할 수 있습니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | FontColor | 폰트 색상 및 투명도를 설정합니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | FontSize | 폰트 크기를 결정합니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | Text | 사용할 텍스트를 적어줍니다. |

# 입력

#### ButtonComponent

[ButtonComponent](/apiReference/Components/ButtonComponent)는 유저의 입력을 받을 때 사용하는 대표적인 컴포넌트입니다. '사용자가 버튼을 눌렀다'라는 입력 정보를 받을 수 있습니다. 주요 프로퍼티는 다음과 같습니다.

![ButtonComponent](https://mod-file.dn.nexoncdn.co.kr/bbs/1657592785058cf83097552544842a3b8a24257de7ce5.png)

| 번호 | 항목 | 설명 |
| :---: | :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | KeyCode | 버튼을 누르면 지정한 keyCode를 누른 것처럼 동작합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | Transition | 버튼 상태의 전환 방식을 설정합니다. 전환 방식에 따라 아래에 설정해야 할 프로퍼티가 달라집니다. <br><ul><li>**ColorTint**: 색상 전환</li><li>**SpriteSwap**: 스프라이트 교체</li></ul> |

**ButtonComponent**는 [ButtonState](/apiReference/Enums/ButtonState)를 활용해 버튼의 상태를 변경할 수 있습니다.

- Normal, Hover, Pressed, Released, Clicked

**ButtonComponent**는 출력 기능이 없습니다. 유저에게 버튼이 눌렸음을 인지시키기 위해 **SpriteGUIRendererComponent**나 **TextComponent**와 함께 사용합니다. **ButtonComponent**는 '입력이 되었다'라는 정보만 보내주기 때문에 버튼이 눌린 이후에 '무엇'을 '어떻게' 처리할지는 스크립트에서 정의해야 합니다. 일반적으로 **Event**를 통해서 버튼 입력을 감지하여 로직을 작성합니다.

주로 활용하는 Event는 다음과 같습니다.

- [ButtonClickEvent](/apiReference/Events/ButtonClickEvent): 버튼을 눌렀을 때 발생하는 이벤트입니다.
- [ButtonPressedEvent](/apiReference/Events/ButtonPressedEvent): 버튼을 누르고 있을 때 발생하는 이벤트입니다.
- [ButtonStateChangeEvent](/apiReference/Events/ButtonStateChangeEvent): 버튼의 상태가 변경될 때 발생하는 이벤트입니다.

#### TextInputComponent

[TextInputComponent](/apiReference/Components/TextInputComponent)은 텍스트 입력을 받을 수 있는 컴포넌트입니다. 주요 프로퍼티는 다음과 같습니다.

![textinput](https://mod-file.dn.nexoncdn.co.kr/bbs/168957179254024254818dac64c37a05886983c29e0dc.png)

| 번호 | 항목 | 설명 |
| :---: | :---: | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | AutoClear | True 이면 텍스트 입력 후 입력 영역을 자동으로 초기화합니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | ContentType | 입력할 수 있는 텍스트 유형을 지정합니다. <br><ul><li>**Standard** : 모든 입력을 허용합니다.</li><li>**Autocorrected** : 모든 입력을 허용하고, 자동 수정을 지원하는 플랫폼에서 자동 수정이 이루어집니다.</li><li>**IntegerNumber**: 숫자만 입력할 수 있습니다.</li><li>**DecimalNumber**: 숫자와 소수점 하나만 입력할 수 있습니다.</li><li>**Alphanumeric**: A-Z, a-z, 0-9를 입력할 수 있습니다.</li><li>**Name**: 첫 번째 글자를 대문자로 표시합니다.</li><li>**EmailAddress**: 하나의 @기호로 구성된 영, 숫자 문자열을 입력할 수 있습니다. 마침표(.)는 연달아 입력할 수 없습니다.</li><li>**Password**: 모든 문자의 입력을 허용하고 별표(asterisk)로 표시합니다.</li><li>**Pin** : 숫자 타입의 입력만 허용하고 별표(asterisk)로 표시합니다.</li><li>**Custom**: 사용자가 직접 유형(Line Type, Input Type, Keyboard Type, 문자열 검증)을 설정할 수 있습니다.</li></ul> |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | LineType | <ul><li>**SingleLine** : 한 줄로 입력합니다.</li><li>**MultiLineSubmit** : 여러 줄로 입력할 수 있고 Enter를 입력하면 입력이 종료됩니다.</li><li>**MultiLineNewline** : 여러 줄로 입력할 수 있고 Enter를 입력하면 개행 처리됩니다.</li></ul> |

**TextInputComponent**는 입력만 받기 때문에 입력받은 것을 표시하기 위해서는 **TextComponent**가 필요합니다. 일반적으로 **TextInputComponent**와 **TextComponent**를 함께 사용합니다. **TextInputComponent**를 통해 입력받은 텍스트를 어떻게 처리할지는 스크립트에서 정의해야 합니다. **TextInputComponent** 또한 **Event**를 통해 텍스트 입력을 감지하여 로직을 작성합니다.

주로 활용하는 Event는 다음과 같습니다.

- [TextInputEndEditEvent](/apiReference?postId=444): 입력이 완료되었을 때 발생하는 이벤트입니다. 완전한 문장이나 단어를 받아서 처리할 경우 사용합니다.
- [TextInputValueChangeEvent](/apiReference?postId=406) : 입력값이 변경될 때 발생하는 이벤트이며, 입력될 때마다 각각의 순간을 감지하여 처리합니다.

Update 2025-12-05 PM 04:34


# UI 제작하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드 메이커에서는 UI를 편집할 수 있는 **UI 에디터**를 제공합니다. UI 에디터를 활용해 캐릭터의 이름이나 스탯 창, 채팅 창 등을 구현할 수 있습니다. 또한 게임의 생동감을 살리는 연출도 만들 수 있습니다. UI 에디터의 기본 기능인 **이미지**와 **텍스트**를 사용해 화면 상단에 환영 메시지 UI를 만들어 봅시다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16607859751670dad1471dc514cef891e7f484d61bf20.png)

##### 참고 가이드

- [UI 에디터](/docs?postId=120)
- [기본 UI 컴포넌트](/docs?postId=744)
- [UI 엔티티 제어하기](/docs?postId=1154)

# 새 그룹에 텍스트 추가

화면 상단 중앙에 **Hello MapleStory Worlds**를 추가해봅시다.

1. 오른쪽 하단의 ![Common_layer_add](https://mod-file.dn.nexoncdn.co.kr/bbs/16345369150225f875c8c218444c58189ffac05201631.png) 버튼을 눌러 새로운 그룹을 추가합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16566580669786e89df499cff4c42aaa5046cd1e5126d.png)  새로운 그룹을 처음 추가하면 **UIGroup**이 생기고, 그룹 선택 창에서 **UIGroup**이 선택됩니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1635466100477be5787d22e4745bca8948e07dc1fe6aa.png)
2. 추가한 **UIGroup**에 텍스트 박스를 추가합니다. 왼쪽 기본 도구에서 ![Ui_Text](https://mod-file.dn.nexoncdn.co.kr/bbs/16345252157689279f2e1212f460381577fe950d87703.png) 버튼을 클릭합니다. 텍스트 박스가 화면 중앙에 배치됩니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1635466110759f18631e58b2845e08eefdadee9584e42.png)
3. 텍스트 박스의 위치와 크기를 설정해 봅시다. **프로퍼티 에디터 - UITransfromComponent**에서 아래와 같이 값을 입력합니다.
  - PosX = 0
  - PosY = 400
  - Width = 500
  - Height = 100 ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1635466119736567a06e7efb749f0bd593cf5583c7ca0.png)
4. 텍스트 박스의 배경색을 변경합니다. **SpriteGUIRendererComponent**의 **Color** 값을 다음과 같이 설정합니다.
  - R : 255
  - G : 255
  - B : 255
  - A : 100% ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1719208795002a31a47af5b3940e6a51f594f60237bf7.png)
5. **SpriteGUIRendererComponent**의 **ImageRUID** 오른쪽에 있는 버튼을 클릭하여 **Resource Picker** 창을 엽니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/168085693599993c114d51e92442c911b153b975dc647.png)
6. **Resource Picker** 창에는 텍스트 박스의 배경으로 사용할 수 있는 이미지 목록이 출력됩니다.
  - RUID: b2efe9b7579bd494baecc7a2ef3 ![TextAndImage_10](https://mod-file.dn.nexoncdn.co.kr/bbs/1680857186821081809892ed1431e9ad72ed3ee213001.png)
7. 이미지를 선택하면 다음과 같이 UI가 적용된 것을 확인할 수 있습니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16354667716403f561d9f75ef4c77ace222e41916872f.png)
8. **TextComponent**의 프로퍼티 값을 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | TextComponent | Text | Hello MapleStory Worlds | | FontSize | 30 |
  > **Tip.** 이 텍스트 박스는 UI 에디터에서는 보이지만 실제 플레이 할 때는 보이지 않습니다. 추가된 **UIGroup**은 기본적으로 보이지 않는 상태로 설정되어 있기 때문입니다.
9. **Hierarchy - ui - UIGroup**을 선택합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/165950430779879b381eacaa846408419a337d605f4bc.png)
10. **UIGroup**의 프로퍼티 에디터에서 **UIGroupComponent**의 **DefaultShow**를 활성화해 **UIGroup**이 항상 보이도록 만듭니다. ![TextAndImage_13](https://mod-file.dn.nexoncdn.co.kr/bbs/1634690751616957f4000f31a406da4fcb2651c1803ed.png)
11. 상단의 ![Tool_UI](https://mod-file.dn.nexoncdn.co.kr/bbs/163453120840744616a62243642e889159a68a78a56c2.png) 버튼을 클릭하여 UI 에디터를 종료합니다. ![ui](https://mod-file.dn.nexoncdn.co.kr/bbs/16607866498590ff06626406440d4a3a3d75e72800f6e.png)
12. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트합니다. 플레이 화면에서 추가한 텍스트가 잘 보이는 것을 확인할 수 있습니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16607861764157e8a105a04e642c09ef7ec13e3622d6a.png)

# 이미지 추가

텍스트 박스가 조금 더 돋보이도록 메소 이미지를 추가하겠습니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1660786201599b49010a72c294a5eb6bc3d8850eb706b.png)

1. UI 에디터를 연 뒤, **UIGroup**을 클릭합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16354668571302757ee322edb4681a95ecc00359dbe19.png)
2. 왼쪽 기본 도구에서 **[이미지]** 버튼을 클릭하여 이미지 UI를 추가합니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1660786345914ecc31fc8aa174ed39195af5c34ed77c2.png)
3. 추가한 이미지의 프로퍼티 에디터에서 **SpriteGUIRendererComponent**의 **ImageRUID** 오른쪽 버튼을 클릭하여 **Resource Picker** 창을 엽니다.
  - RUID:fd255d50cb5177545a0e71c4a84 ![002](https://mod-file.dn.nexoncdn.co.kr/bbs/16808600045139383ec457a95496990e109b3e927509f.png)
4. 프로퍼티 에디터 - **UITransfromComponent**에서 아래와 같이 값을 입력합니다.
  - Pos X = -257
  - Pos Y = 403
  - Width = 70
  - Height = 70 ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1656658276777578d07057c8148a09fb8eced28b3a654.png)
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트합니다. 이미지와 텍스트 박스가 잘 배치된 것을 확인할 수 있습니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16607862245222f3b07edaa1f4535b86ee27851a9646a.png)

Update 2025-11-17 PM 08:14


# UI 엔티티 제어하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=40%EB%B6%84&amp;color=green)

# 학습 과정 소개

UI 엔티티를 효율적으로 제어하는 방법을 알아봅시다. UI 엔티티를 제어할 때 UI와 서버, 그리고 클라이언트의 관계를 파악해 만들어야 합니다.

##### 참고 가이드

- [UI 에디터](/docs?postId=120)
- [UI 제작하기](/docs?postId=64)
- [기본 UI 컴포넌트](/docs?postId=744)

# UI 엔티티 제어

엔티티에 접근하는 것과 동일한 방법으로 UI 엔티티에 접근할 수 있습니다. 엔티티에 접근하는 방법은 [엔티티와 컴포넌트 참조](/docs?postId=164) 가이드를 참고하세요. UI 엔티티는 클라이언트 공간에만 존재하므로 서버에서 접근할 수 없습니다. UI 엔티티나 엔티티의 컴포넌트를 받아올 때는 오직 클라이언트 함수에서만 참조해야 합니다. 서버에서 처리된 내용을 UI로 출력하거나 UI를 통해 입력한 내용을 서버에서 처리해야 할 때는 실행제어를 이용해 각 공간에서 수행하도록 해야 합니다.

![300](https://mod-file.dn.nexoncdn.co.kr/bbs/16376400434986207872f3b3346a1902926ce8e819a84.png)![UIeditor80](https://mod-file.dn.nexoncdn.co.kr/bbs/1660700550069a309016cdd944831981b9f99331b6ff7.png)

#### 버튼 클릭

버튼을 클릭 했을 때 서버에서 처리를 요청하는 예시입니다.

```
Method:
[client only]
void OnBeginPlay()
{
    local button = _EntityService:GetEntityByPath("ButtonEntityPath") 
    -- 가져올 버튼 엔티티 경로를 "ButtonEntityPath"에 입력합니다.
    button:ConnectEvent(ButtonClickEvent, self.OnButtonClickClient)
}

[client only] 
void OnButtonClickClient()
{
    --processing in client..
    self:OnButtonClickServer()
}

[server] 
void OnButtonClickServer()
{
    log("Start processing on the server")
}
```

#### 서버 처리 결과 UI로 출력

```
Property:
[None]
number time = 0

Method:
[server only]
void OnUpdate(number delta)
{
    self.time = self.time + delta
    if self.time >= 3 then
        self.time = 0
        self:ShowToastMessage("Time Reset")
    end
}
    
[client] 
void ShowToastMessage(string text)
{
    local toastUIEntity = _EntityService:GetEntityByPath("UIEntityPath") 
    -- 가져올 UI 엔티티 경로를 "UIEntityPath"에 입력합니다.
    
    local textComponent = toastUIEntity.TextComponent
    
    -- print toast message
    textComponent.Text = text
    toastUIEntity:SetEnable(true)
     
    --reservate hide toast message
    local callback = function()
        toastUIEntity:SetEnable(false)
    end
    _TimerService:SetTimerOnce(callback,3)
}
```

# UI 노출 제어

`SetEnable()` 함수를 사용해 UI의 노출을 제어할 수 있습니다. 아래 그림과 같이 팝업창을 직접 제작하고 동일 계층으로 UI를 만들었을 경우를 살펴봅시다. 이 팝업창은 동시에 나타나고 사라져야 하므로 모든 엔티티의 **Enable**을 별도로 설정해야 합니다.

![uieditor06](https://mod-file.dn.nexoncdn.co.kr/bbs/1659671947080901d185518b64d008152c181b8eb1735.png)

```
void ShowPopupUI()
{
    local PopupUIEntity_1 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODImage_1")
    local PopupUIEntity_2 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODButton_1")
    local PopupUIEntity_3 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODButton_1_1")
    PopupUIEntity_1:SetEnable(true)
    PopupUIEntity_2:SetEnable(true)
    PopupUIEntity_3:SetEnable(true)
}
 
void HidePopupUI()
{
    local PopupUIEntity_1 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODImage_1")
    local PopupUIEntity_2 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODButton_1")
    local PopupUIEntity_3 = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODButton_1_1")
    PopupUIEntity_1:SetEnable(false)
    PopupUIEntity_2:SetEnable(false)
    PopupUIEntity_3:SetEnable(false)
}
```

UI를 제작할 때 UI 기능에 속한 UI 들은 계층 구조를 활용해 **부모-자식** 관계로 만드는 것을 권장합니다. 특정 UI 엔티티를 최상위 엔티티로 만들고 나머지 UI 엔티티를 자식으로 포함시킵니다. 부모-자식의 특성을 이용해 최상위 엔티티만 참조해 모든 UI 엔티티를 제어할 수 있게됩니다. 계층 구조를 활용한 노출/숨김 처리 예시 코드입니다.

```
void ShowPopupUI()
{
    local PopupUIEntity = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODImage_1")
    PopupUIEntity:SetEnable(true)
}
 
void HidePopupUI()
{
    local PopupUIEntity = _EntityService:GetEntityByPath("/ui/DefaultGroup/MODImage_1")
    PopupUIEntity:SetEnable(false)
}
```

# UIGroup 제어

엔티티의 `SetEnable` 함수를 활용해 **UIGroup**를 제어할 수 있습니다.

```
void ShowUIGroup_1()
{
    local UIGroup_1 = _EntityService:GetEntityByPath("/ui/UIGroup_1")
    UIGroup_1:SetEnable(true)
}
 
void HideUIGroup_1()
{
    local UIGroup_1 = _EntityService:GetEntityByPath("/ui/UIGroup_1")
    UIGroup_1:SetEnable(false)
}
```

Update 2025-11-17 PM 08:14


# 엔티티에 이름표 붙이기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

사물을 구분하는 효과적인 방법은 이름을 붙이는 것입니다. 이름표를 이용해 오브젝트와 NPC를 구분하거나, 유저를 구분할 수 있습니다. NameTagComponent 사용 방법과 활용 예시를 소개합니다.

# 이름표 붙이기

엔티티를 선택하고 **NameTagComponent**를 추가합니다. 프로퍼티 값을 변경해 원하는 이름표를 만듭니다. ![NametagComponent](https://mod-file.dn.nexoncdn.co.kr/bbs/1633505174925b7f918183b8d46d996e32b3e84b3c15d.png)

NameTagComponent 프로퍼티 구성은 다음과 같습니다.

| 이름 | 설명 |
| --- | --- |
| FontColor | 글씨 색상을 변경합니다. 색상 변경은 스프라이트 색상 조정을 참고하세요. |
| FontSize | 이름과 이름표 크기를 변경합니다. 초깃값은 1이며, 숫자가 커질수록 이름표 크기가 커집니다. |
| Name | 이름표의 이름을 변경합니다. 초깃값은 Null이며, 원하는 이름으로 변경할 수 있습니다. |
| NameTagRUID | 다양한 이름표 스프라이트를 이용할 수 있습니다.<br>![name](https://mod-file.dn.nexoncdn.co.kr/bbs/1682065127446a1289f492f38401abbff1b9f791dbd13.png) |
| OffsetY | 이름표 위치를 정합니다. 원점 값은 0, 기준 축은 Y 축입니다. <br>값이 0이면 원점에 이름표가 달립니다. 음수를 입력하면 아래로, 양수면 위에 위치합니다. |

# Name Tag 활용

오브젝트에 이름표를 붙여 NPC로 연출하는 예시입니다. 동일한 스프라이트의 몬스터나 NPC를 사용하고 싶다면, 이름표를 붙여 구분할 수 있습니다. 예를 들어, 고양이 오브젝트를 여러 개 배치하고, 그 사이에 고양이 이름표를 단 NPC 고양이를 대장으로 보이게 할 수 있습니다.

아래의 값을 입력해 연습할 수 있습니다.

- FontColor: f5e38b
- FontSize: 1
- Name: 길을 잃은 고양이
- NameTagRUID: ac88638649c3479bbb754e4b34bb3eac
- OffsetY: 0

![nametag cat](https://mod-file.dn.nexoncdn.co.kr/bbs/16335077322494677e24b07a34e5ab5aa8943233fa37c.jpg)

Update 2025-11-17 PM 08:14


# 말풍선 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

엔티티와 플레이어 아바타에 말풍선을 간단하게 붙일 수 있습니다. ChatBalloonComponent 사용 방법과 활용 예시를 소개합니다.

# 말풍선 붙이기

1. 말풍선을 붙일 엔티티를 선택하고 **ChatBalloonComponent**를 추가합니다.
2. 프로퍼티 값을 변경해 원하는 말풍선을 만듭니다. ![chatballoon01](https://mod-file.dn.nexoncdn.co.kr/bbs/1635730184988c95467b0dd9f4613abf9ba85d68914d9.png) 주요 프로퍼티 값은 다음과 같습니다.

| 프로퍼티 명 | 설명 |
| --- | --- |
| ChatBalloonRUID | 다양한 말풍선 스프라이트를 이용할 수 있습니다. |
| BalloonScale | 말풍선 크기를 설정합니다. 입력한 값이 클수록 크기가 양옆으로 늘어납니다. |
| ArrowChatEnabled | 말풍선 꼬리 이미지 붙이거나 뗄 수 있습니다. <br>꼬리가 붙은 상태가 기본 활성 상태입니다. |
| AutoShowEnabled | 말풍선을 자동으로 표시할지 정합니다.<br>Player의 ChatBalloonComponent의 경우 true일 때 동작하지 않습니다. |
| Font Offset | 말풍선 내의 글자의 위치를 상하좌우로 조정합니다. |
| Offset | 말풍선 위치를 정할 수 있습니다. 원점 값은 0, 기준 축은 Y 축입니다. <br>값이 0이면 원점에 이름표가 위치합니다. 음수를 입력하면 아래로, 양수면 위에 위치합니다. |
| HideDuration | 말풍선이 화면에 보이지 않는 시간을 초 단위로 입력합니다.<br>값이 0이면 화면에 항상 보입니다. |
| ShowDuration | 말풍선이 화면에 보이는 시간을 초 단위로 입력합니다.<br>1 이상의 수를 입력해야 말풍선이 보입니다. |
| Message | 말풍선으로 보일 문구를 작성합니다.<br>다른 설정이 활성 상태여도 문구가 없으면 말풍선이 보이지 않습니다. |
| FontSize | 말풍선 문구 크기를 변경합니다.<br>기본값은 1이며, 숫자가 커질수록 글자 크기가 커집니다. |
| FontColor | 말풍선 문구 색상을 변경합니다.<br>색상 변경은 스프라이트 색상 조정을 참고하세요. |
| IsRichText | 말풍선에서 리치 텍스트를 사용할지를 설정합니다. |
| ChatModeEnabled | 활성 시, 채팅창에 입력한 메시지가 말풍선으로 동시에 나타납니다.<br> Player의 ChatBalloonComponent에서 사용할 때만 동작하며, 활성 상태가 기본입니다. |
| AutoShowEnabled | 말풍선이 자동으로 나타나게 할지 여부를 설정합니다. 값이 true일 경우 ShowDuration 동안 말풍선이 보이고 HideDuration 동안 말풍선이 사라지는 동작을 반복합니다. 플레이어의 ChatModeEnabled 값이 true일 경우 자동 말풍선 기능이 동작하지 않습니다. |

#### 활용 예시

물개 엔티티 오브젝트에 말풍선을 만드는 예제입니다. ![chatballoon03](https://mod-file.dn.nexoncdn.co.kr/bbs/1655963930366197ddcce272b435d9633958b4b3fdbff.png)

다음과 같이 값을 입력해 봅시다.

| Property | value |
| :---: | --- |
| ArrowChatEnabled | true |
| AutoShowEnabled | true |
| BalloonScale | 3 |
| ChatBalloonRUID | 0548325d3d4d40649acad12fde2359d4 |
| ChatModeEnabled | false |
| FontColor | #000000 |
| FontSize | 1.5 |
| HideDuration | 5 |
| Message | Is it a seal? Or a ture seal? |
| Offset | 1 |
| ShowDuration | 5 |

Update 2025-11-17 PM 08:14


# UI 디자인 가이드

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드를 제작할 때 User Interface(UI)는 필수 요소입니다. UI는 유저에게 플레이 관련 정보를 명확하고 간결하게 제공해야 합니다. 점수, 체력, 남은 시간, 각종 버튼 같은 UI 요소가 잘 디자인되어 있다면 유저는 직관적으로 월드를 이해하고 재미있게 플레이할 수 있을 것입니다. 유저는 메이플스토리 월드를 PC 및 모바일 환경에서 두루 플레이할 수 있습니다. 그러므로 크리에이터는 다양한 환경에서 불편함이 없도록 UI를 디자인해야 합니다. 물론 월드 콘셉트에도 맞고, 시각적으로 눈길을 사로잡는 디자인을 통해 매력을 발산하는 것도 중요합니다.

이번 시간에는 메이플스토리 월드 UI를 디자인할 때 고려할 사항과 유용한 팁 몇 가지를 소개하겠습니다.

# 상호 작용성

##### 다양한 디바이스를 고려한 레이아웃

UX만 고려한다면 PC와 모바일에 각각 최적화된 UI를 만드는 것이 최선일 것입니다. 하지만 월드를 제작할 때는 다양한 요소에 공을 들여야 하므로 모든 기기 별 UI를 만들기는 어렵습니다. UI 대부분은 공용으로 만들되, 사용성을 위해 반드시 달라져야 하는 부분만 기기 별 UI를 제작하는 것이 좋습니다.

<광부 시뮬레이터> 예시를 살펴봅시다. <광부 시뮬레이터> UI 대부분은 PC와 모바일에서 동일하고, 몇 가지 조작 버튼의 위치만 다릅니다. 공용 UI 텍스트나 버튼 크기는 화면 크기가 작은 모바일을 기준으로 불편함이 없도록 제작되었습니다. PC에 맞춘다면 모바일 화면에서 너무 작아져서 사용하기 어렵기 때문입니다.

| 기기 | 설명 |
| --- | --- |
| 모바일 | ![mobile](https://mod-file.dn.nexoncdn.co.kr/bbs/16813599460498acfdab2130f4fcab496bf76e83d1ec9.png)<br><li>모바일에서 아이템을 편하게 사용할 수 있는 위치에 슬롯을 보여줍니다</li><li>대시, 점프, E 키 조작이 필수적이기에 항상 화면에 보여줍니다.</li><li>조이스틱을 보여줍니다..</li> |
| PC | ![pc](https://mod-file.dn.nexoncdn.co.kr/bbs/168135995962657eba9bd408f459eacaf3055e4f2499c.png)<br><li>아이템 슬롯이 왼쪽 하단에 나옵니다. 단축키가 함께 보여 편하게 사용할 수 있습니다.</li><li>대시는 이 게임에서 유용한 키이므로 단축키 shift와 함께 보여줍니다.</li>그 밖에 PC에서 점프는 모든 메이플스토리 월드에서 공통된 조작이기에 굳이 버튼을 보여주지 않습니다. |

##### 기본 UI를 가리지 않는 레이아웃

모든 월드의 화면 우측 상단에는 메이플스토리 월드 기본 UI가 있습니다. 기본 UI는 위치를 이동하거나 숨길 수 없습니다. 그러므로 기본 UI를 가리지 않도록 월드 UI를 디자인해야 합니다.

| O | X |
| :---: | :---: |
| ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1681365023170ab166d98e0a64396aa51c2475b992350.png)<br>![03](https://mod-file.dn.nexoncdn.co.kr/bbs/168136503481552de0a69652143828a376d12fb7f04f3.png) | ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681365003797e997565b1a80441a9f63c23d1f5d36c2.png) |

##### 터치를 고려한 설계

버튼은 모바일 사용자가 터치할 때 불편하지 않은 크기로 설정해야 합니다. 영역이 너무 작으면 사용자가 터치하기 어렵기 때문입니다. 필수적인 것은 아니나, 일반적으로는 버튼 크기를 **80 X 80px** 이상으로 설정하기를 권장합니다. 디자인 과정에서 권장 크기보다 작은 버튼을 제작했다면 미리 모바일 환경에서 불편하지 않은지 확인해 봅시다. 또한 버튼 간격도 중요합니다. 버튼 간격이 적당히 떨어져 있어야 다른 버튼을 터치할 때 간섭이 없습니다. 손가락 터치를 고려하여 터치 영역 및 여백을 조절해 봅시다.

> **더 알아보기** ![default](https://mod-file.dn.nexoncdn.co.kr/bbs/168137478767305e25de85e584f939475dba219a8896c.png) 월드 우측 상단의 기본 UI 버튼 크기가 80 X 80px입니다. UI 디자인할 때 참고 바랍니다.

# 가독성

##### 폰트 크기

모바일 환경을 고려했을 때 일반적인 폰트 크기는 **24pt** 이상으로 설정하기를 권장합니다. 물론 RPG처럼 유저에게 보여줄 정보량이 많은 월드라면 더 작은 크기를 사용하기도 합니다. 하지만 글씨가 너무 작으면 가독성이 떨어진다는 점을 고려해야 합니다. 그러므로 폰트 크기를 줄여야 하는 상황일지라도 **최소 18pt** 이상으로 설정하는 것이 좋습니다. 월드를 제작할 때 PC나 모바일 환경에서 가독성을 확인하며 만들기를 권장합니다.

> **더 알아보기** ![fontsize](https://mod-file.dn.nexoncdn.co.kr/bbs/16813812593511eb9305748904597aaf6ec9b49e77da9.png) <광부 시뮬레이터>의 상점 카테고리 설명 폰트 크기가 24pt입니다. 폰트 설정할 때 참고 바랍니다.

##### 대비

텍스트와 배경 색상의 대비를 명확하게 하여 텍스트가 선명하게 보이도록 합니다.

| O | X |
| :---: | :---: |
| ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1681381891683a58a23ae4ea3479a981d0540c32e5ad1.png) | ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16813819095597b17034789224a1f8fef16b9e54cc365.png) |

# 일관성

일관성 있는 UI 디자인은 유저가 월드 플레이 방식을 보다 빠르게 이해하고 즐길 수 있도록 도와줍니다. 이러한 UI 디자인을 위해 아래 사항을 참고해 봅시다.

##### 색상 팔레트

UI에서 사용할 색상 팔레트를 결정하고 일관되게 사용해 봅시다. 너무 많은 색상을 사용하면 UI가 지저분해지고 해당 색상이 무엇을 의미하는지도 알 수 없게 됩니다. 해당 월드 UI에서 사용할 몇 가지 색상을 정하고, 비슷한 기능을 하는 요소는 같은 색상을 사용하여 일관성을 유지하는 것이 좋습니다. 예를 들어, [예] 또는 [확인] 버튼에 파란색을 사용하기로 했다면 해당 월드 내에서는 계속 해당 버튼을 파란색으로 설정하도록 합니다.

##### 아이콘

일관된 아이콘을 사용하여 유저가 버튼이나 메뉴 같은 UI 요소를 쉽게 인지하고 사용하도록 합니다.

##### 텍스트 서식

UI에서 사용하는 텍스트 요소의 크기, 폰트, 굵기 같은 서식을 일관되게 사용하는 것이 좋습니다. 중요도 단계를 나눈 뒤, 단계별 텍스트 사이즈를 정하고, 같은 중요도를 가진 텍스트의 크기 및 서식을 통일합니다.

##### 이미지 서식

텍스트 서식을 통일하는 것과 유사한 개념입니다. 정보의 종류 및 중요도에 따라 이미지 크기, 테두리, 그림자 같은 서식을 통일하는 것이 좋습니다.

##### 버튼

같은 비중을 가진 버튼은 같은 크기를 사용하는 것이 좋습니다. 또한 비슷한 기능을 하는 버튼은 같은 방향에 배치합니다. "예", "확인" 같은 긍정적 버튼을 오른쪽에, "아니오", "취소" 같은 부정적 버튼을 왼쪽에 두기로 했다면 방향 일관성을 유지해야 합니다.

##### 애니메이션

애니메이션 효과를 일관되게 사용하여 UI 내에서 전환 및 상호작용 경험을 일관성 있게 만듭니다.

# 그 밖의 디자인 팁

### 기준 해상도

1920 X 1080 해상도 기준으로 작업하기를 권장합니다.

### 유저 리소스

크리에이터는 자신이 제작한 UI 리소스를 Resource Storage에 등록하여 사용할 수 있습니다. UI 리소스를 등록할 때 아래 내용을 참고하기 바랍니다.

##### 리소스 최적화

Resource Storage에 등록할 스프라이트의 가로, 세로 길이를 4의 배수로 맞추면 업로드할 때 자동 최적화되어 용량이 작아집니다. 예를 들어 가로 2000px, 세로 2000px인 스프라이트는 가로, 세로 길이가 모두 4의 배수이므로 업로드할 때 자동으로 최적화됩니다.

##### 필터 모드 설정

크리에이터가 등록한 리소스 세부 정보에서 필터 모드를 변경할 수 있습니다. UI 리소스는 주로 아래 2개 필터 중 적절한 것을 선택해 사용합니다.

| 필터 모드 | 설명 |
| --- | --- |
| Point | 색을 선명하게 유지합니다. 스프라이트를 확대했을 때 색의 경계가 또렷하게 보입니다. <br>도트 이미지처럼 이미지 가장자리가 깔끔하게 떨어지는 리소스에서 주로 사용합니다. |
| Bilinear | 특정 색과 주변 색을 섞어 부드럽게 표현합니다. <br>스프라이트를 확대했을 때 본래 스프라이트보다 색의 경계가 흐릿하게 보일 수 있습니다. |

### 폰트

메이플스토리 월드에서는 네 가지 폰트를 사용할 수 있습니다.

| 폰트 | 예 |
| --- | --- |
| Default (Noto Sans) | ![font01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681288827131ccd383fd33f94b87a4e9032b766bf75b.png) |
| Maple | ![font02](https://mod-file.dn.nexoncdn.co.kr/bbs/1681288844324c4ebcad014dd4f8d8cabbf1e412bd461.png) |
| Bazzi | ![font03](https://mod-file.dn.nexoncdn.co.kr/bbs/168128885797032b65d1d08604b8abf5b6f38546a4c4b.png) |
| Football | ![font04](https://mod-file.dn.nexoncdn.co.kr/bbs/16812888772139dc36fc5340147da9621e41a8ef0ca39.png) |

Noto Sans 폰트는 언어별 호환성이 좋습니다. 글로벌 서비스를 위해 다양한 언어로 번역하는 상황을 고려한다면 Noto Sans를 사용하는 것이 좋습니다. Maple, Bazzi, Football 폰트는 한글 및 영어 사용에는 무리가 없으나 그 외 언어는 대응하지 못하므로 숫자나 영어로 보여줄 부분에만 사용하기를 권장합니다.

### 섬네일

이미지 사이즈를 16:9 비율로 제작합니다. 960 X 540px 사이즈로 제작하는 것을 권장합니다. ![thumbnail](https://mod-file.dn.nexoncdn.co.kr/bbs/168138308206981ffaf18bdae47138a452f4ff430dd64.png)

### UI로 화면 전체 덮기

UI로 화면 전체를 덮을 때는 보통 **UITransformComponent**에서 UI가 화면 전체로 늘어나도록 설정하고 좌표를 (0, 0, 0, 0)으로 설정합니다. ![s01](https://mod-file.dn.nexoncdn.co.kr/bbs/1681871890337b500055a443f40ada2667021869a20d5.png)

하지만 이렇게 설정하면 일부 모바일 기기에서는 Safe Area에 밀려 여백이 생길 수 있습니다. ![s02](https://mod-file.dn.nexoncdn.co.kr/bbs/168187195095784a41c74787c4984b78b3fc353e20573.png)

그러므로 좌표를 (-300, -300, -300, -300) 정도로 확장하면 불필요한 여백을 방지할 수 있습니다. ![s03](https://mod-file.dn.nexoncdn.co.kr/bbs/16818725626457d38a53401074fdab37f5381cd26bdbb.png)

Update 2025-11-17 PM 08:14


# 데이터 편집

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

데이터 셋을 이용해 데이터를 추가하거나 수정할 수 있습니다. 이번 가이드에서는 데이터의 생성 및 편집 방법, 스크립트로 데이터를 불러오는 방법에 대해 알아봅니다.

# 데이터 셋 생성 및 데이터 에디터 열기

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create DataSet**을 클릭합니다.
2. 생성된 데이터를 더블클릭하여 데이터 에디터를 엽니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16354715533571c67244b3c0e4ba688af580c8c34a7dc.png)

# 데이터 에디터

![3](https://mod-file.dn.nexoncdn.co.kr/bbs/custom/69/Doc_69_3_ko.png)

| 번호 | 설명 |
| --- | --- |
| ![NO01](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541272181b5c1a55fcf3d49b19734d25913c38583.jpg) | **컬럼 셀**<br>각 열의 데이터명, 즉 컬럼 명을 정의합니다.<br>각 열의 데이터를 가져올 때 컬럼 명을 통해 가져올 수 있습니다. |
| ![NO_02](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541300837cb541c2f44e046a79bb1901a885aa8ac.jpg) | **셀**<br>각 셀은 인풋 텍스트 필드로 각 열의 정의에 적합한 데이터 값을 입력합니다.<br>입력한 데이터 값은 모두 스트링으로 저장됩니다. |
| ![NO_03](https://mod-file.dn.nexoncdn.co.kr/bbs/163454131465069e090278448490f965207e9a4a10348.jpg) | **행/열 추가 버튼**<br>버튼을 누르면 행/열 끝에 새로운 행이나 열을 추가합니다. |
| ![NO_04](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541326353d8628c1473944497bf376acb7a65ca45.jpg) | **행/열 삽입 및 삭제 핸들러**<br>선택한 행/열을 기준으로 상하/좌우에 새로운 행/열을 추가하거나 선택한 행/열을 삭제할 수 있습니다.<br>핸들러는 각 머리 행 또는 머리 열을 선택하면 노출됩니다. |
| ![NO_05](https://mod-file.dn.nexoncdn.co.kr/bbs/1634541338689678f574f21e54a6ca533737924124d7e.jpg) | **웹에서 데이터 가져오기**<br>GoogleSpreadSheet의 데이터를 가져올 수 있습니다.<br>GoogleSpreadSheet에서 데이터를 작성한 후 해당 데이터의 URL을 팝업창에 넣어주면<br>현재 열려있는 데이터에 GoogleSpreadSheet의 데이터를 덮어씌웁니다.<br>단, GoogleSpreadSheet의 URL은 웹에 게시한 URL만 사용할 수 있습니다.<br> ![NO_05_1](https://mod-file.dn.nexoncdn.co.kr/bbs/1656660216362c29ce81d29e6400caa25bc648b91058a.png) |
| ![NO_06](https://mod-file.dn.nexoncdn.co.kr/bbs/163454135201207284554a25b498380fff224cd767f6b.jpg) | **CSV 파일 불러오기**<br>컴퓨터에 저장된 CSV 파일을 가져와 현재 데이터에 덮어씌울 수 있습니다.<br>utf-8로 저장된 CSV 파일만 정상적으로 가져올 수 있습니다.<br>**CSV 파일 내보내기**<br>메이커의 DataSet을 CSV 파일로 내보내어 컴퓨터에 저장할 수 있습니다. |

# 작성한 데이터 스크립트에서 불러오기

1. 먼저 위에 생성한 **NewDataSet**에 다음과 같이 데이터를 작성합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16596783003508b1add63e564405d9f00a099a8496934.png)
2. 데이터를 저장하고 새 스크립트 컴포넌트 **DataSet**을 추가합니다. ![newcomponent](https://mod-file.dn.nexoncdn.co.kr/bbs/16878457449028bebb7ed9b9141288f93dd176baca7c5.png)
3. **DataSet** 컴포넌트를 열고, `OnBeginPlay()` 함수를 추가합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16354715733367404d00c99aa45de86f5cc5cdfe101ec.png)
4. 다음과 같이 작성합니다.```
[server only]
void OnBeginPlay()
{
    --위에 생성한 데이터의 이름으로 데이터 테이블을 가져옵니다.
    local dataSet = _DataService:GetTable("NewDataSet")    
    --가져오려는 셀 데이터의 행, 열 번호를 매개 변수로 입력해 줍니다.
    local cellValue = dataSet:GetCell(3,2)               
    --셀 값을 콘솔창에 출력합니다.
    log("cellValue : "..tostring(cellValue))             
}
```
5. **Hierarchy - map01**의 콘텍스트 메뉴에서 **Add Component**를 클릭합니다.
6. **DataSet**을 검색하여 **DataSet** 컴포넌트를 추가합니다. ![8-3](https://mod-file.dn.nexoncdn.co.kr/bbs/1637219296068e486bb5b29b4418b9ef31c1647ad3323.png)
  > **더 알아보기** **_DataService:GetTable(string name)** 데이터의 이름으로 데이터 테이블을 리턴하는 함수입니다. 매개 변수로 데이터 이름을 넘겨줍니다.  **UserDataSet:GetCell(int row_1based, int col_based)** 데이터에서 특정 셀의 값을 문자열 타입으로 리턴합니다. 매개 변수로는 셀이 위치한 행, 열 번호를 입력해 줍니다. 행과 열은 1부터 시작합니다.
7. 플레이를 눌러 콘솔 창을 확인합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/165967905703060d30eec2560433d9a4922fefc9ed0db.png)

Update 2025-11-17 PM 08:14


# Data DB 저장 및 불러오기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=45%EB%B6%84&amp;color=green)

# 학습 과정 소개

게임 중 변경된 데이터 값을 GlobalDataStorage에 저장하고 불러오는 방법에 대해 알아봅니다.

# Data 생성 및 불러오기

GlobalDataStorage는 데이터의 저장과 불러오기를 할 수 있는 "보관소"라 할 수 있습니다. 우리는 데이터베이스에서 데이터를 저장하거나 불러올 일이 있을 때 이 "보관소"를 이용하면 됩니다. GlobalDataStorage는 `_DataStorageService:GetGlobalDataStorage`를 통해 생성하거나 불러오기가 가능합니다. GetGlobalDataStorage에 매개 변수로 넘겨지는 name 값에 따라 GlobalDataStorage를 새로 생성하여 리턴하거나 이미 해당 name 값이 등록되어 있는 경우 이전에 생성했던 GlobalDataStorage를 리턴합니다. GlobalDataStorage는 name 값에 따라 여러 개로 생성할 수 있기 때문에, 데이터의 속성이나 용도에 따라 GlobalDataStorage를 구분하여 저장할 수 있습니다. 추가로 `_DataStorageService:GetGlobalDataStorage`는 Server Only 함수이므로, 데이터 불러오기는 서버 공간에서 하는 것이 좋습니다.

```
void FunctionExample()
{
    --데이터를 저장하기 위해 MyData라는 GlobalDataStorage를 생성
    local MyData = _DataStorageService:GetGlobalDataStorage("MyData") 
}
```

# Data 저장하기

데이터의 저장은 GlobalDataStorage의 SetAsync를 활용해 할 수 있습니다. `SetAsync`는 매개 변수로 key와 value, 그리고 콜백 함수를 받는데, 저장할 데이터가 있으면 key와 value 매개 변수로 값을 넘겨 저장하게 됩니다. key는 매번 변경되어 저장되는 value 값을 불러오기 위한 용도로 사용됩니다. 따라서 key 값으로는 프로퍼티 명이나 혹은 저장된 value 값이 의미하는 것으로 입력해 주는 것이 좋습니다. 예를 들어 power라는 프로퍼티(또는 스탯)의 값을 저장한다면 key에는 "Power"를, value에는 Power의 값을 스트링으로 변환하여 입력합니다. 만일 이전에 같은 key 값으로 저장된 적이 있으면, 현재 값을 이전 값에 덮어씌우게 됩니다.

```
Property: 
[Sync]
number Power = 100
 
Method: 
[server only]
void SetData()
{
     local data = _DataStorageService:GetGlobalDataStorage("data") 
     data:SetAsync("Power", tostring(self.Power), nil) 
     --프로퍼티 Power의 값을 "Power"라는 키로 저장합니다. value값은 string으로 저장합니다.  
}
```

콜백 함수는 데이터가 저장되었을 때 호출되며, 매개 변수로는 errorCode와 key 값을 넘겨줍니다. SetAsync를 통한 데이터 저장은 비동기식으로 저장되기 때문에 SetAsync가 실행 중에 값이 저장되지 않습니다. 쉽게 말해 SetAsync는 값을 저장해달라고 요청을 보내는 것이고, 요청받은 DB는 이전에 들어온 요청들부터 순차적으로 저장을 하기 때문에 저장을 요청한 값이 실제로 어느 시점에 저장될지는 보장되지 않습니다. 이와 같은 경우에는 SetAsync 호출 뒤에 처리를 추가하는 것이 아니라, 콜백 함수를 매개 변수로 넘겨서 값이 저장된 시점에서의 처리를 진행하면 됩니다. 콜백 함수의 매개 변수는 errorcode와 key를 받도록 되어있으며, 콜백 함수 호출 시 내부에서 매개 변수로 값을 넘겨줍니다. 만일 콜백 함수를 등록하지 않으려면 nil을 넘겨줍니다.

```
Property: 
[Sync]
number Power = 100

Method: 
[server only]
void FunctionExample()
{
    -- SetAsync가 끝난 시점의 로그와 콜백 함수의 로그가 찍히는 시점을 비교해봅니다.
    -- 콜백 함수는 실제로 값이 저장되는 시점에 호출되므로, 콜백 함수의 로그가 SetAsync가 완료된 후 찍힌 로그보다 늦게 출력됩니다.
    local data = _DataStorageService:GetGlobalDataStorage("data")
    self.Power = 20
    local callBack = function (errorcode, key)
        log(key.."값이 저장되었다.")
    end
    data:SetAsync("Power", tostring(self.Power), callBack)
    log("SetAsync 완료")
}
```

# Data 불러오기

`GetAsync`는 데이터를 불러오기 위한 함수로 value 값 저장 시 함께 저장된 key 값을 통해 value 값을 가져옵니다. 이때 GetAsync도 SetAsync와 마찬가지로 key 값에 해당하는 value 값을 요청하게 되는데, 요청한 value 값을 함수 내에서 직접 리턴 받는 것이 아닌 GetAsync에 등록한 콜백 함수의 매개 변수로 key 값과 함께 들어옵니다. 이유는 GetAsync 역시 비동기식으로 동작을 하기 때문에 불러오기 요청을 보냈을 때 value 값을 언제 보내줄지는 보장되지 않기 때문입니다. 따라서 GetAsync는 value 값을 받았을 때의 처리가 꼭 필요하므로, SetAsync와는 달리 콜백 함수의 등록이 필요합니다.

```
Property: 
[Sync]
number Power = 0
 
Method: 
[server only]
void OnBeginPlay()
{
    local data = _DataStorageService:GetGlobalDataStorage("Data") 
    local callBack = function(errorcode, key, value) 
        if key == "Power" then 
            self.Power = tonumber(value)
        end 
    end 
    data:GetAsync("Power", callBack)
}
```

만일 key 값으로 저장된 value 값이 없을 때 불러오기를 하면 nil이 들어 옵니다. 따라서 불러오기 했을 때, value 값이 nil인지를 체크해서 저장되지 않은 값에 대한 처리를 할 수 있습니다.

```
Property: 
[Sync]
number Power = 0
 
Method: 
[server only]
void OnBeginPlay()
{
    local data = _DataStorageService:GetGlobalDataStorage("Data")
    local callBack = function(errorcode, key, value)
        --value가 nil일 경우의 처리를 추가합니다.
        if value == nil then value = 0 end
            if key == "Power" then
                self.Power = tonumber(value)
            end
    end
    data:GetAsync("Power", callBack)
}
```

# 데이터 스토리지 초기화

테스트 플레이 중 저장된 데이터는 플레이를 종료해도 사라지지 않고 유지되는데, 이에 대한 초기화는 Setting - 만들기 - 데이터 스토리지 설정에서 할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1660722032532384ede92e4bb4644a4a4acbeed74af65.png)

##### 참고 가이드

- [DataStorage 활용하기](/docs/?postId=692)

Update 2025-11-17 PM 08:14


# DataStorage 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=40%EB%B6%84&amp;color=green)

# 학습 과정 소개

이 가이드는 [Data DB 저장 및 불러오기](/docs/?postId=68)와 병행 학습을 권장합니다. "Data DB 저장 및 불러오기"에서는 간편하게 데이터를 생성, 저장, 불러오는 기능 위주로 살펴보았습니다. 이번 가이드에서는 DataStorageService의 다양한 함수를 통해 데이터를 증가시키거나, 페이지를 가지고 오는 등 크리에이터의 목적에 맞게 데이터를 활용하는 방법을 알아봅시다.

##### 참고 가이드

- [DataStorage 사용량 제한 알아보기](/docs?postId=1044)
- [DataStorage 사용량 제한 활용하기](/docs?postId=1045)

# DataStorage 종류와 소개

DataStorage는 4가지 종류로 구분되며 범위, 용도에 따라 크리에이터가 선택해 사용할 수 있습니다. DataStorage는 독립적이므로 식별자를 구분하지 않습니다. 만약 종류가 다른 'Data A' 데이터 스토리지가 2개 존재한다면, 별개의 데이터 스토리지로 취급됩니다. GlobalDataStorage, UserDataStorage, CreatorDataStorage는 string 타입의 값만 사용할 수 있고, SortableDataStorage는 int 타입의 값만 사용할 수 있으므로 사용 시 타입을 구분해야 합니다. CreatorDataStorage를 공동 제작에서 사용할 경우 공동 그룹 자체가 DataStorage를 가지고 있습니다.

> **Tip.** string 값이 아닌 다른 타입의 값을 사용하고 싶다면 `_UtilLogic:TableToString()`를 사용해 문자열로 변경해야 합니다.

4개의 데이터 스토리지마다 다양한 함수를 사용할 수 있습니다. 자세한 내용은 각각의 API Reference를 확인해보세요.

- **GlobalDataStorage** 하나의 월드에서 사용되는 데이터 스토리지로 다른 월드와 데이터가 공유되지 않습니다. 데이터 스토리지를 가져올 때 이름을 지정할 수 있고, 여러 개의 데이터 스토리지를 만들어 가질 수 있습니다. string 타입의 값만 사용할 수 있는 것이 특징입니다. [GlobalDataStorage](/apiReference?postId=708) API Reference를 참고하세요.
- **UserDataStorage** 유저당 하나의 UserDataStorage를 가질 수 있습니다. 하나의 월드에서 사용되는 데이터 스토리지로 다른 월드와 데이터가 공유되지 않습니다. userId를 이용해 데이터 스토리지를 가져오며, string 타입의 값만 사용할 수 있는 것이 특징입니다. 이 데이터 스토리지는 유저의 접속 시간을 저장하거나, 현재 가지고 있는 월드 내의 아이템 정보 등을 불러올 때 사용할 수 있습니다. [UserDataStorage](/apiReference?postId=716) API Reference를 참고하세요.
- **CreatorDataStorage** 크리에이터당 하나의 CreatorDataStorage를 가질 수 있습니다. 다른 월드와 데이터를 공유할 수 있습니다. string 타입의 값만 사용할 수 있는 것이 특징입니다. [CreatorDataStorage](/apiReference?postId=701) API Reference를 참고하세요.
- **SortableDataStorage** 하나의 월드에서 사용되는 데이터 스토리지로 다른 월드와 데이터가 공유되지 않습니다. 여러 개의 데이터 스토리지를 만들어 가질 수 있고, 이름을 지정할 수 있습니다. int 타입의 값만 사용할 수 있고 정렬, 증가 함수를 활용할 수 있는 것이 특징입니다. [SortableDataStorage](/apiReference?postId=710) API Reference를 참고하세요.

#### ErrorCode

DataStorage의 함수를 사용해 데이터를 저장, 삭제, 불러오기, 증가시키기, 순회 하기 등 다양한 데이터 관련 작업을 했을 때 해당 작업이 성공했는지 실패했는지를 에러 코드로 확인할 수 있습니다. 함수 요청이 성공했을 때의 에러 코드는 0입니다. 예를 들어, `local errorCode, successKeys = globalDataStorage:BatchSetAndWait(keyValues)` 와 같이 errorCode를 함께 작성해야 합니다.

| ErrorCode | Error Name | 설명 |
| --- | --- | --- |
| 0 | Ok | 요청이 완료되었습니다. |
| 1000000 | Canceled | 요청이 취소되었습니다. |
| 1000001 | InternalError | 내부 에러가 발생했습니다. |
| 1000002 | NotFound | 요소를 찾을 수 없어 에러가 발생했습니다. |
| 1000003 | BadRequest | 올바르지 않은 요청으로 에러가 발생했습니다. |
| 1000004 | TimedOut | 요청이 너무 오래 걸려 에러가 발생했습니다. |
| 1000005 | ResourceExhausted | 호출 횟수가 한도를 초과해 에러가 발생했습니다. |
| 1000006 | PartialFailure | 일부 요청 실패로 에러가 발생했습니다. |
| 2000000 | UpdateApiFailed | Update 요청 실패로 에러가 발생했습니다. |
| 2147483647 | Unknown | 알 수 없는 에러가 발생했습니다. |

#### Version

값이 가진 버전으로 Version을 활용해 원하는 시점의 값을 가져오거나, 롤백할 수 있습니다. 버전은 크리에이터가 명시적으로 지정할 수 있으며, 명시된 버전이 처음 생성되는 시점의 시간에 따라 우선순위가 정해집니다. Version은 명시하지 않을 경우 기본 버전으로 동작합니다. 이전에 저장된 버전이 하나라도 존재하는 경우에는 가장 마지막에 저장된 버전으로 동작합니다. 예를 들어, A 버전을 추가한 뒤, B 버전을 추가했는데 A 버전을 다시 추가한다면 최신 버전은 B 버전이 됩니다. 이미 A 버전은 생성된 이력이 남아있기 때문입니다.

#### Tag

Tag는 추가 식별자로 목록을 가져올 때 사용합니다. 태그를 사용해 원하는 그룹의 값을 선택 적으로 가져올 수도 있습니다. 태그 값은 지정하지 않을 수도 있지만, 이 경우 지정하지 않은 값에 대한 목록을 받을 수 없습니다. 태그는 그룹을 분리하지 않기 때문에 AKey 키값에 TagA 태그 값을 저장 한 뒤, AKey 키 값에 TagB 태그 값을 저장하면 태그는 TagB로 덮어써집니다.

# DataStorageKeyInfo

[DataStorageKeyInfo](/apiReference?postId=704)는 데이터에 더 많은 정보를 포함시키기 위한 객체입니다. DataStorageKeyInfo는 Key, Tag, Version을 지정할 수 있습니다.

# Storage Item

Item 접미사가 붙은 객체는 두 가지로 분류해 사용합니다. [DataStorageItem](/apiReference?postId=702)은 GlobalDataStorage, UserDataStorage, CreatorDataStorage에 저장된 데이터를 뜻합니다. KeyInfo와 Value가 포함되어 있으며 Value의 타입은 string입니다. [SortableDataStoragePages](/apiReference?postId=713)은 SortableDataStorage에 저장된 데이터를 뜻합니다. KeyInfo와 Value가 포함되어 있으며 Value의 타입은 int입니다.

# Storage Pages

[GlobalDataStoragePages](/apiReference?postId=709), [SortableDataStoragePages](/apiReference?postId=713), [UserDataStoragePages](/apiReference?postId=717), [DataStorageItemPages](/apiReference?postId=703), [SortableDataStorageItemPages](/apiReference?postId=712), [DataStorageVersionPages](/apiReference?postId=706)는 DataStorage와 관련된 정보를 조회하기 위한 객체입니다. 모든 Pages 객체는 IsLastPages 프로퍼티와 GetCurrentPageDatas(), MoveToNextPageAndWait() 함수를 제공합니다. 두 함수를 사용해 데이터 목록을 가져오거나, 다음 페이지로 이동시킬 수 있습니다. 자세한 내용은 각각의 API Reference를 참고하세요.

# 활용 예시

데이터 스토리지는 주로 DataStorageService를 함께 사용합니다. DataStorageService는 여러 데이터 스토리지에 접근하는 함수들을 제공합니다. 데이터를 저장, 삭제, 불러오기, 조회하기 등 데이터를 다양하게 활용할 수 있습니다. 데이터를 활용하는 함수는 데이터 스토리지 종류에 맞는 것으로 사용해야합니다.

## 데이터 저장하기

데이터를 저장하기 위해선 데이터 스토리지의 타입(종류)을 명확하게 구분해 사용해야 합니다. 데이터 스토리지의 타입마다 데이터를 저장하는 값의 타입이 다르기 때문입니다. Global, User, Creator 데이터 스토리지는 값을 문자열로만 저장할 수 있고, Sortable 데이터 스토리지는 값을 정수로만 저장할 수 있습니다. 예를 들어, "globalDS" 데이터 스토리지에 문자열 Grade로 A 값을 저장하고 "globalDS"라는 이름의 GlobalDataStorage에서 "Grade"라는 이름의 키 값을 통해 값을 가져올 때 "A" 라는 값이 반환됩니다.

#### GlobalDataStorage

```
[server only]
void SaveDataStorage()
{
    local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
    globalDataStorage:SetAndWait("Grade", "A")
}
```

#### SortableDataStorage

GetSortableDataStorage는 다른 타입을 사용하지만, 저장하는 방법은 위의 설명과 동일합니다.

```
[server only]
void SaveDataStorage()
{
    local sortableDataStorage = _DataStorageService:GetSortableDataStorage("sortableDS")
    sortableDataStorage:SetAndWait("Score", 90)
}
```

#### 더 많은 정보로 데이터 저장하기

DataStorage에 키 값과 더불어 Tag, Version을 지정해서 저장할 수 있습니다. 새로운 두 값을 저장하기 위해선 DataStorageKeyInfo를 활용해야 합니다. `DataStorageKeyInfo("key", "Tag", "Version1")`처럼 매개 변수로 key, Tag, Version을 사용할 수 있습니다. 만약 DataStorageKeyInfo를 Tag, Version 없이 사용한다면, SetAndWait, SetAsync류 함수를 사용해 데이터를 저장한 것과 동일합니다. 또한 SetByInfoAndWait, SetByInfoAsync 함수를 활용해 DataStorageKeyInfo를 활용한 저장이 가능합니다.

```
[server only]
void SaveDataStorage()
{
    local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
    local keyInfo = DataStorageKeyInfo("key", "Tag", "Version1") -- 이처럼 생성 시 각 값을 지정하거나, 빈 생성자로 생성 후 원하는 값만 채울 수도 있습니다.
    keyInfo = DataStorageKeyInfo()
    keyInfo.Key = "Key"
    keyInfo.Version = "Version1"
     
    globalDataStorage:SetByInfoAndWait(keyInfo, "Value")
}
```

## 데이터 불러오기

저장한 데이터를 불러올 때 데이터 스토리지 종류에 따라 GetGlobalDataStorage, GetUserDataStorage, GetCreatorStorage, GetSortableDataStorage를 활용합니다. 데이터를 가져오는 함수들은 Server Only이므로, 데이터 불러오기는 서버 공간에서 하는 것이 좋습니다.

#### GlobalDataStorage

GlobalDataStorage를 불러올 때는 반드시 이름을 지정해야 합니다. 크리에이터에 따라 종류가 다른 동명의 데이터 스토리지가 존재할 수 있기 때문입니다.

```
[server only]
void getDataStorage()
{
    local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalData")
}
```

#### UserDataStorage

UserDataStorage는 유저마다 가지는 고유한 데이터이므로, userId를 매개 변수로 넣어 데이터를 불러올 수 있습니다. 유저가 가진 데이터를 불러오는 것이므로 아래의 코드는 DefaultPlayer에 추가해야 합니다.

```
[server only]
void getDataStorage()
{
    local userId = self.Entity.Name
    local userDS = _DataStorageService:GetUserDataStorage(userId)
}
```

#### CreatorDataStorage

크리에이터당 하나의 데이터 스토리지를 가지고 있으므로 key를 지정하지 않아도 데이터를 불러올 수 있습니다.

```
[server only]
void getDataStorage()
{
    local creatorDS = _DataStorageService:GetCreatorDataStorage()
}
```

#### SortableDataStorage

```
[server only]
void getDataStorage()
{
    local sortableDS = _DataStorageService:GetSortableDataStorage("sortableDS")
}
```

## 데이터 가져오기

데이터를 가져올 때는 GetAndWait, GetAsync 함수를 사용합니다. GlobalDataStorage, UserDataStorage, CreatorDataStorage는 문자열 타입의 값만 가져올 수 있습니다. 만약 데이터를 저장할 때 `_UtilLogic:TableToString()` 함수를 사용해 데이터를 문자열로 변환했다면, 데이터를 가져올 때는 `_UtilLogic:StringToTable()` 함수를 사용해 기존 타입으로 변환하여 사용할 수 있습니다. SortableDataStorage는 정수 타입의 값만 가져올 수 있습니다.

> **Tip.** Async와 AndWait의 구분 DataStorageService의 함수 앞에 붙은 두 접미사로 해당 함수가 비동기, 동기로 수행되는지 알 수 있습니다. Async는 비동기로 수행되며, 함수의 작업이 완료될 때 callbackFunction 매개 변수로 전달된 함수가 호출됩니다. AndWait은 동기로 수행되며, 함수의 작업이 완료될 때까지 스크립트 실행을 중단합니다.

이름이 'globalDS' GlobalDataStorage를 'Grade'라는 이름의 키 값을 사용해 값을 가져오는 예제입니다.

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
local errorCode, grade = globalDataStorage:GetAndWait("Grade") -- 이전에 저장된 "A" 값 반환
```

#### 더 많은 정보로 데이터 가져오기

DataStorage의 값을 가져올 때 Version을 지정해 특정 버전의 값을 가져올 수 있습니다. 일반 데이터 가져오기와 달리 더 많은 정보로 값을 가져오려면 DataStorageKeyInfo로 객체를 생성한 뒤, 해당 객체를 인수로 지정해야 합니다. DataStorageKeyInfo는 Key, Tag, Version 값을 지정할 수 있습니다. 데이터를 가져올 때는 Tag 값은 지정되어 있더라도 사용하지 않고, 동작에 영향을 끼치지 않습니다. Version을 지정하지 않고, DataStorageKeyInfo를 사용하면 GetAndWait, GetAsync 함수를 사용해 값을 가져온 것과 동일하게 동작하며 가장 마지막에 저장된 버전(최신 버전)의 값을 가져오게 됩니다. GetByInfoAndWait, GetByInfoAsync 함수를 사용해 DataStorageKeyInfo를 활용한 가져오기가 가능합니다.

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
local setterKeyInfo = DataStorageKeyInfo()
setterKeyInfo.Key = "Key"
setterKeyInfo.Version = "Version1"
globalDataStorage:SetByInfoAndWait(setterKeyInfo, "Value1")
 
setterKeyInfo.Key = "Key"
setterKeyInfo.Version = "Version2"
globalDataStorage:SetByInfoAndWait(setterKeyInfo, "Value2")
 
local errorCode, value = globalDataStorage:GetAndWait("Key")
log(value) -- Value2 기본적으로 최신 버전의 값을 가져옵니다.
 
local getterKeyInfo = DataStorageKeyInfo()
getterKeyInfo.Key = "Key"
getterKeyInfo.Version = "Version1"
 
local errorCode, value = globalDataStorage:GetByInfoAndWait(getterKeyInfo)
log(value) -- Value1 원하는 특정 버전을 지정하여 가져올 수 있습니다.
```

## 데이터 증가시키기

SortableDataStorage는 IncreaseAndWait, IncreaseAsync 함수를 활용해 값을 증가시킬 수 있습니다. 각 함수의 delta 입력 값만큼 해당 매개 변수의 값이 증가하거나 감소합니다. 매개 변수로 들어온 값이 양수일 때는 증가, 음수일 때는 감소합니다. 만약, 증가시키고자 하는 값이 DataStorage에 존재하지 않는다면 기본값 0으로 저장하고 delta만큼 증가하게 됩니다. IncreaseAndWait 및 IncreaseAsync 함수는 에러 코드와 증가된 후의 값을 제공합니다.

DataStorage에 저장되지 않은 값을 IncreaseAndWait 함수로 생성, 증가하는 예제입니다.

```
local sortableDataStorage = _DataStorageService:GetSortableDataStorage("sortableDS")
 
-- sortableDataStorage에 "Key"는 저장된 이력이 없음을 가정합니다.
local errorCode, value = sortableDataStorage:IncreaseAndWait("Key", 5)
log(value) --  5, 기본 값인 0으로 생성 후 delta만큼 증가했기 때문에 5를 반환합니다.
 
local errorCode, value = sortableDataStorage:IncreaseAndWait("Key", 10)
log(value) -- 15, 기존에 저장된 값 5에 delta만큼 증가했기 때문에 15를 반환합니다.
```

## 데이터 제거하기

DeleteAndWait 또는 DeleteAsync 함수로 데이터를 제거할 수 있습니다.

이름이 "globalDS"인 GlobalDataStorage에서 "Grade"라는 이름의 키 값에 해당하는 값을 제거하는 예제입니다.

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
globalDataStorage:DeleteAndWait("Grade")
local errorCode, grade = globalDataStorage:GetAndWait("Grade") -- "Grade"는 제거되었기 때문에 유효한 값을 얻을 수 없습니다.
```

## 데이터 목록 가져오기

DataStorageService로 값이 저장된 DataStorage 목록을 조회할 수 있습니다. 목록을 조회하는 함수를 호출하면 해당 DataStorage의 목록을 조회할 수 있는 GlobalDataStoragePages, SortableDataStoragePages, UserDataStoragePages를 받을 수 있습니다. 다만 CreatorDataStorage의 경우 하나만 존재하기 때문에 목록을 가져오는 함수가 없습니다. 목록을 가져오는 함수는 AndWait과 Async를 제공하며 목적에 따라 원하는 형태를 사용할 수 있습니다.

```
local errorCode, globalDataStoragePages = _DataStorageService:GetGlobalDataStoragePagesAndWait()
```

```
local errorCode, sortableDataStoragePages = _DataStorageService:GetSortableDataStoragePagesAndWait()
```

```
local errorCode, userDataStoragePages = _DataStorageService:GetUserDataStoragePagesAndWait()
```

#### pages 순회하기

DataStorage 목록 또는 데이터 목록을 받을 때 페이지 단위로 목록을 조회할 수 있는 객체인 Pages 형태로 값을 받습니다.

```
local errorCode, globalDataStoragePages = _DataStorageService:GetGlobalDataStoragePagesAndWait()
 
while true do
 
    local globalDataStorages = globalDataStoragePages:GetCurrentPageDatas() --GetCurrentPageDatas()로 현재 페이지의 목록을 가져올 수 있습니다.
 
    for _, globalDataStorage in pairs(globalDataStorages) do
        log(globalDataStorage.Name)
    end
     
    if globalDataStoragePages.IsLastPage == true then --IsLastPage 프로퍼티를 통해 현재 페이지가 마지막 페이지인지 확인할 수 있습니다.
        break
    end
    globalDataStoragePages:MoveToNextPageAndWait() --MoveToNextPageAndWait()로 다음 페이지로 넘어갈 수 있습니다.
end
```

## 일괄 요청하기

Batch 접두사인 함수를 활용해 데이터 저장하기, 불러오기, 제거하기를 일괄 요청할 수 있습니다. `BatchSetAndWait()` 및 `BatchSetAsync()` 함수는 에러 코드와 요청이 성공한 값의 키 테이블을 제공합니다. 여러 개의 값을 저장하거나 가져오거나 제거할 때는 Batch 접두사가 붙은 함수를 활용해야 빠르게 많은 요청을 수행할 수 있습니다. Batch 접두사인 함수는 요청된 작업들 중 일부만 성공하는 상황이 발생할 수 있습니다. 그러므로 결괏값을 확인해 성공하지 않은 작업이 있다면 적절한 오류 처리가 필요합니다.

다음은 일괄적으로 데이터를 저장하는 예제입니다.

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
local keyValues = {}
keyValues["key1"] = "value1"
keyValues["key2"] = "value2"
keyValues["key3"] = "value3"
 
local errorCode, successKeys = globalDataStorage:BatchSetAndWait(keyValues)
```

## 원자적으로 일괄 요청하기

Transact 접두사인 함수를 활용해 데이터 저장하기, 불러오기, 제거하기를 원자적으로 일괄 요청할 수 있습니다. 만약 함수 호출에 포함된 모든 작업 중 하나라도 실패한다면, 함수 호출은 실패합니다. 한 번에 Key를 최대 20개까지 조작할 수 있습니다. 한 번에 전달된 요청들이 모두 성공하지 않으면 모두 실패 처리하고, 요청 이전의 데이터를 유지합니다. 그러므로 오류 처리 관련 코드를 간소화할 수 있습니다. 그러나 트랜잭션 보장을 위해 내부적으로 복잡한 처리 과정이 진행됩니다. credit 또한 Batch 함수에 비해 2배로 소모됩니다.

> **더 알아보기** 트랜잭션(Transaction)은 원자적으로 처리되어야 하는 작업의 단위를 의미합니다.

다음은 모든 작업이 성공할 경우 일괄적으로 데이터를 저장하는 예제입니다.

```
local transactDs = _DataStorageService:GetGlobalDataStorage(self.TransactionTestDsName)
local t1 = {}
t1["key1-1"] = "value1"
t1["key1-2"] = "value2"
t1["key1-3"] = "value3"
​
local t2 = {}
t2["key2-1"] = "value1"
t2["key2-2"] = "value2"
t2["key2-3"] = "value3"
​
local callback = function (code, keys)
    if code ~= 0 then
        error("! error. TransactSetAsync. code:"..tostring(code))
        return
    end
     
    for i, key in ipairs(keys)  do
        log("["..tostring(i).."] "..key)       
    end
end
​
-- ~AndWait
local code1, resultKeys1 = transactDs:TransactSetAndWait(t1)
for i, key in ipairs(resultKeys1) do
    log("["..tostring(i).."] "..key)
end
​
-- ~Async
transactDs:TransactSetAsync(t2, callback)
```

다음은 모든 작업이 성공할 경우 일괄적으로 데이터를 제거하는 예제입니다.

```
log("# Test_DataStorage_TransactDelete")
local transactDs = _DataStorageService:GetGlobalDataStorage(self.TransactionTestDsName)
local keys1 = {"key1-1", "key1-2", "key1-3"}
local keys2 = {"key2-1", "key2-2", "key2-3"}
local code1, resultKeys1 = transactDs:TransactDeleteAndWait(keys1)
log("code1: "..tostring(code1))
for _, item in pairs(resultKeys1) do
    log("- deleted key: "..item)
end
​
local callback = function (code, keys)
    if code ~= 0 then
        error("! error. TransactDeleteAsync. code:"..tostring(code))
        return
    end
     
    for i, key in ipairs(keys)  do
        log("- deleted key: "..key)
    end
end
​
transactDs:TransactDeleteAsync(keys2, callback)
```

## 데이터 정렬하기

SortableDataStorage는 GetSortedAndWait 및 GetSortedAsync 함수로 데이터를 정렬할 수 있습니다. 데이터를 정렬하여 가져올 때 오름차순으로 정렬할지 내림차순으로 정렬할지 지정할 수 있으며 최솟값과 최댓값을 지정하여 원하는 범위의 값 목록을 정렬하여 가져올 수 있습니다.

SortableDataStorage에 저장된 데이터를 정렬해 가져오는 예제입니다.

```
local sortableDataStorage = _DataStorageService:GetSortableDataStorage("sortableDS")
 
-- 최솟값 0, 최댓값 100 사이에 있는 값들만 정렬하여 가져옵니다.
local errorCode, pages = sortableDataStorage:GetSortedAndWait(SortDirection.Ascending, 0, 100)
 
while true do
 
    local items = pages:GetCurrentPageDatas()
    for _, item in pairs(items) do
        log(item.KeyInfo.Key)
        log(item.Value)
    end
 
    if pages.IsLastPage == true then
        break
    end
    pages:MoveToNextPageAndWait()
end
```

## 버전 관리하기

DataStorage의 값을 저장할 때 DataStorageKeyInfo를 활용하여 Version을 지정했다면 버전 관리를 할 수 있습니다. 기존 버전을 덮어쓰는 대신 새로운 버전을 만들 수 있고 최신 버전이 유효하지 않은 경우 과거 버전으로 덮어 씌울 수도 있습니다. 버전 목록을 반환하는 함수로 존재하는 버전의 목록을 확인할 수 있습니다.

#### 새로운 version 만들기

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
local keyInfo = DataStorageKeyInfo()
keyInfo.Key = "Key"
keyInfo.Version = "Version1"
 
globalDataStorage:SetByInfoAndWait(keyInfo, "Value")
 
-- 기존 버전의 "Value" 값을 덮어 쓰는 대신 새로운 버전을 만들어 저장합니다.
keyInfo.Key = "Key"
keyInfo.Version = "Version2"
globalDataStorage:SetByInfoAndWait(keyInfo, "Value2")
 
-- "Value" 값은 덮어 씌워진게 아니기 때문에 아직 유효하며 Version1을 지정하여 "Value" 값을 가져올 수 있습니다.
keyInfo.Key = "Key"
keyInfo.Version = "Version1"
local errorCode, value = globalDataStorage:GetByInfoAndWait(keyInfo)
```

#### 과거 version으로 돌아가기

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
keyInfo = DataStorageKeyInfo()
keyInfo.Key = "Key"
keyInfo.Version = "Version1"
 
globalDataStorage:SetByInfoAndWait(keyInfo, "Value")
 
-- 기존 버전의 "Value" 값을 덮어 쓰는 대신 새로운 버전을 만들어 저장합니다.
keyInfo.Key = "Key"
keyInfo.Version = "Version2"
globalDataStorage:SetByInfoAndWait(keyInfo, "Value2")
 
-- "Value" 값은 덮어 씌워진게 아니기 때문에 아직 유효하며 Version1을 지정하여 "Value" 값을 가져올 수 있습니다.
keyInfo.Key = "Key"
keyInfo.Version = "Version1"
local errorCode, oldValue = globalDataStorage:GetByInfoAndWait(keyInfo)
 
-- 과거 버전의 값을 가져와 최신 버전에 덮어씁니다. 이후 GetAndWait 함수를 호출하면 "Value2" 값이 아닌 "Value" 값이 반환됩니다.
keyInfo.Key = "Key"
keyInfo.Version = "Version2"
globalDataStorage:SetByInfoAndWait(keyInfo, oldValue)
```

#### version 목록 가져오기

```
local globalDataStorage = _DataStorageService:GetGlobalDataStorage("globalDS")
 
-- 4월 20일부터 5월 20일까지의 버전 목록만 가져옵니다.
local minDate = DateTime(2022, 4, 20)
local maxDate = DateTime(2022, 5, 20)
 
local errorCode, pages = globalDataStorage:GetVersionsAndWait("Key", SortDirection.Ascending, minDate, maxDate)
 
while true do
 
    local versions = pages:GetCurrentPageDatas()
 
    for _, versionInfo in pairs(versions) do
        log(versionInfo.CreateTime) -- 생성 시점의 시간을 알 수 있습니다.
        log(versionInfo.Version) -- 사용자가 지정한 Version을 알 수 있습니다.
    end
 
    if pages.IsLastPage == true then
        break
    end
    pages:MoveToNextPageAndWait()
end
```

Update 2025-11-17 PM 08:14


# DataStorage 사용량 제한 알아보기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

##### **DataStorage 사용량 제한은 추후 도입 예정으로, 현재는 크리티컬 리포트에서만 사용량 초과 여부를 알 수 있습니다.**

# 학습 과정 소개

DataStorage를 기준치 이상으로 사용할 경우 크리티컬 리포트에 기록됩니다. 향후 기준치 이상 사용할 수 없도록 제한이 도입될 예정입니다. 크리에이터는 데이터 사용량을 사전에 점검하기를 권장합니다. 출시된 월드에서만 DataStorage 사용량이 제한됩니다.

# 데이터 요청과 Credit 소모

데이터 사용량은 크리에이터가 제작한 월드의 월드 인스턴스 전체를 한 번에 계산해 적용됩니다. DataStorage류의 함수는 기본적으로 **요청(Request) 1개 당 1개의 Credit**을 사용합니다. 그러나 요청 1개의 크기가 크면 여러 개의 Credit을 사용할 수도 있습니다. 또한 Credit 소모 기준은 **FunctionGroup**에 따라 다릅니다. Credit에 대해 좀 더 알고 싶다면 [DataStorage 사용량 제한 활용하기](/docs?postId=1045)를 참고하세요.

# FunctionGroup

FunctionGroup은 Credit을 공유하는 함수를 구분하는 기준입니다.

#### List DataStorage

DataStorage의 목록을 가져오는 함수들의 그룹입니다. DataStorageService의 GetGlobalDataStoragePagesAndWait, GetUserDataStoragePagesAndWait 등이 있습니다.

#### Delete DataStorage

DataStorage를 제거하는 함수들의 그룹입니다. DataStorageService의 DeleteGlobalDataStorageAndWait, DeleteUserDataStorageAndWait 등이 있습니다.

#### List Sorted

정렬된 값 목록을 가져오는 함수들의 그룹입니다. SortableDataStorage의 GetSortedAndWait, GetPagesAndWait 등이 있습니다.

#### List

목록을 가져오는 함수들의 그룹입니다. GlobalDataStorage의 GetPagesAndWait, GetVersionsAndWait 등이 있습니다.

#### Delete

값을 제거하는 함수들의 그룹입니다. GlobalDataStorage의 DeleteAndWait, BatchDeleteAndWait 등이 있습니다.

#### Get

값을 가져오는 함수들의 그룹입니다. GlobalDataStorage의 GetAndWait, BatchGetAndWait 등이 있습니다.

#### Set

값을 저장하는 함수들의 그룹입니다. GlobalDataStorage의 SetAndWait, UpdateAndWait, SortableDataStorage의 IncreaseAndWait 등이 있습니다.

#### None

데이터베이스에 요청하지 않는 함수는 None입니다.

# FunctionGroup 안내

| Type | Functions | FunctionGroup |
| --- | --- | --- |
| DataStorageService | DeleteCreatorDataStorageAndWait | Delete DataStorage |
| DeleteCreatorDataStorageAsync | Delete DataStorage |
| DeleteGlobalDataStorageAndWait | Delete DataStorage |
| DeleteGlobalDataStorageAsync | Delete DataStorage |
| DeleteSortableDataStorageAndWait | Delete DataStorage |
| DeleteSortableDataStorageAsync | Delete DataStorage |
| DeleteUserDataStorageAndWait | Delete DataStorage |
| DeleteUserDataStorageAsync | Delete DataStorage |
| GetAndWait | Get |
| GetAsync | Get |
| GetCreatorDataStorage | None |
| GetDataStorage | None |
| GetGlobalDataStorage | None |
| GetGlobalDataStoragePagesAndWait | List DataStorage |
| GetGlobalDataStoragePagesAsync | List DataStorage |
| GetSortableDataStorage | None |
| GetSortableDataStoragePagesAndWait | List DataStorage |
| GetSortableDataStoragePagesAsync | List DataStorage |
| GetUserDataStorage | None |
| GetUserDataStoragePagesAndWait | List DataStorage |
| GetUserDataStoragePagesAsync | List DataStorage |
| SetAndWait | Set |
| SetAsync | Set |
| DataStorage 공통 | BatchDeleteAndWait | Delete |
| BatchDeleteAsync | Delete |
| BatchGetAndWait | Get |
| BatchGetAsync | Get |
| BatchGetByInfoAndWait | Get |
| BatchGetByInfoAsync | Get |
| BatchSetAndWait | Set |
| BatchSetAsync | Set |
| BatchSetByInfoAndWait | Set |
| BatchSetByInfoAsync | Set |
| DeleteAndWait | Delete |
| DeleteAsync | Delete |
| GetAndWait | Get |
| GetAsync | Get |
| GetByInfoAndWait | Get |
| GetByInfoAsync | Get |
| GetVersionsAndWait | List |
| GetVersionsAsync | List |
| SetAndWait | Set |
| SetAsync | Set |
| SetByInfoAndWait | Set |
| SetByInfoAsync | Set |
| TransactSetAsync | Set |
| TransactSetAndWait | Set |
| TransactSetByInfoAsync | Set |
| TransactSetByInfoAndWait | Set |
| TransactDeleteAsync | Delete |
| TransactDeleteAndWait | Delete |
| GlobalDataStorage, UserDataStorage, CreatorDataStorage | UpdateAndWait | Set |
| UpdateAsync | Set |
| UpdateByInfoAndWait | Set |
| UpdateByInfoAsync | Set |
| GetPagesAndWait | List |
| GetPagesAsync | List |
| SortableDataStorage | GetSortedAndWait | List Sorted |
| GetSortedAsync | List Sorted |
| IncreaseAndWait | Set |
| IncreaseAsync | Set |
| GetPagesAndWait | List Sorted |
| GetPagesAsync | List Sorted |

Update 2025-11-17 PM 08:14


# DataStorage 사용량 제한 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

##### **DataStorage 사용량 제한은 추후 도입 예정으로, 현재는 크리티컬 리포트에서만 사용량 초과 여부를 알 수 있습니다.**

# 학습 과정 소개

DataStorage를 사용할 때는 제한 용량과 Credit 제한을 확인하고 용량에 맞게 사용해야 합니다. DataSotorage 사용량 제한에 관해 알아보겠습니다.

# DataStorage 제한 용량

DataStorage의 용량 제한은 다음과 같습니다. 문자열 값 크기는 UTF-8 인코딩을 통해 Byte 배열로 변환했을 때의 Byte 수로 계산됩니다.

| 구분 | 제한 용량 |
| --- | --- |
| DataStorage name | 1 ~ 64 byte |
| DataStorage key | 1 ~ 100 byte |
| DataStorage tag | 0 ~ 64 byte |
| DataStorage version | 0 ~ 64 byte |
| update | 0 ~ 50,000 byte |
| set | 0 ~ 300,000 byte |

# Credit

Credit이란 데이터베이스 요청 수 제한을 위해 계산되는 단위를 의미합니다. Credit의 최솟값은 1입니다. Credit은 실제 데이터베이스에 요청하는 경우에만 소모되는 특징이 있습니다. FunctionGroup별로 매분 지급되는 Credit 수, 누적되는 Credit 수, 데이터베이스 요청 시 소모되는 Credit 수가 다릅니다. 함수별로 속하는 FunctionGroup은 [DataStorage 사용량 제한 알아보기](/docs?postId=1044)에서 확인할 수 있습니다.

| FunctionGroup | 분당 지급되는 Credit | 최대 누적 가능한 Credit | 요청 시 소모되는 Credit |
| --- | --- | --- | --- |
| List DataStorage | 10 + (접속자 수 * 2) | 분당 지급되는 Credit * 2 | 1 |
| Delete DataStorage | 10 + (접속자 수 * 2) | 분당 지급되는 Credit * 2 | 1 |
| List Sorted | 50 + (접속자 수 * 2) | 분당 지급되는 Credit * 2 | 1 |
| List | 10 + (접속자 수 * 2) | 분당 지급되는 Credit * 2 | 1 |
| Delete | 50 + (접속자 수 * 2) | 분당 지급되는 Credit * 2 | 4,000byte당 1 |
| Get | 100 + (접속자 수 * 10) | 분당 지급되는 Credit * 2 | 4,000byte당 1 |
| Set | 100 + (접속자 수 * 10) | 분당 지급되는 Credit * 2 | 4,000byte당 1 |

#### Byte 크기에 따른 Credit 소모

**0에서 4000 Byte**는 1 Credit을 사용합니다. 또한 존재하지 않는 값을 조회했을 때도 Credit이 소모됩니다. 문자열 값 크기는 UTF-8 인코딩을 통해 Byte 배열로 변환했을 때의 Byte 수로 계산됩니다.

> **Tip.** **Key, Tag, Version** 크기는 Credit에 영향을 끼치지 않습니다.

#### batch 계열 함수의 Credit 소모

BatchGetAsync 같은 Batch 계열 함수는 여러 키를 한 번에 접근할 수 있습니다. 이 함수들은 요청하는 **키 수에 따라 Credit 소모 개수**가 정해집니다. 두 값을 요청한 경우라도, 요청한 Byte 수에 따라 소모되는 Credit 수가 달라집니다. 예를 들어 요청한 두 값의 크기가 각 2,000 Byte라면 총 2 Credit을 소모합니다. 반면에, 두 값의 크기가 각 4,000 Byte, 4,500 Byte라면 4,000Byte인 값은 1 Credit을 소모하고 4,500 Byte인 값은 2 Credit을 소모합니다. Batch 계열 함수를 사용할 때는 **Credit이 소모되는 시점**을 염두에 두어야 합니다. Credit은 데이터베이스에 실제로 요청하는 시점에 소모됩니다. 만약 `BatchGetAndWait()` 함수로 50개의 Key를 넘겼다면 호출 한 번에 50개 값에 대한 Credit이 소모되지 않습니다. 호출 즉시에는 25개 값만큼의 Credit이 소모되고, 이후 반환되는 Page를 통해 `MoveToNextPageAndWait()`를 통해 다음 Page로 이동할 때 나머지 25개 값만큼의 Credit이 소모됩니다.

> **Tip.** `BatchSetAndWait()` 함수는 넘긴 키 개수만큼을 곧바로 요청합니다.

#### Transact 계열 함수의 Credit 소모

Transact 계열 함수는 batch 계열 함수와 비슷하게 동작합니다. 다만 트랜잭션 보장을 위해 더 많은 처리가 필요하므로 batch 계열 함수보다 **2배의 Credit**을 소모합니다.

#### Credit을 소모하지 않는 함수

어떤 함수를 사용했지만, 이미 다른 함수가 Page를 불러왔을 때는 Credit을 소모하지 않습니다. 대표적으로 `MoveToNextPageAndWait()`, `LoadNextPageAndWait()` 함수는 상황에 따라 Credit을 소모하지 않습니다. 예를 들어, GlobalDataStoragePages의 `LoadNextPageAndWait()` 함수를 사용해 다음 Page를 미리 불러오고 `MoveToNextPageAndWait()`함수를 호출하면 이미 Page를 불러왔기 때문에 데이터베이스에 요청하지 않습니다. 그러므로 Credit은 `LoadNextPageAndWait()`함수를 호출할 때만 소모하게 됩니다.

Update 2025-11-17 PM 08:14


# 기본 개념

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

아바타의 구성과 로직을 알아봅시다. 개념을 이해하면 아래 참고 가이드를 따라 각종 아이템을 제작하여 착용할 수 있습니다. 아바타 아이템은 Adobe Photoshop를 사용해 제작이 가능하며 제작 시트는 psd 파일로 제공됩니다.

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)
- [신발 만들기](/docs?postId=583)
- [헤어 만들기](/docs?postId=657)
- [모자 만들기](/docs?postId=592)
- [한벌옷 만들기](/docs/?postId=1042)

# 아바타의 유형과 구성

- 성별을 구분 짓지 않은 하나의 아바타 구성을 사용합니다.![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1645599045163ccc2935448284dc8a4bf416dddb0dc0f.gif)
- 피부 색상은 18종입니다.![02](https://mod-file.dn.nexoncdn.co.kr/bbs/164559906683366b8775726e848979b8ae26b139185bf.gif)
- 아바타는 머리(Head), 보디(Body), 팔(Arm)로 구분됩니다.![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16455990991107dd9fc17151646c3b43934bbea7b7e48.gif) ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/16455991096109a166aa7d8044e5997faa0ff2873995b.png)
- 아이템은 아바타 구분에 맞춰 머리, 보디, 팔로 제작됩니다. 레이어에 맞춰 그려주며 다리는 앞뒤 레이어 개념이 없으므로 레이어 한 장에 그려줍니다.![05](https://mod-file.dn.nexoncdn.co.kr/bbs/164559923490369fb6e7547894507b12b0f6c9508a1c8.gif)

# 아바타 의상

한 벌 의상과 일반 의상 모두 시트 작업으로 진행됩니다. 시트는 psd 파일로 제공되며 레이어가 구분되어 있습니다. [하의 만들기](/docs?postId=584), [상의 만들기](/docs?postId=586)를 참고하세요.![06](https://mod-file.dn.nexoncdn.co.kr/bbs/16455992831750c17309e8c164dd582a5a3e7de378694.gif)

#### 제작 시트 안내

아이템 제작은 제작 전용 파일을 사용해야 합니다. 각 파일은 용도에 맞게 레이어로 구분되어 있습니다. 회색 레이어는 가이드용으로 제공하고, 크리에이터의 실제 작업은 **노란색 레이어**에서 이뤄져야 합니다.

아바타를 구성하는 이미지는 몇 개의 층으로 이루어져 있습니다. 아바타의 구성은 머리, 보디, 팔로 구분되며 팔은 머리를 기준으로 레이어가 더 세분됩니다. 몸이 옷보다 아래에 있고, 옷 위에는 방패가, 방패 위에는 무기가 위치하여야 하므로 이미지를 분리해 놓았습니다. 이렇게 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다. 이 레이어의 이름을 수정하면 아이템 제작을 할 수 없습니다. 각 시트는 zmap의 정보를 갖고 있으며 레이어 이름, 숫자, 위치가 고정된 내부 규칙이 적용되어 있기 때문에 마찬가지로 레이어 이름을 수정하면 안 됩니다.

샘플 시트와 레이어의 구성은 아래와 같습니다. ![26](https://mod-file.dn.nexoncdn.co.kr/bbs/16456098529897d1257963fee4195847d88ea72c39bf9.png)![25](https://mod-file.dn.nexoncdn.co.kr/bbs/1645609844102aade2f41f8144232b2d35fd5318a6bef.png)

# 아바타 얼굴

- 다양한 피부색에 맞는 얼굴 성형이 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1645608336694ccb878c41f2c4e409756ebf0fb5feb31.gif)
- 다양한 피부색과 어울리는 얼굴 성형을 만들기 위해선 검은색(또는 진한 색)으로 선을 그려준 후 제일 바깥쪽 라인과 쌍꺼풀 라인, 흰자 부분은 투명도를 체크 후 지우개로 지워줍니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/164560843607021a6e8aec7ec45d3bc4162389238585b.gif)![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1645608450343ea9e7a33235f48e08b7fded4924960f4.gif)

# 아바타 헤어

헤어는 긴 헤어, 짧은 헤어 두 가지로 구분됩니다. 그림자는 헤어 모양에 맞춰 #6D5031 색상으로 그려주고, 투명도 30%를 적용하면 모든 피부톤에 어울립니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/16456096534270fee743409094561820666e6aed2fe56.gif)![23](https://mod-file.dn.nexoncdn.co.kr/bbs/1645609664691b243cbfb8cb44544972f03fac255bcbf.gif)![24](https://mod-file.dn.nexoncdn.co.kr/bbs/1645609675823dabb15759fd0454a9b75286fee4d5864.gif) 눌린 헤어에는 아래 이미지와 같이 다양한 모자를 씌울 수 있습니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/164560961847630710d0ba78a48119c7793a2212f3f4e.gif)![20](https://mod-file.dn.nexoncdn.co.kr/bbs/1645609600856ad0518160caa4e01a1b00d34d77b7bea.gif)

#### 긴 헤어

앞의 Layer는 총 6종이 필요합니다. 어깨 아래로 내려오는 긴 헤어는 엎드린 동작을 위한 추가 이미지가 필요합니다.

- 필요한 Layer: **앞, 뒤, 눌린 헤어, 그림자, 엎드린 헤어, 엎드린 상태에서 눌린 헤어** ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16456085782149a8f92aac0e748d4a07a86f36fa5e5e8.png)

#### 짧은 헤어

앞의 Layer는 총 3종이 필요합니다. 짧은 헤어의 경우는 엎드린 동작에서 기본 헤어와 동일하게 사용합니다

- 필요한 Layer: **앞, 눌린 헤어, 그림자** ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/164560862626678907376b1fa40b59cee3536e0f68fec.png)

# 아바타 모자

모자는 앞모습을 기준으로 두 가지로 분류되며, 동작에 맞추는 기타 모자가 추가로 존재합니다.

- 헤어 앞에 1개의 레이어만 있는 모자 ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16456086818980350155566144780905e8e4b0ff45a26.gif)
- 헤어 앞뒤에 2개의 레이어가 있는 모자 ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1645608696039146c8981c7fa4bdfa258b97f390c0965.gif)
- 동작에 맞춰 시트를 활용하여 만드는 모자 ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16456087096046eb7438793364ede8186282bdca75a61.gif)

Update 2025-11-20 PM 02:03


# 아바타 아이템 등록하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서 크리에이터는 직접 아바타 아이템을 제작할 수 있습니다. 아바타 아이템을 만들기 위해서는 **제작**과 **등록** 단계를 진행해야 합니다. 이번 가이드에서는 등록 과정에 대한 내용을 설명하며 제작 과정에 대해서는 아래 가이드를 참고 부탁드립니다.

##### 참고 가이드

- [기본 개념](/docs?postId=588)
- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)
- [신발 만들기](/docs?postId=583)
- [헤어 만들기](/docs?postId=657)
- [모자 만들기](/docs?postId=592)

등록 가능한 파츠는 헤어, 모자, 망토, 상의, 장갑, 하의, 신발입니다. 파츠별 등록 절차는 유사하므로 이번 가이드는 상의를 등록하는 과정을 예시로 진행하겠습니다. 아래는 예시에서 사용할 리소스 파일입니다.

# 아바타 아이템 등록하기

1. **[만들기]** 메뉴를 클릭 후 상단의 **아바타** 탭을 클릭합니다. ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1669019254358e2b78bc004cb49e78821286942fca062.png)
2. **Avatar_Coat.psd** 파일을 다운로드받은 후 **아바타** 탭에서 **[새로 만들기]** 버튼을 클릭합니다. (크리에이터가 직접 제작한 아바타 아이템 PSD 파일이 있다면 해당 파일로 진행하면 됩니다.) ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1669019306792d3d8ff661e504b3e96c0729b0fc12f97.png)
3. **[PSD 파일 선택]** 버튼을 눌러 다운로드받은 PSD 파일을 선택합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/166910417912802c0ed4f36b84aacae46ce794631687a.png)
4. PSD 파일이 올라가면 미리보기를 확인할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16786871851811f83988980cb4074a502fb157a4e4ec1.png)
5. 크리에이터의 의도대로 아이템이 제작되었는지 확인합니다.
  - 아이템이 아바타 동작 별로 정상적으로 보이는지 확인합니다.
    - 동작 목록에서 각 **ActionName**을 클릭한 후 확인할 수 있습니다.
    - **AutoPlay**를 클릭하면 특정 프레임을 지정하여 아바타 프리뷰를 확인할 수 있습니다.![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1678687227625a70c35df565d4377a7962ab9c5a23649.png)
  - **[내 아바타 적용]** 및 **[월드 배경 적용]**
    - **[내 아바타 적용]** 버튼을 클릭해 제작 중인 아이템을 착용한 내 아바타의 모습을 미리보기 합니다.
    - **[월드 배경 적용]** 버튼을 클릭해 실제 게임에서 어떻게 보일지 간단하게 확인합니다.![6](https://mod-file.dn.nexoncdn.co.kr/bbs/167868732738290f6f4c876e9423aac23d2df0d797a75.png)
6. 아이템 이름과 설명을 작성합니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/16786876275693ad03e7fe940425388c01fc3648e7bb6.png)
  > **Tip.** 아이템의 섬네일 이미지는 업로드한 PSD 파일을 토대로 자동으로 생성됩니다. 현재 설정된 아바타 애니메이션의 동작 및 프레임을 기준으로 썸네일을 설정할 수 있습니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1678687664096c56cff3d738e43e58b36ede3e8a9e96a.png)
7. 이제 **AvatarItem Editor**에서 **[업로드]** 버튼을 클릭합니다. 완료되면 아바타 목록에서 등록한 아이템을 확인할 수 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1669106021060a037a278b90d49da921b7cf3c01a1f5d.png)

# 리소스 저장소에서 등록 방법

메이커의 리소스 저장소에서도 아바타 아이템을 등록할 수 있습니다. 상단 내비게이션 메뉴에서 **Panels - Resource Storage**를 클릭해 리소스 저장소를 엽니다. **내 리소스 - avatarItem - coat**로 들어가면 앞서 등록했던 아이템을 확인할 수 있습니다. 상단의 ![add](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/icon_layer_add.png) 버튼을 클릭하면 리소스 저장소에서도 아바타를 등록할 수 있습니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/166916511337367055347068e4aeeb11321444a13ac81.png)

# 아바타 아이템 수정과 삭제

아바타 아이템 콘텍스트 메뉴를 살펴봅시다.

- **Rename**: 리소스의 이름을 변경합니다.
- **Delete** : 리소스를 삭제합니다.
- **Copy RUID**: 리소스의 RUID를 클립보드에 저장합니다.
- **Detail Info**: 리소스의 세부 정보를 볼 수 있는 팝업창을 출력합니다. 리소스 아이콘을 더블클릭하여 동일한 동작을 진행할 수 있습니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1656554906953f6d2eb6287874ecfa49a2132ad6e31af.png)

리소스 아이콘을 더블클릭하거나 **Detail Info**를 클릭하면 세부 정보를 확인할 수 있습니다. 또한 리소스 이름과 설명도 변경할 수 있습니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1669121019983e70960598be64859807a18e31bd968fd.png)

위의 **세부 정보** 창에서 화살표로 표시된 부분의 **[파일 열기]** 버튼을 클릭하면 **AvatarItem Editor** 창이 열리고 PSD 파일 교체 등을 할 수 있습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1678687824650bafee251dfde44e69a82506565e87ef9.png)

# 아바타 아이템 착용 방법

크리에이터가 제작한 월드에서 아바타 아이템을 착용할 수 있습니다.

1. **DefaultPlayer**의 **CostumeManagerComponent**에서 착용하고자 하는 아바타 아이템의 프로퍼티를 클릭합니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16456053556420f1ccdd1896d45a2a25427d572cbfecf.png)
2. 해당 버튼을 클릭하면 **Resource Picker**가 열리고 **내 리소스**에 등록한 아바타 아이템이 나옵니다. 원하는 아바타 아이템을 클릭합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1681088510460830119711df64e69a6220ce40c3f11e3.png)
3. 프로퍼티를 확인해보면 다음과 같이 RUID 값이 입력되어 있음을 확인할 수 있습니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16456054206924cdf9652c0614d239739b4b10e9b8c3a.png)

> **더 알아보기** 직접 제작한 아바타 아이템을 상품으로 등록하면 크리에이터도 해당 상품을 구입해 입을 수 있고, 다른 유저에게도 판매할 수 있습니다. 아바타 아이템을 판매하려면 [아바타 상품 만들기](/docs/?postId=830) 가이드를 참고해 봅시다.

Update 2025-12-02 PM 03:52


# 망토 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

망토 제작 방법을 알아봅시다. 기본 망토에 컬러를 바꾸고 그 위에 그림을 그릴 수 있습니다. 망토 대신 풍선을 제작할 수도 있습니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 3개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

#### 회색 레이어

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cape**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:Sr**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_summary 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid**: 그리드 선 기준으로 아이템을 제작합니다. 초록색 선 안에서만 작업을 해야 합니다. ![cape01](https://mod-file.dn.nexoncdn.co.kr/bbs/1645511035444e8349fcd53a8498eafb9e14c0a5e0fe0.png)

#### 노란색 레이어

노란색 레이어에는 크리에이터가 제작할 망토를 그릴 수 있습니다.

- **edithere:cape_capeOverHead_10**: 망토의 바깥쪽 부분 레이어입니다.
- **edithere:cape_cape_48**: 엎드렸을 때 보이는 망토 레이어입니다.
- **edithere:cape_capeBelowBody_83**: 망토의 안쪽 부분 레이어입니다.

![cape02](https://mod-file.dn.nexoncdn.co.kr/bbs/16455110548840d829341a51d485097d7258e74e7b2ba.png)

# 제작하기

크리에이터가 구상한 독특한 망토를 제작해봅시다. 제작 중 망토의 동작하는 애니메이션을 확인하고 싶다면 [등록하기](/docs?postId=590)를 이용해 미리 확인할 수 있습니다.

#### 무늬 그리기

1. **edithere:cape_capeOverHead_10**를 선택합니다. ![cape14](https://mod-file.dn.nexoncdn.co.kr/bbs/1646030772333162edae825294ac48cc1d5fbb96647c1.png)
2. 망토의 바깥쪽에만 무늬를 그립니다. Pencil Tool을 이용해 3번 레이어에 하트 무늬를 그립니다.![cape05](https://mod-file.dn.nexoncdn.co.kr/bbs/16456004442401ea5defa579a4b6abf23766fae78e720.png)![coat10](https://mod-file.dn.nexoncdn.co.kr/bbs/1645601105790a0371e5caeb844c998d7e93f9cef9bdd.gif)

#### 색상 변경하기

1. 노란색 레이어를 클릭합니다.
2. **Image - Adjustments - Hue/Saturation** 또는 단축키 **Ctrl+U**를 입력해 Hue/Saturation 창을 엽니다.
3. Hue, Saturation 값을 조정합니다. 망토 색상을 원하는 색으로 변경합니다.![cape04](https://mod-file.dn.nexoncdn.co.kr/bbs/16455174179436b418feba80a437dbff18a16cb72c1d8.png)
4. 모든 노란색 레이어의 색상을 변경한 뒤 파일을 저장합니다.![coat11](https://mod-file.dn.nexoncdn.co.kr/bbs/1645601140643c559a7b9c69a42ebb92aa2ff968912a6.gif)

#### 풍선 만들기

풍선 제작용 시트(Avatar_Cape_balloon.psd)를 엽니다.

1. 노란색 레이어를 클릭합니다.![ballon](https://mod-file.dn.nexoncdn.co.kr/bbs/164551700483099e8c4210c404b7a86d0e8663daf82fc.png)
2. **Image - Adjustments - Hue/Saturation** 또는 단축키 **Ctrl+U**를 입력해 Hue/Saturation 창을 엽니다.
3. Hue, Saturation 값을 조정합니다. 풍선 색상을 원하는 색으로 바꾸고 'OK' 버튼을 누릅니다. ![ballon01](https://mod-file.dn.nexoncdn.co.kr/bbs/1645516927945b5a70e3c58994a7b99fb73ff90921c95.png)
4. Pencil tool을 선택하고 풍선에 리본을 그려줍니다. 각각의 동작에 모두 그려줍니다. ![ballon02](https://mod-file.dn.nexoncdn.co.kr/bbs/16455169584853247e15f49954ad69dd7a2d1d12567d7.png)
5. 모든 노란색 레이어에서 색상 변경을 한 뒤 파일을 저장합니다.![coat12](https://mod-file.dn.nexoncdn.co.kr/bbs/1645601233197520c1a81436a4d819c9273af39c3b9cb.gif)

> **Tip** 리본 하나를 그린 후 다른 동작의 풍선에 붙이면 편리합니다.
> **더 알아보기** 풍선은 망토에 해당하는 아이템으로 취급되기 때문에 망토와 동시에 사용할 수 없습니다.

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)
- [신발 만들기](/docs?postId=583)

Update 2025-11-20 PM 02:03


# 제작 과정 안내

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=50%EB%B6%84&amp;color=green)

# 학습 과정 소개

뒤통수가 개방된 모자를 기준으로 모자를 만드는 방법을 소개합니다. 하나의 유형의 제작 방법을 익힌 후 다른 모자 유형 제작에 도전하는 것을 권장합니다. [뒤통수가 개방된 모자](/docs?postId=684)의 제작 시트 파일과 레이어 설명을 참고해 제작에 도전해보세요.

# 제작하기

### 장식이 달린 검정비니 만들기

비니의 하트 장식을 지우고 꽃장식을 만들어봅시다.

![32](https://mod-file.dn.nexoncdn.co.kr/bbs/1645791272340b6560797cef648819c675e8136bb5f44.png)![31](https://mod-file.dn.nexoncdn.co.kr/bbs/1645791161302775fa9f0d44d4b489f6b85e3d2513b98.png)

1. 노란색 레이어 **edithere:cap_cap_34**를 선택합니다.![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16457812707994a879e5d7ff5455b8415c392021d348b.png)
2. Eyedropper tool 클릭하고 모자 컬러를 추출한 후 **'Pencil tool'**을 선택해 장식을 덧칠해 없앱니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16457813036144967276e8fd944f69c27197971d89c8b.png)
3. Pencil tool의 색을 빨간색으로 변경하고, 꽃을 크게 그립니다.
4. 꽃이 크기 때문에 뒷모습에서 꽃이 약간 보여야 합니다.노란색 레이어 **edithere:cap_backCap_92**를 선택합니다.
5. 왼쪽에 꽃송이가 약간 보이게 그려줍니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16457813415818c106aa53f8d436fbb80937e48b2d555.png)

### 색상 변경하기

기본 검정 비니의 색상을 변경해봅시다. 장식 그리기에 익숙해졌다면 꽃장식도 추가로 그려보세요.

![30](https://mod-file.dn.nexoncdn.co.kr/bbs/16457911483162090d8b4bcbe47f3b9f3b7b80ea1c184.png)![33](https://mod-file.dn.nexoncdn.co.kr/bbs/164579153406366fb27ce813d4b0388d7044f29b1b7c2.png)

1. 노란색 레이어 **edithere:cap_cap_34**를 선택합니다.![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16457813695371a6dac5875364af99fe85b363c460f5d.png)
2. 포토샵 메뉴 **Image - Adjustments - Color Balance** 또는 단축키 **Ctrl+B**를 누릅니다.
3. Color Balance에 **85, 0, +45**를 입력해 보라색으로 색상을 변경합니다.![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781387384ba71feabcec149d3959f3ad2b124b2ad.png)
4. 포토샵 메뉴 **Image - Adjustments - Levels** 또는 단축키 **Ctrl+L**을 누릅니다.
5. Input Levels 값을 0, 1.00, 156 입력해 밝은 보라색으로 색상을 변경합니다.![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781398683671652b3c7394bf0932413f9c060cc63.png)
6. 모자의 뒷모습도 같은 방법으로 변경합니다.

### 이펙트 모자 만들기

이펙트 모자를 만들기 위해 **Avatar_Cap_Ani.psd** 파일을 열어 하트 모양 이펙트를 만들어봅시다.

| 기본 이펙트 | 하트 이펙트 |
| --- | --- |
| ![35](https://mod-file.dn.nexoncdn.co.kr/bbs/16457929316460fe14b326d45465ea5d3ac18e833c95f.gif) | ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/1646010456539bc80ce04d59c41b1a4d73a4d229f5fd2.gif) |

1. case1.front 폴더 - **edithere:cap_cap_34:0** 레이어에 모자의 앞모습을 그립니다.![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16457814337298252d7cb3bfa4f3eb8201cfa4692d18a.png)
2. 모자를 복사해 나머지 3개의 레이어에 동일하게 그립니다.
  - **edithere:cap_cap_34:1**
  - **edithere:cap_cap_34:2**
  - **edithere:cap_cap_34:3**
3. 애니메이션은 레이어 명의 끝자리 수가 작은 수에서부터 큰 수로 재생되기 때문에 0부터 4까지 동일한 위치에 하트를 점점 크게 그립니다.![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781449807a9572a07c1c44ffaa0107bba7aba7a81.png)
4. case2.back 폴더 - **edithere:cap_backCap_92:0** 레이어에 모자의 뒷모습을 그립니다.
5. 모자를 복사해 **edithere:cap_backCap_92:1**에 동일하게 그립니다.
6. 0부터 4까지 동일한 위치에 하트를 점점 크게 그립니다.

#### 포토샵 타임라인 확인

1. 포토샵에서 **Window - Timeline** 선택해 Timeline 메뉴를 활성화합니다.
2. Create Frame Animation을 클릭하고 시작합니다.![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781481606d9b1f6c9d22a438598eae1dfcc5ec1e6.png)
3. Timeline 1번 채널에 앞모습의 레이어 0번(edithere:cap_cap_34:0)과 뒷모습의 레이어 0번(edithere:cap_backCap_92:0)을 선택하고, 타임라인의 + 버튼을 누릅니다.Timeline 2번 채널에 앞모습의 레이어 1번(edithere:cap_cap_34:1)과 뒷모습의 레이어 1번(edithere:cap_backCap_92:1)을 선택하고, 타임라인의 + 버튼을 누릅니다.Timeline 3번 채널에 앞모습의 레이어 2번(edithere:cap_cap_34:2)과 뒷모습의 레이어 0번(edithere:cap_backCap_92:0)을 선택하고, 타임라인의 + 버튼을 누릅니다.Timeline 4번 채널에 앞모습의 레이어 3번(edithere:cap_cap_34:3)과 뒷모습의 레이어 1번(edithere:cap_backCap_92:1)을 선택하고, 타임라인의 + 버튼을 누릅니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781496623b8751a23b2ee44f1b4016c6604d791a3.png)
4. 4프레임을 만들고, 플레이를 애니메이션을 확인합니다.애니메이션을 자연스럽게 재생하기 위해 프레임 재생 속도를 0.0초를 0.2초로 변경합니다.  ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/1645781514920abaecc4ac7a34c57920a8b86f8b7f580.png)
5. 완성되었다면 PSD 그대로 저장합니다.

> **Tip.** 포토샵 메뉴의 File - Save a Copy 또는 'Alt+Ctrl+S'를 눌러 GIF 파일 저장해 확인할 수도 있습니다. ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/1646010456539bc80ce04d59c41b1a4d73a4d229f5fd2.gif)
> **더 알아보기** 'stand', 'walk', 'fly', 'rope', 'ladder' 동작에서만 이펙트가 재생됩니다. 다른 동작들에서는 첫 번째 프레임만 보입니다.

##### 참고 가이드

- [뒤통수를 덮는 모자](/docs?postId=677)
- [액세서리](/docs?postId=678)
- [가발](/docs?postId=679)
- [얼굴을 가리는 탈](/docs?postId=680)
- [얼굴이 보이는 탈](/docs?postId=681)
- [후드](/docs?postId=682)

Update 2025-11-20 PM 02:03


# 뒤통수가 개방된 모자

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

뒤통수가 개방된 모자 제작 방법을 알아봅시다. 기본 모자의 색상을 변경하고, 악세사리를 그릴 수 있습니다. 모자는 복잡한 구조로 바지나 신발 아이템 제작에 익숙해진 후 작업하는 걸 권장합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_A1.psd](blob:https://maplestoryworlds-creators.nexon.com/439bdb30-2b85-42c3-8551-93471ebe21c3)

[Avatar_Cap_A2.psd](blob:https://maplestoryworlds-creators.nexon.com/04e0d4c5-7282-44e0-8255-51505c642ae2)

[Avatar_Cap_Ani.psd](blob:https://maplestoryworlds-creators.nexon.com/05496f51-2098-4f87-85d5-0b1accb6d209)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
  - guide_backHairBelowCapWide_samples_94, guide_backHairBelowCapNarrow_samples_95는 모자 모양에 따른 넓은 헤어와 좁은 헤어의 샘플입니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16457811937535becc03a37664135889302106c115bff.png)
3. **(빨간색 레이어) data:vslot:CpH1H5**: 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다.

![layer](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032356769c4bb8003ae4447ab8b8f3f11c31e2428.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 모자를 그릴 수 있습니다.

#### 앞모습에서 헤어 앞에 1개의 레이어만 있는 모자 (Avatar_Cap_A1)

- **case1.front**: 모자의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 모자의 앞모습을 그릴 수 있는 레이어입니다.
- **case2.back**: 모자의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 모자의 뒷모습을 그릴 수 있는 레이어입니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16770399860801689e03a56a847c6b3082835b716c0f9.png)

#### 앞모습에서 헤어 앞뒤로 2개의 레이어가 있는 모자 (Avatar_Cap_A2)

- **case1.front**: 모자의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 모자의 앞모습을 그릴 수 있는 레이어입니다.
  - **edithere:cap_frontBackCap_92**: 헤어 뒤에 오는 모자의 앞모습을 그릴 수 있는 레이어입니다.
- **case2.back**: 모자의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 모자의 뒷모습을 그릴 수 있는 레이어입니다.

![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16856818406522ccc7186c35648dd8beb320cfcc7a07b.png)

> **더 알아보기** 뒤통수가 개방된 모자(Avatar_Cap_A)를 작업할 때는 guide_backHairBelowCapWide_samples_94, guide_backHairBelowCapNarrow_samples_95의 헤어 샘플 중 Wide와 Narrow 이미지가 동일한 001번 샘플을 사용합니다.

#### 이펙트가 있는 파일(Avatar_Cap_Ani.psd)

아바타 시트에서 앞모습은 4프레임의 애니메이션, 뒷모습은 2프레임의 애니메이션 규칙이 있습니다. 해당 프레임을 모자 이펙트로 적용합니다. 애니메이션 레이어 순서에 따라 재생될 모자와 이펙트를 각각 그려야 합니다.

- **case1.front** : 모자의 앞모습과 이펙트를 그릴 레이어들이 animation 폴더에 들어있고, 아바타 샘플이 포함되어 있습니다.
  - **animation 폴더**: 모자의 앞모습과 이펙트를 그릴 수 있는 레이어 4장이 있습니다. 동일한 모자를 모든 레이어에 그려야 합니다.
- **case2.back**: 모자의 뒷모습과 이펙트를 그릴 레이어들이 animation 폴더에 들어 있고, 아바타 샘플이 포함되어 있습니다.
  - **animation 폴더**: 모자의 앞모습과 이펙트를 그릴 수 있는 레이어 2장이 있습니다. 동일한 모자를 모든 레이어에 그려야 합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16770332160558c40d4d45b4349d29f54ace53eec586e.png)

> **더 알아보기** 'stand', 'walk', 'fly', 'rope', 'ladder' 동작에서만 이펙트가 재생됩니다. 다른 동작들에서는 첫 번째 프레임만 보입니다.

Update 2025-11-17 PM 08:14


# 뒤통수를 덮는 모자

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

뒤통수를 덮는 모자의 제작 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_B.psd](blob:https://maplestoryworlds-creators.nexon.com/96a8b75c-25c1-4a3c-89c7-eaeb6792eae4)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
  - guide_backHairBelowCapWide_samples_94, guide_backHairBelowCapNarrow_samples_95는 모자 모양에 따른 넓은 헤어와 좁은 헤어의 샘플입니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16457811937535becc03a37664135889302106c115bff.png)
3. **(빨간색 레이어) data:vslot:CpH1H4** : 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeB](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032543121310bc61208a34d33b830aba8862f51c4.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 모자를 그릴 수 있습니다.

1. **case1.front**: 모자의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 모자의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 모자의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 모자의 뒷모습을 그릴 수 있는 레이어입니다.

![TypeB01](https://mod-file.dn.nexoncdn.co.kr/bbs/1677033338202aa1833624a264a098601f346edc6fc3f.png)

> **더 알아보기** 뒤통수를 덮는 모자(Avatar_Cap_B)를 작업할 때는 guide_backHairBelowCapWide_samples_94, guide_backHairBelowCapNarrow_samples_95의 헤어 샘플에서 Wide와 Narrow 이미지가 다른 002번 샘플을 사용합니다.

Update 2025-11-17 PM 08:14


# 액세서리

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

액세서리 제작 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_C1.psd](blob:https://maplestoryworlds-creators.nexon.com/b44c54fa-4442-4afe-b749-621a08a3e338)

[Avatar_Cap_C2.psd](blob:https://maplestoryworlds-creators.nexon.com/d39fdf5e-4c65-4642-bb5c-db0de3cb9e21)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
  - guide_backHairBelowCapWide_samples_94, guide_backHairBelowCapNarrow_samples_95는 모자 모양에 따른 넓은 헤어와 좁은 헤어의 샘플입니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16457811937535becc03a37664135889302106c115bff.png)
3. **(빨간색 레이어) data:vslot:Cp**: 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeC](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032925906d8d5e7d2d4fc4919abdd056f95e86764.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 모자를 그릴 수 있습니다.

#### 헤어 앞 액세서리(Avatar_Cap_C1)

1. **case1.front**: 액세서리 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 액세서리의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 액세서리의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 액세서리의 뒷모습을 그릴 수 있는 레이어입니다. ![TypeC1](https://mod-file.dn.nexoncdn.co.kr/bbs/1677033049022e937abd5539d482db48c27edb17f2f5d.png)

#### 헤어 뒤 액세서리 (Avatar_Cap_C2)

1. **case1.front**: 액세서리 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 액세서리의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 액세서리의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCapAccessory_118**: 액세서리의 뒷모습을 그릴 수 있는 레이어입니다 ![TypeC2](https://mod-file.dn.nexoncdn.co.kr/bbs/167703307307804e247f40f174b1291de064b6b72eacb.png)

Update 2025-11-17 PM 08:14


# 가발

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

가발 제작 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_D.psd](blob:https://maplestoryworlds-creators.nexon.com/846144aa-a278-454d-b7ba-49292afe4654)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **(빨간색 레이어) data:vslot:CpH1H2H3H4H5H6HfHsHbHc** : 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeD](https://mod-file.dn.nexoncdn.co.kr/bbs/1677033750714bee6e496b432440aa917a6c4fceeb4ca.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 가발을 그릴 수 있습니다.

1. **case1.front**: 가발의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 가발의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 가발의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 가발의 뒷모습을 그릴 수 있는 레이어입니다. ![TypeD1](https://mod-file.dn.nexoncdn.co.kr/bbs/16770337662241601c8da5b484bb2b9fa358959c05109.png)

Update 2025-11-17 PM 08:14


# 얼굴을 가리는 탈

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

얼굴을 가리는 탈 제작 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_E.psd](blob:https://maplestoryworlds-creators.nexon.com/0ebcfec1-b1f4-4b16-9039-4262e973b8f2)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **(빨간색 레이어) data:vslot:CpH1H2H3H4H5H6HfHsHbHcAfAyAsAe** : 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeE](https://mod-file.dn.nexoncdn.co.kr/bbs/167703389960214c1a08396d74ffeba19e07a5787b1eb.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 얼굴을 가리는 탈을 그릴 수 있습니다.

1. **case1.front**: 얼굴을 가리는 탈의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 얼굴을 가리는 탈의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 얼굴을 가리는 탈의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 얼굴을 가리는 탈의 뒷모습을 그릴 수 있는 레이어입니다. ![[TypeE1]](https://mod-file.dn.nexoncdn.co.kr/bbs/1724918527383e3a3141a069e42d7a212bfaec518a4be.png)

Update 2025-11-20 PM 02:03


# 얼굴이 보이는 탈

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

얼굴이 보이는 탈 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_F.psd](blob:https://maplestoryworlds-creators.nexon.com/5a3d70a4-7b73-4091-b6ec-1f1b9131040d)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **(빨간색 레이어) data:vslot:CpH1H2H3H4H5H6HfHsHbHcAe** : 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeF](https://mod-file.dn.nexoncdn.co.kr/bbs/16770339977519ce67c0abb134ff4b6e40e636da925d6.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 얼굴이 보이는 탈을 그릴 수 있습니다.

1. **case1.front**: 얼굴이 보이는 탈의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 얼굴이 보이는 탈의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 얼굴이 보이는 탈의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 얼굴이 보이는 탈의 뒷모습을 그릴 수 있는 레이어입니다. ![TypeF1](https://mod-file.dn.nexoncdn.co.kr/bbs/1677034011337213501bd84684eeebd56d177670563f1.png)

Update 2025-11-17 PM 08:15


# 후드

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

후드 시트를 소개합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Cap_G.psd](blob:https://maplestoryworlds-creators.nexon.com/1f62cb13-097f-4cf7-82fe-92ea4ebf332f)

> **Tip.** 모자는 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16769485559327fc72cf03aca4128998b423540c3e049.png)

# 제작 시트 설명

모자 제작 시트는 회색, 빨간색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다. 빨간색 레이어는 모자와 헤어의 우선순위를 결정하는 역할을 합니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어/빨간색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Cap**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **(빨간색 레이어) data:vslot:CpH1H3H4H5H6HfHbHcAe** : 빨간색 레이어는 모자에만 있는 개념입니다. 모자 제작 파일에서의 vslot 레이어는 머리카락과 모자가 겹칠 경우 보이는 우선순위를 결정하는 역할을 합니다. ![TypeG](https://mod-file.dn.nexoncdn.co.kr/bbs/16770341216345bee47ec320b47038b44a99935ece7a2.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 후드를 그릴 수 있습니다.

1. **case1.front**: 후드의 앞모습을 그릴 레이어와 앞모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_cap_34**: 후드의 앞모습을 그릴 수 있는 레이어입니다.
2. **case2.back**: 후드의 뒷모습을 그릴 레이어와 뒷모습의 일반 헤어와 눌린 헤어 샘플이 포함되어 있습니다.
  - **edithere:cap_backCap_92**: 후드의 뒷모습을 그릴 수 있는 레이어입니다. ![TypeG1](https://mod-file.dn.nexoncdn.co.kr/bbs/1677034101578d0917d0379e545b2b4bf30612376cdbf.png)

Update 2025-11-17 PM 08:15


# 상의 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

상의 제작 방법을 알아봅시다. 기본 상의 색상을 바꾸고 그 위에 그림을 그릴 수 있습니다. 상의는 복잡한 구조로 구성되어 있기 때문에 바지나 신발 아이템 제작에 익숙해진 후 작업하는 걸 권장합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Coat.psd](blob:https://maplestoryworlds-creators.nexon.com/2cd05767-8029-449f-90cc-7bfbbad1d03d)

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 4개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어, 바탕용 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

#### 회색 레이어

포토샵에서 시트를 열면 회색 레이어는 자물쇠로 잠겨 있습니다. 아이템 등록에 관련된 내용으로 변형이 불가한 레이어입니다.

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Coat**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:Ma**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_ 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid**: 그리드 선 기준으로 아이템을 제작합니다. 초록색 선 안에서만 작업을 해야 합니다.
4. **guide_background**: 바탕 컬러는 gray_blue와 gray가 있습니다. gray_blue에 위치된 팔은 예외적인 자리에 이미지가 그려지므로 표시를 해 두었습니다.

![coat01](https://mod-file.dn.nexoncdn.co.kr/bbs/165061743355448155ebe84c9405391d1de99cb7ca495.png)

#### 노란색 레이어

노란색 레이어에는 크리에이터가 제작할 상의를 그릴 수 있습니다.

1. guide_character_backBody_113: 아바타 뒷모습과 팔
  - **edithere:mail_backMailChest_103**: 아바타 뒷모습과 팔 위에 그려지는 옷
2. guide_character_summary_78,100: 아바타 몸과 팔, 뒷모습 머리
  - **edithere:mail_mailChest_68**: 아바타 몸과 팔 위에 그려지는 옷
3. guide_character_summary_60,62: 아바타 팔
  - **edithere:mailArm_mailArmBelowHead_58,61**: 아바타 팔 위에 그려지는 옷
4. guide_character_summary_52,53: 아바타 팔
  - **edithere:mailArm_mailArm_50**: 아바타 팔 위에 그려지는 옷
5. guide_character_summary_26,47: 아바타 머리와 팔
  - **edithere:mailArm_mailArmOverHairBelowWeapon_25**: 아바타 머리와 팔 위에 그려지는 옷
6. guide_character_armOverHair_24 : 아바타 팔
  - **edithere:mailArm_mailArmOverHair_22**: 아바타 팔 위에 그려지는 옷

![coat02](https://mod-file.dn.nexoncdn.co.kr/bbs/1645582927632f0e7790d36844043a8bbb992b2d24154.png)

# 제작하기

기본 상의를 바탕으로 무늬가 있는 상의, 다른 색상의 상의, 긴 팔 상의를 제작해봅시다.

| 기본 상의 | 무늬 그리기 | 색상 변경 | 긴 팔 상의 |
| --- | --- | --- | --- |
| ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1645684463571e684de7e0cba4bdf8d78e2022a34c1a1.png) | ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16456845084177670d36c4b664d549d420a02542734dd.png) | ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16503348006950e9be3c69e664a34966cbc1fbdf57b0f.png) | ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1650334752955e04ab9761b2a43f8b724def5b499f658.png) |

#### 무늬 그리기

1. 노란색 레이어 2번(edithere:mail_mailChest_68)에 이미지 작업을 합니다.  ![coat03](https://mod-file.dn.nexoncdn.co.kr/bbs/16455830786944859a717c0be483bb5f59faa8651c14f.png)
2. 작은 하트를 각각의 동작에 그려줍니다.몸통에만 하트가 그려지므로 다른 레이어는 그대로 둡니다.![coat04](https://mod-file.dn.nexoncdn.co.kr/bbs/1645583092780f3345eebaa4a4be5a9c23f91b74096cd.png)

#### 색상 변경하기

1. 노란색 레이어를 클릭합니다.
2. **image - Adjustments - Hue/Saturation** 또는 단축키 **Ctrl+U**를 입력해 Hue/Saturation 창을 엽니다.
3. **Hue** 값을 조정합니다. 모든 노란색 레이어의 상의 색상을 원하는 색으로 바꾸고 'OK' 버튼을 누른 후 파일을 저장합니다.![coat16](https://mod-file.dn.nexoncdn.co.kr/bbs/1645591630688cb5180ce8d77408787f2decf3776e412.png)

#### 긴소매 상의 만들기

1. 노란색 레이어 1번부터 6번에 이미지 작업을 합니다. ![coat16](https://mod-file.dn.nexoncdn.co.kr/bbs/165033411781314df1c56f85942fe8483569d7af5e76d.png)
2. body에 맞게 pencil tool을 이용해 긴 팔을 그립니다.![coat17](https://mod-file.dn.nexoncdn.co.kr/bbs/1650334169976ee38f585747246f596f2fb80b3e19d42.png)![coat18](https://mod-file.dn.nexoncdn.co.kr/bbs/1650334184379e86690f2a3f547eaa6bf6a44a445ae97.png)![coat19](https://mod-file.dn.nexoncdn.co.kr/bbs/16503342030177f5460daeddc46f2971251a579dc4698.png)![coat20](https://mod-file.dn.nexoncdn.co.kr/bbs/16503342772725975591ca82d42a289930aff1428fc53.png)![coat21](https://mod-file.dn.nexoncdn.co.kr/bbs/1650334295006e903a60bc3314a47b4c65c47c9a5aacf.png)![coat22](https://mod-file.dn.nexoncdn.co.kr/bbs/1650334309071f637ad711b474bf19c38c1aeacbfa18d.png)
3. 상의의 소매 부분을 그릴 때는 기본 규칙과 다른 예외 시트를 염두에 두고 그려야합니다.시트의 동작 중 **Swing O3, Swing OF, Stab TF, Swim-Fly, Sit**을 그릴 때는 일부 예외적인 법칙을 따라야 합니다.**Swing O3, Swing OF**는 레이어를 기준으로는 'guide'에서 body(팔)은 3번 위치에 있으나 소매는 4번 레이어에 그려줍니다.**Stab TF, Swim-Fly, Sit**는 레이어를 기준으로는 'guide'에서 body(팔)은 4번 위치에 있으나 소매는 6번 레이어에 그려줍니다 ![coat22](https://mod-file.dn.nexoncdn.co.kr/bbs/16503343643288cb65f8b3cd847089f0e4a494bbed99c.png) 레이어만으로 이미지의 레이어 위치를 모를 때는 **기본으로 제공된 흰 티셔츠가 작업된 레이어**를 찾아 그리면 됩니다. ![coat23](https://mod-file.dn.nexoncdn.co.kr/bbs/16503344581568f0d7baaca4d4c5ea17ddc395dad1716.png)![coat24](https://mod-file.dn.nexoncdn.co.kr/bbs/16503344730397780d272d77c48ba929bca725111a81b.png) ![coat24](https://mod-file.dn.nexoncdn.co.kr/bbs/16503344933842ba8ee3242524637907486057d58ee84.png)![coat25](https://mod-file.dn.nexoncdn.co.kr/bbs/16503345071810a077a814e404a4dba975667e0261846.png) ![coat26](https://mod-file.dn.nexoncdn.co.kr/bbs/16503345264358fbc43530b6e4822b41cfe99165d8f48.png)

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [장갑 만들기](/docs?postId=587)
- [신발 만들기](/docs?postId=583)

Update 2025-11-20 PM 02:03


# 신발 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

신발 제작 방법을 알아봅시다. 신발 제작을 응용해 신발과 함께 양말, 부츠도 제작할 수 있습니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 3개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

#### 회색 레이어

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Shoes**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:So**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.  아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_summary 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid**: 그리드 선 기준으로 아이템을 제작합니다. 초록색 선 안에서만 작업을 해야 합니다. ![shoes07](https://mod-file.dn.nexoncdn.co.kr/bbs/16454358868351d94f93644cf46569a2be51ed1f9a202.png)

#### 노란색 레이어

크리에이이터는 노란색 레이어(edithere:shoes_shoesTop_69)에 신발을 그릴 수 있습니다. 신발을 그릴 때는 초록색 가이드 선을 벗어나지 않게 그려야합니다. ![shoes08](https://mod-file.dn.nexoncdn.co.kr/bbs/1645440415221e758aa75302b4bd09e503f4d49bcb3e6.png)

# 제작하기

기본 신발을 바탕으로 아래와 같은 양말과 부츠를 제작해봅시다.

| 기본 신발 | 양말 | 부츠 |
| --- | --- | --- |
| ![shoes01](https://mod-file.dn.nexoncdn.co.kr/bbs/1677034678429be2cb1f089194731bb321d1ae36b20b9.gif) | ![shoes02](https://mod-file.dn.nexoncdn.co.kr/bbs/16454352494023ec9b27f8e0a42a381d086d237e2b2b3.gif) | ![shoes03](https://mod-file.dn.nexoncdn.co.kr/bbs/1645435264743dc9d75c9a3f64a42b6e86045f49379c6.gif) |
| ![shoes04](https://mod-file.dn.nexoncdn.co.kr/bbs/16770347093535d4307c5ab37400aa90bad527003fba3.png) | ![shoes05](https://mod-file.dn.nexoncdn.co.kr/bbs/1645435318415ef3ced3935204051b9cc6449d708478c.png) | ![shoes06](https://mod-file.dn.nexoncdn.co.kr/bbs/1645435335260644d7e893d5b40ddb3be0e42b7337cb5.png) |

#### 양말 만들기

1. 노란색 레이어(edithere:shoes_shoesTop_69)에 이미지 작업을 합니다.![shoes09](https://mod-file.dn.nexoncdn.co.kr/bbs/16454410334432e1fa75cfc224edd82bb0b18c3dba8a4.png)
2. 포토샵 툴에서 **Pencil tool** 클릭하고 아바타의 body에 맞춰 각각의 동작에 도트로 초록 양말을 그려줍니다.![shoes10](https://mod-file.dn.nexoncdn.co.kr/bbs/16770347338082118238cdd5b49a4be66f71c853fea79.png)

> **더 알아보기** 애니메이션을 확인해 보고 싶다면 [등록하기](/docs/?postId=590)를 진행하여 미리 보기로 확인할 수 있습니다.

#### 부츠 만들기

1. 노란색 레이어(edithere:shoes_shoesTop_69)에 이미지 작업을 합니다.![shoes09](https://mod-file.dn.nexoncdn.co.kr/bbs/16454410334432e1fa75cfc224edd82bb0b18c3dba8a4.png)
2. 포토샵 툴에서 **Pencil tool** 클릭하고 아바타의 body에 맞춰 각각의 동작에 도트로 부츠를 그려줍니다.![shoes10](https://mod-file.dn.nexoncdn.co.kr/bbs/16455205733994a5eb10228ae4fc5aa409cb8b24588f8.png)

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)

Update 2025-11-17 PM 08:14


# 장갑 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

장갑 제작 방법을 알아봅시다. 기본 장갑 색상을 바꾸고 그 위에 그림을 그릴 수 있습니다. 장갑은 복잡한 구조로 구성되어 있기 때문에 바지나 신발 아이템 제작에 익숙해진 후 작업하는 걸 권장합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 3개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어

![glove00](https://mod-file.dn.nexoncdn.co.kr/bbs/16460333014592202c8cc50e94904959448d94d68d14d.png)

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Glove**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:GlGw**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_summary 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid**: 그리드 선 기준으로 아이템을 제작합니다. 초록색 선 안에서만 작업을 해야 합니다.
4. **guide_background** : 바탕 컬러는 gray_blue와 gray가 있습니다. gray_blue에 배치된 손은 얼굴에 가려 보이지 않으므로 장갑을 그리지 않아도 좋습니다. ![glove](https://mod-file.dn.nexoncdn.co.kr/bbs/164559428580573f3ac0478a74420915915fc5e57ab5f.png) ![glove06](https://mod-file.dn.nexoncdn.co.kr/bbs/164559429595558ea67d1a9b54db09324b060805a18fe.png)

### 노란색 레이어

노란색 레이어에 크리에이터가 제작할 장갑을 그릴 수 있습니다.

#### 왼손 오른손 구분

아바타의 손은 왼손, 오른손이 구분되어 있으며 그 위에 아이템이 그려지게 됩니다. 화면 상에서 **lGlove**은 왼손, **rGlove**는 오른손으로 설정되어 있습니다. ![coat09](https://mod-file.dn.nexoncdn.co.kr/bbs/16455945165795c6af89bbd624ecd8f515e2236212434.png) ![coat08](https://mod-file.dn.nexoncdn.co.kr/bbs/1645594498083853f96a383c14814b91cbc2e90c29d90.png)

#### 작업 기준

1. **guide_character_Body_78**: 아바타의 샘플을 기준으로 1, 2, 3, 4, 5, 6 위치의 레이어에 장갑을 그려줍니다. 장갑 샘플이 그려진 위치를 참고하시면서 아바타의 손에 맞춰 그려줍니다.![glove10](https://mod-file.dn.nexoncdn.co.kr/bbs/16455950125317caa13191faa4327be3e5c715ae2f8fa.png)
2. **guide_character_summary_52,53,62**: 아바타의 샘플을 기준으로 3, 4, 5, 6 위치의 레이어에 장갑을 그려줍니다. 장갑 샘플이 그려진 위치를 참고하시면서 아바타의 손에 맞춰 그려줍니다.![glove11](https://mod-file.dn.nexoncdn.co.kr/bbs/1645595078631cca5a165684046189a9a240bcd976956.png)
3. **guide_character_summary_24,47**: 아바타의 샘플을 기준으로 5,6 위치의 레이어에 장갑을 그려줍니다. 장갑 샘플이 그려진 위치를 참고하시면서 아바타의 손에 맞춰 그려줍니다.![glove12](https://mod-file.dn.nexoncdn.co.kr/bbs/1645595114548b9b59cd3a86346f0a629d8cb2842a41f.png)

# 제작하기

#### 무늬 그리기

노란색 레이어에 **Pencil Tool**을 이용해 작은 하트를 모든 **lGlove, rGlove 레이어**에 모두 꼼꼼하게 그려줍니다.

![glove13](https://mod-file.dn.nexoncdn.co.kr/bbs/1645595325199dbbd9655c991466abd72cfe5e814921a.png)![glove13](https://mod-file.dn.nexoncdn.co.kr/bbs/1645595338100bf3e9fc39a5e4f58b382ad8976540d1d.png)

> **Tip** 주로 한 쪽에만 차는 팔찌나 시계는 잘 보이는 'rGlove' 한 쪽에만 그립니다.

#### 색상 변경하기

1. 노란색 레이어를 클릭합니다.
2. **image - Adjustments - Hue/Saturation** 또는 단축키 **Ctrl+U**를 입력해 Hue/Saturation 창을 엽니다.
3. 'Lightness' 값을 **-40**으로 설정해 회색 컬러로 변경해줍니다.![glove14](https://mod-file.dn.nexoncdn.co.kr/bbs/1645596666352e7cc00268c8a40eca6dbddc476691c10.png)
4. **Image - Adjustments - Color Balance** 클릭 또는 단축키 **Ctrl+B**를 입력합니다.  Color Balance를 **Blue**로 조정합니다.![glove15](https://mod-file.dn.nexoncdn.co.kr/bbs/1645596879737ee76f2425107404a9507095929b396d9.png)
5. **Image - Adjustments - Levels** 또는 **Ctrl+L**로 창을 엽니다.
6. 양 끝의 값을 **53, 189**로 변경해 장갑을 보라색으로 만듭니다.![glove16](https://mod-file.dn.nexoncdn.co.kr/bbs/16455975905835fb5e72dbb074a25b4179641537a66e1.png)

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [신발 만들기](/docs?postId=583)

Update 2025-11-20 PM 02:03


# 하의 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

하의 제작 방법을 알아봅시다. 기본으로 제공되는 청 반바지의 길이를 조정하고 컬러를 바꿔 제작해보고, 자신만의 독특한 치마나 긴 바지를 만들 수 있습니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 3개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

#### 회색 레이어

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Pants**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:Pn**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_summary 레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid**: 그리드 선 기준으로 아이템을 제작합니다. 초록색 선 안에서만 작업을 해야 합니다. ![pants04](https://mod-file.dn.nexoncdn.co.kr/bbs/1645498107053da17e0eeb2704d77ba834b73bf65d9c7.png)

#### 노란색 레이어

노란색 레이어(edithere:pants_pantsBelowShoes_75)는 크리에이터가 제작할 하의를 그릴 수 있습니다. ![pants05](https://mod-file.dn.nexoncdn.co.kr/bbs/16454981267650d9164635d8d474bad641d8cd0cd5ea0.png)

# 제작하기

기본 하의를 바탕으로 아래와 같은 짧은 바지와 긴 바지를 제작해봅시다.

| 기본 하의 | 색상 변경 | 긴 바지 |
| --- | --- | --- |
| ![pants01](https://mod-file.dn.nexoncdn.co.kr/bbs/16454979999409fd4d08bd2f4489c858250629ef0f2ed.png) | ![pants02](https://mod-file.dn.nexoncdn.co.kr/bbs/1645498013081746575d0b440465897991f2dc116df30.png) | ![pants03](https://mod-file.dn.nexoncdn.co.kr/bbs/1645498023976f2cc0d293501416f9c65f13ce1c63681.png) |

#### 색상 변경하기

1. 노란색 레이어(edithere:pants_pantsBelowShoes_75)를 클릭합니다.
2. **image - Adjustments - Hue/Saturation** 또는 단축키 **Ctrl+U**를 입력해 Hue/Saturation 창을 엽니다.
3. **Hue** 값을 조정합니다. 하의 색상을 원하는 색으로 바꾸고 'OK' 버튼을 누른 후 파일을 저장합니다. ![pants07](https://mod-file.dn.nexoncdn.co.kr/bbs/164550404415997459e844dd54f63917a5815a36a1fb2.png)

#### 다른 종류의 하의 제작

1. 노란색 레이어(edithere:pants_pantsBelowShoes_75)에 이미지 작업을 합니다.![pants12](https://mod-file.dn.nexoncdn.co.kr/bbs/164558135888530c409a7de4e47e49ccac81ee21c58d2.png)
2. 포토샵에서 **Pencil tool**을 선택하고 아바타의 body에 맞춰 모든 동작에 도트로 그려줍니다.치마류를 그릴 때는 발에 맞춰 그리고, 초록색 안내선을 넘지 않게 주의해야 합니다.![pants09](https://mod-file.dn.nexoncdn.co.kr/bbs/16455041383060a17d6620fdf422cab54bab983600362.png)

##### 참고 가이드

- [신발 만들기](/docs?postId=583)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)

Update 2025-11-20 PM 02:03


# 헤어 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

헤어 제작 방법을 알아봅시다. 기본 헤어의 색상을 변경하거나, 새롭게 그릴 수 있습니다. 헤어는 복잡한 구조로 바지나 신발 아이템 제작에 익숙해진 후 작업하는 걸 권장합니다. [아바타 아이템 제작의 기본 개념](/docs?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

[Avatar_Hair.psd](blob:https://maplestoryworlds-creators.nexon.com/7c5b48d9-2709-4903-bb61-476354a50c6f)

> **Tip.** 헤어는 아바타 발을 기준으로 최대 **120x120**안에서 제작을 권장합니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/1685684754306c9db40323e1a487d8d01f6401b8a2ba4.png)

# 헤어 종류

헤어는 짧은 헤어와 긴헤어로 구분됩니다.

| 짧은 헤어 | 긴헤어 |
| --- | --- |
| ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/168568956575557a3b5c4532c4f31ba37bdfa798338fb.png) | ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/168568957903110d3a4890ef74bd58109ed7890cd741a.png) |

# 제작 시트 설명

헤어 제작 시트는 회색, 노란색 레이어로 구분되어 있습니다. 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

### 회색 레이어

1. **data 폴더**: data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Hair**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:H1H2H3H4H5H6HfHsHb**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다.아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_ 레이어**: 아바타의 샘플 body와 모자입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.

![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1685684844020a9b9fe1ac2e748eba8846bd952a2f77e.png)

# 노란색 레이어

노란색 레이어에 크리에이터가 제작할 헤어를 그릴 수 있으며, 3개의 폴더로 나뉘어져 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1685685193823a97012a2929d430ea43007325272ecf4.png)

1. **case1.front**: 헤어의 앞모습 작업을 위한 body와 여러 가지의 모자 샘플이 포함되어 있습니다.
2. **case2.front_proneStab**: 엎드려 있을 때의 헤어 작업을 위한 body와 여러 가지의 모자 샘플이 포함되어 있습니다. 하위에 보라색 레이어가 있습니다.
3. **case3.back**: 헤어의 뒷모습 작업을 위한 body와 여러 가지의 모자 샘플이 포함되어 있습니다.

#### case1.front

![front](https://mod-file.dn.nexoncdn.co.kr/bbs/168568527472950ccb61ca0e14cbe86f2644e579fd5d3.png)

1. NoCap 폴더 헤어의 앞모습을 그릴 레이어와 모자 샘플을 포함한 폴더입니다. [모자 만들기](/docs?postId=592) vslot의 3번 유형에 해당하는 모자 샘플입니다.
  - **guide_cap_samples**: 기본 헤어로 머리 모양이 변하지 않는 모자 샘플이 포함되어 있습니다.
  - **edithere:front_hairOverHead_31**: 헤어의 앞모습을 그릴 수 있는 레이어입니다.
2. WithCap 폴더 모자를 썼을 때 눌리는 헤어의 앞모습을 그릴 레이어와 해당하는 종류의 모자 샘플들이 들어있습니다. [모자 만들기](/docs?postId=592) vslot의 1, 2번 유형에 해당하는 모자 샘플입니다.
  - **guide_cap_samples**: 헤어를 누르는 종류의 모자 샘플이 포함되어 있습니다.
  - **edithere:front_hair_35**: 눌린 헤어의 앞모습을 그릴 수 있는 레이어입니다.
3. **edithere:front_hairShade_46** 헤어의 그림자를 그릴 수 있는 레이어입니다. 그림자는 헤어 모양에 맞춰 **#6d5031** 색으로 그린 뒤, 투명도 30% 적용해주면 모든 피부색에 어울리게 됩니다.
4. **edithere:front_hairBelowBody_84** 몸 뒤로 배치되는 헤어를 그릴 수 있는 레이어입니다. 주로 긴 헤어가 해당합니다.

#### case2.front_proneStab

![proneStab](https://mod-file.dn.nexoncdn.co.kr/bbs/168568532965909c3e58fa3c34781830758d9ea4b2c33.png)

1. **NoCap(copy from 1-a.NoCap) 폴더** 엎드린 자세일 때 헤어의 앞모습을 그릴 레이어와 모자 샘플을 포함한 폴더입니다.
  - **edithere:proneStab_hairOverHead_31**: 엎드린 헤어의 앞모습을 그릴 수 있는 레이어입니다. 작업 시 원활한 작업을 위해 WithCap 폴더에서 작업한 edithere:front_hairOverHead_31 레이어를 붙여 넣은 후 엎드렸을때 기준으로 넓게 퍼진 모습으로 그려줍니다.
2. **WithCap(copy from 1-b.WithCap) 폴더** 엎드린 자세로 모자를 썼을 때 눌리는 헤어의 앞모습을 그릴 레이어와 해당하는 종류의 모자 샘플들이 들어있습니다.
  - **guide_cap_samples**: 헤어를 누르는 종류의 모자 샘플이 포함되어 있습니다.
  - **edithere:proneStab_hair_35**: 엎드린 헤어의 앞모습을 그릴 수 있는 레이어입니다. edithere:front_hair_35 레이어의 그림을 복사해 참고용으로 사용하며 엎드렸을때 기준으로 넓게 퍼진 모습으로 그려줍니다.
  > **Tip.** **duplicated:front_hairOverHead_31, duplicated:front_hairOverHead_35**에 그리는 헤어의 앞모습은 edithere:front_hairOverHead_31, edithere:front_hair_35와 같아야 합니다.
3. **edithere:proneStab_hairBelowBody_84** 엎드린 자세일 때 몸 뒤로 배치되는 헤어를 그릴 수 있는 레이어입니다. 주로 긴 헤어가 해당합니다.

#### case3.back

![back](https://mod-file.dn.nexoncdn.co.kr/bbs/1685685577670201094e012274eb19907cfcb18577e89.png)

1. NoCap 헤어의 뒷모습을 그릴 수 있는 레이어와 모자 샘플이 포함되어 있습니다. [모자 만들기](/docs?postId=592) vslot의 3번 유형에 해당하는 모자 샘플입니다.
  - **guide_cap_samples**: 기본 헤어로 머리 모양이 변하지 않는 모자 샘플이 포함되어 있습니다.
  - **edithere:back_backHair_91**: 헤어의 뒷모습을 그릴 수 있는 레이어입니다. 앞모습에서는 별도의 레이어에 그린 긴 머리를 함께 그려야합니다
2. WithCap 모자를 썼을 때 눌리는 헤어의 뒷모습을 그릴 레이어와 해당하는 종류의 모자 샘플들이 들어있습니다.
  - **guide_cap_samples**: 헤어를 누르는 종류의 모자 샘플이 포함되어 있습니다. 아래 두 레이어의 같은 모양의 헤어이지만 넓은 모양과 좁은 모양으로 다르게 작업할 수도 있습니다. 샘플처럼 같은 간격으로 그려도 무방합니다. [모자 만들기](/docs?postId=592) vslot의 1, 2번 유형에서 뒷모습의 머리카락 간격을 확인해보세요.![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1646015941633b8506858e9f44000aed41fdb5f5efe41.png)
  - **edithere:back_backHairBelowCapWide_94**: 눌린 헤어의 뒷모습을 그릴 수 있는 레이어입니다. 뒤에서 보이는 긴 머리카락의 간격을 넓게 그립니다.
  - **edithere:back_backHairBelowCapNarrow_95**: 눌린 헤어의 뒷모습을 그릴 수 있는 레이어입니다. 뒤에서 보이는 긴 머리카락의 간격을 좁게 그립니다.
  > **더 알아보기** 모자의 유형에 따라 Wide와 Narrow의 머리 모양을 구분하기도 합니다. 모자의 vslot의 유형 중 뒤통수를 덮는 모자가 적용될 때 제작해야 하는 헤어입니다. 크리에이터의 기획에 따라 넓은 모양과 좁은 모양으로 다르게 작업할 수 있습니다. 제공된 모자 샘플을 착용해 보고 어색하지 않다면 Wide와 Narrow를 동일하게 사용해도 좋습니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1646019003831f716ca8d04f043dc82dfb6646dd13d68.png)

# 제작하기

노란색 레이어에만 이미지 작업을 합니다. 검은색으로 기본 모양을 만든 후 세부 헤어 모양과 컬러를 수정하면 효율적으로 작업할 수 있습니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/168568560935132a94259bdea4729a8de80f5f318ada0.png)

#### 앞모습 그리기

edithere:front_hairOverHead_31, edithere:front_hairBelowBody_84, edithere:front_hair_35, edithere:front_hairShade_46 레이어에 이미지 작업을 합니다.![17](https://mod-file.dn.nexoncdn.co.kr/bbs/164601737197069b5662eaca34060b8ee41ad221a610e.png)

1. edithere:front_hairOverHead_31, edithere:front_hairBelowBody_84 레이어에 **'Pencil tool'**로 기본 모양을 검은색으로 그린 뒤 색상을 변경하고, 세부 헤어 모양을 그립니다. 짧은 헤어일 경우는 몸의 뒤로 배치되는 헤어를 그리는 **edithere:front_hairBelowBody_84** 레이어는 비워둡니다.![12](https://mod-file.dn.nexoncdn.co.kr/bbs/168568563110469b6c925c14447018db3dde23d47ee9a.png)
2. **edithere:front_hair_35** 레이어에 눌린 머리를 두상에 맞게 지워줍니다.![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16856861702113e6be6f4c60f474cb20004a28f6faf56.png)
3. 앞 헤어에는 그림자가 있습니다. **edithere:front_hairShade_46**에 헤어 모양에 맞춰 R:109, G:80, B:49 또는 #6D5031 색상으로 그림자를 그려줍니다. 레이어에 투명도 30% 적용해주면 모든 피부톤에 어울립니다.![14](https://mod-file.dn.nexoncdn.co.kr/bbs/16856862015273a94bd2c09b84f52aa3deaf45a6c8199.png)

#### 엎드린 자세의 헤어 그리기

'case1.front'의 헤어와 동일한 이미지를 사용하면 편리하므로 해당하는 레이어들을 복제해 사용합니다. 복제한 레이어의 이름을 변경하여 작업합니다. 짧은 머리는 그대로 사용하고, 긴 머리는 엎드린 때의 모습을 기준으로 넓게 퍼진 모습으로 그립니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/168568935395427b2788e8cd941e897fee75547b9970b.png)

1. edithere:front_hairOverHead_31 레이어를 복사해 2-a.NoCap(copy from 1-a.NoCap) 폴더로 붙여 넣기 합니다.
2. edithere:front_hair_35 레이어를 복사해 2-a.NoCap(copy from 1-a.NoCap) 폴더로 붙여 넣기 합니다.
3. **edithere:proneStab_hairBelowBody_84** 레이어에 엎드렸을 때 몸 뒤로 배치되는 헤어가 넓게 퍼진 모습을 그려줍니다.![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1685689459920fd561d6ff4fc406498b6eb0ae6ea6190.png)

#### 뒷모습 그리기

edithere:back_backHair_91, edithere:back_backHairBelowCapWide_94, edithere:back_backHairBelowCapNarrow_95 레이어에 이미지 작업을 합니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/1646018647414c1a3589d385249488341053dd0652423.png)

1. edithere:back_backHair_91에 'Pencil tool'로 기본 모양을 검정색으로 그린 뒤 색상을 변경하고, 세부 헤어 모양을 그립니다.![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1685689505332f4c4431c46954bc1b4e4f671835ec0ff.png)
2. edithere:back_backHairBelowCapWide_94 레이어에 눌린 머리를 두상에 맞게 지워줍니다.![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16856895279327b7abfea089946e79eed6a94368c2980.png)
3. 2번을 복사하여 edithere:back_backHairBelowCapNarrow_95에 넣어줍니다. 묶인 뒷머리의 간격을 좁히고 싶을 경우 긴 머리를 지우고 다시 그립니다.![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16457811937535becc03a37664135889302106c115bff.png)

##### 참고 가이드

- [하의 만들기](/docs?postId=584)
- [망토 만들기](/docs?postId=585)
- [상의 만들기](/docs?postId=586)
- [장갑 만들기](/docs?postId=587)
- [신발 만들기](/docs?postId=583)
- [모자 만들기](/docs?postId=592)

Update 2025-11-20 PM 02:03


# 한벌옷 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=100%EB%B6%84&amp;color=green)

# 학습 과정 소개

한벌옷의 제작 방법을 알아봅시다. 한벌옷은 상의와 같은 구조로 구성되어 있으며 상하가 연결된 모든 의상 작업이 가능합니다. [아바타 아이템 제작의 기본 개념](docs/?postId=588)을 참고해 아바타의 기본 개념을 먼저 숙지하길 바랍니다.

# 사전 준비

아이템 제작을 위해선 Adobe Photoshop이 필요합니다. 해당 소프트웨어를 설치한 후 아래 파일을 받아 엽니다.

> **Tip.** 아이템은 아바타 발을 기준으로 최대 120x120 안에서 제작을 권장합니다. ![Examples](https://mod-file.dn.nexoncdn.co.kr/bbs/1677032255514a026c711634c4196ab0b96bc5424e7f9.png)

# 제작 시트 설명

제작 시트는 회색 레이어와 노란색 레이어로 구분되어 있습니다. 4개의 회색 레이어는 이미지를 데이터화하기 위한 data 폴더, 이미지 제작에 도움을 줄 아바타 body 레이어, 가이드용 선 레이어가 있습니다. 회색 레이어는 모두 잠겨있고, 작업 중에 수정은 필요하지 않습니다. 노란색 레이어는 크리에이터가 실제 아이템을 그릴 수 있는 곳입니다.

> **Tip.** 모든 레이어의 이름을 수정하거나 삭제할 경우 아이템을 제작할 수 없습니다. **절대 이름을 변경하지 마세요.**

#### 회색 레이어

포토샵에서 시트를 오픈하면 회색 레이어는 자물쇠로 잠겨 있습니다. 아이템 등록에 관련된 내용으로 변형이 불가한 레이어입니다.

1. **data 폴더** data 폴더는 아이템을 데이터화하기 위해 필요한 폴더입니다. 이미지 제작에는 영향을 주지 않습니다.
  - **data:origin**: 빨간색 점으로 데이터의 중심을 표시합니다.
  - **data:type:Longcoat**: 어떤 종류의 데이터인지 알 수 있습니다.
  - **data:vslot:MaPn**: vslot의 개념은 모자에서만 사용됩니다.
  - **data:use_zmap_preset1**: 아바타를 구성하는 이미지는 층층이 쌓여 만들어집니다. 아바타의 다양한 몸동작을 만들기 위해 몸을 바탕으로 옷, 방패, 무기 순으로 이미지가 층층이 위에 쌓이는 구조입니다. 아이템에 따라 분리된 각 Sprite의 높이가 순서대로 정리된 파일이 zmap입니다.
2. **guide_character_레이어**: 아바타의 샘플 body입니다. 레이어 이름 뒤에 붙은 숫자가 클수록 아래에 배치되는 내부적인 규칙입니다.
3. **guide_grid 레이어**: 작업 영역을 나타내는 레이어입니다. 초록색 선 안에서만 작업해야 합니다.
4. **guide_background 레이어**: 이 레이어의 배경색은 2가지입니다. gray_blue와 gray로 동작마다 다르게 구분되어 있습니다. 이 중 gray_blue 배경이 있는 동작 시트에선 팔이 예외적인 자리에 그려집니다. ![0](https://mod-file.dn.nexoncdn.co.kr/bbs/168560569152022a0080afa5945e6a338edc40ecf2495.png)

#### 노란색 레이어

노란색 레이어에는 크리에이터가 제작할 한벌옷을 그릴 수 있습니다.

- guide_character_backBody_113: 아바타 뒷모습과 팔
  - **edithere:mail_backMailChest_103**: 아바타 뒷모습과 팔 위에 그려지는 옷
- guide_character_summary_78,100: 아바타 몸과 팔, 뒷모습 머리
  - **edithere:mail_mailChest_68**: 아바타 몸과 팔 위에 그려지는 옷
- guide_character_summary_60,62: 아바타 팔
  - **edithere:mailArm_mailArmBelowHead_58,61**: 아바타 팔 위에 그려지는 옷
- guide_character_summary_52,53: 아바타 팔
  - **edithere:mailArm_mailArm_50**: 아바타 팔 위에 그려지는 옷
- guide_character_summary_26,47: 아바타 머리와 팔
  - **edithere:mailArm_mailArmOverHairBelowWeapon_2**5: 아바타 머리와 팔 위에 그려지는 옷
- guide_character_armOverHair_24: 아바타 팔
  - **edithere:mailArm_mailArmOverHair_22**: 아바타 팔 위에 그려지는 옷 ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16856057153095341c6103f9b42a4992a1feee99bbe88.png)

# 제작하기

기본 우주복을 바탕으로 무늬를 지우고 귀여운 민소매 한벌옷을 제작해봅시다.

| 기본 한벌옷 | 민소매 한벌옷 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/168560341854841c7039d6fff4e2bb8c4656c77001cff.png) | ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/168560345801161262e10c2b64268b4637b52cc34aac6.png) |

#### 민소매 만들기

1. 노란색 레이어 3번부터 5번 레이어를 소매를 지워줍니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16856045068945b529e99248f4295afc9dbe1a8249689.png)
  > **더 알아보기** 선택한 레이어의 모든 기본 이미지를 지울 때는 **ctrl + a**로 전체 선택 후 **Delete** 키를 눌러 삭제할 수 있습니다.
2. 노란색 레이어 1번과 2번을 선택하여 이미지 작업을 합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16856049808171f93176089ab4fa68328b6cc295eb013.png)
3. 1번 레이어에서 Pencil tool을 이용해 무늬를 지우고 목 부분과 팔 부분을 다듬어 그립니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1685604996639af0f8d46c1d54e80a4fe8937830f890c.png)
4. 2번 레이어에서 Pencil tool을 선택하고 각각의 동작에 무늬를 지우고 목 부분과 팔 부분을 다듬어 줍니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16856050073062819ed930f434646888db96f17e2c75d.png)

> **Tip.** 소매 부분을 변경하실 때는 기본 규칙과 다른 예외 내용이 있습니다. 자세한 내용은 [상의 만들기](docs/?postId=586)를 참고하세요 시트의 동작 중 **Swing O3, Swing OF, Stab TF, Swim-Fly, Sit**을 그릴 때는 일부 예외적인 법칙을 따라야 합니다. **Swing O3, Swing OF**의 body(팔)은 3번 위치에 있으나 소매는 4번 레이어에 그려줍니다. **Stab TF, Swim-Fly, Sit**의 body(팔)은 4번 위치에 있으나 소매는 6번 레이어에 그려줍니다.
> **Tip.** 소매를 그릴 때는 기본으로 제공하는 우주복의 소매를 찾아 그리면 수월하게 작업할 수 있습니다.

Update 2025-11-17 PM 08:14


# 애니메이션 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

애니메이션 클립 에디터를 이용해 기존의 메이플스토리 월드 애니메이션을 편집하거나 직접 제작한 애니메이션을 월드에 활용할 수 있습니다. 애니메이션 클립 에디터의 구성과 사용 방법을 알아봅시다.

# 애니메이션 클립 에디터 소개

![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1689298030106bf128b54e6924786b59a8721b26d23cf.png)

| 숫자 | 설명 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | **[새로 열기]**, **[추가하기]** 버튼으로 불러온 스프라이트가 배치됩니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 타임라인에 추가한 스프라이트들이 차례로 재생되며 초록 십자선을 기준으로 애니메이션 재생 위치를 확인할 수 있습니다.<br>상단의 Scale 슬라이더를 조절하여 축소하거나 확대해 볼 수 있습니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 편집, 제작한 리소스를 저장하기 위해 사용합니다.<ul><li>이름: 필수 값으로 이름이 없으면 저장되지 않습니다.</li><li>카테고리: 애니메이션 클립이 저장될 카테고리를 선택합니다. 저장 시 선택한 카테고리로 Resource Storage에 저장됩니다.</li><li>설명: 저장할 애니메이션 클립의 설명을 작성할 수 있습니다.</li></ul> |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 애니메이션이 순서대로 나열되는 타임라인 창입니다. 재생 순서는 왼쪽에서 오른쪽입니다.<br>스프라이트 순서를 변경하거나 복사할 수 있습니다. 재생 위치(Offset)을 변경할 수 있고, 재생 속도를 조절할 수 있습니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | <ul><li>RUID 복사: 저장한 애니메이션 클립의 RUID를 복사합니다.</li><li>업로드: 편집, 제작한 애니메이션 클립을 저장합니다.</li></ul> |

# 리소스 불러오기

| Resource Storage | AimationClip Editor |
| --- | --- |
| <li>Scene 옆의 **Resource Storage** 혹은 Panels - Resource Storage를 선택합니다.</li><li>MSW 리소스 - animationclip에서 원하는 애니메이션 클립의 콘텍스트 메뉴를 엽니다.<br>![03](https://mod-file.dn.nexoncdn.co.kr/bbs/16456960832992162cfc946dc41b5bcea1ba1916207e5.png)</li><li>Make Animation Clip을 선택하면 AnimationClip Editor가 열리고 선택한 애니메이션 클립의 모든 스프라이트가 불러와집니다.</li> | <li>**Window - Animation Clip Editor - 새로 열기** 버튼을 누릅니다.<br>![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1645696224908f637e6221fe64268b998d7c5f1441f03.png)</li><li>불러오려는 애니메이션 클립을 선택합니다.</li><li>선택한 애니메이션 클립의 모든 스프라이트를 불러옵니다.</li> |

> **Tip.** 애니메이션 클립을 **Resource Picker**에서 고를 때 이미지 위에 마우스 커서를 올려놓으면 애니메이션이 재생됩니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/16456955254226df46c48334d46d3ba67812d1387132b.gif)

# 오프셋 조정하기

메이플스토리 월드에서 제공하는 애니메이션 클립들의 오프셋 위치는 다릅니다. 어떤 애니메이션 클립은 RUID 값을 입력했을 때 생각했던 것과 다른 곳에 배치될 때가 있습니다. 이는 리소스마다 오프셋 값이 다르기 때문입니다. 특정 애니메이션 클립을 자주 사용한다면 애니메이션을 편집해 오프셋 위치를 정중앙으로 맞출 수 있습니다. 오프셋을 정중앙으로 변경하면 엔티티 배치를 수월하게 할 수 있습니다.

1. 타임라인의 이미지 중 하나를 선택해 초록색 가로, 세로 선이 교차하는 지점에 맞게 **Offset** 값을 조정합니다.
2. 가장 첫 번째의 이미지를 선택하고 **Shift** 키를 누릅니다.
3. 스크롤바를 움직여 마지막 이미지를 선택합니다.
4. **Offset**의 Y 값에 **-70**을 입력합니다.
5. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_anim_play.png)**[재생]** 버튼을 눌러 이미지가 선의 교차 지점에서 재생되는지 확인합니다.
6. 편집한 애니메이션의 이름을 입력하고, **[업로드]** 버튼을 눌러 저장합니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/1689290777042f5a94f531c2c4e9ba9aba655904df826.gif)

오프셋은 색다른 움직임을 표현할 때도 활용할 수 있습니다. 프레임 전체를 수정하는 것이 아니라 특정 프레임 오프셋의 Y값만 변경한다면 점프하는 듯한 애니메이션을 만들 수도 있습니다.

# 프레임 속도 조절하기

하나의 프레임이 재생될 시간을 조절해 같은 스프라이트로 제작한 애니메이션의 재생 속도를 조절할 수 있습니다. 재생 속도 값은 수가 커질수록 느리게 재생됩니다.

| 0.3 | 2.0 |
| --- | --- |
| ![0.3](https://mod-file.dn.nexoncdn.co.kr/bbs/1647569448836918d836f9ef04519bab4799a6bc03399.gif) | ![2.0](https://mod-file.dn.nexoncdn.co.kr/bbs/1647569468680d2f96a8611664549b55bddc28babe088.gif) |

1. 타임라인의 가장 첫 번째 이미지를 선택하고 **Shift** 키를 누릅니다.
2. 스크롤 바를 움직여 마지막 이미지를 선택합니다.
3. **Delay** 값에 **0.3**을 입력합니다.
4. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_anim_play.png)**[재생]** 버튼을 눌러 애니메이션 재생 속도를 확인합니다.
5. 편집한 애니메이션의 이름을 입력하고, **[업로드]** 버튼을 눌러 저장합니다. ![002](https://mod-file.dn.nexoncdn.co.kr/bbs/1689291732468cb763ecbdec1468d9de2d7ce1153afcc.gif)

# 프레임 조정하기

프레임은 애니메이션이 되는 이미지를 늘어놓았을 때 하나의 스프라이프(이미지)를 프레임이라 칭합니다. 타임라인에서는 맨 왼쪽의 스프라이프가 첫 번째 프레임이 되고, 맨 오른쪽의 스프라이프가 마지막 프레임이 됩니다. 프레임을 선택해 애니메이션 재생 순서를 조정할 수 있습니다. 또한 MSW 클립 리소스에 MSW 스프라이트를 추가하거나, 제작한 스프라이트를 추가해 기존과 다른 독특한 애니메이션을 만들 수 있습니다.

프레임 조정은 스프라이트를 선택한 뒤 원하는 위치로 드래그하거나 버튼을 눌러 진행할 수 있습니다. 프레임 조정 버튼 아이콘은 다음과 같습니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1645703702067ee94dc82642b43f4bfd7039e24970f47.png)

| 아이콘 | 설명 |
| --- | --- |
| ![duplicate](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_duplicate.png) | 선택한 스프라이트를 복제해 타임라인 마지막에 추가합니다. |
| ![forward](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_move_forward_01.png) | 선택한 스프라이트를 맨 앞으로 옮깁니다. |
| ![forward](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_move_forward_02.png) | 선택한 스프라이트를 한 칸(프레임) 앞으로 이동시킵니다. |
| ![backwards](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_move_backwards_01.png) | 선택한 스프라이프를 한 칸(프레임) 뒤로 이동시킵니다. |
| ![backwards](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_move_backwards_02.png) | 선택한 스프라이프를 맨 뒤로 옮깁니다. |

#### 변신하는 애니메이션 만들기

하나의 애니메이션 클립과 여러 장의 스프라이트를 추가해 모습이 변하는 몬스터 애니메이션을 만들어봅시다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/164578012706467425729618e4962bbc03bb827cbf967.gif)

1. **[새로 열기]** 버튼을 눌러 **MSW 리소스 - monster - animationclip-4440**를 선택합니다.
2. **[추가하기]** 버튼을 눌러 **monster - sprite-171514, 171518, 171541, 171544**를 선택합니다.
3. 스프라이프를 추가한 뒤, 드래그하여 프레임을 원하는 위치로 움직입니다. ![003](https://mod-file.dn.nexoncdn.co.kr/bbs/1689294966234e70238ff30c74c5bbc6c42c0ee62b076.gif)
4. **이름**을 입력하고, **카테고리**를 **NPC**로 변경한 뒤 **[업로드]** 버튼을 누릅니다.
5. **Resource Storage - animationclip**에서 추가된 애니메이션 클립을 확인합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1689295304237077c76fcb909452bab8c1ed6a261d075.png)

# 나만의 애니메이션 만들기

직접 여러 장의 스프라이트를 제작해 나만의 독특한 애니메이션 클립을 제작할 수 있습니다. 직접 제작한 스프라이트가 없다면, 아래 파일을 받아 진행해봅시다.

[Frame.zip](blob:https://maplestoryworlds-creators.nexon.com/a86d9edc-6ee5-4045-b964-59534225a4be)

1. **Resource Storage - 내 리소스 - sprite - npc**를 선택합니다. 선택한 폴더로 크리에이터의 스프라이트가 저장됩니다.
2. 검색창 왼쪽의 **[+]** 버튼을 눌러 파일을 불러옵니다.
  > **Tip** 한번에 여러 장의 파일을 불러올 수 없습니다.
3. **Window - AnimationClip Editor** 창을 열고, **[추가하기]** 버튼을 클릭합니다.
4. **Resource Picker - 내 리소스 - sprite - npc**에서 스프라이프를 하나씩 선택해 추가합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1689296780181013da160eb024e48bcf68417deccac15.gif)
5. 추가한 스프라이트를 선택하고, 타임라인에 추가합니다.
6. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/AnimationClip_Editor/icon_anim_play.png)**[재생]** 버튼을 눌러 애니메이션을 확인합니다. ![005](https://mod-file.dn.nexoncdn.co.kr/bbs/1689297597848ccfa98fa15054d1a8154e1f7a734a087.gif)
7. **이름**을 입력하고, **카테고리**를 npc로 변경한 뒤 업로드를 누릅니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1689297700213a70ed35a06484eeebae59aac566e2eee.png)

Update 2025-11-20 PM 02:03


# 렉트 타일 제작하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 안내

크리에이터의 월드에 어울리는 특색 있는 렉트 타일을 그리는 방법을 소개합니다. 크리에이터가 사용하기 편한 소프트웨어를 사용해 타일을 제작할 수 있습니다. 이 가이드는 Adobe Photoshop을 사용해 타일을 제작합니다. 제작한 시트는 [아틀라스 활용하기](/docs/?postId=687)를 참고해 이미지를 일정한 크기로 잘라 타일로 활용할 수 있습니다.

##### 참고 가이드

[RectTileMap의 활용](/docs/?postId=589) [아틀라스 활용하기](/docs/?postId=687)

# 타일 종류

월드의 맵을 다채롭게 꾸미기 위해서는 다양한 타일이 필요합니다. 만약 차도를 만든다면 교차로, 막다른 길 같은 길도 제작해야 합니다. MSW에서 나누는 타일 종류는 아래와 같습니다.

1. **기본 타일**: 기본 타일은 두 가지로 나눌 수 있습니다.
  - **패턴이 없는 타일**: 맵을 구성하는 기본 타일로 사용하는 높이가 느껴지지 않는 타일입니다.![tile01](https://mod-file.dn.nexoncdn.co.kr/bbs/1683172461007e5dd537aba3b4c36a7988bc6e051253b.png)
  - **패턴이 있는 타일**: 패턴이 있는 기본 타일입니다. 높이가 느껴지지 않습니다.![Tile02](https://mod-file.dn.nexoncdn.co.kr/bbs/1683172485011d380326979b94099928580e77910ef59.png)
2. **연결 타일**: 두 가지 기본 타일을 사용해 차도, 도보, 오솔길 등을 만들 때 사용합니다.![Tile03](https://mod-file.dn.nexoncdn.co.kr/bbs/1683172563731bbae861a1a4a4e159914605d974e095c.png)
3. **높이 타일**: 플레이어에게 높낮이를 인식하게 하거나, 갈 수 없는 곳으로 인식하게 만들 때 사용합니다.
  - **벽 타일**: 막힌 느낌을 낼 때 사용하는 타일입니다. 작업 시 64px 두 칸을 사용해야 합니다.
  - **계단 타일**: 주로 벽 타일 사이에 배치되어 이동할 수 있는 곳으로 보일 수 있게 작업합니다.

# 사전 준비

기본 타일 1개의 크기는 64x64px입니다. 높이 타일은 타일 종류에 따라 여러 칸을 사용해 그려야 합니다.

> **Tip** 한 캔버스에서 64x64 크기를 미리 볼 수 있습니다. 아래처럼 설정하면 가상의 선이 일정한 간격으로 캔버스에 보입니다. **편집 - 환경설정 - 안내선, 격자 및 분할 영역 - 격자**에서 격자 간격을 **64px**로 설정한 뒤 확인을 누릅니다. ![Tile04](https://mod-file.dn.nexoncdn.co.kr/bbs/1683176857137d50049c253964d4ab7cfed7384c46603.png)

# 기본 타일 그리기

타일을 그릴 때는 연필 툴을 사용해 그립니다. **1px**크기로 설정해 세밀하게 작업하기를 권장합니다.

#### 패턴이 없는 타일

잔디밭으로 사용할 타일을 그려봅시다. 노이즈 효과를 사용해 빠르게 만들 수 있습니다.

1. 타일의 기본색을 캔버스에 그립니다. ![tile05](https://mod-file.dn.nexoncdn.co.kr/bbs/1683177510180846b5f4a72854ca09cb73fe35a50bf25.png)
2. 노이즈를 만들어 기본 색상을 다양하게 만들 수 있습니다. **필터 - 노이즈 추가**를 선택합니다. 분포를 **가우시안**으로 선택해 규칙이 생기지 않게 합니다. ![tile06](https://mod-file.dn.nexoncdn.co.kr/bbs/1683177742296dfce8ee50e7a4ae9b62b58ecd398f650.png)
3. 레이어를 추가하고, 캔버스를 확대해 가장 어두운 색을 **스포이드 도구**를 사용해 추출합니다.
4. 선택한 색상을 기준으로 다양한 색상을 선택해 크리에이터의 기획에 따라 패턴을 그립니다.필요한 경우 새로운 레이어를 추가하고, 꽃, 돌, 벌레 등을 그려 활용할 수 있습니다. ![tile07](https://mod-file.dn.nexoncdn.co.kr/bbs/1683178056930bd6b1b6e43774f0bbad8cd074b5a997c.png)

> **Tip** **패턴 미리보기 기능**을 사용해 타일을 연속으로 배치했을 때 자연스러울지 확인할 수 있습니다. ![tile9](https://mod-file.dn.nexoncdn.co.kr/bbs/168317923354137e1942dea934dcd99a2b073829f8cc3.png)

#### 패턴이 있는 타일

패턴이 있는 타일은 노이즈 효과를 사용하지 않고, 직접 패턴을 확인하며 그리는 것이 좋습니다.

1. 기본색을 캔버스에 칠합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1684213100045b739955101124b2e9c94a4e1f790a164.png)
2. 연필 도구를 사용해 패턴을 그립니다. 다양한 크기의 패턴을 사용하면 좀 더 자연스러운 패턴을 만들 수 있습니다. 사방의 가장자리가 자연스럽게 이어지는지 확인합니다. 타일에 패턴을 그릴 때는 불규칙적인 모양으로 그리는 것을 권장합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16842125974123f276d4479a1433c9fb49407ad3ec8fa.png)
3. 패턴이 자연스럽게 이어지면, 다양한 색을 사용해 좀 더 다채롭게 보이게 수정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1684212623125803ddf134ed84e8ba260cc08d9ab2d6b.png)
4. 경계가 흐리면 외곽선에 사용한 색을 좀 더 어두운 색을 사용합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1684213063427fd9e3ff1e8c54d09b587c485d32ddc6e.png)

#### 연결 타일

도로, 오솔길 같은 길을 만들기 위해서는 최소 12개의 타일이 필요하며, 크리에이터의 의도에 따라 더 필요할 수도 있습니다. 12개의 타일은 9개, 4개씩 정사각형 모양으로 모아 그리면 수월하게 작업할 수 있습니다. 연결 타일을 그릴 때는 레이어 한 개를 사용하는 것보단, 여러 개의 레이어를 사용해 적절히 타일을 나누어 그리는 것이 좋습니다. 또한, 이어지는 타일을 만들 때 캔버스 크기를 더 크게 만들어, 남는 여유 공간에 제작한 타일을 이리저리 응용해 배치해보며 타일들이 어울리는지 확인하는 작업을 거치는 것을 추천합니다.

1. 12칸에 모두 제작한 기본 타일들을 각각의 레이어에 옮겨 그립니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16841253385017f35e462522443939954b1c45e9af49b.png)

> **Tip.** 사각형 도구를 이용해 제작한 타일을 손쉽게 추가할 수 있습니다. 사각형 선택 윤곽 도구(M) - 복사(Ctrl+C) - 붙여넣기(Ctrl+V)

1. 빈 레이어를 추가하고, 사각형 도구를 사용해 9개의 타일 안쪽에 지울 영역을 설정합니다. ![tile12](https://mod-file.dn.nexoncdn.co.kr/bbs/1683600217782267bb2460a3648d795ae8035dbfc6943.png)
2. 사각형 선택 윤곽 도구를 활용해 기본 타일 레이어에서 작은 사각형 범위를 선택합니다. Delete를 눌러 안쪽을 지웁니다. ![tile14](https://mod-file.dn.nexoncdn.co.kr/bbs/16836003085094e6f0e1c4b384cd79fa4883cf8baf54a.png)
3. 두 타일이 만나는 경계가 자연스럽게 이어지도록 기본 타일 레이어에서 그림자를 그립니다.
4. 4칸의 타일 안쪽에 지울 영역을 사각형 도구를 이용해 그립니다. 중앙에 작게 그리는 것이 좋습니다. ![tile15](https://mod-file.dn.nexoncdn.co.kr/bbs/16837929814178a2fa1b9d3a84089811d9668aa1abd79.png)
5. 기본 타일 레이어에서 사각형 바깥 영역을 지웁니다. 타일이 겹치는 부분이 자연스럽게 이어지도록 그림자를 그립니다. ![tile15](https://mod-file.dn.nexoncdn.co.kr/bbs/1683792351851bdf013fb85324732ba72cacad615b344.png)

> **더 알아보기** 시트의 여유 공간에 사각형 선택 도구를 활용해 제작한 연결 타일들을 미리 다양하게 배치해볼 수 있습니다. 다양하게 조합해 그린 타일들이 모두 자연스럽게 이어지는지 확인하고 수정할 수 있습니다.. ![Tile03](https://mod-file.dn.nexoncdn.co.kr/bbs/1683172563731bbae861a1a4a4e159914605d974e095c.png)

# 높이 타일 그리기

크리에이터의 의도에 따라 높이 타일을 제작해 입체감이 느껴지는 맵을 제작할 수 있습니다. 벽 타일과 계단 타일 제작 방법을 소개합니다. 높이 타일 크리에이터의 의도에 따라 응용하여 그릴 수 있습니다.

#### 벽 타일

벽 타일은 아래와 같은 순서로 그립니다 ![tile17](https://mod-file.dn.nexoncdn.co.kr/bbs/16837937290502fb16601298145539698b1e606f50ad4.png)

1. 배경색을 캔버스에 그립니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/168379507952663b08c218c404a698ed06d5d712c239d.png)

높이 타일은 2칸을 한 타일을 만드는 기준으로 생각하고 그립니다. 이때 칸 전체를 꽉 채워 그리기보다 위, 아래 4-6px 여백을 만들어 그리는 것을 권장합니다. 타일 칸 전체를 꽉 채워 제작하면 캐릭터와 타일이 겹칠 때 공간감이 어색해지기 때문입니다. ![tile17](https://mod-file.dn.nexoncdn.co.kr/bbs/1683793076682f42c6e4d211249a085896ac4d968d131.png)

1. 브러쉬, 연필 툴을 사용해 타일을 그립니다. 벽의 윗부분이 될 부분을 남기고 앞에서 봤을 때 보이는 부분을 먼저 그립니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1683799584550110a5602bd174daab81d06aefb44885a.png)
2. 사물을 위에서 내려봤을 때를 생각해 그려야 합니다. 돌담의 경우 돌담의 가장 윗부분이 함께 보여야 합니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/168380235708851a9316b524646f78d3730eda72853bb.png)
3. 패턴 미리보기 기능을 활성화 합니다. 타일이 이어서 배치되었을 때 어색한 부분이 있는 지 확인합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1683799652780e101c88d4935443d8ffa868750dd2818.png)
4. 패턴이 자연스럽게 이어지는지 확인했다면, 타일에 명암을 나타나게 색을 칠합니다. 윗부분은 밝은 색, 아래는 어두운 색으로 칠해 명암을 나타냅니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16838017207928e91a3c7af2a4bfb9f90261110122226.png)
5. 그림자와 풀을 그려 마무리합니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16838027731038ea6a3aeb2684b818debeb2de2fe1dff.png)

#### 계단 타일

계단은 다른 타일과 이어 사용하는 경우가 많습니다. 벽으로 사용하는 타일과 함께 자주 사용되므로 함께 사용했을 때 적절히 잘 어울리는지 확인하며 그리는 것이 좋습니다. 이번에는 벽 타일 사이에 들어가는 계단 타일 그리는 법을 살펴봅시다.

1. 제작한 벽 타일을 양쪽에 배치하고가운데 지정한 배경색으로 사각형을 그립니다. 사각형은 양 벽 타일 대비 안쪽으로 만드는 것이 좋습니다. ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/16838048081190e727c53a86f461cb048285a5692503b.png)
2. 배경색보다 약간 어두운 색상의 연필 도구로 계단 형태를 그립니다. ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/1683805578337318af7a249044751bcd3c360ffbccb91.png)
3. 계단의 윗쪽은 밝게, 아랫쪽은 어둡게 그리며 계단에 명암을 나타냅니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/1683806374729a2adb6d3cbb14d02a8cc06ade600f063.png)

> **더 알아보기** 다양한 형태의 높이 타일을 만들어 아래와 같이 활용할 수 있습니다. ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/16841254749616f0d753209764215945f389c15eac91c.png)

Update 2025-11-17 PM 08:15


# 프로파일러로 월드 성능 분석하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드의 루아 프로파일러가 스크립트를 중점적으로 분석하는 도구라면 성능 프로파일러(이하 프로파일러)는 현재 월드의 성능에 영향을 미칠 수 있는 요인들에 대해 전반적인 분석 결과를 보여줍니다. 프로파일링을 통해 월드 성능을 저하시키는 요인을 파악할 수 있고 이를 해결하여 월드 성능을 향상시킬 수 있습니다. 이번 과정에서는 프로파일러의 실행 및 사용 방법, 그리고 데이터 분석 결과를 해석하는 방법을 살펴보겠습니다.

##### 참고 가이드

[루아 프로파일러 활용하기](/docs/?postId=762)

# 프로파일러 실행하기

메이커에서 **Panels - Profiler**로 들어가면 프로파일러를 실행할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1689323157908f695d8d7daab4e6ca5b9a94148205fc1.png)

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 눌러 플레이 상태로 진입한 뒤, 프로파일러의 **[분석 레코드]** 버튼을 누르면 기록이 시작되며, 한 번 더 누르면 기록이 중지됩니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1689323138212ef0142ece16f49dc939fcd1bb58e7b51.png)

> **더 알아보기** 프로파일러 기록 중 정적 맵에서 인스턴스 맵으로 진입하거나, 반대로 인스턴스 맵에서 정적 맵으로 나오면 기록이 초기화됩니다.

# 프로파일러 살펴보기

프로파일러 UI를 자세히 살펴봅시다. ![ui](https://mod-file.dn.nexoncdn.co.kr/bbs/1689748450026758f03f4c54c42338295dfa5bfd4a04a.png)

| 대분류 | 번호 | 항목 | 설명 |
| --- | --- | --- | --- |
| ①<br>분석 컨트롤 영역 | 1-1 | Clear | 이전에 기록된 분석 결과를 초기화합니다. |
| 1-2 | 분석 레코드 | 분석 기록을 시작합니다. 한 번 더 누르면 기록을 중지합니다. |
| 1-3 | 가장 오래된 타임라인 | 첫 타임라인으로 이동합니다. |
| 1-4 | 이전 타임라인 | 선택한 타임라인보다 바로 앞으로 이동합니다. <br>`Left Arrow` 키로도 이동할 수 있습니다. |
| 1-5 | 다음 타임라인 | 선택한 타임라인보다 바로 다음으로 이동합니다. <br>`Right Arrow` 키로도 이동할 수 있습니다. |
| 1-6 | 현재 타임라인 | 가장 마지막 타임라인으로 이동합니다. |
| 1-7 | Timeline Indexes | 타임라인 인덱스를 보여줍니다. |
| 1-8 | Profiler Config | ![config](https://mod-file.dn.nexoncdn.co.kr/bbs/168956161350735b564735a634ee1b5fc873165db74c7.png)<br>분석 차트 영역 설정 창입니다.<ul><li>X Axis Size : X축에 보이는 인덱스 개수를 설정합니다.</li><li>Fill Chart : 그래프 채우기</li></ul> |
| 1-9 | 카테고리 | <ul><li>Client : 클라이언트 영역의 분석 차트를 보여줍니다.</li><li>Server : 서버 영역의 분석 차트를 보여줍니다.</li></ul> |
| ②<br>분석 차트 영역 | 2-1 | 분석 항목 정보 | 분석 항목을 보여줍니다. |
| 2-2 | 차트 | 분석 항목 별 차트가 기록되는 영역입니다. |
| 2-3 | 타임라인 선택 | <ul><li>마우스 왼쪽 클릭으로 원하는 타임라인을 선택할 수 있습니다.</li><li>마우스 오른쪽 클릭한 상태로 좌우 이동하면 그래프를 이동하며 볼 수 있습니다.</li><li>마우스 휠을 클릭한 상태로 왼쪽으로 이동하면 그래프가 축소되고 오른쪽으로 이동하면 확대됩니다.</li></ul> |
| 2-4 | 정보 툴팁 | 차트에 마우스 오버하면 툴팁으로 해당 타임라인의 상세 정보를 확인할 수 있습니다. |
| 2-5 | 가이드라인 | <ul><li>안정적인 성능을 위해 권장하는 수치 정보를 가이드라인(하늘색 선)으로 보여줍니다.</li><li>가이드라인에 마우스를 올리면 툴팁으로 상세 정보를 확인할 수 있습니다.</li></ul> |
| ③<br>분석 결과 영역 | 3-1 | 분석 상세 정보 | <ul><li>2-1에서 선택한 항목의 상세 분석 결과를 보여줍니다.</li><li>고정 항목 이외에 추가로 추적하려는 항목은 **Chase** 체크박스를 활성화하여 기록할 수 있습니다.</li></ul> |
| 3-2 | 검색 | <ul><li>검색어와 일치하는 항목을 표시합니다.</li><li>영어 대소문자는 구분하지 않습니다.</li><li>**[X]** 버튼을 누르면 입력된 검색어를 모두 지웁니다.</li></ul> |
| 3-3 | 결과 펼치기 / 접기 | 분석 결과를 모두 펼치거나 접을 수 있습니다. |

# 데이터 분석

유저가 각각 사용하는 PC, 모바일 기기의 사양이 매우 다양하기 때문에 같은 월드라도 플레이 환경의 쾌적함 정도는 상당히 달라질 수 있습니다. 하지만 대략적으로 분석 수치가 아래와 같을 경우 해당 월드의 성능을 어느 정도 판단할 수 있습니다. 아래의 수치는 대략적인 참고값으로 활용할 수 있으며, 그 이전에도 체감되지 않는 성능 하락은 발생할 수 있습니다.

### FPS (Client)

FPS는 클라이언트에서 측정하는 요소로 반응성 및 화면 재생과 관련이 있습니다.

- 플레이할 때 화면 재생에 영향을 미칩니다. FPS가 떨어지면 화면 끊김이 발생할 수 있습니다.
- 최소 30FPS를 유지하는 것을 권장합니다.

| 항목 | 설명 |
| --- | --- |
| World FPS | <ul><li>크리에이터의 로직을 처리하는 월드 코어의 FPS를 보여줍니다.</li><li>비효율적인 로직, 과도한 Sync Property, 실행 제어를 통해 다른 실행 공간의 함수를 호출하는 등 다양한 원인에 의해 FPS가 떨어질 수 있습니다.</li></ul> |
| Engine FPS | <ul><li>주로 입력, 네트워킹, 그래픽을 연산하는 엔진의 FPS를 보여줍니다.</li><li>엔티티의 양이 너무 많거나, 과도한 이펙트 및 파티클을 사용하는 경우에 Engine FPS가 크게 떨어질 수 있습니다.</li></ul> |

### Tick (Server)

Tick은 서버의 초당 연산 수행 횟수를 보여주는 수치로 서버와 통신 반응성에 큰 영향을 미칩니다.

- Server Tick이 낮아질수록 Ping(네트워크 지연 시간)이 높아진 것과 비슷하게 느껴질 수 있습니다.
- 월드의 비효율적인 로직, 과도한 Sync Property, 다른 실행 공간 사용 및 잘못된 로직으로 발생한 패킷 홍수로 Server Tick이 떨어질 수 있습니다.
- PvP나 대전 장르와 같이 반응성이 중요한 경우, 최소 30 Server Tick을 유지하기를 권장합니다.
- 실시간 반응성이 크게 중요하지 않은 월드라면 최소 10 Server Tick을 유지하기를 권장합니다.
- Server Tick이 높을수록(최대 60Tick) 서버 반응성이 좋아집니다.

> **더 알아보기** 패킷 홍수(Packet Flodding)란 매우 많은 양의 패킷(초당 약 10만 개 이상)이 송신 또는 수신되는 것을 말합니다. 클라이언트나 메이커에서 테스트 플레이를 하는 도중에는 더 적은 양의 패킷도 성능에 영향을 줄 수 있습니다. 패킷 홍수는 주로 매 프레임이나 Tick마다 다른 실행 공간의 함수를 호출하는 경우 쉽게 발생합니다. ![packet](https://mod-file.dn.nexoncdn.co.kr/bbs/1689732427563cd559f693ea145369ebb2c7a75cd1e0d.png) 위 그림은 User1의 정보가 다른 User2, User3에게 전달되고, User2와 User3의 정보도 각각 다른 유저들에게도 전달될 때 대략적인 패킷 전달 모습입니다. 위의 상황은 한 프레임 또는 Tick 당 유저 한 명이 한 번의 패킷을 발생시킨 경우이지만 한 프레임에 여러 번을 호출한다면 패킷량은 더욱 늘어납니다. 패킷 홍수는 싱글 플레이보다는 다수의 유저가 함께 플레이할 때 확인되는 경우가 많습니다. 패킷 홍수의 대표적인 원인과 해결 방법은 다음과 같습니다. - **TargetUserId를 사용하지 않은 경우**  - TargetUserId를 통해 특정 User에게만 함수를 호출하여 필요하지 않은 함수 호출을 줄입니다.  - 자세한 내용은 [Effective MSW 1](/docs/?postId=559) 가이드에서 "특정 클라이언트에만 응답 보내기" 내용을 참고해 봅시다. - **클라이언트 값을 동기화 해야 하는 경우**  - 클라이언트 값을 서버를 통해 다른 유저들이나 다른 공간 함수 호출로 동기화해야하는 경우가 있습니다.  - 이때, 서버에서 동기화하기 보다는 Sync Property로 대체하거나, 한 Tick에 다른 클라이언트의 값들을 함께 모아서 한 번의 함수 호출로 전달해봅시다. 동기화 횟수를 줄이면 패킷 홍수 해결에 도움이 됩니다.

### Memory

클라이언트에서 사용되는 메모리 사용량을 보여줍니다. 메모리 사용량이 너무 많아지지 않게 관리하는 것이 좋습니다. 특히 모바일 환경에서는 메모리 사용량이 1GB를 넘어가면 메이플스토리 월드가 강제 종료되는 문제가 발생할 수 있습니다.

### Entity

맵 별, UI 그룹 별 엔티티의 총 개수와 엔티티 생성 / 파괴 횟수를 보여줍니다. 엔티티의 생성 / 파괴가 자주 발생하면 전반적인 성능에 좋지 않습니다. 기기의 사양마다 다르지만 모바일 환경에서는 엔티티가 5000개 이상일 경우 성능 저하 현상이 발생할 수 있습니다. 그러므로 엔티티의 개수는 5000개 이하로 관리하는 것이 좋습니다.

| 항목 | 설명 |
| --- | --- |
| Total Entity | 현재 월드에 생성된 모든 엔티티의 개수입니다.<ul><li>Client<ul><li>User Entity가 존재하는 맵 이외의 다른 맵은 불러오지 않습니다.</li></ul></li><li>Server</li><ul><li>메이커에서 테스트 플레이를 할 때, User Entity가 한번이라도 이동했던 맵은 불러온 뒤 다시 파괴하지 않습니다.</li><li>실제 서버는 최초 실행 시 모든 맵의 엔티티를 불러옵니다.</li></ul></ul> |
| Construct / Destroy Entity | <ul><li>엔티티가 생성 및 파괴된 개수를 보여줍니다.</li><li>맵 단위로 엔티티가 이동하는 경우, 실제 엔티티가 생성 / 파괴되지 않더라도 개수를 세고 있습니다. 이는 향후 개선 예정입니다.</li><li>이펙트, 파티클, 대미지 스킨의 파괴 또는 생성 횟수도 기록될 수 있으나 풀링(Pooling)되고 있기에 성능에 큰 영향을 미치지 않습니다.</li></ul> |

> **Tip.** 풀링(Pooling)이란 오브젝트 풀링(Object Pooling)을 의미합니다. 오브젝트를 미리 생성해두고 재사용함으로써 성능을 향상시키는 방법을 말합니다.

##### 엔티티 관련 성능 저하 개선

엔티티로 인해 월드 성능이 저하될 경우 아래의 방법으로 개선할 수 있습니다.

- **엔티티 개수가 많은 경우** 클라이언트 측면에서 엔티티 개수가 너무 많으면 World FPS 뿐만 아니라 Engine FPS에도 악영향을 끼칠 수 있습니다. 만약 UI에 배치된 엔티티가 많다면 개별 UI 엔티티가 아니라 UI 그룹을 Disable 처리해 봅시다. Engine FPS 성능을 향상시킬 수 있습니다. | UI Entity Disable | UI Group Disable |
| :---: | :---: | | ![ui01](https://mod-file.dn.nexoncdn.co.kr/bbs/16897413642185c6ae74a889e4a9e9a77f12573388e67.png) | ![ui02](https://mod-file.dn.nexoncdn.co.kr/bbs/168974137819127d563f222d94d33815194e818333c02.png) | 서버 측면에서 엔티티의 개수가 너무 많으면 Tick에 영향을 줄 수 있습니다. 또한 공개된 게임에서 서버를 새로 생성해야 하는 경우에는 초기화 과정이 오래 걸릴 수 있습니다. 엔티티의 개수를 줄이는 것이 가장 좋은 방법입니다.
- **엔티티 생성 / 파괴 횟수가 많은 경우** 엔티티의 과도한 생성과 파괴는 월드 성능에 좋지 않은 영향을 미칩니다. 오브젝트 풀링을 통해 성능에 미치는 영향을 줄일 수 있습니다.

### Execute Space Count

다른 실행 공간의 함수를 호출하는 경우, 즉 클라이언트에서 서버 함수를 호출하거나 서버에서 클라이언트 함수를 호출하는 횟수를 보여줍니다.

| 항목 | 설명 |
| --- | --- |
| Send Count | 다른 실행 공간의 함수 호출 송신 횟수입니다. |
| Receive Count | 다른 실행 공간의 함수 호출 수신 횟수입니다. |

##### Execute Space Count 관련 성능 저하 개선

Execute Space Count가 많아지면 FPS나 Tick에 악영향을 끼칠 수 있습니다. 시간이 오래 걸리는 함수를 과도하게 호출하지 않도록 수정해야 합니다. 특히 Execute Space Count가 많아지면 패킷 홍수가 발생하여 서버 단에서 패킷 밀림 현상이 생길 수 있으므로 주의해야 합니다.

### Execute Space Byte

다른 실행 공간의 함수를 호출할 때의 데이터량을 보여줍니다. 보통은 Execute Space Count에 비례하여 증가합니다. 하지만 클라이언트에서 Count는 낮은데 Byte만 높은 경우도 있습니다. 인터넷 회선이 불안정한 환경에서는 FPS가 높아도 움직임이 밀리거나 끊기는 듯한 모습을 볼 수 있습니다. 한 번에 전달되는 데이터의 크기와 전달 횟수를 줄이면 이러한 현상을 개선할 수 있습니다.

| 항목 | 설명 |
| --- | --- |
| Send Byte | 다른 실행 공간의 함수 호출 송신 데이터량입니다. |
| Receive Byte | 다른 실행 공간의 함수 호출 수신 데이터량입니다. |

### Sync Property Count

Sync Property의 동기화 횟수입니다.

| 항목 | 설명 |
| --- | --- |
| Send Count | 컴포넌트 단위의 동기화 및 프로퍼티 별 동기화 송신 횟수입니다. |
| Receive Count | 컴포넌트 단위의 동기화 및 프로퍼티 별 동기화 수신 횟수입니다. |

##### Sync Property Count 관련 성능 저하 개선

Sync Property Count가 많아지면 FPS나 Tick에 악영향을 끼칠 수 있습니다. Sync Property는 None-Sync Property와 달리 내부적으로 동기화 로직을 거칩니다. 너무 많은 Sync Property를 사용하면 월드 성능이 나빠질 수 있습니다. 그러므로 동기화가 필요하지 않은 프로퍼티는 None-Sync로 변경해야 합니다. 또한 모든 User에게 동기화할 필요가 없다면 다른 실행 공간 함수의 TargetUserId를 사용하여 동기화량을 줄일 수 있습니다.

### Sync Property Byte

Sync Property의 동기화 데이터량입니다.

| 항목 | 설명 |
| --- | --- |
| Send Byte | 컴포넌트 단위의 동기화 및 프로퍼티 별 동기화 송신 Byte입니다. |
| Receive Byte | 컴포넌트 단위의 동기화 및 프로퍼티 별 동기화 수신 Byte입니다. |

### TimerService

Timer Service를 이용한 타이머의 생성 / 파괴 정보입니다.

| 항목 | 설명 |
| --- | --- |
| Total Timer | 현재 동작하거나 대기 중인 타이머 개수입니다. |
| Add Timer | <ul><li>생성된 타이머의 개수와 생성 위치를 보여줍니다.</li><li>Effect Service를 사용하는 Effect 또한 내부적으로는 Timer를 사용하고 있기에 개수에 포함됩니다. 단, 호출 위치는 보이지 않습니다.</li></ul> |
| Remove Timer | 삭제된 타이머의 개수입니다. |

##### TimerService 관련 성능 저하 개선

Total Timer가 증가하고 계속 쌓이면 FPS나 Tick에 악영향을 끼칠 수 있습니다. 주로 타이머를 일시 정지한 뒤 제거하지 않았거나, 무한 반복되는 타이머를 생성한 뒤 제거하지 않았을 때 Total Timer가 증가합니다. 그러므로 isRepeat을 true로 설정한 `TimerService:SetTimer()` 함수를 사용하거나, `TimerService:SetTimerRepeat()` 함수로 생성된 타이머를 명시적으로 제거해야 합니다. Total Timer가 300개 이상이면 월드 성능이 저하될 수 있으므로 Timer 개수가 과도하게 늘어나지 않도록 관리해봅시다.

### Tween Logic

Tween Logic과 관련된 Tweener의 생성/파괴 정보입니다.

| 항목 | 설명 |
| --- | --- |
| Total Tween | 현재 존재하는 Tweener 개수입니다. |
| Add Tween | 생성된 Tweener 개수 및 생성 위치를 보여줍니다. |
| Remove Tween | 삭제된 Tweener 개수입니다. |

##### Tween Logic 관련 성능 저하 개선

Total Tween 개수가 증가하고 계속 쌓이면 FPS나 Tick에 악영향을 끼칠 수 있습니다. 이러한 문제는 Tweener의 **AutoDestroy** 프로퍼티 값을 **false**로 설정한 뒤 명시적으로 파괴해주지 않을 때 발생합니다. 그러므로 **AutoDestroy**를 **false**로 설정한 Tweener의 사용이 끝난 후에는 별도로 재사용하거나 파괴해야 합니다. Total Tween이 300 이상이면 화면 순간 끊김이나 FPS가 하락하는 등 월드 성능이 저하될 수 있으므로 Tweener 개수가 과도하게 늘어나지 않도록 관리해봅시다.

Update 2025-11-17 PM 08:15


# 루아 프로파일링 요약 보고서

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

루아 프로파일링 요약 보고서에서 어떤 정보가 제공되는지 살펴봅시다.

##### 참고 가이드

[루아 프로파일러를 활용하여 최적화하기](/docs/?postId=762)

# 루아 프로파일링 요약 보고서

루아 프로파일러에서 **File - Export Report**를 클릭하면 루아 프로파일링 요약 리포트를 XML로 Export할 수 있습니다. 다음은 요약 리포트에서 제공되는 정보 목록입니다.

| 항목 | 설명 |
| --- | --- |
| Name | 콘텍스트 이름 |
| FrameCount | 계측된 프레임 수 |
| StartTime | 프로파일링 시작 Tick |
| EndTime | 프로파일링 종료 Tick <br><ul><li>Tick은 10ns 단위</li><li>프로파일링 시간은 (EndTime - StartTime) / 10,000,000 초로 계산 될 수 있음</li></ul> |
| AvgElapsedTime | 프레임 당 평균 소요 시간 (단위 ms) |
| PeakElapsedTime | 최대 프레임 소요 시간 (단위 ms) |
| AvgNetworkSend | 프레임 당 평균 네트워크 전송량 (단위 byte) |
| PeakNetworkSend | 한 프레임에서 최대 네트워크 전송량 (단위 byte) |
| AvgNetworkRecv | 프레임 당 평균 네트워트 수신량 (단위 byte) |
| PeakNetworkRecv | 한 프레임에서 최대 네트워크 수신량 (단위 byte) |
| AvgManagedObjectCount | 루아에서 관리되는 오브젝트 수의 평균 |
| PeakManagedObjectCount | 루아에서 관리되는 최대 오브젝트 수 |
| AvgTotalLuaMemory | 루아에서 사용 중인 메모리 양의 평균 (단위 byte) |
| PeakTotalLuaMemory | 루아에서 사용 중인 최대 메모리 양 (단위 byte) |
| SampleSummary | 각 샘플의 프로파일링 요약 호출 트리 |

# 샘플의 프로파일링 요약

다음은 SampleSummary에서 제공되는 정보 목록입니다.

| 항목 | 설명 |
| --- | --- |
| Name | 샘플의 이름 |
| Category | 샘플의 종류 |
| CallCount | 호출 횟수 |
| AvgElapsedTime | 샘플의 평균 실행 소요 시간 (단위 ms) |
| PeakElapsedTime | 샘플의 최대 실행 소요 시간 (단위 ms) |
| AvgSelfElapsedTime | 자식 샘플의 실행 시간을 제외한 샘플의 평균 실행 소요 시간 (단위 ms) |
| PeakSelfElapsedTime | 자식 샘플의 실행 시간을 제외한 샘플의 최대 실행 소요 시간 (단위 ms) |
| AvgLuaMemory | 평균 Lua memory 할당 양 (단위 byte) |
| PeakLuaMemory | 최대 Lua memory 할당 양 (단위 byte) |
| AvgSelfLuaMemory | 자식 샘플에서 할당한 Lua memory 양을 제외한 평균 Lua memory 할당 양 (단위 byte) |
| PeakSelfLuaMemory | 자식 샘플에서 할당한 Lua memory 양을 제외한 최대 Lua memory 할당 양 (단위 byte) |
| AvgNetworkUsage | 평균 네트워크 전송양 (단위 byte) |
| PeakNetworkUsage | 최대 네트워크 전송양 (단위 byte) |

Update 2025-11-17 PM 08:15


# 루아 프로파일러를 활용하여 최적화하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

제작한 게임을 플레이하다 보면 다양한 상황에서 느려지는 것을 경험할 수 있습니다. 이처럼 게임의 처리 속도에서 부하가 걸리는 병목 지점(Bottleneck)을 찾아 수정하는 것을 최적화라고 합니다. 일부 병목 지점만 해결해도 게임의 전체적인 성능 향상을 기대할 수 있기 때문에 최적화는 상당히 중요한 작업입니다. 루아 프로파일러는 이러한 스크립트 최적화 작업을 더욱 손쉽게 진행할 수 있도록 도와줍니다. 이번 시간에는 **루아 프로파일러**가 무엇인지 알아보고 활용법을 살펴보도록 합시다.

**더 알아보기**

> 루아 프로파일러를 사용하기 위해서는 최신 업데이트된 윈도우7 이상의 운영체제를 필요로 합니다. 또한 `.NET Core 3.1 Desktop Runtime` 이상의 버전을 설치해야 합니다. 루아 프로파일러를 실행할 수 없다면 [.NET Core 3.1 Desktop Runtime](https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/runtime-desktop-3.1.27-windows-x64-installer) 설치 후 다시 시도해보세요.

##### 참고 가이드

[루아 프로파일링 요약 보고서](docs/?postId=1046)

# 루아 프로파일러 소개

## 루아 프로파일러 실행

### 제작 중인 월드에서 실행

게임 만들기 화면에서 **Window - Lua Profiler**를 누르면 루아 프로파일러가 실행됩니다. ![profiler1](https://mod-file.dn.nexoncdn.co.kr/bbs/16588152380315f27ceb0abf148f5952f65813e870f7f.png)  ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) 시작을 누르고 플레이 상태에서 루아 프로파일러의 **[Recording]** 버튼을 누르면 기록이 시작됩니다. 이미 플레이 테스트 중인 상태로 루아 프로파일러를 실행하면 실행 즉시 기록이 시작됩니다. ![ui](https://mod-file.dn.nexoncdn.co.kr/bbs/16599472883762d82c3ab3435482ab40812db3ef2c76f.gif)

### 배포된 게임에서 실행

배포된 게임을 플레이할 때도 루아 프로파일러를 실행할 수 있습니다.

1. 먼저 게임 우측 상단의 설정 버튼을 누릅니다. ![setting](https://mod-file.dn.nexoncdn.co.kr/bbs/1659057882093e645caa2c4204a45828e93b96a599f60.png)
2. 기타 탭을 선택한 후 **Lua Profiler 사용**을 켜고 **Lua Profiler 실행** 버튼을 누르면 루아 프로파일러가 실행되면서 바로 기록이 시작됩니다. ![setting2](https://mod-file.dn.nexoncdn.co.kr/bbs/165905803015405f2966f34094161937c4055c7268b0a.png)

## 루아 프로파일러 살펴보기

루아 프로파일러 UI를 자세히 살펴봅시다. ![profilerUI](https://mod-file.dn.nexoncdn.co.kr/bbs/165968854387833959c5ede1d42b59fbac5dc06f301f3.png)

### ① File

![file](https://mod-file.dn.nexoncdn.co.kr/bbs/168413955956620e175ed60fa4ea180d5c1dc01a99bbb.png)

- **Load / Save** : 프로파일링으로 수집한 데이터를 XML로 저장하거나 불러올 수 있습니다.
- **Export Report** : [루아 프로파일링 요약 보고서](/docs/?postId=1046)를 XML로 Export할 수 있습니다.
- **Options** ![option](https://mod-file.dn.nexoncdn.co.kr/bbs/1658887084903492a0fe98e0f4f3381e0f12434ac2320.png) | 목록 | 하위 목록 | 설명 |
| :---: | :---: | --- | | Record Max Frames | - | 기록이 많이 쌓이면 루아 프로파일러가 느려집니다. 그래서 지정한 프레임 수 이상으로 기록되면 이전 데이터를 버리도록 처리하고 있습니다. 기본값은 1,000프레임인데 1초에 60프레임이라 가정하면 약 16초 정도 기록되는 것입니다. 더 길게 기록하고 싶다면 프레임 수를 변경해봅시다. | | Record Timeline Max Seconds | - | 타임라인 차트에서 데이터를 저장할 최대 시간입니다. | | Active Module | Execution Time | 함수 혹은 Scope의 실행 시간입니다. <br>실행 시간은 지표에 가장 중요한 부분이므로 반드시 측정해야 합니다. | | Native scope | 스크립트가 사용되지 않은 Native 영역의 시간을 측정합니다. | | Memory | 함수 혹은 Scope가 실행되는 동안 발생한 Lua Memory Allocation Size입니다. | | Network | 함수 혹은 Scope가 실행되는 동안 발생한 Network Write입니다. <br>실행 제어 호출이 대부분이며 다른 스레드에서 발생한 Network Write가 기록되는 경우도 있습니다. |

### ② Connect / Disconnect

- 루아 프로파일러는 플레이 중인 게임에 접속하여 데이터를 수집하는 형태로 동작합니다.
- Disconnect 버튼을 누르면 루아 프로파일러의 게임 접속이 종료됩니다.

### ③ Context

- Context는 Core에서의 실행 흐름을 뜻합니다.
- Server, Client, Instance, Editor 등의 Context 중에서 선택할 수 있습니다.
- Context를 선택하면 ⑤ 차트 영역과 ⑨ 프로파일링 결과 영역에서 데이터를 확인할 수 있습니다.

### ④ 그래프 선택

- **Elapsed Time, Network Send, Network Receive, Lua Memory** 중에서 어떤 그래프를 ⑤의 차트 영역에 표시할 것인지 선택합니다.
- **File - Option**에서 **Network**를 체크하고 기록하면 **Network Send, Network Receive** 정보를 볼 수 있습니다.
- **File - Option**에서 **Memory**를 체크하고 기록하면 **Lua Memory** 정보를 볼 수 있습니다.

### ⑤ 차트

- **FrameChart**와 **TimelineChart** 중 선택할 수 있으며 일반적으로 FrameChart를 많이 활용합니다.
- 차트 영역을 클릭해 특정 프레임을 선택할 수 있습니다.
- 차트 영역에는 ④에서 체크한 그래프를 볼 수 있습니다. 차트 위에서 우클릭하면 다음 메뉴를 확인할 수 있습니다. ![chart](https://mod-file.dn.nexoncdn.co.kr/bbs/1658893776888960b3923990b449bb99c0ee2defb2c0f.png)
  - **Save Image** : 현재 차트를 png 이미지로 저장합니다.
  - **Copy Image** : 현재 차트 이미지를 클립보드에 복사합니다.
  - **Zoom to Fit Data** : 전체 차트를 화면 사이즈에 맞게 보여줍니다. 차트를 확대해서 보다가 다시 전체 차트를 보려고 할 때 유용합니다.
  - **Help** : 차트 조작법 안내입니다.
  - **Open in New Window** : 현재 차트를 별도 창으로 엽니다.

### ⑥ Recording

- 버튼을 누르면 프로파일링을 시작하고 한 번 더 누르면 프로파일링을 종료합니다.

### ⑦ Clear

- 지금까지 기록한 프로파일링 데이터를 삭제합니다.

### ⑧ Frame Data

- All을 선택해 전체 프레임을 합산해서 보거나 개별 프레임을 선택해 데이터를 볼 수 있습니다. ![framedata](https://mod-file.dn.nexoncdn.co.kr/bbs/16588974397120d5a96e886b647eca63856d08516834a.png)

### ⑨ 프로파일링 결과

- 프로파일링 결과를 확인할 수 있습니다.

| 항목 | 설명 |
| :---: | --- |
| Name | 함수 혹은 Scope의 이름입니다. <br>프로퍼티에서 Get, Set도 함수로 취급합니다. |
| Category | 크게 Lua와 Native로 나뉩니다. <br>하위 소분류로 Function, Getter, Setter, Scope가 있습니다. |
| Call Count | 호출 횟수입니다. |
| Total Time (ms) | 총 실행 시간입니다. |
| Total Self Time (ms) | 하위 샘플을 제외하고 해당 함수 자체에서 소요된 시간입니다. |
| Average Time (ms) | 평균 실행 시간입니다. <br>Total Time/Call Count 값입니다. |
| Peak Time (ms) | 1회 호출에서 가장 긴 실행 시간입니다. |
| Peak Self Time (ms) | 1회 호출에서 가장 긴 함수 자체 실행 시간입니다. |
| Network Usage | 함수 실행 시간 동안 발생한 Network Send Size입니다. <br>일반적으로 실행 제어 함수가 대부분을 차지합니다. |
| Lua Memory | 함수를 실행하는 동안 발생한 Lua memory allocation 크기입니다. |
| Lua Memory (Self) | 함수 자체에서 발생한 Lua memory allocation 크기입니다. |

### ⑩ Log

- 루아 프로파일러 로그를 표시합니다.
- Clear 버튼을 누르면 이전 로그를 삭제합니다.

# 데이터 분석

샘플 데이터를 분석해보면서 루아 프로파일링을 어떻게 진행하면 좋을지 참고해봅시다. ![sample](https://mod-file.dn.nexoncdn.co.kr/bbs/165994423724064220755849b4970b212baf200482c9b.png) ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) Context로 Server를 선택하고 ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) Frame Data는 All을 선택합니다. 이처럼 프로파일링 데이터가 수집되었을 때 아래의 항목을 먼저 체크해봅시다.

- Frame의 Total Self Time (![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg))
- 시간 점유율이 높은 함수 (![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg))
- Peak Time이 높은 함수 (![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg))

위의 ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg), ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg), ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg)에 대해 자세히 살펴봅시다.

## Frame의 Total Self Time

샘플 데이터를 보면 Frame의 Total Self Time이 전체의 62% 이상을 차지하는 것을 알 수 있습니다. Frame에서의 Self Time은 스크립트 실행을 제외하고 Native에서 소요된 시간이므로 Native Scope의 세부 분석이 필요한 상황입니다. 루아 프로파일러의 **File - Option**에서 **Native Scope**에 체크한 후 다시 프로파일링해봅시다. ![nativescope](https://mod-file.dn.nexoncdn.co.kr/bbs/16590581743509659d9f6757e4497ac32594f3d715eb9.png)  다시 수집한 데이터의 카테고리를 살펴보면 Native Scope 세부 분석이 이루어졌음을 알 수 있습니다. ![nativescope2](https://mod-file.dn.nexoncdn.co.kr/bbs/1659944748212c0a5c7969ae24263842732d10d984ba7.png) Frame의 Total Self Time은 확연히 줄어들었고, 대신 Native Function인 TriggerComponent의 OnUpdate가 18% 이상의 상당한 점유율을 차지하고 있습니다. 호출 횟수도 많고 Peak Time도 높으므로 최적화를 고민해봐야 함을 알 수 있습니다.

## 시간 점유율이 높은 함수

가장 높은 시간 점유율을 가지는 함수도 우선 분석 대상입니다. ![sample2](https://mod-file.dn.nexoncdn.co.kr/bbs/1659945181899df0e60b1ce264dc3ab43d41b59e3cfe3.png) 이 샘플에서 MonsterController - OnUpdate 함수의 ServerElapsedSeconds를 살펴보면 평균 실행 시간은 매우 짧지만 호출 횟수가 많아 총 실행 시간이 길어짐을 확인할 수 있습니다. 이처럼 단순한 프로퍼티 접근이라도 호출 횟수가 많으면 그만큼 비용이 증가함을 알 수 있습니다. 제작한 게임을 프로파일링했을 때 이런 부분이 발견된다면 스크립트 최적화를 고려해봅시다.

## Peak Time이 높은 함수

호출 횟수가 적더라도 실행 시간 자체가 높은 함수가 있다면 검토해봐야 합니다. 차트 영역에서 **Shift + 클릭**하면 주변 10% 범위에서 총 실행 시간이 가장 높은 프레임이 선택되는데 이를 통해 Peak Time의 원인이 되는 함수를 파악하고 수정 여부를 판단할 수 있습니다. 단, 한 번의 Peak가 관찰되었다고 해서 무조건 해당 함수에 문제가 있다고 볼 수는 없습니다. 프로파일링 노이즈가 발생했을 가능성도 있으므로 여러 차례 프로파일링하여 같은 부분에서 Peak가 발생한다면 최적화를 고려해봅시다.

# 스크립트 함수 표본 추출

프로파일링 결과 수정이 필요해 보이는 스크립트 함수를 발견했으나 해당 함수의 내용이 너무 길다면 세부적인 분석이 필요할 수 있습니다. 이런 경우에는 표본 추출을 활용해봅시다.

```
void Function1(string arg1)
{
    profiler.beginscope("FirstLoop")
    for i = 1, 10000 do
    	local en = self.Entity
    end
    profiler.endscope()
    
    profiler.beginscope("SecondLoop")
    for i = 1, 10000 do
    	local en = self.Entity
    end
    profiler.endscope()
}
```

분석하려는 함수에 위와 같이 `profiler.beginscope("name")` ~ `profiler.endscope()`를 설정하면 아래와 같이 프로파일링 데이터에서 표본을 뽑을 수 있습니다. ![sample3](https://mod-file.dn.nexoncdn.co.kr/bbs/1659945606718a0afa01deb2f43c7ba0905c583f6d2d5.png)

Update 2025-11-17 PM 08:15


# TargetUserSync와 프로퍼티 동기화 최적화

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

프로퍼티 동기화 방식 중 하나인 TargetUserSync에 대해 알아봅니다.

##### 참고 가이드

- [프로퍼티](/docs/?postId=205)
- [프로퍼티 동기화](/docs/?postId=208)
- [서버와 클라이언트](/docs/?postId=207)

# TargetUserSync 알아보기

TargetUserSync는 Sync 프로퍼티 동기화를 좀 더 특정해 최적화하는 방식입니다. TargetUserSync는 플레이어가 스스로 조작하는 PlayerEntity에 포함된 컴포넌트의 프로퍼티만을 대상으로 동기화합니다. 서버에서 프로퍼티 값이 변경되었다면 프로퍼티 값이 변경된 플레이어 엔티티를 조작할 수 있는 유저에게만 프로퍼티 값을 동기화해줍니다. TargetUserSync는 다른 유저의 정보를 참조할 필요 없는 값인 경우에 사용하는 것이 좋습니다. 개인 재화, 업적, 소모품 같은 개인의 데이터가 이에 해당합니다. TargetUserSync 프로퍼티를 PlayerEntity가 아닌 다른 Entity의 컴포넌트에서 사용한다면 TargetUserSync는 정상적으로 동작하지 않습니다. 이 경우 None 프로퍼티와 동일하게 동작합니다

> **Tip.** TargetUserSync는 접속한 Client와 해당 Client가 조작하는 PlayerEntity를 기준으로 작동합니다. 즉 Entity에 적용되는 Component Script에서만 작동하며 아래 Script의 프로퍼티에서는 TargetUserSync를 사용할 수 없습니다. - EventType, ItemType, BTNodeType, StateType, StructType, Logic

#### TargetUserSync 설정

TargetUserSync는 프로퍼티의 동기화 설정 부분에서 설정할 수 있습니다. 동기화가 가능한 타입은 Sync와 동일합니다.

- 동기화 가능한 타입: string, integer, number, boolean, SyncTable< v >, SyncTable< k,v >, Vector2, Vector3, Vector4, Color, Entity, Component, EntityRef, ComponentRef

![TargetUserSync1](https://mod-file.dn.nexoncdn.co.kr/bbs/16988033334991153af9548234020a1c66e3872cadf4a.png)

한 Component에서 Sync와 TargetUserSync를 함께 쓰는 경우도 가능합니다. Sync 프로퍼티와 마찬가지로 OnSyncProperty를 통해 TargetUserSync가 변화되는 시점을 확인할 수 있습니다. ![TargetUserSync2](https://mod-file.dn.nexoncdn.co.kr/bbs/16987294568417ecb037ea67e4e35a64f34c4a401f740.png)

# Sync와 TargetUserSync의 차이점

Sync로 설정한 프로퍼티의 경우 서버에서 프로퍼티 값을 변경하면, 서버에서 클라이언트 방향으로 해당 엔티티를 가진 맵에 있는 모든 유저에게 값을 동기화합니다. 만약 실시간으로 다른 유저의 정보를 확인하고 처리하는 월드를 만든다면 Sync로 설정한 프로퍼티를 사용할 수 있습니다. 그러나 Sync로 설정한 프로퍼티 값의 변화는 맵의 모든 유저에게 동기화되므로 최적화를 고려해 사용해야 합니다.

#### Sync 방식

모든 플레이어 엔티티에 아래와 같은 컴포넌트를 추가했다고 생각해봅시다. meso 프로퍼티는 유저의 재화를 관리하기 위한 프로퍼티입니다. 따라서 다른 유저의 meso 값을 몰라야 합니다.

```
Property:
[Sync]
integer meso = 0

Method:
[server only]
void IncreaseMeso()
{
	self.meso += 1
}
```

A, B client가 같은 맵에 접속해 있다면 각각 서버와 클라이언트에서 보는 엔티티들의 프로퍼티 값은 아래와 같습니다.

![TargetUserSync1](https://mod-file.dn.nexoncdn.co.kr/bbs/1698802548910ae0fdd13b6e14f4ab5bd34c52b2f5cd4.png)

이때 PlayerEntity A의 `InscreaseMeso()`가 호출되어 A 엔티티의 변경된 meso 프로퍼티 값이 동기화되면 모든 Client에서 PlayerEntityA 값이 변경됩니다. Sync 프로퍼티는 같은 맵에 있는 모든 Client의 PlayerEntityA에게 제한 없이 변경된 meso 값을 동기화하기 때문입니다. 모든 Client에게 동기화하게 되면, ClientB는 불필요한 프로퍼티 동기화 처리로 인해 연산과 패킷 낭비가 발생합니다. 또한 서버는 불필요한 패킷을 모든 Client로 전송해야하므로 패킷을 낭비하게 됩니다.  ![TargetSyncProperty2](https://mod-file.dn.nexoncdn.co.kr/bbs/169925298455090466d29434b4a46b24070db138b88d5.png)

#### TargetUserSync 방식

meso 프로퍼티를 TargetUserSync로 변경한 뒤 서버에서 PlayerEntity A의 `IncreaseMeso()`를 호출하면, PlayerEntity A의 조작 제어권이 있는 Client A에만 meso 값이 동기화됩니다. Client B의 PlayerEntity A에는 변경이 일어나지 않는, None과 동일하게 처리됩니다.

```
Property:
[TargetUserSync]
integer meso = 0

Method:	
[server only]
void IncreaseMeso()
{
	self.meso += 1
}
```

![3](https://mod-file.dn.nexoncdn.co.kr/bbs/169872111296512b78d9fec8f463f8fd68d25ea813523.png)

Update 2025-11-17 PM 08:15


# 패킷 변조 대비하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

서버와 클라이언트가 패킷을 주고 받을 때 데이터 변조가 발생해 크리에이터의 월드에 불편을 초래할 수 있습니다. 패킷 변조를 예방해 쾌적한 월드를 만들기 위해 패킷의 개념과 예방 방법을 알아봅시다.

##### 참고 가이드

- [WorldConfig](/docs/?postId=1101)
- [예시로 알아보는 서버 검증](/docs?postId=1084)

# 패킷 알아보기

**패킷**은 서버와 클라이언트가 주고받는 데이터의 단위를 말합니다. 메이플스토리 월드에서는 함수의 실행 공간에 따라 클라이언트와 서버가 통신해 데이터를 주고받을 수 있습니다. 이때 클라이언트와 서버는 데이터를 단순하게 주고받는 것이 아니라, 이를 담은 **패킷**으로 서로 통신합니다. 예를 들어 클라이언트에서 실행제어가 server인 함수를 호출한다고 생각해 봅시다. 이때 함수를 어떤 엔티티, 컴포넌트, 함수, 인자로 실행할지에 관한 정보를 패킷에 담아 서버로 전달합니다. 서버는 전달받은 정보대로 함수를 실행시키게 됩니다.

# 패킷 변조 알아보기

**패킷 변조**란 네트워크 통신 중 악의적으로 패킷을 변경하는 행위를 뜻합니다. 패킷 변조는 보통 네트워크로 전송된 패킷을 분석해 구조를 파악하고, 실제 데이터 부분을 변조하는 방식으로 이루어집니다.

메이플스토리 월드에서는 패킷의 엔티티, 컴포넌트, 함수, 인자, 대상 클라이언트 정보 등의 변조를 시도할 수 있습니다. 스크립트를 작성할 때 클라이언트 변조나 패킷 변조에 대비해 서버는 받은 데이터를 검증한 뒤 실제 데이터를 변경하도록 해야 합니다.

자주 발생하는 패킷 변조 방식은 패킷에서 특정 데이터의 값을 찾아 클라이언트에서 서버로 패킷을 전송할 때 값을 변경하는 것입니다. 이 패킷 변조 방식은 게임 재화 및 아이템 가치를 변동시켜 게임 생태계에 악의적인 영향을 끼칠 수 있습니다. 아래 그림과 같이 몬스터를 처지하면 보상으로 크리에이터가 설정한 메소, 경험치, 아이템을 얻게 만들었다고 생각해 봅시다. 이때 실제로 유저가 처치한 몬스터로부터 얻을 보상은 100 메소, 1000 경험치, Normal 아이템이지만 패킷 변조를 통해 그보다 훨씬 좋은 보상을 얻을 수 있습니다.

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1706080639140c27ad828ae0a49aca8cec1d0a1e9da34.png)

# 패킷 데이터 변조 1

패킷 변조 예방을 위해 패킷에 실제 골드, 경험치, 아이템 이름 데이터를 담아 보내는 방식은 지양하는 것이 좋습니다. 서버에 요청만 보내고 실제 데이터는 서버에서 결정하는 방식을 권장합니다. 이때 서버는 받은 패킷을 다시 한 번 검증한 뒤 적용하는 것도 중요합니다. 패킷 데이터 변조를 예방하는 자세한 방식은 [예시로 알아보는 서버 검증](/docs?postId=1084) 가이드를 참고합니다.

예시를 통해 엔티티와 컴포넌트를 변조하는 경우와 대처 방식을 소개합니다. 먼저 패킷 하나에 4가지 데이터를 담아 클라이언트에서 서버로 전송한다고 가정합니다.

- **엔티티 이름**: PlayerEntity
- **컴포넌트 이름**: MyPlayerDataComponent
- **함수 이름**: RequestGetCoin
- **함수 인수**: 500

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17116124998769b237ee7005a4bd7a9d464cf615f5e4c.png)

이때, 데이터를 악의적으로 변조하는 대표적인 2가지 예시입니다.

1. **RequestGetCoin 패킷을 반복 전송해 퀘스트를 완료하지 않아도 골드를 얻습니다.**
  - Server에 지급 요청이 왔을 때 골드 획득 조건에 부합하는지 검증합니다. Client에서 온 요청을 검증 없이 반영하지 않습니다.
2. **얻을 골드 수치에 해당하는 인수 값을 변경해 다량의 골드를 한 번에 얻습니다.**
  - 실제 얻을 골드의 양을 클라이언트에서 보내지 않습니다. 서버에서 클라이언트로부터 온 요청과 맞는 값의 골드를 지급합니다.

#### 중요한 함수 server only 지정

클라이언트에서 서버로 패킷을 보낼 때 내용을 그대로 전송하게 되면, 변조 위험률이 높아집니다. 그러므로 중요한 함수는 실행제어를 **server only**로 설정해 패킷 반복 전송, 인자 값 변경 시도 등을 예방하는 것이 좋습니다. 또한 서버 함수는 클라이언트로부터 온 정보가 변조되지 않았는지 확인해야 합니다. 예를 들어 보상을 지급하는 함수를 작성해야 한다면 **client → server → server only** 함수 순서로 호출되도록 작성하는 것을 권장합니다. 이때 실제 보상을 지급하는 함수는 **server only** 함수여야 합니다.

**100 메소 획득**이란 내용 자체를 클라이언트에서 서버로 보낸다면 클라이언트를 변조해 더 많은 메소를 얻거나, 다른 클라이언트에게 지급할 수 있습니다. 패킷 변조를 예방하기 위해선 보상 지급 요청 패킷을 서버로 보내게 작성하고, 실제 지급 함수는 server only로 작성해야 합니다.

```
Method:
[client only]
void ClickGetRewardButton()
{
    self:RewardProcess()
}

[server]
void RewardProcess()
{
    -- SendCoin() 함수를 호출하기 전, 반드시 올바른 요청이 맞는지 검증해야 합니다.
    self:SendCoin()
}


[server only]
void SendCoin()
{
    -- 실제 지급 로직 
}
```

> **Tip.** 모든 로직의 실행제어를 **server**로 설정하는 것은 서버에 부하를 줄 수 있습니다. 애니메이션 재생과 같은 렌더링 처리는 client에서 처리하고, 재화나 아이템 같은 중요한 처리는 서버에서 하는 것을 권장합니다.

# 패킷 데이터 변조 2

또 다른 패킷 변조 방식으로는 플레이어 엔티티 이름 변조가 있습니다. 이 방식으로 실제로 특정 행동을 하지 않은 유저가 특정 행동을 완료하고 보상을 받을 수 있게 됩니다. 예를 들어 PlayerEntityA와 B 중 실제 플레이한 사람은 A이지만, 보상 지급은 B에게 될 수 있습니다. 플레이어 엔티티 이름이 변조되어 실제로 퀘스트를 수행한 플레이어가 아닌 다른 플레이어 엔티티에게 골드를 지급했기 때문입니다. 이를 예방하기 위해서는 로컬 클라이언트 외 다른 클라이언트에서 플레이어 엔티티의 서버 함수를 호출하지 못하도록 해야 합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17116125320499f54fab802ea4f0cbdbb81827d3955f7.png)

#### PlayerEntityAuthorityCheck 활용

WorldCofig의 **PlayerEntityAuthorityCheck**는 플레이어 엔티티에 속한 컴포넌트들의 서버 함수들을 로컬 클라이언트에만 호출하도록 합니다. 다른 클라이언트에서 서버 함수를 호출할 수 없기 때문에 다른 플레이어 엔티티에게 골드 지급하도록 패킷 변조를 할 수 없습니다. 만약 다른 플레이어 엔티티의 서버 함수 호출을 시도하면 아래와 같은 에러가 발생합니다.

![PlayerEntity](https://mod-file.dn.nexoncdn.co.kr/bbs/169571933009917b0b6c1d9994fe9a9e71fa7ff2dacbd.png)

> **Tip.** 로컬 플레이어 엔티티 여부는 클라이언트와 서버 양쪽에서 검증합니다.

PlayerEntityAuthorityCheck를 비활성화할 경우 실제로 값을 보내야 하는 플레이어 엔티티가 아닌 다른 플레이어 엔티티에 값을 전송해 보상이 다른 플레이어에게 갈 수 있습니다. 만약 PlayerEntityA가 몬스터를 사냥했다면 PlayerEntityA에게 메소를 추가하는 것이 정상 동작입니다. 하지만, 패킷의 엔티티 정보를 PlayerEntityB로 변조하면, PlayerEntityB의 서버 함수가 호출되어 PlayerEntityB에게 메소가 추가될 수 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17116125839800b14b16908dc40c3bdb3eb44b3777e0d.png)

#### Server 함수 호출자 senderUserId

**senderUserId**는 서버 함수의 인자로 서버 함수를 호출한 **클라이언트의 userId** 정보를 가지고 있습니다. senderUserId는 서버에서 부여하는 값으로 클라이언트에서 변조되지 않습니다. 예를 들어 월드의 유저A가 자신의 인벤토리에서 특정 아이템을 파기할 때는 아래와 같이 스크립트를 작성할 수 있습니다. 이 스크립트의 경우 다른 클라이언트에서 `RequestDropItem()` 함수를 호출하면, 유저A의 아이템이 삭제될 수 있습니다.

```
[server]
void RequestDropItem(Entity targetItem)
{
    if self:HasItemInInventory(targetItem) then
        return
    end
}
```

특정 유저가 아이템을 파기할 때 다른 유저들의 아이템을 안전하게 지키기 위해선 senderUserId를 활용합니다. `RequestDropItem()` 함수를 호출한 유저와 인벤토리에서 아이템이 삭제될 유저가 일치하는지 알 수 있습니다. `RequestDropItem()` 함수를 로컬 클라이언트가 아닌 다른 클라이언트에서 호출할 경우 인벤토리에서 아이템을 삭제할 수 없도록 아래와 같이 작성할 수 있습니다.

```
[server]
void RequestDropItem(Entity targetItem)
{
    if senderUserId ~= self.Entity.PlayerComponent.UserId then
        return
    end

    if self:HasItemInInventory(targetItem) then
        self:RemoveItemInInventory(targetItem)
    end
}
```

# ServiceAuthorityCheck 활용

메이플스토리 월드는 크리에이터의 제작 편의성을 위해 Service 함수의 실행제어를 변경할 수 있도록 지원합니다. WorldConfig의 **ServiceAuthorityCheck**는 Service의 모든 서버 함수를 **server only** 함수로 동작하도록 변경할 수 있습니다. 예를 들어 TeleportService의 함수는 서버 함수로 플레이어 엔티티가 특정 플레이어 엔티티를 텔레포트 시킬 수 있습니다. 그러나 ServiceAuthorityCheck를 활성화하면 Teleportservice 함수는 server only로 변경되므로 클라이언트에서 호출할 수 없습니다. 그러므로 의도하지 않은 플레이어 엔티티가 텔레포트 되는 현상을 대비할 수 있습니다.

# RestrictedPlayerEntitySync 활용

WorldConfig의 **RestrictedPlayerEntitySync**를 활성화해 플레이어 엔티티에 속한 네이티브 컴포넌트의 **Sync** 프로퍼티가 클라이언트에서 변경된 값을 서버로 동기화하지 않도록 할 수 있습니다. 기본적으로 네이티브 컴포넌트의 Sync 프로퍼티는 서버에서 값이 변경될 때마다 모든 클라이언트로 동기화합니다. 반대로 클라이언트에서 변경된 값은 서버로 동기화하지 않습니다. 그러나 네이티브 컴포넌트가 플레이어 엔티티에 속한 경우 예외적으로 클라이언트에서 변경된 값을 서버로 동기화합니다. 이는 유저 입력이 있을 때 클라이언트에서 상태를 즉시 변경하기 위함입니다. 유저의 입력을 서버에서 먼저 처리하고, 결과를 클라이언트로 보내줄 때 유저는 입력 반응이 지연되는 것을 느낄 수 있기 때문입니다. 그러나 이 동기화 방식을 이용해 플레이어 엔티티의 데이터를 변조할 가능성이 있습니다. 예를 들어 채팅 UI가 없는 월드임에도 클라이언트에서 ChatBalloonComponent의 프로퍼티 값을 변조해 아바타에 말풍선을 띄울 수 있습니다.

> **Tip.** 아래 컴포넌트들은 플레이어 엔티티에 포함되더라도 입력 반응성을 위해 RestrictedPlayerEntitySync 영향을 받지 않습니다. 활성화 여부와 무관하게 플레이어 엔티티에 포함된 경우 항상 클라이언트에서 서버로 동기화가 이루어집니다. - MovementComponent - PlayerControllerComponent - StateComponent - TransformComponent

Update 2025-11-17 PM 08:15


# RateLimitService 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

유저의 server 함수 사용량을 제한하는 방법을 알아봅시다.

##### 참고 가이드

[패킷 변조 대비하기](https://maplestoryworlds-creators.nexon.com/ko/docs?postId=1102) [월드 인스턴스](https://maplestoryworlds-creators.nexon.com/ko/docs?postId=984) [인스턴스 맵 만들기](https://maplestoryworlds-creators.nexon.com/ko/docs/?postId=540)

# RateLimitService 알아보기

server 실행 함수는 클라이언트가 서버에 직접 특정 동작을 수행하도록 만들기 때문에 누군가 악의를 갖고 패킷을 변조하거나, 같은 행위를 반복할 경우 월드에 장애를 발생시킬 수 있습니다. `RateLimitService`는 server 실행 함수의 사용량을 크리에이터가 설정한 값에 따라 제한하고, 유저가 제한된 함수를 다시 사용할 수 있을 때까지 필요한 대기 시간 또한 설정하는 방식으로 월드 보안을 강화할 수 있습니다. `RateLimitService`로 사용량을 제한할 수 있는 함수는 Native API의 server 함수와 크리에이터가 제작한 server 함수 두 가지입니다. RateLimitService는 룸의 특성을 고려해 크리에이터 월드에 어울리는 방식으로 활용하는 것이 좋습니다. 룸마다 RateLimitService가 존재하므로 특정 룸의 사용량 제한은 다른 룸에 영향을 주지 않는 점을 염두에 두어야 합니다.

> **더 알아보기** 유연하게 RateLimitSevice를 사용하고 싶다면 Logic에서 활용할 수 있습니다.

#### 토큰 소비와 재충전

`RateLimitService`를 사용하기 위해서는 토큰 개념을 알아야 합니다. 토큰이란 사용량을 제한하기 위해 크리에이터가 정하는 임의의 호출 제한 한도입니다. 사용량 제한에 도달한 플레이어는 토큰이 재충전될 때까지 함수를 호출하지 못하게 됩니다. 사용량을 제한하기 위해 크리에이터는 토큰 수와 토큰의 충전 간격을 크리에이터가 함수의 매개 변수로 정해야 합니다. 월드 설계에 따라 플레이어가 상대적으로 빈번하게 호출하는 함수의 경우 충전 간격을 다른 함수보다 짧게 두는 것이 좋습니다.

`RateLimitService`의 `SetServerFunctionRateLimitForLogic()`의 매개 변수를 살펴보며 토큰을 이해해 봅시다.

```
void SetServerFunctionRateLimitForLogic(string logicName, string functionName, int maxToken, float tokenRefillPerSecond)
```

**maxToken** 수를 정하고, 초당 충전되는 토큰 수를 **tokenRefillPerSecond**로 정합니다. 매개 변수의 자세한 의미는 다음과 같습니다.

- **logicName**: 사용량을 제한할 함수가 있는 logic의 이름입니다.
- **functionName**: 사용량을 제한할 함수의 이름입니다.
- **maxToken**: 크리에이터가 설정하는 최대 토큰 수로 유저가 함수를 호출할 때마다 1개씩 차감됩니다.
- **tokenRefillPerSecond**: 초당 충전되는 토큰 수입니다. 예를 들어 0.2로 설정하면 5초 뒤 토큰 수가 1 증가합니다.

# 활용 예제

플레이어가 `MoveToMapPosition()` 함수를 짧은 주기 동안 여러 번 호출할 수 없도록 제한하는 예제를 만들어 봅시다. `PlayerComponent`의 `MoveToMapPosition()` 함수를 3초에 한 번만 호출할 수 있도록 제한합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17320008539686a2dfc3bc0ec4a84921966a3cb61b1c4.gif)

#### 맵 제작

맵에 텔레포트를 위해 이동할 수 있는 **InteractionEntity**를 만들고, 타일에 도착 장소인 **Destination**을 배치합니다. 이 맵은 InteractionEntity를 통해 이동한 후, 다시 이동 가능 지점까지 걸리는 시간이 3초라고 가정합니다. 3초보다 빠르게 맵 이동을 시도한다면 이는 함수를 변조했다고 간주할 수 있습니다. 이러한 변조를 막기 위해 `RateLimitService`를 활용해 함수 사용을 제한하는 예제 월드를 만들어 봅시다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1731998004301d26b2a6ee3fa43b39b779b5e178e7a80.png)

#### InteractionEntity 제작

1. **Map01- Create Entity - Create Empty**를 선택해 새로운 **InteractionEntity**를 생성합니다.
2. **TransformComponent, SpriteRendererComponent, InteractionComponent**를 추가합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1731995623163f098c06a614f4f65b32ee64b0075c1ad.png)
3. **Workspace - MyDesk - Create Scripts - Create Component**를 선택해 **TeleportComponent**를 생성합니다.
4. **TeleportComponent**를 생성한 InteractionEntity에 추가합니다.
5. **TeleportComponent**에 **Destination** 프로퍼티를 추가합니다.```
Property:
[None]
Entity Destination = nil
```
6. **InteractionEntity**의 프로퍼티 창에서 크리에이터가 맵에 생성한 Destination 엔티티를 프로퍼티 경로로 지정합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1731995613556801c7b7d6d2641c2861813f93712fc1b.png)
7. `E`키를 눌러 만든 포탈 엔티티와 플레이어가 상호 작용하면 플레이어를 **Destination 엔티티**로 이동시키도록 아래와 같이 작성합니다.```
Event Handler:
[client only][self]
HandleInteractionEvent(InteractionEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InteractionComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    local InteractionEntity = event.InteractionEntity
    ---------------------------------------------------------

    -- 상호 작용 키를 누르면 내 플레이어 엔티티를 'Destination' 엔티티로 이동 시킵니다.
    if InteractionEntity == _UserService.LocalPlayer then
        local localPlayer = _UserService.LocalPlayer
        local currMap = self.Entity.CurrentMap
        local destPos = self.Destination.TransformComponent.WorldPosition:ToVector2()
        localPlayer.PlayerComponent:MoveToMapPosition(currMap.Name, destPos)
    end
}
```

#### 텔레포트 UI 제작

언제든지 Destination 엔티티로 이동할 수 있는 UI를 만들어봅시다. 이 UI를 사용할 경우 사용량 제한에 걸리게 됩니다.

1. **Hierarchy - ui - DefaultGroup - Create Entity - Create Button**을 선택해 새로운 **UIButton**을 생성합니다.
2. 크기와 색상을 자유롭게 결정합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/173199759809163519c556d1f4457b5407341c986eeb7.png)
3. **Workspace - MyDesk - Create Scripts - Create Component**를 선택해 새로운 **CheatingComponent**를 생성합니다.
4. **DefaultPlayer**에 **CheatingComponent**를 추가합니다.
5. 프로퍼티 **Destination**에는 도착지가 될 Entity의 경로를 지정합니다.```
Property:
[None]
Entity Destination = /maps/map01/Destination
```
6. 버튼을 누르면 플레이어가 Destination 위치로 이동할 수 있도록 **ButtonClickEvent**에 **UIButton**을 연결하고 아래와 같이 작성합니다.```
Event Handler:
[entity: UIButton(/ui/DefaultGroup/UIButton)]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    -- local Entity = event.Entity
    ---------------------------------------------------------

    local currMap = self.Entity.CurrentMap
    local destPos = self.Destination.TransformComponent.WorldPosition:ToVector2()
    self.Entity.PlayerComponent:MoveToMapPosition(currMap.Name, destPos)
}
```

#### 사용량 제한 로직 제작

유저가 입장하면 PlayerComponent의 `MoveToMapPosition()` 함수를 제한할 수 있도록 아래와 같이 작성합니다.

1. **Workspace - MyDesk - Create Scripts - Create Logic**을 선택해 **RateLimitLogic**을 생성합니다.
2. 유저가 월드에 입장하면 PlayerComponent의 `MoveToMapPosition()` 함수의 사용량을 제한하도록 `SetServerFunctionRateLimitForComponent()` 함수를 활용합니다. 토큰 수는 2, 초당 토큰 재충전 수는 0.3입니다.```
Event Handler:
[service: UserService]
HandleUserEnterEvent(UserEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------

    local userEntity = _UserService:GetUserEntityByUserId(UserId)
    _RateLimitService:SetServerFunctionRateLimitForComponent(userEntity.Id, "PlayerComponent", "MoveToMapPosition", 2, 0.3)
}
```
3. 사용량 제한에 도달한 유저가 있을 경우 경고 로그가 출력되도록 작성합니다. `UserService`를 활용해 유저 정보를 알 수 있습니다.```
[service: RateLimitService]
HandleServerFunctionRateLimitEvent(ServerFunctionRateLimitEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: RateLimitService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    local FunctionName = event.FunctionName
    local ProfileCode = event.ProfileCode
    ---------------------------------------------------------

    local user = _UserService:GetUserByProfileCode(ProfileCode)
    log_warning("'" .. user.Nickname .. "\' 유저는 \'" .. FunctionName .. "\' 함수 사용량 제한을 초과했습니다.")
}
```
4. [시작]을 누르고 Teleport 버튼을 짧은 시간 안에 여러 번 눌러 `MoveToMapPosition()` 함수를 호출합니다. Console 창에서 에러 로그가 발생한 것을 확인할 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17319973792924df9664512dc4cfbbfdd6b94193b440b.png)

Update 2025-11-17 PM 08:15


# 예시로 알아보는 서버 검증

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

플레이어 엔티티에서 서버 함수를 호출할 경우 '패킷'을 통해 데이터를 전송합니다. 중요한 데이터를 패킷에 담아 보낼 경우, 서버는 받은 패킷을 바로 반영하지 않고 한 번 더 검증해 보안을 강화해야 합니다. 이번 가이드에서는 서버 검증 스크립트를 작성하고, 안정적인 서버를 구성하는 방법을 알아봅니다.

##### 참고 가이드

- [패킷 변조 대비](/docs/?postId=1102)
- [WorldConfig](/docs/?postId=1101)

# 검증 시 유의 사항

클라이언트 변조 및 패킷 변조 예방을 위해 서버 검증 장치를 추가해야 합니다. 월드 제작 시 모든 판정을 서버에서 할 필요는 없으나, 중요한 데이터를 다루는 판정은 서버에서 이뤄져야 합니다. 만약 클라이언트에서 판정을 거친 후 서버로 요청이 온 경우일지라도 중요한 데이터라면 서버에서 다시 검증하길 권장합니다. UI엔티티의 경우 클라이언트에만 존재하므로 UI 동작은 서버에서 클라이언트로 전송하고, 반영하도록 구현하길 권장합니다. 또한 클라이언트에서 보낸 패킷에 월드의 중요한 데이터를 바로 담는 것은 삼가야 합니다. 클라이언트에서 보낸 패킷에 골드, 경험치 같은 중요한 데이터를 담아서는 안 됩니다.

# 패킷 변조를 예방하는 서버 구성 예시

NPC와 상호 작용해 열쇠를 메소로 교환하는 시스템을 만들어봅시다. 교환 과정에서 변조 될 수 있는 경우의 수를 파악해 검증 방식을 추가합니다.

#### UI 만들기

1. DefaultGroup에 **UISprite, UIText**를 2개씩 추가해 골드와 키 보유량을 알 수있는 UI를 만듭니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1706514331040538a923e7d024f43a83255f2192034cc.png) ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1713870204930fa91eb3313cd42b5932269d713784fe1.png)
2. DefaultUI에 **UISprite, UIInputText, UIText**를 추가해 교환용 UI를 만들고 아래와 같이 이름을 변경합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/170607103930210c9ec96e8d7461392a7468ded173cda.png) ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1713924692487c458e7057dcf4f598ab8fae58a1c1e3d.png)
3. 생성한 교환용 UI의 **Enable**을 해제해 보이지 않게 만듭니다.

#### NPC 배치하기

1. Scene에 **NPC** 프리셋을 배치하고, **TriggerComponent**를 추가합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1706070955652fdf1e41bb11243df8e185796b7f9c95a.png)
2. **CollisionGroup**에서 새로운 **Npc** 그룹을 추가합니다. Npc 그룹은 Npc, Default와 충돌할 수 있도록 아래와 같이 Matrix를 설정합니다. ![npc](https://mod-file.dn.nexoncdn.co.kr/bbs/1706514288932b68b705f4d6e49df8b8be935dc051b67.png)
3. Npc의 TriggerComponent의 **CollisionGroup**을 **Npc**로 변경합니다.

#### 클라이언트 함수 작성하기

NPC와 플레이어가 상호작용할 수 있게 만들어봅시다. NPC의 trigger 범위에 플레이어가 있을 때 `E` 키를 누르면 UI가 열리고, `ESC` 키를 누르면 UI가 닫히도록 만듭니다.

1. 새로운 **MyPlayerComponent**를 생성하고, **DefaultPlayer**에 추가합니다.
2. **MyPlayerComponent**에 아래와 같이 작성합니다.```
Property:
[None]
Entity triggerNpcEntity = nil
[Sync]
number key = 0
[None]
number lastExchangeTime = 0
[None]
number talkableDistance = 1
[Sync]
number gold = 0
[None]
Entity goldUI = /ui/DefaultGroup/GoldUI
[None]
Entity keyUI = /ui/DefaultGroup/KeyUI

Method:
[client only]
void OnSyncProperty(String name, any value)
{
    if name == "key" then
        -- key UI 갱신
        self.keyUI.TextComponent.Text = tostring(self.key)
    end

    if name == "gold" then
        -- gold UI 갱신
        self.goldUI.TextComponent.Text = tostring(self.gold)
    end
}

Event Handler:
[service: InputServie]
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local key = event.key
    ---------------------------------------------------------

    -- 로컬 플레이어인지 확인
    if self.Entity ~= _UserService.LocalPlayer then
        return
    end

    -- 키 입력 확인
    if key == KeyboardKey.E then
        -- 대화 가능한 NPC가 있는지 확인
        if self.triggerNpcEntity == nil then
            log('trigger 없음')
            return
        end

        self.triggerNpcEntity.NpcComponent:OnRequestOpenDialog(true)
    elseif key == KeyboardKey.Escape then
        if self.triggerNpcEntity ~= nil then
            self.triggerNpcEntity.NpcComponent:OnRequestOpenDialog(false)
        end
    end
}

[client only][self]
HandleTriggerLeaveEvent(TriggerLeaveEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    log('triggerLeave')
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    if self.triggerNpcEntity == TriggerBodyEntity then
        self.triggerNpcEntity.NpcComponent:OnRequestOpenDialog(false)
        self.triggerNpcEntity = nil
    end
}

[client only][self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------
    log('triggerEnter')
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    if TriggerBodyEntity.TriggerComponent.CollisionGroup == CollisionGroups.Npc then
        self.triggerNpcEntity = TriggerBodyEntity
    end
}
```
3. 새로운 **NpcComponent**를 생성하고, **NPC** 엔티티에 추가합니다.
4. 교환 버튼을 누르면 열쇠를 골드로 교환할 수 있도록 **NpcComponent**에 아래와 같이 작성합니다.```
Property:
[None]
Entity DialogEntity = ui/DefaultGroup/DialogBackground
[None]
TextInputComponent QuantityInput = ui/DefaultGroup/DialogBackground/Dialog/Count

Method:
[client]
void OnRequestOpenDialog (boolean isOpen)
{
    self.DialogEntity.Enable = isOpen
}

Event Handler:
[entity: ExchangeButton(/ui/DefaultGroup/DialogBackground/Dialog/ExchangeButton)]
HandleButtonClickEvent(ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------
    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------

    -- 쿨타임 확인
    local myPlayerComponent = _UserService.LocalPlayer.MyPlayerComponent
    if DateTime.UtcNow.Elapsed - myPlayerComponent.lastExchangeTime < 1000 then
        log('지난 요청으로부터 1초가 지나지 않음')
        return
    end

    local keyQuantity = tonumber(self.QuantityInput.Text)
    if keyQuantity > 0 then
        myPlayerComponent.lastExchangeTime = DateTime.UtcNow.Elapsed

        myPlayerComponent:VerifyExchangeKeyToGold(keyQuantity, myPlayerComponent.triggerNpcEntity)
    end
}
```

#### 서버 함수 검증 요소 알아보기

열쇠 아이템을 소지한 플레이어가 열쇠를 메소로 교환해주는 NPC와 상호 작용할 때의 서버 검증 예시를 살펴봅시다. 플레이어가 NPC에게 열쇠를 1000메소로 교환할 때 확인해야 할 서버 검증 요소는 4가지입니다.

1. **로컬 Client가 아닌 다른 Client에서 요청을 보내지는 않았는지 검증합니다.** 검증할 수 있는 방법은 두 가지 입니다. 첫 번째는 [WorldConfig](/docs/?postId=1101)의 **PlayerEntityAuthority**를 활용해 대비합니다. 두 번째는 **senderUserId**를 사용해 패킷을 보낸 플레이어 엔티티가 교환을 요청한 플레이어 엔티티와 일치하는지 확인합니다. senderUserId를 사용하여 패킷을 보낸 플레이어 엔티티가 교환하려는 플레이어 엔티티와 일치하는지 확인합니다.```
-- 로컬 Client가 아닌 다른 Client에서 요청을 보내지는 않았는지 검증
if senderUserId ~= self.Entity.PlayerComponent.UserId then
    log('로컬 Client가 아닌 다른 Client에서 요청을 보냄')
    return
end
```
2. **비정상적으로 많은 반복 요청이 있는지 검증합니다.** 패킷을 임의적으로 반복해 보내는 경우를 대비하기 위해 클라이언트에서 **재사용 대기 시간**을 검사합니다. 또한 서버에서 한번 더 검사해야 합니다. 만약, 크리에이터가 지정한 시간이 지나지 않았을 때 서버 함수가 호출된 경우 비정상적인 패킷으로 의심할 수 있습니다. 정상적인 클라이언트라면 재사용 대기 시간이 지나기 전에 서버 함수를 호출하지 않기 때문입니다.```
-- 요청이 비정상적으로 반복되어 보내지지는 않았는지 재사용 대기 시간을 추가해 검증
if DateTime.UtcNow.Elapsed - self.lastExchangeTime < 1000 then
    log('지난 요청으로부터 1초가 지나지 않았습니다.')
    return
end
```
3. **플레이어 엔티티가 해당 NPC의 트리거가 발동되는 위치에 있는지 검증합니다.** 플레이어 엔티티가 NPC 트리거 위치에 있을 때 패킷을 보내도록 작성합니다. 또한 `ExchangeKeyToGold()` 함수를 트리거가 발동될 수 없는 위치에서 호출해 패킷을 보내는 경우를 대비하기 위해 서버에서 한 번 더 플레이어와 NPC 거리를 계산합니다. 트리거가 발동될 수 없는 거리에 플레이어 엔티티가 있지만, 패킷 요청이 온다면 비정상적인 패킷 요청으로 의심할 수 있습니다.```
-- 플레이어 엔티티가 해당 NPC의 트리거가 발동되는 위치에 있는지 검증
if npcEntity == nil then
    log('트리거 npc가 없음')
    return
end

local playerPos = self.Entity.TransformComponent.WorldPosition
local npcPos = npcEntity.TransformComponent.WorldPosition
local distance = Vector2.Distance(Vector2(playerPos.x, playerPos.y), Vector2(npcPos.x, npcPos.y))

if distance > self.talkableDistance then
    log("Trigger 발생 범위 내에 플레이어가 위치하지 않습니다. 비정상적 패킷입니다.")
    return
end
```
4. **교환 요청 온 열쇠 개수가 플레이어가 가진 열쇠 개수보다 적지 않은지 검증합니다.** 플레이어가 교환 버튼을 누를 때 열쇠 개수가 교환 요청한 개수보다 적은 경우 교환할 수 없도록 한 번 더 교환 조건을 확인합니다.```
-- 교환 요청 온 열쇠의 개수가 플레이어가 가진 열쇠의 개수보다 적지는 않은지 검증
if self.key < keyQuantity then
    log('플레이어의 열쇠 개수가 부족합니다.')
    return
end
```

#### 서버 함수 작성하기

위의 4가지 검증 요소 확인하고, 열쇠를 메소로 교환할 수 있는 서버 함수들을 작성해봅시다.

1. MyPlayerComponent에 `OnBeginPlay()` 함수를 생성합니다. 월드 입장 시 열쇠를 10개를 지급하고, 골드는 0으로 초기화할 수 있도록 아래와 같이 작성합니다.```
[server only]
void OnBeginPlay()
{
    -- key, gold 값 세팅
    self.key = 10
    self.gold = 0
}
```
2. **MyPlayerComponent**에 새로운 `VerifyExchangeKeyToGold()` 함수를 생성합니다. 실행제어를 **server**로 설정하고, 매개변수 **keyQuantity, npcEntity**를 추가합니다. 서버에서 검증에 성공하면 메소를 지급하도록 아래와 같이 작성합니다.```
Method:
[server]
void VerifyExchangeKeyToGold(number keyQuantity, Entity npcEntity)
{
    -- 로컬 Client가 아닌 다른 Client에서 요청을 보내지는 않았는지 검증
    if senderUserId ~= self.Entity.PlayerComponent.UserId then
        log('로컬 Client가 아닌 다른 Client에서 요청을 보냄')
        return
    end

    -- 요청이 비정상적으로 반복적으로 보내지지 않았는지 검증
    -- 재사용 대기 시간 추가해 검증
    if DateTime.UtcNow.Elapsed - self.lastExchangeTime < 1000 then
        log('지난 요청으로부터 1초가 지나지 않음')
        return
    end

    -- 플레이어 엔티티가 해당 NPC의 트리거가 발동되는 위치에 있는가
    if npcEntity == nil then
        log('Trigger npc가 없음')
        return
    end

    local playerPos = self.Entity.TransformComponent.WorldPosition
    local npcPos = npcEntity.TransformComponent.WorldPosition
    local distance = Vector2.Distance(Vector2(playerPos.x, playerPos.y), Vector2(npcPos.x, npcPos.y))

    if distance > self.talkableDistance then
        log("Trigger 발생 범위 내에 플레이어가 위치하지 않습니다. 비정상적인 패킷입니다.")
        return
    end

    -- 교환 요청 온 열쇠의 개수가 플레이어가 가진 열쇠의 개수보다 적지는 않은가
    if self.key < keyQuantity then
        log('플레이어의 열쇠 개수가 부족합니다.')
        return
    end

    -- 검증 성공 시 교환 함수 호출
    self:ExchangeKeyToGold(keyQuantity)
   }
```
3. 새로운 `ExchangeKeyToGold()`함수를 생성합니다. 실제로 골드를 지급하는 함수이므로 실행제어를 **server only**로 설정합니다. 검증에 성공했다면, 키 수량에 맞는 골드를 지급할 수 있도록 작성합니다.```
[server only]
void ExchangeKeyToGold(number keyQuantity)
{
    self.key = self.key - keyQuantity
    self.gold = self.gold + keyQuantity * 1000
    self.lastExchangeTime = DateTime.UtcNow.Elapsed
}
```

Update 2025-11-17 PM 08:15


# 상품 등록하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 월드에서 판매할 수 있는 상품인 아이템과 이용권에 대해서 알아봅니다. 상품에 대해서 알아보고, 만들고 싶은 상품을 등록해봅니다. 상품은 이용자들이 가진 월드코인으로 구매할 수 있습니다. 크리에이터는 상품의 구매 대가로 이용자들에게 이용권과 같은 서비스를 제공해줘야 합니다. 크리에이터는 추후 이용자가 지불한 월드코인을 정산할 수 있습니다.

# 상품 등록하기

상품을 등록하는 방법은 두 가지입니다. 메이플스토리 월드 [공식 홈페이지](https://maplestoryworlds.nexon.com/) 혹은 메이커 내에서 등록이 가능합니다. 등록 화면과 절차는 동일하므로 크리에이터가 선호하는 곳에서 상품을 등록할 수 있습니다. 상품은 아이템과 이용권 두 종류로 나뉩니다. 크리에이터가 판매할 상품의 종류에 맞게 선택해 등록해야 합니다. 상품을 등록할 때는 상품 종류, 상품 이름, 가격, 판매 기간, 출시 여부, 상품 섬네일을 필수 입력해야 하며, 필요에 따라 상품 설명을 추가할 수 있습니다.

![Item](https://mod-file.dn.nexoncdn.co.kr/bbs/1701238969183c2cf13ab66fa4008b09e44dcb8a57781.png)

| 번호 | 이름 | 설명 |
| --- | --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | 상품 종류 | 상품 종류는 두 가지입니다. 각 상품의 특성에 따라<ul><li>**아이템**: 재구매가 가능한 상품입니다. 예를 들어, HP를 회복시키는 HP 회복 물약의 경우, 상점에서 계속 구매할 수 있어야 합니다.</li><li>**이용권**: 한 번만 구매할 수 있고, 지속적인 효과를 내는 상품입니다. 예를 들어, 월드에서 보상받을 때 추가로 혜택 받을 수 있는 상품을 만들 때 사용합니다.</li></ul> |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | 상품 이름 | 유저에게 보일 상품 이름을 입력합니다. 최대 50자까지 작성할 수 있습니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | 가격 | <ul><li>**무료**: 상품을 무료로 구매할 수 있습니다.</li><li>**유료**: 월드 이용자들이 코인으로 상품을 구매할 수 있습니다. 가격은 최소 10에서 최대 10,000까지 설정할 수 있습니다.</li></ul> |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | 판매 기간 | 월드에서 유저가 상품을 구매할 수 있는 기한을 정합니다.<ul><li>**무기한**: 상품을 상시 판매합니다.</li><li>**유기한**: 정해진 기간 내에만 상품을 판매합니다. 판매 시작일과 종료일, 시간까지 설정할 수 있습니다. 설정한 판매 시작일이 되면 배지의 상태가 **'판매 중'** 상태로 변경되며 배지 획득이 가능해집니다.</li></ul> |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | 출시 여부 | 상품의 출시 여부를 설정합니다. 그룹 월드의 경우 그룹장만 출시 여부를 설정할 수 있습니다.<ul><li>**미출시**: 상품을 출시하지 않습니다. 만약 출시한 상품을 미출시 상태로 변경하면 웹 상점 및 월드 상품 리스트에서 제외되고, 판매할 수 없습니다. 이미 상품을 구매한 유저의 상품 목록에서도 보이지 않습니다.</li><li>**출시**: 상품을 출시합니다.</li></ul> |
| ![6](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_06.jpg) | 상품 섬네일 | 유저가 획득하는 상품의 이미지 파일을 업로드할 수 있습니다. 2MB 이하의 jpg, png 파일을 1개만 등록 가능하며 120x120 px 크기의 이미지 사용을 권장합니다. 상품 등록 시 이미지를 반드시 등록해야 합니다. |
| ![7](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_07.jpg) | 상품 설명 | 유저에게 보일 상품 설명을 입력할 수 있습니다. 설명 입력은 선택 사항입니다. |

#### 웹에서 등록

1. 로그인 후 월드 만들기 선택, 상품을 생성할 월드를 선택합니다.
2. **상점 관리 - 상품 등록**을 선택합니다.
3. 상점 관리 창에서 상품 종류, 상품 이름, 출시 여부, 상품 섬네일을 정한 뒤 등록을 누릅니다.
4. 상점 관리 창에서 등록한 상품이 추가되고, 판매 상태가 **미출시**인지 확인합니다.

#### 메이커에서 등록

1. **Panels - World Shop Viewer**를 엽니다.
2. 마우스 오른쪽을 눌러 콘텍스트 메뉴를 열고, **Create New Item**을 선택합니다.
3. 열린 새 창에서 웹에서의 등록과 마찬가지로 상품 종류, 상품 이름, 출시 여부, 상품 섬네일을 정한 뒤 등록을 누릅니다.
4. 등록한 상품이 추가되고, 상태가 **미출시**인지 확인합니다.

# 상품 상태

상품 상태는 총 5개로 구분됩니다. 메이커에서 테스트할 때는 모든 상태에서 구매할 수 있습니다. 월드에서 실제로 판매하기 위해서는 상품의 상태가 **판매 중**이어야 합니다.

| 이름 | 설명 |
| --- | --- |
| 미출시 | 출시 여부를 '미출시'로 설정한 상태입니다. 판매 기간이 되어도 월드 웹 상점 및 클라이언트 내에서도 노출되지 않고 판매도 불가합니다. 플레이어가 보유한 상품도 목록에서 확인이 불가합니다. |
| 판매 대기 | 판매 시작일이 아직 도래하지 않아 대기 중인 상태입니다. 출시 상태로 판매 기간을 지정하면, 판매 시작일에 맞춰 **'판매 중'** 상태로 자동 변경됩니다. |
| 판매 중 | 상품을 판매할 수 있습니다. 판매 일자를 설정한 경우, 해당 기간만 상품을 판매할 수 있습니다. |
| 판매 종료 | 판매 기간이 지난 상태로 상점에서 판매할 수 없습니다. |
| 제재 중 | 제재 처리된 상품입니다. 출시 여부, 판매 기간에 관계없이 판매가 불가능합니다. 크리에이터는 제재 상품을 수정할 수 있으나, 제재 상태 관련 문의는 고객센터에 문의해야 합니다 |

# 그룹 월드에서 상품 등록

상품 등록, 수정 모두 **그룹장**만 가능합니다.

##### 참고 가이드

‘유료’ 확률형 콘텐츠를 제공하는 경우 확률 정보 공개 가이드에 따라 콘텐츠 사용 전 사용자에게 고지해야 할 의무가 있습니다. [확률 정보 공개](/docs/?postId=667)를 참고해 상품을 제작하길 바랍니다.

- [상품 관리하기](/docs?postId=658)
- [월드 숍 서비스 활용하기](/docs?postId=659)

Update 2025-11-20 PM 02:03


# 상품 관리하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드 숍 뷰어의 활용 방법과 상품 상태별 기능 제한에 대해 알아봅시다.

# World Shop Viewer

메이커에서 상품을 등록하고, 관리할 수 있는 창입니다. 등록한 상품 종류에 따라 각 폴더에 자동으로 분류됩니다. 주요 콘텍스트 메뉴는 아래와 같습니다.

![WorldShopViewer](https://mod-file.dn.nexoncdn.co.kr/bbs/166858313170660da397e5b2e48979353a37c1b33889d.png)

| 이름 | 설명 |
| --- | --- |
| Copy Item ID | 등록한 상품의 ID를 복사합니다. |
| Copy Item Thumbnail RUID | 등록한 상품의 섬네일 RUID를 복사합니다. |
| Create New Item | 새로운 아이템, 이용권을 생성합니다. 메뉴를 누르면 상품 등록 페이지가 열립니다. |
| Edit Item | 등록한 상품을 수정합니다. |
| Open Item List(Web) | 생성한 상품들의 상태를 확인할 수 있는 외부 브라우저 창을 엽니다. |
| Refresh Viewer | 상품 목록을 새로고침합니다. |

등록한 상품에 커서를 올려 상품 정보를 확인할 수 있습니다. ![ItemInformation](https://mod-file.dn.nexoncdn.co.kr/bbs/1668586084462d10abb24e7614e7dba6a3b078397c147.png)

# 상품 상태별 기능 제한

상품의 상태에 따라 기능이 제한됩니다. 아래의 표를 참고하세요. 전체 상품를 검색할 때 판매 대기 상태인 상품을 노출하지 않으려면, 해당 상품을 미출시 상태로 변경하여 조회되지 않도록 할 수 있습니다.

| 상태 | 월드에서 정보 조회 | 월드에서 상품 노출 | 실제 구매 가능 | 테스트 구매 가능 | 상품 정보 수정 | 공식 홈페이지 상품 노출 |
| --- | --- | --- | --- | --- | --- | --- |
| **미출시** | 불가 | 불가 | 불가 | 가능 | 가능 | 불가 |
| **판매 대기** | 가능 | 노출 | 불가 | 가능 | 가능 | 노출 안 됨 |
| **판매 중** | 가능 | 노출 | 가능 | 가능 | 가능 | 이용권만 노출 |
| **판매 종료** | 가능 | 노출 | 불가 | 가능 | 가능 | 노출 안 됨 |
| **제재 중** | 가능 | 노출 | 불가 | 가능 | 가능 | 노출 안 됨 |

#### 상품 제재 안내

크리에이터가 제작한 상품은 메이플스토리 월드의 [운영 정책](https://maplestoryworlds.nexon.com/legal/policy)에 따라 제재받을 수 있습니다. 제재받은 상품 이름은 월드 유저에게는 운영정책 위반 명칭으로 변경되어 보이게 됩니다. 더불어 상품 이미지는 기본으로 변경됩니다. 상품의 제재 내용은 **World Shop Viewer**의 툴팁에서 확인할 수 있습니다.

제재 상품 관련 문의가 있다면 [고객센터](https://cs.nexon.com/HelpBoard/Nexon?gamecode=363)를 이용해 주세요.

# 메이커와 월드에서의 차이

상품을 구매 환경에 따라 아래와 같은 차이점이 있습니다.

| 상태 | 메이커 | 출시된 월드 |
| --- | --- | --- |
| 코인 차감 | 코인을 차감하지 않고 구매할 수 있습니다. | 코인을 차감합니다. |
| 구매 팝업 | 상품 구매 창 하단에 '테스트 구매 시에는 코인을 차감하지 않습니다.' 문구가 표시됩니다. | 상품 구매 창 하단에 잔액이 표시됩니다. |
| 상품 조회 | **미출시, 판매 중, 판매 대기, 판매 종료**상태에서 모두 조회할 수 있습니다. | **판매 대기, 판매 중, 판매 종료** 상태의 상품만 조회할 수 있습니다. |
| 구매 | **미출시, 판매 중, 판매 대기, 판매 종료** 상태에서 모두 구매 할 수 있습니다. | **판매 중** 상태의 상품만 구매할 수 있습니다. |

##### 참고 가이드

‘유료’ 확률형 콘텐츠를 제공하는 경우 확률 정보 공개 가이드에 따라 콘텐츠 사용 전 사용자에게 고지해야 할 의무가 있습니다. [확률 정보 공개](/docs/?postId=667)를 참고해 상품을 제작하길 바랍니다.

- [상품 등록하기](/docs/?postId=581)
- [월드 숍 서비스 활용하기](/docs/?postId=659)

Update 2025-11-20 PM 02:03


# 월드 숍 서비스 활용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

`WorldShopService`를 활용해 웹에서 등록한 아이템, 이용권을 구매할 수 있게 만들어봅시다. 출시하지 않은 월드에서는 상품을 출시하더라도, 실제로 판매할 수 없음을 유념하세요.

# WorldShopService

등록한 상품을 월드에서 활용할 때는 `WorldShopService`를 활용해야 합니다. 구매 성공한 유저는 크리에이터가 제공한 상품을 지급 받아야 합니다.

# 활용 예시

아이템과 이용권을 등록합니다. 아이템을 구매하면 즉시 포션 수를 100으로 증가시키고, 이용권을 구매한 뒤 공격을 누르면 포션 수를 15개 증가시킵니다.

![example](https://mod-file.dn.nexoncdn.co.kr/bbs/16690340160770272c9d6580a42c99c9be10128f2e9f7.gif)

#### 사전 준비

[상품 등록하기](/docs?postId=581)를 따라 아이템과 이용권을 등록합니다.

| 상품 종류 | 아이템 | 이용권 |
| --- | --- | --- |
| 상품 이름 | 포션 아이템 | 포션 추가 PASS |
| 가격 | 무료 | 무료 |
| 판매 기간 | 무기한 | 무기한 |
| 상품 섬네일 | ![Item](https://mod-file.dn.nexoncdn.co.kr/bbs/1669032688633b964bbc6fc0b4f5784c7bf5e7461f58f.png) | ![Pass](https://mod-file.dn.nexoncdn.co.kr/bbs/1669032702800d3d79eebd2dd463990f7b0fe404b06e7.png) |
| 상품 설명 | 무료 포션 100개를 얻을 수 있습니다. | 포션을 추가로 얻을 수 있습니다. |

#### 상품 구매창 UI 만들기

1. **UI 에디터 - DefaultGroup - Create Entity - Create UIEmpty**를 선택해 배치하고, 이름을 **MiniShop**으로 변경합니다.
2. 새로운 **Item 엔티티**를 생성해 **MiniShop** 엔티티 하위에 배치한 뒤 텍스트를 활용해 아래 그림과 같이 이미지와 상품 구매창을 만듭니다. ![ShopUI](https://mod-file.dn.nexoncdn.co.kr/bbs/16686688390882a43ba5bfd2842c7821fc9e59cc23a25.png)
3. World Shop Viewer에서 상품을 선택하고, 콘텍스트 메뉴를 열어 **Copy Item Thumbnail RUID**를 선택합니다. ![Copy](https://mod-file.dn.nexoncdn.co.kr/bbs/166877214605218b6051c1c4145f9b9b55ee2c391130d.png)
4. 상품 이미지를 보여줄 이미지 엔티티를 선택하고, **SpriteGUIRendererComponent**의 ImageRUID에 상품 RUID를 붙여 넣습니다.
5. 만든 Item 엔티티를 복사해 **MiniShop** 엔티티 하위에 나란히 배치합니다. ![ShopUI](https://mod-file.dn.nexoncdn.co.kr/bbs/16687721843201c7dbc6d49c3468eb14a56c815b8b21f.png)
6. 복사한 엔티티의 이름을 **Pass**로 변경하고, 이용권 RUID를 붙여넣습니다.
7. MiniShop의 **Enable** 프로퍼티를 ![off](https://mod-file.dn.nexoncdn.co.kr/storage/icons/common/CheckboxOff.png)해제합니다.

#### 상점 버튼 UI 만들기

상품 구매창을 열고 닫는 버튼을 만들어봅시다. ![ButtonShop](https://mod-file.dn.nexoncdn.co.kr/bbs/1669181482837083a5716f94f4b9dac17c23994305949.png)

1. **UI 에디터 - DefaultGroup - ShopOpenBtn** 버튼을 배치합니다.
2. **SpriteGUIRendererComponent - ImageRUID**에 상점 모양 스프라이트 찾아 적용합니다.
  - ImageRUID: 92a05d93672f65b4f991279cf1f0b4e6
3. 새로운 **OpenShopBtn**스크립트 컴포넌트를 생성하고, ShopOpenBtn에 추가합니다. ![ShopOpenBtn](https://mod-file.dn.nexoncdn.co.kr/bbs/1668771870564d9e4aa0cc7d84cf78a4d010cf2254125.png)
4. ShopOpenBtn을 누르면 Minishop을 열고 닫을 수 있게 아래와 같이 작성합니다.

```
Method:
[client only]
void OpenShop()
{
    local Shop = _EntityService:GetEntityByPath("/ui/DefaultGroup/MiniShop")
    local Item = Shop:GetChildByName("Item") 
    local Pass = Shop:GetChildByName("Pass") 
        
    if Shop.Enable == false then
    
        Shop:SetEnable(true)   
                      
    else
    
        Shop:SetEnable(false)
        
    end
}

Event Handler:
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    self:OpenShop()
}
```

#### 상품 획득 확인 UI 만들기

상품 구매에 성공했을 때 포션 개수와 이용권 보유 여부를 확인할 수 있는 ui를 만들어봅시다.

1. **UI 에디터 - DefaultGroup - MyPotionInfo** 이미지 엔티티를 배치합니다.
2. 하위에 이미지와 텍스트 엔티티를 배치하고, 아래의 그림처럼 이름을 변경합니다. ![info](https://mod-file.dn.nexoncdn.co.kr/bbs/166918924041307df0d08c4824221a462c16df2e2b840.png)

#### 상품 정보를 구매창에 불러오기

1. 새로운 **ItemSlot** 스크립트 컴포넌트를 생성하고 **Item, Pass UI엔티티**에 추가합니다.
2. **ItemSlot** 컴포넌트 스크립트 에디터 창을 열고, 프로퍼티를 추가합니다.```
Property:
[None]
string ItemID = ""
[None]
Entity PurchaseBtn = nil
```
3. World Shop Viewer 에서 상품의 콘텍스틀 메뉴를 열어 Copy ID를 선택합니다. ![CopyID](https://mod-file.dn.nexoncdn.co.kr/bbs/16691907394815f8bdb41e2224869a012f97b5d142317.png)
4. 복사한 ID를 각각의 Item, Pass의 ItemSlot 컴포넌트의 ID에 추가합니다. ![PropertyItemID](https://mod-file.dn.nexoncdn.co.kr/bbs/1669191109035f825047ab3a2458ab3e37daa4f3c6401.png)
5. 상품 구매창이 열릴 때마다 정보를 갱신할 수 있도록, **MyDesk - Create Scripts - Create EventType**을 선택해 새로운 **ShopOpenEvent**를 만듭니다. ![ShopOpenEvent](https://mod-file.dn.nexoncdn.co.kr/bbs/166903451819499a0605245bf40c5ad0497ac93cacefb.png)
6. **ItemSlot** 컴포넌트에 `WorldShopService:PromptPurchase()`를 활용해 구매 버튼을 누르면 상품 구매창에 상품 정보가 보이도록 아래와 같이 작성합니다.```
Method:  
[client only]
void PurchaseItem()
{
    _WorldShopService:PromptPurchase(self.ItemID)
}

[client only]
void OnBeginPlay()
{
    self.PurchaseBtn = self.Entity:GetChildByName("PurchaseBtn")
    self.PurchaseBtn:ConnectEvent("ButtonClickEvent", function(event) 
        self:PurchaseItem()
    end)
}
```
7. 상점 버튼을 누를 때의 이벤트를 받도록 Event Handler에 **ShopOpenEvent**를 추가합니다. self를 눌러 Entity로 변경하고, 버튼 엔티티를 지정합니다. ![EventHandler](https://mod-file.dn.nexoncdn.co.kr/bbs/1668773199934df13c978c30e49b0989d36024f8a5ce4.png)```
Method:
[client only]
void RefreshShop()
{
    self._T.ItemName = nil
    self._T.ItemName =  self.Entity:GetChildByName("ItemName").TextComponent
    local SearchResult = _WorldShopService:GetProductAndWait(self.ItemID)
    self._T.ItemName.Text = SearchResult.Name
}

Event Handler:
[entity] ShopOpenBtn (/ui/DefaultGroup/ShopOpenBtn)
HandleShopOpenEvent(ShopOpenEvent event)
{
    -- Parameters
    --------------------------------------------------------
    self:RefreshShop()
}
```

#### 상품 지급하기

**MyShopLogic**에 포션 상품 구매에 성공하는 경우 포션 100개를 얻을 수 있도록 아래와 같이 입력합니다. `WorldShopService:SetProcessPurchaseCallback`을 활용해 상품 구매가 발생했을 때 상품을 지급합니다. 상품을 지급이 성공하면 true를, 실패하면 false를 반환해야 합니다.

```
Method:
[server only]
void OnBeginPlay()
{
    _WorldShopService:SetProcessPurchaseCallback(self.ProcessPurchase)
}


[server only]
boolean ProcessPurchase(any purchaseInfo)
{
    local userEntity = _UserService:GetUserEntityByUserId(purchaseInfo.UserId)
     
    if _EntityService:IsValid(userEntity) == false then
        log_error("유효하지 않은 사용자! PurchaseId: " .. purchaseInfo.PurchaseId .. " / " ..
                    "UserId: " .. purchaseInfo.UserId .. " / " ..
                    "ProductId: " .. purchaseInfo.ProductId)
        return false   
    end
    
    if purchaseInfo.ProductId == "ItemID를 입력하세요" then     
        userEntity.PlayerReward:GetPotion(100)
    end
    if purchaseInfo.ProductId == "PassID를 입력하세요" then
    
        userEntity.PlayerReward:PassCheck()
    
    end
    
    return true
}
```

#### UI에 상품 구매 여부 반영하기

상품이 구매한 유저에게 반영될 수 있도록 만들어 봅시다.

1. 새로운 **PlayerReward** 컴포넌트를 생성하고, **DefaultPlayer**에 추가합니다.
2. 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None] 
TextComponent PotionValue = /ui/DefaultGroup/MyPotionInfo/PotionValue     
[Sync]    
number Potion= 0    
[None]
TextComponent PotionValue = /ui/DefaultGroup/MyPotionInfo/PassValue        
[Sync]
boolean HasPass = false
```
3. 포션 아이템을 구매했을 때 100개를 지급 받을 수 있도록 아래와 같이 작성합니다.```
Method:
void GetPoint(number value)
{
    self.Potion = self.Potion + Value
}

[client only]
void OnSyncProperty(string name, any value)
{
    if self.Entity ~= _UserService.LocalPlayer then
        return
    end

    if name == "Potion" then
        self.PotionValue.Text = value
    end
}
```
4. 포션 Pass 이용권을 구매했을 때 이용권 보유 UI가 변경되도록 아래와 같이 작성합니다. 이용권 ID에는 등록한 이용권 ID를 입력합니다.```
[client]
void PassCheck()
{
    if self.Entity ~= _UserService.LocalPlayer then 
        return 
    end

    if _WorldShopService:UserHasPassAndWait(self.Entity.Name, "이용권 ID") then 
        self.PassValue.Text = "O"
        self:PassUpdate(true)
    else
        self.PassValue.Text = "x"
        self:PassUpdate(false)
    end
}

[server only]
void OnBeginPlay()
{
    self:PassCheck()
}

[server]
void PassUpdate(boolean value)
{
    self.HasPass = value
}
```
5. 이용권이 있을 때 공격을 누를 때마다 추가로 포션 15개를 획득할 수 있게 아래와 같이 작성합니다.```
Event Handler:
{
    -- Parameters
    local ActionName = event.ActionName
    local PlayerEntity = event.PlayerEntity
    --------------------------------------------------------
    if self:IsServer() == false then 
        return 
    end 

    if self.HasPass == false then 
        return 
    end 

    if ActionName ~= "Attack" then 
        return 
    end 

    self:GetPotion(15)
}
```

> **Tip** 이용권은 한 번만 구매할 수 있으므로 재구매가 가능한지 사전 확인이 필요합니다. 이미 구매한 이용권을 구매 버튼을 누르면 구매 불가 안내창이 나타납니다. ![AlreadyGotItem](https://mod-file.dn.nexoncdn.co.kr/bbs/1669032829433abbe55794afa4b9c8aa997f6831de580.png)
> **Tip** 구매한 유저만 소유할 수 있는지 이용권 출시 전 반드시 확인해야 합니다. 메이커에서 테스트용 유저를 추가해 이용권을 구매한 사람만 소유할 수 있는지 확인 후 월드 출시하기를 권장합니다.

##### 참고 가이드

‘유료’ 확률형 콘텐츠를 제공하는 경우 확률 정보 공개 가이드에 따라 콘텐츠 사용 전 사용자에게 고지해야 할 의무가 있습니다. [확률 정보 공개](/docs/?postId=667)를 참고해 상품을 제작하길 바랍니다.

- [상품 등록하기](/docs?postId=581)
- [상품 관리하기](/docs?postId=658)

Update 2025-12-02 PM 03:52


# 아바타 상품 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서 크리에이터는 직접 제작한 아바타 아이템을 판매할 수 있습니다. 이번 가이드에서는 제작한 아바타 아이템 판매 방법을 알아봅니다. 판매하기 전에 아바타 아이템을 제작하고 등록하는 방법은 아래 가이드를 참고해 봅시다.

##### 참고 가이드

- [아바타 아이템 제작](/docs/?postId=582)

> **더 알아보기** 아이템 제작, 판매할 때는 [메이플스토리 월드 크리에이터 운영정책](https://maplestoryworlds.nexon.com/legal/policy/699)을 준수하기 바랍니다.

# 아바타 상품 만들기

아바타 아이템을 판매하려면 먼저 아바타 아이템을 제작한 후 등록해야 합니다. [아바타 아이템 등록하기](/docs/?postId=590) 가이드를 참고하여 제작한 아이템을 먼저 등록한 뒤 아래 과정을 진행합니다.

1. 아이템을 등록한 후 [메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/)에 들어가 **[아바타 상품 만들기]** 메뉴를 클릭합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1669007328991a5c617b7ca474648a05cb21e632762ff.png)
2. 아바타 아이템 목록에서 내가 등록한 아이템을 확인한 후, **[+ 상품등록]** 버튼을 클릭합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16690073628804fdcf39b19d14594b6e5ff259b91e819.png)
3. 아바타 상품 만들기 페이지에서 상품 이름, 가격, 판매 기간, 출시 여부를 설정합니다. 상품 설명은 선택 입력 사항입니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/166900757567106f1cba685c745408c2d2c8a946d6c15.png)
4. 이용약관에 동의한 후 **[등록]** 버튼을 클릭합니다.
5. 등록비를 결제하면 상품에 상점에 등록됩니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16690087351190c5842cc74524e81beec924fc4a8c332.png) ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1669008749635e118c8be5b0148119d5f080e6cb66915.png)
6. 아바타 상품 목록에 정상적으로 등록된 것을 확인합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/1669008790305183b1d518e594964b3d31ec8e4a7fc24.png)
7. 클라이언트에서도 정상적으로 판매되는 것을 확인합니다.

# 아바타 상품 수정하기

이미 등록한 아바타 상품 정보를 수정할 수 있습니다.

1. 아바타 상품 목록에서 원하는 상품의 **[수정]** 버튼을 클릭합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/166900912623816ad7427f92844bbba84178f28746f04.png)
2. 상품 가격, 판매 기간, 출시 여부 및 상품 설명을 수정할 수 있습니다. 원하는 정보를 수정 후 **[수정]** 버튼을 클릭합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16690091362509ff950272fb949cb9ec05fe3b6e55afd.png)

# 아바타 상품 판매 상태

아바타 상품은 출시 여부, 등록비 결제 여부, 판매 기간, 제재 등에 따라 판매 상태가 달라집니다. 판매 상태는 다음과 같이 구분됩니다.

| 판매 상태 | 설명 |
| :---: | --- |
| 미출시 | 출시 여부를 '미출시'로 설정한 상태이며, 판매 기간이 되어도 상점에 노출되지 않고 판매도 불가합니다. <br>플레이어가 이미 보유하고 있는 상품도 확인 불가합니다. |
| 결제 대기 | 상품 등록 후 등록비를 결제하기 전 단계입니다. |
| 판매 대기 | 판매 시작일 이전에 등록이 완료된 상태로 상품의 판매 시작일에 맞춰 판매 중 상태로 변경됩니다. |
| 판매 중 | 판매가 시작된 상태로 판매 종료일이 설정된 경우 해당 기간까지 상품을 판매합니다. |
| 판매 종료 | 판매 종료일이 지난 상태로 상점에서 상품을 판매하지 않습니다. |
| 제재 중 | 해당 상품이 제재 처리된 상태입니다. <br>상점에서 노출되지 않으며 유저에게 판매할 수 없습니다. |

상품은 판매 종료 상태가 되어도 플레이어가 이미 구매한 상품은 계속 소유할 수 있습니다.

Update 2025-11-17 PM 08:15


# 월드코인 환불하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 크리에이터가 자신의 월드에서 상품을 제작해 판매할 수 있습니다. 하지만 여러 가지 이유로 상품을 구매한 유저에게 환불 요청을 받을 수 있습니다. 메이플스토리 월드에서는 크리에이터 편의를 위해 상품 구매 관련 로그를 제공할 예정이나 아직은 로그 조회 시스템을 구축하는 중입니다. 시스템이 완성되기 전까지는 크리에이터가 직접 자신의 월드에 구매 정보를 기록하고 조회하는 스크립트를 추가해두어야 합니다.  이번 시간에는 **월드 내 상품 구매 정보를 기록/조회하는 방법**과 이를 토대로 **유저에게 환불해 주는 방법**을 알아보겠습니다.

# 월드코인 환불 의무

원칙적으로 크리에이터가 판매 중인 아이템이 아래 경우에 해당한다면 구매자에게 월드코인을 환불해 주어야 합니다.  **1. 이용자가 월드 내에서 구매한 유료 상품(콘텐츠, 아이템 등)을 미사용하였으며 구매일로부터 7일이 지나지 않았을 경우 2. 크리에이터가 임의로 유료 상품(콘텐츠, 아이템 등)을 삭제 또는 변경하여 보유 중인 상품(콘텐츠, 아이템 등)에 중대한 영향을 준 경우 3. 월드 내 유료 상품(콘텐츠, 아이템 등)의 섬네일 또는 설명과 실제 지급된 상품이 다를 경우**

> **더 알아보기** 월드코인 환불 관련 상세 내용은 [크리에이터 운영 정책](https://maplestoryworlds.nexon.com/legal/policy/699)의 **8. 환불(코인 반환)정책**을 참고 바랍니다.

특히 3번 항목에는 크리에이터의 실수로 유저의 월드코인만 소비시키고 실제 아이템 지급이 되지 않은 경우도 해당됩니다. 이런 경우에는 구매자의 환불 요구가 정당한지 먼저 확인해야 합니다. 구매자가 정상적으로 코인을 지불했는데도 상품을 획득하지 못한 것이 맞는지 확인 후 환불 여부를 결정해야 하기 때문입니다. 이제 상품 구매 정보를 기록하고 조회하는 방법을 살펴봅시다.

# 상품 구매 정보 기록하기

상품 구매 정보를 기록하는 예제 코드는 아래와 같습니다.

```
-- 구매자의 상품 구매 요청에 대한 콜백 함수 등록
_WorldShopService:SetProcessPurchaseCallback(function(purchaseInfo)
    -- 구매에 대한 처리가 완료되면 관련 정보를 기록합니다.
    _LogStorageService:LogPurchaseInfo(purchaseInfo, "아이템 구매 완료")
end)
```

이와 같은 형태로 월드 내에서 상품 구매 요청이 발생할 경우, 관련 정보가 기록되도록 처리합니다.

# 상품 구매 정보 조회하기

기록한 구매 정보를 조회하는 예제 코드를 살펴봅시다.

```
-- 협정 세계시 기준으로 11월 25일부터 11월 30일 사이에 기록된 구매 정보를 조회합니다.
local fromDate = DateTime(2022, 11, 25)
local toDate = DateTime(2022, 11, 30)
_LogStorageService:GetPurchaseLogPagesAsync(fromDate, toDate, function(purchaseLogPages)  
    while true do
        -- GetCurrentPageDatas()로 현재 페이지의 목록을 가져옵니다.
        local purchaseLogs = purchaseLogPages:GetCurrentPageDatas()
 
        for index, purchaseLog in ipairs(purchaseLogs) do
            -- 가져온 목록을 순회하며 기록된 내용을 확인합니다.
            -- 추가로 기록할 로직이 있다면 이곳에 넣으면 됩니다.
            log(purchaseLog)
        end
 
        -- PurchaseLogPages의 IsLastPage 프로퍼티를 통해 현재 페이지가 마지막 페이지인지 확인할 수 있습니다.
        if purchaseLogPages.IsLastPage == true then
            break
        end
 
        -- MoveToNextPageAndWait()로 다음 페이지로 넘어갈 수 있습니다.
        purchaseLogPages:MoveToNextPageAndWait()
    end
end)
```

구매 정보를 조회하는 방법은 크리에이터가 원하는 형태로 구현하면 됩니다. 예를 들어, 본인이 제작하고 출시한 월드에 접속했을 때 크리에이터에게만 보이는 별도의 UI를 만들고 해당 UI에서 상품 구매 정보를 조회하는 형태로 구현할 수도 있습니다. 상품 구매 정보 조회는 메이커에서 테스트할 수 없고 월드 출시 이후 확인할 수 있습니다. 비공개 월드로 출시하여 조회가 정상적으로 진행되는지 확인한 후 공개 전환하는 것을 권장합니다.

# 환불 방법

위와 같은 절차로 구매 정보를 확인했을 때 구매자의 환불 요청이 정당하다고 판단되면 크리에이터는 구매자에게 환불해 주어야 합니다.

1. [메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/) 로그인 후 내 계정의 구매 내역 페이지를 엽니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16693566958837ea77011b2f54531be6227c52125f1d1.png)
2. 구매 내역 페이지에서 **[월드코인 내역]** 버튼을 클릭합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1669356709913369a7fa841b949e2b773853613a4cccb.png)
3. 월드코인 수익 내역에서 환불해 주려는 주문번호를 확인한 뒤 **[상세보기]** 버튼을 클릭합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16753934060756a5a48a5a8cb41ceab043202f19d49c0.png)
4. 주문 상세 정보에서 수익 금액 옆의 **[환불하기]** 버튼을 클릭합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1675393847138262176ffe1b54eec97b9373b61d830c8.png)
5. 확인 팝업 창에서 **[확인]** 버튼을 클릭하면 환불 처리됩니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/166927504244455fbec33eb2c4f0ea85ce774d17d2d8a.png)
6. 다시 월드코인 내역으로 돌아와 환불 완료 처리된 것을 확인합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1675394107929fbd4e7adfddc434daf57232364a93c1f.png)

## 주의사항

- **월드 아이템, 아바타 아이템**은 판매 후 30일까지 크리에이터가 환불해 줄 수 있습니다.
- 환불을 요청한 유저의 계정에 따라 환불 방식이 다릅니다. 계정 유형은 가입된 지역에 따라 한국/ 그 외로 구분됩니다.
  - **한국 계정의 환불 요청**인 경우 크리에이터는 유저가 선택한 환불 사유가 타당한지 검토해야 합니다. 검토 후 환불 요청을 거절하거나 승인할 수 있습니다. 환불 사유로는 상품 불일치, 잘못된 구매, 품질 문제, 단순 변심, 기타가 있습니다.
  - **그 외 계정의 환불 요청**인 경우 판매 후 30일 이내의 환불 요청에 대해서만 환불 요청을 거절하거나 승인할 수 있습니다.

Update 2025-11-17 PM 08:15


# 메이플스토리 월드에서 수익 출금하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 유료로 판매한 CGC 상품을 통해 수익을 획득할 수 있으며, 획득한 수익은 일정 조건 충족 및 절차를 거쳐 현금으로 출금할 수 있습니다.

**✓ 메이플스토리 월드 내 수익 창출 방법**

1. **아바타 상품 판매 수익**
  - ‘아바타 상점’에 등록된 상품을 이용자가 구매할 수 있습니다.
2. **월드 상품 판매 수익**
  - 월드 내에서 판매 중인 월드 상품(월드 아이템, 이용권)을 이용자가 구매할 수 있습니다.

# 내 수익 출금 조건

메이플스토리 월드에서 수익을 현금으로 출금할 수 있는 조건은 다음과 같습니다.

| 항목 | 내용 |
| --- | --- |
| 계정 조건 | <ul><li>만 18세 이상 본인인증이 완료된 계정</li>*자세한 사항은 [\[플랫폼 가이드 넥슨 ID 인증 방법\]](https://maplestoryworlds.nexon.com/ko/community/2129/2130/2472792)을 참고 부탁드립니다.</ul> |
| 최소 지급 요청액 | <ul><li>100 USD</li><li>‘지급 예정(수익 대기)’ 상태에서 ‘수익’으로 전환된 금액만 인정</li><li>1회 최소 100 USD ~ 최대 10,000 USD까지 출금 가능</li><li>USD가 아닌 각 국가별 원화 (ex. KRW)로 신청 시 Tipalti 내부 정책에 따라 통화별 최소 송금액 기준이 다를 수 있으며, 해당 최소 송금액 기준에 미달할 경우 출금이 거절됩니다.<br>* 자세한 사항은 [티팔티 FAQ(바로가기)](https://support.tipalti.com/Content/Topics/UserGuide/PaymentInformation/PaymentMethodsCoverage/IntroUSD.htm?Highlight=krw)를 참고해주시길 바랍니다.</li></ul> |
| 신청 기간 | <ul><li>한 달에 1회 신청 가능</li><li>출금 신청은 UTC+0 기준으로 신청 횟수가 갱신됩니다.</li>![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1767338986284c0fe367f6e66458bab3d8559f013d2ff.png)<li>출금 승인 결과에 관계없이 출금 신청이 완료되면 당월 출금 신청 횟수를 사용한 것으로 판단됩니다. 출금 반려 시 다음월에 재신청 부탁드립니다.</li></ul> |
| 크리에이터 정보 등록 | <ul><li>출금 신청 시 크리에이터 정보가 등록되어 있어야 합니다.</li><li>최초 등록 시 등록된 정보에 대해 심사가 진행되며, 승인 완료 이후 출금 신청이 가능합니다.</li><li>심사 완료 후 등록된 주요 정보에 수정사항이 생길 경우 재심사가 진행될 수 있습니다.</li></ul> |

# 출금을 위한 크리에이터 정보 등록하기

메이플스토리 월드에서 **출금을 신청하기 위해서는 크리에이터 정보 등록이 필요**합니다. 최초 등록된 크리에이터 정보에 대해서는 심사를 거쳐 승인이 완료된 이후부터 출금 신청이 가능합니다.

크리에이터 정보 심사는 **매월 15일(UTC+9 기준 ~23:59)까지 등록된 크리에이터 정보를 대상**으로 진행됩니다.

| 항목 | 내용 |
| --- | --- |
| 당월 심사 대상 | 전월 16일 오전 0시 ~ 당월 15일 오후 11시 59분까지 크리에이터 정보 등록을 완료한 경우 |
| 다음월 심사 대상 | 당월 16일 오전 0시 ~ 다음월 15일 오후 11시 59분까지 크리에이터 정보 등록을 완료한 경우 |

15일 내 정보 등록을 완료하셨더라도 크리에이터 정보 심사에 시일이 소요될 수 있으니, 심사 완료 및 출금 신청 간 여유 일정을 두어 최소한 출금 신청 희망일 한달 전에는 등록해두시는 것을 권장 드립니다.

크리에이터 정보 등록 및 심사가 완료되면 이후에는 추가 심사 절차 없이 바로 출금 신청이 가능하나, **등록된 주요 정보가 수정될 경우에는 재심사 과정이 발생**할 수 있습니다.

아울러, 등록된 크리에이터 정보는 출금 신청 과정에서도 활용되며, 등록된 크리에이터 정보와 출금 신청 정보가 일치하지 않을 경우 출금이 거절될 수 있으니, 출금 신청 시에는 크리에이터 정보의 최신화 여부를 확인 부탁드립니다.

#### 출금을 위한 크리에이터 정보 등록 경로

출금 신청 페이지 또는 계정 프로필 페이지를 통해 출금을 위한 크리에이터 정보 수정 페이지에 진입할 수 있습니다.

| 출금 신청 페이지를 통한 진입 | 계정 프로필 페이지를 통한 진입 |
| --- | --- |
| ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17454596149448215ae7b0cd2465b869e7519a088470c.png) | ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1745459655647250ceb23ff264e91b57caa4ad1084e05.png) |

#### 크리에이터 유형 선택하기

메이플스토리 월드에서 활동하고 있는 크리에이터 유형을 선택해주세요. 크리에이터 유형은 **법인 사업자, 개인 사업자, 개인**으로 구분됩니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17673394362803f6d54d053c84122842ce960b0cf3ad8.png)

#### 크리에이터 정보 등록하기

**1. 공통**

- 기본 정보
  - 크리에이터 기본 정보 중, 성명, 생년월일, 이메일주소, 전화번호는 넥슨ID 정보를 토대로 자동 기입됩니다.
  - 지급 수단의 명의를 포함한 **출금 관련 정보**는 메이플스토리 월드를 이용하는 크리에이터 계정의 **넥슨 홈페이지 회원 명의 정보와 일치해야 합니다.**
  - 기본 정보는 [넥슨 홈페이지>내정보>개인정보변경]에서 수정하실 수 있습니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17673400488757f79195dcd834397a95ecc4548355f36.png)

**2. 개인 크리에이터**

- 자동으로 기입된 기본 정보를 기반으로 영문 성명 및 주소 정보를 추가로 등록합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17673400645890b64f650bce941eba0ced08fd41e444b.png)

**3. 개인 사업자 크리에이터**

- 자동으로 기입된 기본 정보를 기반으로 영문 성명 및 주소 정보와 사업자 정보를 추가로 등록합니다.
- 신고된 사업자등록증(필수), 통신판매업신고증(선택)을 증빙 문서로 첨부해야 하며, 증빙 문서를 첨부하면 등록증의 정보를 자동으로 불러옵니다.**※ 확인해주세요!**
  - **사업자등록증의 유효성을 확인**해주세요. 유효하지 않은 사업자등록증을 첨부할 경우 등록에 실패할 수 있습니다.
  - **사업자등록증 내 사업자 정보****와 크리에이터 계정의 넥슨 홈페이지 회원 명의 정보가 일치**해야 합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1767340078455879c5fafc21847feb486d8450ede02f3.png)

**4. 법인 사업자 크리에이터**

- 자동으로 기입된 기본 정보를 기반으로 영문 성명 및 주소 정보와 사업자 정보를 추가로 등록합니다.
- 신고된 사업자등록증(필수), 법인인감증명서(필수), 크리에이터 플랫폼 이용 위임 계약서 및 크리에이터 위임장(필수), 통신판매업신고증(선택)을 증빙 문서로 첨부해야 하며, 증빙 문서를 첨부하면 등록증의 정보를 자동으로 불러옵니다.**※ 확인해주세요!**
  - **사업자등록증의 유효성을 확인**해주세요. 유효하지 않은 사업자등록증을 첨부할 경우 등록에 실패할 수 있습니다.
  - 크리에이터 플랫폼 이용 위임 계약서 및 크리에이터 위임장 양식은 법인 크리에이터 정보 입력 화면에서 다운로드할 수 있습니다.
  - **위임장 내 출금 담당자 정보****와 크리에이터 계정의 넥슨 홈페이지 회원 명의 정보가 일치**해야 합니다. *위임 대상자(= 출금 신청하는 크리에이터 계정 명의자)가 아닌 다른 구성원의 정보가 입력되지 않도록 유의해주세요.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17673401066999d48c7ba0acd4b43a58dbb378b68a9f6.png)

# 출금 신청하기

출금 신청은 메이플스토리 월드 공식 홈페이지에서 진행할 수 있으며, 출금 조건을 만족하고 등록된 크리에이터 정보 심사가 완료되면 출금 신청 페이지의 [출금 신청하기] 버튼이 활성화됩니다.

**1. [메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/) 접속 후 메이플스토리 월드 계정으로 로그인합니다.**

**2. 우측 상단의 계정 아이콘 → '월드코인'을 클릭합니다.**

**3. [![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17453728693241b680c02f53e4c4aa28aefa4c232b6d0.png) 내역] 버튼을 클릭해 크리에이터 출금 페이지로 진입합니다.** ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/174537715636483d4921bf2db41c289743fc17c753052.png)

**4. [출금하기] 버튼을 클릭하여 출금 신청 조건 및 등록된 크리에이터 정보 심사 완료 여부를 확인 후 [출금 신청 하기] 버튼을 클릭합니다.** ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1745377337526f50ebc56d91d4ecca74f416a535aaa85.png) ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17453773500633d61fb1687704827bc364c2f60ea1252.png)

**5. 출금 신청 금액을 입력하고 약관을 확인한 뒤, [출금 신청 하기] 버튼을 클릭합니다.** ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17453774083478abe7c39e54842e68eea131af2c72f91.png)

**6. 출금에 필요한 모든 요청 정보를 입력합니다.** **출금 수익 지급을 위한 정보 입력 단계로, 출금 중개 서비스인 ‘Tipalti’에서 입력을 진행합니다.**

**※ 확인해주세요!**

- 출금을 위한 크리에이터 정보 등록 단계에서 입력한 기본 정보는 자동으로 불러와지며, 이외 정보는 크리에이터 계정과 동일한 정보를 입력해주세요. 등록된 정보와 출금 상세 정보가 다를 경우 승인이 거절될 수 있습니다.
- 사용자의 거주 국가 설정에 따라 이후 요구하는 지급 정보가 달라질 수 있습니다.
- 모든 입력 정보는 영문 기입을 기본으로 합니다. 이 외 언어를 입력할 경우 최종 지급 단계에서 반려될 수 있습니다.  **① 메이플스토리 월드에서 불러온 기본 정보가 제대로 입력되어 있는지 확인합니다.** ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1745377738000e9e4f8c8081f45c894171b3fa14427c6.png)

**② 지급 수단 정보를 입력합니다. 지급 수단 정보는 ①번에서 입력된 계정 소유주의 정보여야 합니다.**

- 국내 기준 eCheck, 송금, 체크 수표, PayPal 중 지급 방식을 선택할 수 있습니다. 단, 거주 국가에 따라 지원하는 지급 방식에 차이가 있을 수 있습니다.
- 출금 통화(Payment Currency)는 설정 국가의 원화와 USD 중 선택할 수 있습니다. 단, 선택한 지급 수단에 따라 출금 통화 선택에 차이가 있을 수 있습니다. *원화로 출금 신청 시 일반 송금 수수료와 차이가 있을 수 있습니다. *USD로의 출금은 외환 계좌를 보유한 경우에만 가능합니다.

**③ 세금 신고 정보를 입력합니다.**

- 미국 / 미국 외 국가로 분류되며, 세금 양식 선택 가이드를 참고하여 세금 신청을 진행할 수 있습니다.

**④ 정보 제출이 완료되었습니다. 이후 출금 신청에 대한 검토가 진행됩니다.**

- 정상적으로 제출이 완료되었다면 메이플스토리 월드 공식 홈페이지를 통해 신청 완료 문구를 확인할 수 있습니다.

# 출금 신청 정보 확인하기

출금 신청이 완료되면 신청 다음월에 메이플스토리 월드의 지급에 대한 적합성 심사 과정이 진행됩니다. 심사 결과에 따라 지급 승인 혹은 거절 결과가 전송되며, 지급 현황 및 거절 사유는 메이플스토리 월드 홈페이지에서 확인할 수 있습니다.

출금 신청 건에 대한 검토는 매월 새롭게 진행되며, 과거 출금 신청이 거절되었더라도 출금 신청에 대한 적합성이 확인되면 승인될 수 있습니다.

신청 완료된 출금 신청은 취소가 불가능합니다. 신청 완료 전 다시 한 번 확인해주세요.

#### 출금 신청 현황 확인 경로

**1. [메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/) 접속 후 MSW 계정으로 로그인합니다.**  **2. 우측 상단의 계정 아이콘 → '월드코인'을 클릭합니다.**  **3. [출금 내역 보기] 버튼을 클릭해 크리에이터 출금 페이지로 들어갑니다.**  ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1745377961985b8ebc172fe774754a39855836cadae12.png)

#### 필수 확인 사항

**1. [출금내역 보기]는 적합성 심사 후 승인된 내역에 대해 조회됩니다.** 출금 신청 후 심사가 완료되기 전까지는 신청 건에 대한 조회가 어려울 수 있습니다.

- [수익 내역] 페이지를 통해 수익 차감 여부를 확인해주세요.
- 신청 일자에 ‘출금’으로 수익이 차감되었다면 출금 신청이 진행된 것입니다.

**2. 출금 신청 완료 시 계정 내 보유하고 있던 수익이 즉시 차감되며, 적합성 심사 및 최종 지급 승인된 이후 현금으로 출금된 금액을 확인할 수 있습니다.**

- 매월 신청된 출금 건은 익월 말까지 처리되며, 내부 검토 과정에 따라 지연될 수 있습니다.

**3. 실제 지급은 선택한 지급 수단 혹은 출금 신청 국가에 따라 처리 시간이 다를 수 있습니다.** 지급 수단별 예상 처리 시간은 아래와 같으며, 실제 처리 과정에서 예상 시간보다 더 소요될 수 있습니다.

| 지급 수단 | 처리 시간 |
| --- | --- |
| 송금 | 영업일 기준 1~5일 |
| PayPal | 영업일 기준 2~3일 |
| eCheck | 영업일 기준 3~5일 |
| 체크 수표 | 영업일 기준 7~14일 |

**이외 출금 관련 주의 사항은 크리에이터 운영 가이드 [\[18강 (활용) 크리에이터 수익 출금하기\]](https://maplestoryworlds-creators.nexon.com/ko/resource/CreatorGuide/Guide18)에서도 상세 안내드리고 있으니 함께 확인 부탁드립니다.**

Update 2026-01-02 PM 05:41


# 월드코인 정산 비율

# 학습 과정 소개

이번 과정에서는 크리에이터가 판매한 월드 상품과 아바타 상품(‘크리에이터 제작 콘텐츠’를 의미하며 이하 ‘CGC 상품’)이 어떻게 수익으로 전환되는지 알아봅시다. 메이플스토리 월드에서 CGC 상품을 판매하시면 일정한 정산 비율을 거쳐 크리에이터 수익으로 적립해 드립니다. 자세한 정산 비율은 아래 항목을 참고해 주세요.

# 월드코인 정산 비율

메이플스토리 월드는 CGC 상품 판매 금액의 65%를 공제한 후, 35%를 USD로 크리에이터님께 정산해 드립니다. 자세한 정산 비율은 아래 그래프를 참고해 주세요.

**판매 수수료 (30%)** CGC 상품 판매 시, 판매 수수료 30%가 자동 공제됩니다. 판매 수수료에는 각 스토어(Google, Apple)에서 발생하는 결제 수수료, PG 수수료 등이 해당됩니다. 메이플스토리 월드는 상품 판매 시 차감되는 판매 수수료 외 어떤 수수료도 청구하지 않습니다.

**Toben (35%)** CGC 상품 판매 시, 판매 수수료를 제외한 수익(70%)의 50%를 Toben Studio Inc.에 정산합니다. 정산된 수익은 서버, DB, 솔루션의 유지와 더불어 더 나은 플랫폼 서비스를 제공하기 위한 개발, R&D, 마케팅 등 운영 및 유지비용으로 사용됩니다.

**크리에이터 (35%)** CGC 상품 판매 시, 판매 수수료를 제외한 수익(70%)의 50%를 크리에이터님께 정산해 드립니다. CGC 상품은 모두 동일한 정산 비율을 가지고 있습니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1744251496690ba02c799916b4c24beadc0fe044a12fd.png)

Update 2025-08-27 PM 07:53


# 로컬라이징의 이해

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터가 제작한 월드를 다양한 지역의 유저들이 즐길 수 있도록 하려면 로컬라이징 과정은 필수적입니다. `LocalizationService`는 클라이언트의 언어를 기반으로 텍스트나 어셋 등을 해당 언어에 맞게 제공할 수 있도록 도와줍니다. 이번 과정에서는 로컬라이징의 개념을 살펴보고 `LocalizationService`를 사용해 텍스트를 번역하는 방법을 알아봅시다.

##### 참고 가이드

[포맷에 맞게 로컬라이징하기](docs/?postId=968) [자동 번역](docs/?postId=1072) [LocalDataSet](docs?postId=1120)

##### 참고 API Reference

[LocalizationService](/apiReference/Services/LocalizationService)

# 로컬라이징이란?

좁은 의미의 **로컬라이징**은 기본적으로 월드에서 유저가 보는 단어나 문장을 **번역**하는 것입니다. 예를 들어 크리에이터가 지원 언어를 '한국어'로만 설정한 월드가 있습니다. 이 월드에 클라이언트 언어를 영어로 설정한 유저가 접속했을 때 단어 **사과**를 **Apple**로 번역하는 것입니다.

로컬라이징 의미를 넓게 보면 월드의 언어와 여러 요소를 각 언어 및 문화권에 맞게 아울러 지원하는 것입니다. 예를 들어 날짜 표기법이 다릅니다. 한국의 날짜 표기법은 **연/월/일** 순입니다. 2023년 1월 31일은 "2023/01/31"과 같은 방식으로 씁니다. 반면에 미국, 캐나다 등에서는 보통 **월/일/년** (01/31/2023)으로 표현합니다. 또 다른 문화권에서는 **일/월/년** (31/01/2023)으로 표현하기도 합니다. 다른 예시로 문화권 별로 다른 숫자 표기 방식이 다릅니다. **1234567.89** 숫자를 한국, 미국, 캐나다 등에서는 보통 천 단위 구분 기호로 쉼표(,)를 사용하고 소수점으로는 마침표(.)를 사용해 **1,234,567.89**로 표기합니다. 하지만 프랑스, 독일, 오스트리아 등에서는 천 단위 구분 기호로 마침표(.)를 사용하고 소수점으로 쉼표(,)를 사용해 **1.234.567,89**로 표기합니다. 또 다른 문화권에서는 **1 234 567.89**과 같이 천 단위 구분 기호를 따로 쓰지 않고 그냥 공백으로 표현하기도 합니다.

따라서 여러 언어 문화권 유저의 편의를 고려해 날짜, 숫자를 문화권에 맞는 형식으로 표현할 필요가 있습니다. 로컬라이징은 단순한 번역이 아닌 각 문화권에서 접속하는 유저가 불편 없이 콘텐츠를 이용할 수 있도록 조정하는 과정 전체를 통칭합니다.

## 메이플스토리 월드의 로컬라이징

메이플스토리 월드는 장기적으로 글로벌 원빌드를 지향합니다. 그렇기에 하나의 서버에 여러 지역에서 접속한 클라이언트가 함께 연결될 수도 있습니다. 때문에 메이플스토리 월드에서는 하나의 텍스트를 동시에 여러 언어로 번역할 수 있도록 지원하고 있습니다. ![101](https://mod-file.dn.nexoncdn.co.kr/bbs/167479872265151ac9e8a10ee49638f070ced7e26e7b1.png)

다만 서버에서는 로컬라이징된 메시지 자체를 직접 발송하는 것이 아니라 로컬라이징 키(Localizing Key)를 보내야 합니다. 로컬라이징 키로 통신하며 클라이언트 언어 설정 별로 다르게 출력하면 됩니다. 메이플스토리 월드에서 실제 로컬라이징을 어떤 방식으로 할 수 있는지 예제와 함께 살펴보도록 하겠습니다.

# 텍스트 번역하기

클라이언트 언어 설정에 따라 텍스트를 번역하려면 번역 테이블을 생성해야 합니다..

#### LocaleDataSet 만들기

LocaleDataSet을 활용해 간단한 방법으로 텍스트를 번역해 봅시다.

1. UI 에디터에서 텍스트 엔티티를 추가합니다. ![islocal](https://mod-file.dn.nexoncdn.co.kr/bbs/1686728912583c7cafe2f6fa244b49e51195f776c6ed2.png) 추가한 텍스트 엔티티의 **TextComponent**에서 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| :---: | :---: | :---: | | TextComponent | FontSize | 50 | | Text | UI_Hello | | IsLocalizationKey | True |
2. **LocaleDataSet**을 생성하고 아래와 같이 입력합니다. | ID | Key | Source | ko | en |
| :---: | :---: | :---: | :---: | :---: | | 1 | UI_Hello | Hello! | 안녕하세요! | Hello! |
3. 클라이언트의 언어 설정이 한국어인 상태에서 ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 누른 뒤 테스트해 봅시다. **안녕하세요!**라고 출력되는 것을 확인할 수 있습니다. ![hello1](https://mod-file.dn.nexoncdn.co.kr/bbs/1674808092988390b7fa2c4e648b28503ad01d9a744a5.png)
4. 상단 메뉴에서 언어 설정을 한국어를 영어로 변경합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1720601013220ffb2496a775d4a3190fe5ddbea8d7ad2.png)
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. **Hello!**라고 출력됩니다.![hello2](https://mod-file.dn.nexoncdn.co.kr/bbs/167480819908819eb8fb051a2483d878600f5f3fa548f.png)

## GetText 함수

**TextComponent**의 텍스트는 **IsLocalizationKey**로 간단하게 번역 여부를 설정할 수 있지만 그 외의 텍스트를 번역해야 하거나, 스크립트에서 번역을 제어할 때는 `GetText()` 함수를 활용합니다. `GetText()` 함수는 번역 테이블의 **Key**열에서 인수(argument)로 받은 키와 같은 값을 가진 행을 찾아 해당 행에서 클라이언트 언어 코드와 동일한 열의 텍스트 값을 반환합니다.

간단한 예제를 통해 클라이언트의 언어 설정별 텍스트 출력 방법을 알아봅시다. 맵에 2명의 NPC를 배치하고 언어 설정에 따라 적절한 이름을 출력해 보겠습니다.

1. 맵에 NPC 2명을 배치합니다. 본 예제에서는 아래의 두 NPC를 배치했습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/167410631018585e61a9abb2544af96dbb18c261313f3.png)
  - npc-931
  - npc-845
2. 각 NPC 엔티티의 이름을 아래와 같이 수정합니다. | NPC | Entity Name |
| :---: | :---: | | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1674097464492fb3054921620425a80664d1380f3f695.png) | Stan | | ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16740974755475f8d0c294b5a491f907eefb8acc7bad1.png) | Rina |
3. **LocaleDataSet**을 생성하고 아래와 같이 입력합니다. | ID | Key | Source | ko | en |
| :---: | :---: | :---: | :---: | :---: | | 1 | UI_TEXT_NPC_Stan | Stan | 스탄 | Stan | | 2 | UI_TEXT_NPC_Rina | Rina | 리나 | Rina |
4. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Logic**을 클릭하고 **LocalizationTest**라는 이름으로 새 로직을 추가합니다.
5. **LocalizationTest**에 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
Entity Stan = /maps/map01/Stan
[None]
Entity Rina = /maps/map01/Rina
```
6. `OnBeginPlay()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client only]
void OnBeginPlay()
{
    self.Stan.NameTagComponent.Name = _LocalizationService:GetText("UI_TEXT_NPC_Stan")
    self.Rina.NameTagComponent.Name = _LocalizationService:GetText("UI_TEXT_NPC_Rina")
}
```
7. 클라이언트의 언어 설정이 한국어인 상태에서 ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 누른 뒤 테스트해 봅시다. NPC 이름이 아래와 같이 나오는 것을 확인할 수 있습니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/16741065097102ce4bfb23e3c453aaae7dc1b04f14365.png)  언어 설정을 영어로 바꾸면 NPC 이름이 아래와 같이 영어로 나오는 것을 확인할 수 있습니다. ![9en](https://mod-file.dn.nexoncdn.co.kr/bbs/1674106659362b89a441ef8b045ed811972bb1bdd84e7.png)

### Translator

**LocalizationService**에는 **LocalTranslator** 프로퍼티가 있습니다.

- **LocalTranslator** 프로퍼티의 타입은 [**Translator**](/apiReference/Misc/Translator)입니다.
- **LocalTranslator**는 **LocaleId**(string 타입 프로퍼티)를 갖고 있습니다.

다음 두 줄의 코드는 같은 값을 반환합니다.

```
_LocalizationService:GetText("UI_TEXT_NPC_Stan")                   -- 스탄
_LocalizationService.LocalTranslator:GetText("UI_TEXT_NPC_Stan")     -- 스탄
```

**LocalTranslator**의 **LocaleId**는 현재 실행 중인 클라이언트의 언어 코드입니다. 예를 들어, 현재 실행 중인 클라이언트의 언어가 한국어라면 **LocalTranslator**의 **LocaleId**는 **ko**입니다. **LocalizationService**에서 별도로 생성한 **Translator**를 사용하지 않고 곧바로 `GetText()`등의 함수를 호출하면 **LocalTranslator**의 **LocaleId**를 기준으로 기능을 수행합니다. 만일 현재 클라이언트 언어 설정이 한국어인데 영어 번역을 가지고 오고 싶다면 다음과 같이 코드를 작성하면 됩니다.

```
local enTranslator = _LocalizationService:GetTranslatorForLocale("en")
enTranslator:GetText("UI_TEXT_NPC_Stan") -- Stan
```

# 리소스 로컬라이징

텍스트 뿐만 아니라 리소스도 필요에 따라 로컬라이징할 수 있습니다.

예제를 통해 살펴봅시다.

1. UI 에디터에서 [ ![image](https://mod-file.dn.nexoncdn.co.kr/storage/icons/UI/icon_image.png) ] 이미지 버튼을 눌러 빈 이미지를 생성하고 이름을 **SpriteTest**로 변경합니다.
2. 새 스크립트 컴포넌트 **SpriteLocalization**를 생성합니다. 그리고 위에 생성한 **SpriteTest** 이미지에 컴포넌트를 추가합니다.
3. **SpriteLocalization** 스크립트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
string ResourceKey = ""
```
4. `OnInitialize()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client only]
void OnInitialize()
{
    self.Entity.SpriteGUIRendererComponent.ImageRUID = _LocalizationService:GetText(self.ResourceKey)
}
```
5. **SpriteTest**의 프로퍼티 에디터에서 **SpriteLocalization - ResourceKey**에 **RESOURCE_LOGO**라고 입력합니다.![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1674184215431d6a44d479721419f9e694e289de686ce.png)
6. **LocaleDataSet**을 열고 아래 내용을 추가합니다.
  - **Key** : **RESOURCE_LOGO**
  - **Source** : **3110502e753742d39794e042c2657ce5**
  - **ko** : **7ae6a288ee884b75a44851c59b595789**
  - **en** : **3110502e753742d39794e042c2657ce5**
7. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 언어 설정이 한국어일때는 한국어 로고 이미지가, 영어일 때는 영어 로고 이미지가 나옵니다.![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16741847984983e92b71d5e1f48d3b3469a98d7feb597.png)

Update 2025-12-02 PM 03:52


# LocaleDataSet

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

월드의 텍스트 번역 시 필수적으로 사용해야 하는 LocaleDataSet에 대해 알아봅시다.

##### 참고 가이드

[로컬라이징의 이해](docs/?postId=951) [포맷에 맞게 로컬라이징하기](docs/?postId=968) [자동 번역](docs/?postId=1072)

# LocaleDataSet 소개

LocaleDataSet은 번역을 위한 전용 DataSet입니다. LocaleDataSet은 **Default, WebSync** 두 종류가 있습니다. LocaleDataSet은 **Workspace - MyDesk - Create LocaleDataSet**에서 **Default, WebSync**중 하나를 선택해 생성할 수 있습니다. ![LocaleDataSet](https://mod-file.dn.nexoncdn.co.kr/bbs/16983152847384b0c9b653fc74b3ea842f39a739ac243.png)

#### Default

기본 LocaleDataSet입니다. Key, Source, Note 컬럼이 기본으로 추가되어 있으며 크리에이터가 컬럼을 추가해 번역문을 입력하고 관리할 수 있습니다. Default 종류의 LocaleDataSet은 공식 홈페이지의 번역 관리와 연동되지 않습니다. 열 추가 버튼을 눌러 번역할 수 있는 언어 목록을 선택해 언어 코드를 추가할 수 있습니다. 언어 코드는 중복으로 추가할 수 없습니다. Default LocaleDataSet는 번역의 양이 많지 않아 메이커에서 직접 번역 관리가 가능한 경우 사용하기 적합합니다.

![default](https://mod-file.dn.nexoncdn.co.kr/bbs/16988269998795f9915d9c6c5478d8c93413d8b9bf3e7.png)

#### WebSync

WebSync LocaleDataSet은 공식 홈페이지의 번역 관리에서 번역한 내용을 진행하고, 메이커의 LocaleDataSet 에디터에서 연동해 확인할 수 있는 LocaleDataSet입니다. 마지막으로 편집한 시점을 저장해 공식 홈페이지의 번역 관리와 연동합니다. WebSync LocaleDataSet은 Key, Source, Note 컬럼만 편집할 수 있으며, 메이커에서 새로운 컬럼을 추가할 수 없습니다. 번역을 동기화하면 수정 불가능한 컬럼이 자동으로 추가됩니다. WebSync LocaleDataSet는 월드를 제작하는 멤버 수가 많아 메이커에 직접적으로 접근하는 사람 수 관리가 필요하거나, 번역 양이 많을 때 사용하기 적합힙니다.

![WebSync](https://mod-file.dn.nexoncdn.co.kr/bbs/169837602461617090b6ba590446daa40528e6ab4150c.png)

# LocaleDataSet 에디터

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/custom/1120/Doc_1120_2_ko.png)

| 번호 | 설명 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | **컬럼 셀**<br>각 열의 데이터명, 즉 컬럼 명을 정의합니다. 기본 고정 컬럼 셀은 삭제가 불가능합니다<br><ul><li>**Key**: 식별자 키입니다. 중복된 Key를 사용할 수 없습니다.</li><li>**Source**: 원본 언어, 원본 내용</li><li>**Note**: 번역자에게 제공할 추가 정보를 입력합니다. 해당 정보는 공식 홈페이지 번역 관리에서 확인할 수 있습니다.</li></ul> |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | **셀**<br>각 셀은 인풋 텍스트 필드로 각 열의 정의에 적합한 데이터 값을 입력합니다. 입력한 데이터 값은 모두 스트링으로 저장됩니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | **행 추가 버튼**<br>버튼을 누르면 행 끝에 새로운 행을 추가합니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | **열 추가 버튼**<br>버튼을 누르면 열 끝에 새로운 행을 추가합니다. LocaleDataSet이 Default인 경우 번역할 언어를 선택해 언어 코드를 추가할 수 있고, WebSync인 경우 비활성화 됩니다. |
| ![5](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_05.jpg) | **Sync 버튼**<br> 공식 홈페이지의 번역 관리의 번역문을 연동합니다. Sync 버튼을 눌러 연동하면, 에디터에 컬럼이 추가됩니다. 추가된 컬럼은 메이커에서 할 수 없습니다.<br> **웹에서 데이터 가져오기**<br>Google SpreadSheet의 데이터를 가져올 수 있습니다.<br>Google SpreadSheet에서 데이터를 작성한 후 해당 데이터의 URL을 팝업창에 넣어주면 현재 열려있는 데이터에 Google SpreadSheet의 데이터를 덮어씌웁니다. 단, Google SpreadSheet의 URL은 웹에 게시한 URL만 사용할 수 있습니다. <br>Import 기능을 사용할 때는 LocaleDataSet 형식에 맞춰 Key, Source, Note 순으로 머릿글 행이 채워져 있어야 합니다. 그 외 다른 데이터는 모두 삭제된 채로 Import합니다.<br>![NO_05_1](https://mod-file.dn.nexoncdn.co.kr/bbs/1656660216362c29ce81d29e6400caa25bc648b91058a.png)<br>**CSV 파일 불러오기**<br>컴퓨터에 저장된 CSV 파일을 가져와 현재 데이터에 덮어씌울 수 있습니다. utf-8로 저장된 CSV 파일만 정상적으로 가져올 수 있습니다.<br>불러오기 기능을 사용할 때는 LocaleDataSet 형식에 맞춰 Key, Source, Note 순으로 머릿글 행이 채워져 있어야 합니다. 그 외 다른 데이터는 모두 삭제된 채로 데이터를 가져옵니다.<br>**CSV 파일 내보내기**<br>메이커의 LocaleDataSet을 CSV 파일로 내보내어 컴퓨터에 저장할 수 있습니다. |

# 번역 관리

메이커에서 생성한 WebSync 타입의 LocaleDataSet은 공식 홈페이지에서 번역할 수 있습니다. 또한 번역 관리에서 번역한 내용을 메이커의 LocaleDataSet 에디터에 연동할 수 있습니다. 번역 관리는 **공식 홈페이지 - 월드 만들기 - 크리에이터의 제작 월드 - 번역 관리 - 월드 콘텐츠**에 있습니다. 메이플스토리 월드는 현재 한국어, 영어 번역만 지원하고 있습니다.

![WebLocalizing](https://mod-file.dn.nexoncdn.co.kr/bbs/1698372454364d4e1b9829c23441eac692acab07bfcc1.png)

| 번호 | 설명 |
| --- | --- |
| ![1](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_01.jpg) | **월드 콘텐츠** <br>메이커에서 생성한 LocaleDataSet의 목록입니다. |
| ![2](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_02.jpg) | **Sync UP**<br>버튼을 눌러, 메이커에서 생성한 LocaleDataSet의 정보를 최신화할 수 있습니다. |
| ![3](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_03.jpg) | **검색창**<br> Key, Source, Note를 기준으로 번역문을 검색할 수 있습니다. |
| ![4](https://mod-file.dn.nexoncdn.co.kr/storage/numbers/NO_04.jpg) | **번역문**<br> Key, Source, Note 정보를 함께 확인하고, 번역할 수 있습니다. **[저장]** 버튼을 눌러 번역을 저장할 수 있습니다. 메이커에 번역을 연동 시킬 때는 메이커에서 **[Sync]** 버튼을 눌러야합니다. |

Update 2025-12-02 PM 03:52


# 포맷에 맞게 로컬라이징하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

로컬라이징을 할 때, 번역할 텍스트에 상황에 따라 변할 수 있는 문자열이 포함될 수도 있습니다. 이럴 때 활용할 수 있는 함수를 알아보고 예제를 통해 그 사용법을 살펴보도록 합시다. 본 과정을 진행하기 전에 [로컬라이징의 이해](/docs?postId=951) 가이드를 먼저 살펴보면 도움이 됩니다.

# 포맷에 맞게 변환하기

번역할 텍스트에는 월드 상황에 따라 변할 수 있는 문자열이 포함될 수 있습니다. 예를 들어, 단순하게 한국어 **"리나"**를 영어 **"Rina"**로 번역하는 것이 아니라 **"안녕, {0}!"**라는 문장(포맷)을 번역하는 상황을 생각해 봅시다. 그리고 {0} 빈칸에는 "리나(Rina)", "스탄(Stan)", "알렉스(Alex)" 등 여러 NPC의 이름이 들어갈 수 있다고 가정해 봅시다. **"안녕, {0}!"**처럼 특정한 포맷이 있고, 이 문장의 빈칸을 상황에 따라 적절한 단어로 채워서 문자열을 출력하는 것을 **"포맷에 맞게 변환한다."**고 표현할 수 있습니다.  포맷은 인수 빈칸(Argument hole)을 갖고 있습니다. 위의 예시 문장에서 **{0}** 부분이 바로 **Argument hole**입니다. ![arghole](https://mod-file.dn.nexoncdn.co.kr/bbs/167480440826756abe6fbe7164b5588aa34f246d61f4f.png) 포맷의 한 문자열 안에는 여러 개의 **Argument hole**이 존재할 수 있습니다.  포맷에 맞게 변환할 때는 `GetTextFormat()` 또는 `SmartFormat()` 함수를 활용합니다. 각 함수의 활용 방법을 자세히 살펴봅시다.

## GetTextFormat

`GetTextFormat()` 함수는 **LocalizationTable**에서 **Key**를 인수로 받습니다. 이 **Key**에 해당하는 텍스트를 찾고, 추가로 전달 받은 포맷 인수(format argument)가 있다면 그것을 형식에 맞게 채워 넣은 결과를 반환합니다.

예를 들어 아래와 같이 NPC 2명이 서 있고, 플레이어 캐릭터가 각 NPC와 만나면(충돌하면) 주황색 텍스트 상자에 **"안녕, NPCName!"**라는 문장을 출력해봅시다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1674106811875c0dbb4e97c5a4c7595813713f1ed11ce.png)

1. 맵에 NPC 2명을 배치하고 각 NPC 엔티티의 이름을 아래와 같이 수정합니다. | NPC | Entity Name |
| :---: | :---: | | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1674097464492fb3054921620425a80664d1380f3f695.png) | Stan | | ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16740974755475f8d0c294b5a491f907eefb8acc7bad1.png) | Rina |
2. **NPC Stan**과 **Rina**에 **TriggerComponent**를 추가합니다.
3. UI 에디터에서 **ui - DefaultGroup**에 텍스트 엔티티를 추가하고 이름을 **TextBox**로 설정합니다. 그리고 각 프로퍼티를 아래와 같이 설정합니다. | 프로퍼티 | 값 |
| --- | --- | | ImageRUID | b9ab8455d5737bf4cb21433f00fdc19d | | Color | ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16752124711410bee46bc546d4bc68fd23e8476ca817e.png) |
4. **LocalizationTable**을 생성하고 아래와 같이 입력합니다. | ID | Key | Source | ko | en |
| :---: | :---: | :---: | :---: | :---: | | 1 | UI_TEXT_NPC_Stan | Stan | 스탄 | Stan | | 2 | UI_TEXT_NPC_Rina | Rina | 리나 | Rina | | 3 | UI_TEXT_HELLO | Hello, {0}! | 안녕, {0}! | Hello, {0}! |
5. 새 스크립트 컴포넌트 **LocalizationTest**를 생성합니다. 그리고 **Workspace - DefaultPlayer**에 **LocalizationTest** 컴포넌트를 추가합니다.
6. **LocalizationTest**에 아래와 같이 프로퍼티를 추가합니다.```
Property:
[None]
Entity Stan = /maps/map01/Stan
[None]
Entity Rina = /maps/map01/Rina
```
7. `OnBeginPlay()` 함수를 추가하고 아래와 같이 작성합니다. 실행 공간은 **client only**로 설정합니다.```
[client only]
void OnBeginPlay()
{
    self.Stan.NameTagComponent.Name = _LocalizationService:GetText("UI_TEXT_NPC_Stan")
    self.Rina.NameTagComponent.Name = _LocalizationService:GetText("UI_TEXT_NPC_Rina")
}
```
8. 이벤트 핸들러에 **TriggerEnterEvent**를 추가합니다. 실행 공간은 **client only**로 설정합니다. 그리고 아래와 같이 내용을 작성합니다.```
[client only][self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local npcName = TriggerBodyEntity.NameTagComponent.Name
    local translateText = _LocalizationService:GetTextFormat("UI_TEXT_HELLO", npcName)
    _EntityService:GetEntityByPath("/ui/DefaultGroup/TextBox").TextComponent.Text = translateText
}
```
9. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 클라이언트의 언어 설정에 따라 적절한 메시지가 나옵니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16741095688573170d1d86f0543609e51f38f2bce3942.gif) ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1674109590083201ff51e11794e63b0343f945ff0e693.gif)

## SmartFormat

`GetText()`나 `GetTextFormat()`은 번역 테이블을 필요로 합니다. 번역 테이블을 사용하지 않고 `GetTextFormat()`의 포맷 기능만 따로 이용하고 싶다면 `SmartFormat()` 함수를 사용합니다. `SmartFormat()`에서는 인수로 **LocalizationTable**의 **Key** 대신 출력할 문자열을 직접 받습니다.  ![format](https://mod-file.dn.nexoncdn.co.kr/bbs/16750583548154a12eeaac0d048d39e1820ca865996a3.png)  `SmartFormat()`를 사용해 위의 예제를 구현하면 아래와 같습니다.

```
[client only][self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local npcName = TriggerBodyEntity.NameTagComponent.Name
    local translateText = _LocalizationService:SmartFormat("안녕, {0}!", npcName)
    _EntityService:GetEntityByPath("/ui/DefaultGroup/TextBox").TextComponent.Text = translateText
}
```

하지만 이렇게 설정하면 클라이언트 언어 설정이 영어(en)일 때도 한국어로 "안녕"이 출력될 것입니다. 각 언어 설정에 맞게 출력하려면 이벤트 핸들러를 아래와 같이 수정합니다.

```
[client only][self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local npcName = TriggerBodyEntity.NameTagComponent.Name
    local localeId = _LocalizationService.CurrentLocaleId
    
    local translateTextKo = _LocalizationService:SmartFormat("안녕, {0}!", npcName)
    local translateTextEn = _LocalizationService:SmartFormat("Hello, {0}!", npcName)
    
    if localeId == "ko" then 
	_EntityService:GetEntityByPath("/ui/DefaultGroup/TextBox").TextComponent.Text = translateTextKo
    elseif localeId == "en" then
    	_EntityService:GetEntityByPath("/ui/DefaultGroup/TextBox").TextComponent.Text = translateTextEn
    end
}
```

# 포맷 활용하기

위에서 살펴본 것처럼 **LocalizationService**에서는 텍스트의 변환 서식을 설정할 수 있는 두 가지 API를 제공합니다.

- **GetTextFormat(string key, any... args)**
- **SmartFormat(string format, any... args)**

포맷에 포함되어 있는 **Argument hole**에는 단순한 단어가 들어갈 수도 있지만 특정 규칙에 맞춰 변환된 문자가 들어갈 수도 있습니다. 예를 들면 한국어 조사나 단수 복수 처리가 이에 해당합니다. **Argument hole**의 형식은 다음와 같습니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/167411584046890fd957c327e4425ae0066bd4307301b.png) 여기서 대괄호([])안의 내용은 선택적 요소들입니다. 즉, {0} 처럼 단순히 인덱스만 넣을 수도 있지만 **formatterName**과 **formatterArgument**를 설정할 수도 있습니다. **formatter**를 활용하면 각 언어 문화권의 문법에 맞고 자연스러운 문장으로 변환할 수 있습니다.  **formatter**로 아래의 두 가지를 사용할 수 있습니다.

| formatterName | 기능 | 설명 |
| :---: | --- | --- |
| hpp | 한국어 조사 처리 | 인수로 받은 문자열의 마지막 글자가 종성을 포함하는지 아닌지 여부에 따라 두 개의 formatterArgument중 하나를 출력합니다. |
| plural 또는 p | 단수, 복수 처리 | <ul><li>인수로 받은 숫자(숫자로만 구성된 문자열 포함)를 기반으로 명사 또는 단위 표현 시 복수형을 처리합니다.</li><li>formatterArgument의 개수는 언어마다 다릅니다.</li><li>자세한 규칙은 [링크](https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/language_plural_rules.html#jv)를 참고합니다.</li></ul> |

각 **formatter**을 활용하는 방법을 자세히 살펴봅시다.

## hpp : 한국어 조사 처리

한국어에서 조사는 체언(명사, 대명사, 수사) 뒤에 붙어 문법의 의미를 더하는 품사입니다. 체언의 받침 유무에 따라 뒤에 붙는 조사가 달라집니다. 예를 들어, **"나는 [ ]을/를 만납니다."** 라는 문장이 있다면 빈칸 [ ]에 들어갈 단어의 마지막 글자 종성 유무에 따라 조사 **'을'** 또는 **'를'**이 연결됩니다.

| 빈칸에 들어갈 단어 | 조사 | 완성된 문장 |
| :---: | :---: | :---: |
| 스탄 | 을 | 나는 스탄을 만납니다. |
| 리나 | 를 | 나는 리나를 만납니다. |

이러한 처리를 할 수 있도록 해주는 것이 **hpp**입니다. 기본 형태는 아래와 같습니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1674181700829ead15381640f44de9a63d997522d22d0.png)

| 기준 | 조사 |
| --- | --- |
| 앞의 체언에 종성 있을 때 | 은, 이, 을, 과, 아, 이여, 이랑, 으로 |
| 앞의 체언에 종성 없을 때 | 는, 가, 를, 와, 야, 여, 랑, 로 |

예제를 통해 hpp의 사용 방법을 알아봅시다.

1. **LocalizationTable**을 열고 아래와 같이 3행을 수정합니다. | ID | Key | Source | ko | en |
| :---: | --- | --- | --- | --- | | 3 | UI_TEXT_HELLO | I meet {0}. | 나는 {0}{0:hpp:을\|를} 만납니다. | I meet {0}. |
2. 이벤트 핸들러를 아래와 같이 수정합니다.```
[client only][self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local npcName = TriggerBodyEntity.NameTagComponent.Name
    local translateText = _LocalizationService:GetTextFormat("UI_TEXT_HELLO",npcName)
    _EntityService:GetEntityByPath("/ui/DefaultGroup/TextBox").TextComponent.Text = translateText
}
```
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 클라이언트의 언어 설정에 따라 적절한 메시지가 나옵니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16741799873045e413c513a6a4640a91b930f3b1da366.gif) ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16741799991931b62b30881134d439b8416dd3296fb7e.gif)

## plural : 단수, 복수 처리

한국어는 단수, 복수 관련 처리가 별도로 필요하지 않지만 단수, 복수 관련 처리가 필요한 언어도 있습니다. 이를 처리하기 위한 **plural**의 기본 형태는 아래와 같습니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/167418048551082631b1ae8ec4e51b5e53e487bac5857.png)

예를 들어 영어는 1개일 때는 단수로 취급하지만 나머지는 복수로 취급합니다. 따라서 총 두 개의 **formatterArgument** 받습니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1674180498732cb6f503c59a940ab8340f688dd1470b6.png)

아래와 같이 활용해봅시다.

```
_LocalizationService:SmartFormat("I have {0:plural:an apple|{} apples}.", 2) -- I have 2 apples.
```

위와 같이 **formatterArgument** 중 하나에만 인수로 받은 문자열을 출력하고 싶다면 비어있는 중괄호 {}를 사용합니다.

> **Tip.** **plural**은 **p**로 줄여서 쓸 수 있습니다.

## 예외

다음과 같이 포맷이 올바르지 않을 때는 원문 그대로 출력합니다.

##### formatterName이 틀린 경우

**formatterName**에 띄어쓰기가 포함되었거나, 오탈자가 있다면 원문이 그대로 출력됩니다.

```
-- 1) 언어 설정 영어 : formatter name에 띄어쓰기가 포함된 경우 
log(_LocalizationService:SmartFormat("I have {0: plural:an apple|{} apples}.", 2))
```

![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1675214317926babf748aa5a14e4db96a7f039a29cc3d.png)

```
-- 2) formatter name 자체가 틀린 경우 (예: hpp를 hp로 잘못 작성)
log(_LocalizationService:SmartFormat("나는 {0}{0:hp:을|를} 만났다.", "스탄"))
```

![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16752143336956dc58a0870ac444e9df8d70251208021.png)아래와 같이 수정하면 포맷에 맞게 제대로 변환된 문자열이 출력됩니다.

```
log(_LocalizationService:SmartFormat("I have {0:plural:an apple|{} apples}.", 2))
```

![18a](https://mod-file.dn.nexoncdn.co.kr/bbs/1675214386354a550210300ea457d82d969f5ecb641a8.png)

```
log(_LocalizationService:SmartFormat("나는 {0}{0:hpp:을|를} 만났다.", "스탄"))
```

![19a](https://mod-file.dn.nexoncdn.co.kr/bbs/16752144025748615eeea77e545de9bb158996665c1ad.png)

##### 입력한 formatterArgument의 수가 요구하는 수와 다른 경우

이런 경우에는 상황에 따라 정상 출력될 수도 있고 포맷에 맞게 변환하는데 실패해 원문 그대로 출력될 수도 있습니다. 아래의 예시를 참고 바랍니다.

```
-- 언어 설정 한국어 : plural 사용
log(_LocalizationService:SmartFormat("아이템 {0:plural:한 |여러 }개를 획득했다.", 1))
-- 결과 : 원문 출력  (한국어 plural은 1개의 formatter argument만 받기 때문)
```

![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1675213948789797bb2bfe84142ce88c090892532edf1.png)

```
-- 언어 설정 영어 : formatter argument의 개수가 필요한 개수와 다른 경우
log(_LocalizationService:SmartFormat("I have {0:plural:one}.", 1))
-- 결과 : 원문 출력 (영어 plural은 2개의 formatter argument를 받기 때문)

-- 언어 설정 영어 : formatter argument를 공백으로 둘 때
log(_LocalizationService:SmartFormat("I have {0:plural:|}.", 1))
-- 결과 : 정상 출력 (빈 문자열을 formatter argument로 사용함)
```

![22](https://mod-file.dn.nexoncdn.co.kr/bbs/167521385644376cb49230ea64165b8e61d50f95b8c01.png)

##### 중괄호 {}의 쌍이 맞지 않는 경우

중괄호가 중첩되거나 포맷이 잘못된 경우에는 제대로 변환이 이루어지지 않으므로 원문 그대로 출력됩니다.

##### formatArgument의 개수와 argument hole의 인덱스가 맞지 않는 경우

이런 경우에는 상황에 따라 정상 출력될 수도 있고 포맷에 맞게 변환하는데 실패해 원문 그대로 출력될 수도 있습니다. 아래의 예시를 참고 바랍니다.

```
-- 언어 설정 영어 : format argument의 개수가 argument hole의 최대 인덱스 +1보다 많음
log(_LocalizationService:SmartFormat("I have {0:plural:an apple|{} apples} and {1:plural:a cherry|{} cherries}.", 2, 1, 1))
-- 결과 : 정상 출력

-- 언어 설정 영어 : format argument의 개수가 argument hole의 최대 인덱스보다 적음
log(_LocalizationService:SmartFormat("I have {0:plural:an apple|{} apples} and {1:plural:a cherry|{} cherries}.", 2))
-- 결과 : 원문 출력

-- 언어 설정 영어 : format argument의 인덱스를 건너 뛰어서 사용
log(_LocalizationService:SmartFormat("I have {1:plural:an apple|{} apples}.", 0, 1))
-- 결과 : 정상 출력
```

![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1675214079174ce82f7da440c49c1a1208d193461cad1.png)

Update 2025-11-20 PM 02:03


# 월드 정보와 배지, 상품 번역하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터가 제작한 월드 정보, 상품, 배지, 아바타 상품 정보를 번역하여 제공한다면 보다 다양한 지역의 유저들이 재미있게 월드를 즐길 수 있을 것입니다. [공식 홈페이지](https://maplestoryworlds.nexon.com/)의 번역 관리 메뉴를 활용하면 영어, 한국어 번역문을 입력할 수 있습니다. 본 가이드를 통해 월드 정보, 상품, 배지, 그리고 아바타 상품의 번역 적용 방법을 알아보겠습니다.

# 번역 관리하기

[메이플스토리 월드 공식 홈페이지](https://maplestoryworlds.nexon.com/)에서 **[월드 만들기]** 메뉴로 들어간 뒤, 번역할 월드를 선택합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/167625326897495623b9665374e3bb63f53fa92cbbfdf.png)  해당 월드의 관리 페이지에서 **[번역 관리]** 메뉴로 들어가면 한국어 및 영어로 내용을 입력할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/16762639843762ccb043479b547a088a96f93bd00a8d0.png)

## 월드 정보 번역

번역 관리 페이지에서 월드 이름, 설명 등 월드 정보를 번역할 수 있습니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1676268127959ab4f11ab1cea4b17bfe2b9e67f37abb7.png)

1. 월드 정보 하위 메뉴에서 번역하려는 정보를 클릭합니다.
2. 기존에 작성해 둔 내용을 참고하여 번역문을 입력합니다.
3. **[저장]** 버튼을 클릭해 작성한 내용을 저장합니다.

## 상점 상품 번역

월드에 등록해 둔 상품이 있다면 해당 상품의 이름, 섬네일, 설명을 번역할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/167626991452558c8ab2579b541f98ba25a7c0140fe43.png)

1. 번역하려는 상점 상품을 선택합니다.
2. 상품 이름을 번역합니다.
3. 상품 섬네일을 등록합니다. 한국어 사용 유저와 영어 사용 유저에게 각기 다른 섬네일을 보여줄 때 활용합니다.
4. 상품 설명을 번역합니다.
5. **[저장]** 버튼을 클릭해 작성한 내용을 저장합니다.

> **더 알아보기** 상품을 등록하는 방법은 [**상품 등록하기**](/docs/?postId=581) 가이드를 참고합니다.

## 배지 번역

배지 이름, 섬네일, 설명을 번역할 수 있습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16762700589361f038dd11b91478ebd3ea9ae4fc110c3.png)

1. 번역하려는 배지를 선택합니다.
2. 배지 이름을 번역합니다.
3. 배지 섬네일을 등록합니다. 한국어 사용 유저와 영어 사용 유저에게 각기 다른 섬네일을 보여줄 때 활용합니다.
4. 배지 설명을 번역합니다.
5. **[저장]** 버튼을 클릭해 작성한 내용을 저장합니다.

> **더 알아보기** 배지를 등록하는 방법은 [**배지 등록하기**](/docs/?postId=656) 가이드를 참고합니다.

## 아바타 상품 번역

아바타 상품을 번역할 수 있습니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16770343644112aa1262edd574c5e9db05235cbead89a.png)

1. **[아바타 상품 만들기]** 메뉴로 들어갑니다.
2. **[번역관리 바로가기]** 버튼을 클릭합니다.
3. 번역하려는 아바타 상품을 선택합니다.
4. 상품 이름을 번역합니다. 아바타 상품 이름은 한 번 등록하면 수정할 수 없으므로 신중하게 결정 후 저장합니다.
5. 상품 설명을 번역합니다.
6. **[저장]** 버튼을 클릭해 작성한 내용을 저장합니다.

> **더 알아보기** 아바타 상품을 만드는 방법은 [**아바타 상품 만들기**](/docs/?postId=830) 가이드를 참고합니다.

Update 2025-11-17 PM 08:15


# 자동 번역

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

메이플스토리 월드에서는 크리에이터가 지원하지 않은 언어의 자동 번역 기능을 지원합니다. 이 기능을 통해 크리에이터는 번역 부담을 덜고, 다양한 언어 사용자들은 보다 편하게 월드를 즐길 수 있습니다. 이번 과정에서는 자동 번역 기능 작동 방식과 설정 방법을 알아봅시다.

##### 참고 가이드

[WorldConfig](/docs?postId=1101) [로컬라이징의 이해](/docs/?postId=951) [포맷에 맞게 로컬라이징하기](/docs/?postId=968)

##### 참고 API Reference

[TextComponent](/apiReference/Components/TextComponent) [TextInputComponent](/apiReference/Components/TextInputComponent) [TextRendererComponent](/apiReference/Components/TextRendererComponent) [ChatBalloonComponent](/apiReference/Components/ChatBalloonComponent)

# 자동 번역 개념 소개

자동 번역은 크리에이터가 정식으로 지원하지 않는 언어의 번역을 기계 번역을 통해 제공하는 것을 의미합니다.

예를 들어 모어가 영어이며, 이중언어 구사자는 아닌 크리에이터가 월드를 제작해 출시했다고 생각해 봅시다. 이 크리에이터는 혼자 월드를 제작하고 있으므로, 월드에서 사용한 모든 단어와 문장을 다개국어로 번역해 제공하는 것은 시간 여건상 쉽지 않습니다. 이때 크리에이터는 자동 번역을 사용할 수 있습니다. 모어로 자동 번역 기준이 되는 원문만 작성하고, 지원 언어 또한 자신의 모어인 영어로만 설정해 월드를 출시합니다.

이 월드에 한국어만 구사하는 플레이어가 월드 언어 설정을 한국어로 변경하면 월드를 한국어로 즐길 수 있게 됩니다. 월드 설정에서 **언어(자동 번역)**로 표시되는 언어 중 번역하고자 하는 언어인 한국어를 선택하면 월드의 언어가 번역됩니다.

> **더 알아보기**- 자동 번역 옵션의 설정 정보는 기기별로 저장됩니다. - 번역할 내용이 5,000자 이상이면 번역되지 않으므로 주의해야 합니다.

# 자동 번역 설정

플레이어가 언어 설정 변경을 통해 자동 번역을 사용하기 위해서 크리에이터는 **AllowAutomaticTranslation**을 활성화해야 합니다. 이 프로퍼티는 `TextComponent, TextInputComponent, TextRendererComponent, ChatBalloonComponent`에 있습니다. 예제를 통해 자동 번역 설정 방법을 살펴봅시다.

1. 자동 번역할 텍스트 엔티티의 `TextComponent, TextInputComponent, TextRendererComponent, ChatBalloonComponent`에서 **AllowAutomaticTranslation**를 활성화합니다. ![AllowAutomaticTranslation](https://mod-file.dn.nexoncdn.co.kr/bbs/16983007897332bb3b13efdb14c27baa6ce77d2fd6f42.png)
2. 월드 출시 시 크리에이터가 정한 원문 언어와 직접 번역을 제공하는 언어를 **지원 언어**로 설정합니다. 출시 시 지원 언어로 설정하지 않은 언어는 자동 번역으로 제공됩니다. 출시한 월드에서 플레이어가 월드 언어에서 자동 번역 대상 언어로 설정할 경우, AllowAutomaticTranslation가 활성화된 모든 엔티티는 자동으로 번역됩니다.

![Realase](https://mod-file.dn.nexoncdn.co.kr/bbs/1698300827862477f0eab1ddc424e9f1a44c2658b117e.png)

> **Tip.** 크리에이터가 번역 기준으로 삼은 원문 언어는 **Workspace - WorldConfig - SourceLanguage**에서 설정할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1698826078961925a793678514dc0821fb980cf8072ee.png)
> **더 알아보기** 설정한 SourceLanguage와 다른 언어를 크리에이터가 월드에 임의로 입력한 경우 자동 번역이 정상적으로 동작하지 않을 수 있습니다. 자동 번역 시 작성된 언어와 상관없이 SourceLanguage로 설정한 언어로 가정하고 번역하기 때문입니다.

# 자동 번역 작동 방식

출시한 월드에 접속한 플레이어는 월드 언어 설정 창에서 해당 월드를 어떤 언어로 플레이할지 설정할 수 있습니다. 해당 월드의 미지원 언어는 월드 언어 목록에서 자동 번역으로 표시됩니다. 플레이어가 월드 언어에서 자동 번역 대상 언어를 설정할 경우, **AllowAutomaticTranslation 프로퍼티**가 활성화된 모든 엔티티는 자동 번역됩니다.

![language](https://mod-file.dn.nexoncdn.co.kr/bbs/1739775149202fb0268e2a9b344eaa392cc8c110b9514.png)

Update 2025-12-02 AM 10:55


# 서버 전용 엔트리 설정하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

크리에이터가 월드를 제작할 때 보안 상의 이슈로 게임을 플레이하는 유저들에게 공개하고 싶지 않은 DataSet이나 스크립트 내 함수가 존재할 수 있습니다. 이번 시간에는 DataSet이나 함수를 서버 전용으로 설정하는 방법에 대해 알아봅시다.

# 서버 전용 엔트리의 필요성

월드를 제작할 때, 예를 들어 쿠폰 코드나 게임상에서 활용되는 중요한 키, 대미지 공식이나 내부 로직 등의 정보는 서버에서만 처리되도록 하는 것이 안전합니다. 만약 이러한 중요 정보가 서버와 클라이언트 모두에 존재한다면 클라이언트에서도 중요 정보에 접근할 수 있으므로 보안에 취약할 수 있습니다. 이런 경우에는 중요한 DataSet이나 스크립트 내 함수의 구현부를 클라이언트로 전달되지 않도록 설정하여 보안 이슈를 해결해야 합니다.

# 서버 전용 DataSet 설정

DataSet의 ![property](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_inspector.png) Property에서 ServerOnly 체크 박스에 체크하면 해당 게임 월드를 플레이할 때 DataSet의 내용이 클라이언트로 전달되지 않도록 처리할 수 있습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1661169318239863cf967cd4a46d3b1467ddcf4659ddc.png) ServerOnly로 설정한 DataSet에는 클라이언트가 접근할 수 없으므로 크리에이터는 이 점을 감안하여 스크립트를 작성해야 합니다. 해당 DataSet의 일부 데이터가 특정 타이밍에 필요한 경우, 실행 제어나 동기화 등으로 클라이언트에 전달해야 합니다.

# 함수의 실행 공간 설정

스크립트 내 함수의 실행 공간을 ServerOnly 또는 Server로 설정하면 해당 함수의 구현부는 클라이언트에 전달되지 않습니다.

1. 함수 설정 버튼을 클릭한 뒤, Execution Space Setting 메뉴를 선택합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1661216740609c9bbe61a337e4b62ba90e21ab21e65e2.png)
2. 실행 공간을 Server 또는 ServerOnly로 설정합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16612169670630c1a142634e6421b8c693d1f83c9e811.png) 이렇게 설정된 함수의 구현부는 클라이언트에 전달되지 않습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/166117015841552bb10e2fffd476b82770fe72c0a5787.png)

Update 2025-11-17 PM 08:15


# 테스트 서버

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

출시한 월드에 안정적으로 콘텐츠 업데이트를 하려면 테스트 진행은 필수입니다. 예상치 못한 버그를 미리 발견하고 수정하기 위해 크리에이터는 테스트 서버를 열고 제한된 인원에게만 서버 키를 배포해 다양한 상황을 테스트할 수 있습니다. 이번 시간에는 테스트 서버 생성, 접속 및 폐쇄 방법을 알아보겠습니다.

# 테스트 서버 생성

크리에이터가 출시한 월드의 상세 정보 페이지로 들어갑니다. [⋯] 버튼을 눌러 콘텍스트 메뉴를 열고 **[테스트 서버 열기]** 메뉴를 클릭합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1679281107295511e211e33bd4ee886e4d47f70887df7.png)

이후 열린 팝업창에서 테스트 서버로 입장하거나, 서버 키를 복사할 수 있습니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/167894468121377cac3fad8884ef78987d59cb0ed440c.png)

# 테스트 서버 접속

**[테스트 서버 참가]** 메뉴를 클릭하여 테스트 서버에 접속합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16792811969272138b2803725445c965a8401f094e6f1.png)

서버 참가 창에 서버 키를 입력한 사람만 테스트 서버에 접속할 수 있습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/167894580671505d0f588307546d6bb9221db37959d7e.png)

# 테스트 서버 폐쇄

테스트 종료 이후, 크리에이터는 테스트 서버를 폐쇄할 수 있습니다. 테스트 서버 폐쇄 방법은 두 가지입니다.

- 월드 상세 페이지의 콘텍스트 메뉴에서 폐쇄
- 테스트 서버 안에서 직접 폐쇄

| 월드 상세 페이지 | 테스트 서버 |
| :---: | :---: |
| ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1679288336258cfa88ddd5fb741a08abc2a9dac343923.png) | ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1678948554540846dd9f0284242a493994244bdc8131a.png) |

테스트 서버가 폐쇄되면 서버 키 역시 폐기됩니다.

Update 2025-11-17 PM 08:15


# 모바일 기기의 진동 기능 활용

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

모바일 기기에서 진동을 울려 월드를 이용하는 유저에게 피드백을 줄 수 있습니다.

# MobileVibratorService

`MobileVibratorService`를 활용하면 모바일 기능에서 진동을 울릴 수 있습니다. 이 서비스는 모바일에서만 테스트와 활용이 가능하므로 메이커에서 테스트한다면 정상적으로 작동하지 않습니다.

# 활용 예제

버튼을 누를 때마다 진동과 함께 토스트 알림창이 나오게 만들어 봅시다.

![Example](https://mod-file.dn.nexoncdn.co.kr/bbs/16691656921273488fc31718d491dafd206dc89dd0996.gif)

1. **UI 에디터 - ui - DefaultGroup - Create Entity - Create Button**을 선택해 **UIButton_Vib**를 배치합니다.
  - ImageRUID: e00ce931b027545449e68e06b0f0b411
2. 새로운 **Vibrate** 컴포넌트를 생성하고 **UIButton_Vib**에 추가합니다.
3. **Vibrate** 컴포넌트에 ButtonClickEvent를 추가하고, entity로 변경한 뒤 **UIButton_vib**로 지정합니다.```
Event Handler:
[entity] (/ui/DefaultGroup/UIButton_Vib)
HandleButtonClickEvent (ButtonClickEvent event)
{
    local Entity = event.Entity
    --------------------------------------------------------
    if _MobileVibratorService:IsHWSupported() then
    	_MobileVibratorService:Vibrate()
    	_UIToast:ShowMessage("Vibration On")
    end
}
```
4. 비공개로 출시한 뒤 모바일 기기에서 버튼을 눌러 진동이 울리는지 확인합니다.

> **더 알아보기** 토스트 UI는 UI 에디터 - ToastGroup에서 편집 가능합니다.

Update 2025-11-17 PM 08:15


# 모바일 기기의 중력 센서 사용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

`MobileGyroscopeService`를 활용해 모바일 기기에서 자이로스코프 센서 기능을 지원하는지 확인하고, 값을 측정할 수 있습니다.

# MobileGyroscopeService

`MobileGyroscopeService`를 활용하면 모바일 기기의 중력, 중력 가속도, 회전 가속도 값 등을 측정해 기기가 어디서, 얼마만큼의 힘을 받아 움직였는지 알 수 있습니다. 예를 들어 핸드폰을 위로 던졌을 때 얼마나 위로 올라갔는지 측정할 때 이 서비스를 사용합니다.

MobileGyroScopeService는 모바일에서만 테스트와 활용이 가능합니다. 그러므로 기기가 자이로스코프 센서를 지원하는지 확인하고, 이를 지원하지 않는 기기를 사용 중이라면 안내해야 합니다.

```
void GyroscopeCheck (boolean onoff)
{
    if _MobileGyroscopeService:IsHWSupported() then
    	if _MobileGyroscopeService:IsEnabled() then
    		_MobileGyroscopeService:StopAndWait()
    	else
    		_MobileGyroscopeService:StartAndWait()	
    	end
    else
    	_UIToast:ShowMessage("Failed to start gyroscope")
    end
}
```

# 활용 예제

모바일 기기를 특정 방향으로 흔들었을 때 공이 해당 방향으로 힘을 받아 움직이게 만들어 봅시다. ![GyroExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1669112286682bf20fdee201444148bdcf22b3e9c2a8c.gif)

#### 벽 만들기

1. **Hierachy - World - maps - map01**에서 콘텍스트 메뉴를 열어 **Switch to RecTileMap**을 선택합니다.
2. **Hierachy - World - maps - map01**에 **PhysicsSimulatorComponent**를 추가합니다.
3. 새로운 **Wall** 엔티티를 생성하고, **TransformComponent, SpriteRendererComponent, CustomeFootholdComponent**를 추가합니다.
4. 벽 모양 RUID를 SpriteRendererComponent - SpriteRUID에 입력하고, 스프라이트 길이만큼 **CustomFootholdComponent**로 발판을 생성합니다.
  - SpriteRUID: 9b518d2cf3a549f4bdbbac8662fecd42
5. **PhysicsColliderComponent**를 추가하고, 충돌 영역을 스프라이트 크기에 맞게 조정합니다.
6. **PhysicsRigidbodyComponent**를 추가하고, 프로퍼티를 설정합니다.
  - BodyType: Static
  - Friction: 0.5
  - Restitution 0.2
  - CollisionDetectionMode: Continuous
7. 만든 벽을 3개 복사해 사각형 벽을 만듭니다.

#### 공 만들기

1. 새로운 **TiltBall** 엔티티를 생성하고,**TransformComponent, SpriteRendererComponent**를 추가합니다.
2. 공 모양 RUID를 SpriteRendererComponent - SpriteRUID에 입력합니다.
  - SpriteRUID: 777ee92d25c84f839a12739590d149b6
3. TiltBall에 **PhysicsColliderComponent**를 추가하고, **ColliderType**을 **Circle**로 설정한 뒤 충돌 영역을 스프라이트에 맞게 지정합니다.
4. **PhysicsRigidbodyComponent**을 추가하고, 프로퍼티를 아래와 같이 설정합니다.
  - BodyType: Dynamic
  - Mass: 1
  - Friction: 0.2
  - Restitution: 1
  - CollisionDetectionMode: Discrete
  - GravityScale: 1
  - SleepingMode: StartAwake

#### 공 움직이게 만들기

1. 새로운 **GyroscopeLogic**을 생성합니다.
2. Property를 추가하고, BallEntityRef에 TiltBall을 지정합니다.```
Property:
[None]
EntityRef BallEntityRef = /maps/map01/TiltBall
[None]
number ForcePower = 100
```
3. `MobileGyroscopeService:IsHWSupported()`를 활용해 기기에서 자이로스코프 센서를 지원하는지 확인한 후, 값 측정을 시작합니다.```
[client only]
void OnBeginPlay
{
    if _MobileGyroscopeService:IsHWSupported() then
    	local enabled = _MobileGyroscopeService:StartAndWait()
    	if enabled then
    		_UIToast:ShowMessage("Gyroscope Started!")
    	else
    		log_error("Failed to start gyroscope")
    	end
    end
}
```
4. 기기가 받은 힘과 방향에 따라 움직이도록 아래와 같이 작성합니다.```
void OnUpdate (number delta)
{
    if _MobileGyroscopeService:IsEnabled() then
    	local userAcceleration = _MobileGyroscopeService:GetUserAcceleration()
    	local userAccelDir = Vector2(userAcceleration.x, userAcceleration.y)
    	self:Tilt(userAccelDir)
    end
}

[server]
void Tilt (Vector2 direction)
{
    if direction.x > 0.2 or direction.y > 0.2 then
    	self.BallEntityRef.PhysicsRigidbodyComponent:ApplyForce(direction * self.ForcePower)	
    end
}
```
5. 월드를 출시하고, 모바일에서 확인합니다.

##### 참고 가이드

- [발판 만들기](/docs/?postId=71)
- [RectTileMap의 활용](/docs/?postId=589)
- [물리 사용하기](/docs/?postId=757)

Update 2025-11-17 PM 08:15


# 모바일 기기의 가속도 센서 사용하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=15%EB%B6%84&amp;color=green)

# 학습 과정 소개

`MobileAccelerometerService` 활용해 모바일 기기에서 가속도 센서 기능을 지원하는지 확인하고, 값을 측정할 수 있습니다.

# MobileAccelerometerService

`MobileAccelerometerService`를 활용하면 모바일 기기의 기울기를 측정할 수 있습니다. MobileAccelerometerService는 가속도 센서가 있는 모바일 기기에서만 동작합니다. 그러므로 월드에 입장한 유저가 정상적으로 플레이할 수 있는지 확인하고 가속도 센서를 지원하지 않는 기기를 사용 중이라면 안내가 필요합니다.

```
if _MobileAccelerometerService:IsHWSupported() then
    if _MobileAccelerometerService:IsEnabled() then
        _MobileAccelerometerService:Stop() 
    else
        _MobileAccelerometerService:Start()
    end
else
    _UIToast:ShowMessage("Failed to start Accelerometer")
end
```

# 활용 예제

모바일 기기를 특정 방향으로 기울였을 때, 그 방향으로 공이 굴러가게 만들어 봅시다.

![AccExample](https://mod-file.dn.nexoncdn.co.kr/bbs/1669116956573f5e430d1d6b546baa73dab2a0ecd76f5.gif)

#### 벽 만들기

1. **Hierachy - World - maps - map01**에서 콘텍스트 메뉴를 열어 **Switch to RecTileMap**을 선택합니다.
2. **Hierachy - World - maps - map01**에 **PhysicsSimulatorComponent**를 추가합니다.
3. 새로운 **Wall** 엔티티를 생성하고, **TransformComponent, SpriteRendererComponent, CustomeFootholdComponent**를 추가합니다.
4. 벽 모양 RUID를 SpriteRendererComponent - SpriteRUID에 입력하고, 스프라이트 크기만큼 **CustomFootholdComponent**로 발판을 생성합니다.
  - SpriteRUID: 9b518d2cf3a549f4bdbbac8662fecd42
5. **PhysicsColliderComponent**를 추가하고, 충돌 영역을 스프라이트 크기에 맞게 조정합니다.
6. **PhysicsRigidbodyComponent**를 추가하고, 프로퍼티를 설정합니다.
  - BodyType: Static
  - Friction: 0.2
  - Restitution 0.5
  - CollisionDetectionMode: Continuous
7. 만든 벽을 3개 복사해 사각형 벽을 만듭니다.

#### 공 만들기

1. 새로운 **TiltBall** 엔티티를 생성하고,**TransformComponent, SpriteRendererComponent**를 추가합니다.
2. 공 모양 RUID를 SpriteRendererComponent - SpriteRUID에 입력합니다.
  - SpriteRUID: 777ee92d25c84f839a12739590d149b6
3. TiltBall에 **PhysicsColliderComponent**를 추가하고, **ColliderType**을 **Circle**로 설정한 뒤 충돌 영역을 스프라이트에 맞게 지정합니다.
4. **PhysicsRigidbodyComponent**을 추가하고, 프로퍼티를 아래와 같이 설정합니다.
  - BodyType: Dynamic
  - Mass: 1
  - Friction: 0.2
  - Restitution: 1
  - CollisionDetectionMode: Discrete
  - GravityScale: 1
  - SleepingMode: StartAwake

#### 가속도 센서

1. 새로운 **AccelerometerLogic**을 생성합니다.
2. Property를 아래와 같이 추가하고, BallEntityRef에 TiltBall을 지정합니다.```
Property:
[None]
EntityRef BallEntityRef = /maps/map01/TiltBall
[None]
number ForcePower = 100
```
3. `MobileAccelerometerService:IsHWSupported()`를 활용해 기기에서 가속도 센서를 지원하는지 확인한 뒤, 가속도 측정을 시작합니다.```
Method:
[clinet only]
void OnBeginPlay ()
{
    if _MobileAccelerometerService:IsHWSupported() then
    	_MobileAccelerometerService:Start()
    end
}
```
4. 가속도 측정을 시작하면 기기가 기울어진 방향에 따라 공이 움직이도록 아래와 같이 작성합니다.```
void OnUpdate (number delta)
{
    if _MobileAccelerometerService:IsEnabled() then
    	local AccelerationDirection = _MobileAccelerometerService:GetLastAcceleration()
    	local direction = Vector2(AccelerationDirection.x, AccelerationDirection.y)
    	self:Tilt(direction)
    end
}

[server]
void Tilt (Vector2 direction)
{
    self.BallEntityRef.PhysicsRigidbodyComponent:ApplyForce(direction * self.ForcePower)
}
```

##### 참고 가이드

- [발판 만들기](/docs/?postId=71)
- [RectTileMap의 활용](/docs/?postId=589)
- [물리 사용하기](/docs/?postId=757)

Update 2025-11-17 PM 08:15


# 정규식

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

정규식(Regular expression)을 활용하면 텍스트를 유연하고 효율적으로 처리할 수 있습니다. 메이플스토리 월드에서는 기본적인 루아 문자열 패턴 일치 외에도 정규식을 지원합니다. 정규식의 패턴 일치 표기법을 사용하면 많은 양의 텍스트 구문을 분석하여 아래의 항목을 수행할 수 있습니다.

- 특정 문자 패턴 찾기
- 텍스트 유효성을 검사하여 미리 정의된 패턴과 일치하는지 확인
- 텍스트 하위 문자열을 추출, 편집, 변경, 삭제할 수 있음

단, 정규식은 다소 무겁기 때문에 간단한 정규식 작업을 할 때에는 루아 문자열 패턴 일치 기능을 활용하는 것이 좋습니다. 복잡한 작업이 필요한 경우에 아래 가이드를 참고하여 정규식을 활용해 봅시다.

##### 참고 API Reference

[Regex](/apiReference/Misc/Regex)

##### 참고 가이드

[정규식 언어](/docs/?postId=1043)

# 생성자

`Regex(String pattern)`로 특정 문자열 패턴을 가진 정규식 객체를 생성할 수 있습니다. 예를 들어 "word"를 찾는 정규식 객체는 아래와 같이 생성합니다.

```
-- "word" 를 찾는 정규식 객체
local regex = Regex("word")
```

또한 정규식 객체를 생성할 때 `RegexOption`을 사용하면 여러 가지 필요한 옵션을 지정할 수 있습니다. 예를 들어, 아래와 같이 `RegexOption.IgnoreCase`를 설정하면 지정한 문자열 패턴을 대/소문자를 구분하지 않고 찾을 수 있습니다.

```
-- 대/소문자를 구분하지 않고 "word" 를 검색
local regex = Regex("word", RegexOption.IgnoreCase)
```

# 프로퍼티

**boolean** 타입의 **IsRightToLeft** 프로퍼티가 있습니다. 이 프로퍼티로 정규식을 오른쪽에서 왼쪽으로 매칭하는지 여부를 가져옵니다.

# 함수

### IsMatch

`IsMatch(String origin)`는 지정된 정규식 패턴과 일치하는 항목이 입력 문자열(String origin)에 존재하는지 여부를 확인합니다.

- 정규식 패턴과 일치하는 항목이 있으면 true를 반환합니다.
- 정규식 패턴과 일치하는 항목이 없거나 제한 시간을 초과하여 정규식이 실패하면 false를 반환합니다.

```
-- 일반
local pattern = "^[A-Z0-9]\\d{2}[A-Z0-9](-\\d{3}){2}[A-Z0-9]$"
local regex = Regex(pattern, RegexOption.IgnoreCase)
 
log(regex:IsMatch("1298-673-4192"))    --  true
log(regex:IsMatch("A08Z-931-468a"))    --  true
 
log(regex:IsMatch("_A90-123-129X"))    --  false
log(regex:IsMatch("12345-KKA-1230"))    --  false
log(regex:IsMatch("0919-2893-1256"))    --  false
```

`IsMatch(String origin, Int32 startIndex)`는 입력 문자열의 탐색 시작 위치(startIndex)부터 지정된 정규식 패턴과 일치하는 항목이 존재하는지 여부를 확인합니다.

```
-- startIndex 지정
local pattern = "[a-zA-Z0-9]\\d{2}[a-zA-Z0-9](-\\d{3}){2}[A-Za-z0-9]$"
local regex = Regex(pattern)

log(regex:IsMatch("Part Number: 1298-673-4192", 10))  -- true
log(regex:IsMatch("Part Number: 1298-673-4192", 15))  -- false
```

### Match

`Match(String origin)`는 입력 문자열에서 정규식 패턴과 일치하는 첫 항목을 검색합니다.

```
local input = "One car red car blue car"
local pattern = "(\\w+)\\s+(car)"
     
local regex = Regex(pattern, RegexOption.IgnoreCase)
 
local match = regex:Match(input)
 
while match.Success do
    log(match.Text)
    match = match:NextMatch()
end
 
-- (결과)
-- One car
-- red car
-- blue car
```

`Match(String origin, Int32 startIndex)`는 입력 문자열의 탐색 시작 위치부터 정규식 패턴과 일치하는 첫 번째 항목을 검색합니다. 정규식이 실패하면 nil이 반환됩니다.

```
-- startIndex 지정
local origin = "123456789"
local pattern = "\\d"
 
local regex = Regex(pattern)
 
log(regex:Match(origin, 1).Text)      -- 1
log(regex:Match(origin, 3).Text)      -- 3
log(regex:Match(origin, 5).Text)      -- 5
```

`Match(String origin, Int32 startIndex, Int32 length)`는 입력 문자열의 탐색 시작 위치부터 지정된 길이의 문자열 내에서 정규식 패턴과 일치하는 첫 번째 항목을 검색합니다. 정규식이 실패하면 nil이 반환됩니다.

```
-- startIndex와 길이 지정
local origin = "123456789"
local pattern = "\\d+"
 
local regex = Regex(pattern)
 
log(regex:Match(origin, 1, 5).Text)   -- 12345
log(regex:Match(origin, 3, 3).Text)   -- 345
log(regex:Match(origin, 5, 1).Text)   -- 5
```

### Matches

`Matches(String origin)`는 입력 문자열에서 정규식 패턴과 일치하는 모든 항목을 검색합니다.

```
local origin = "Who writes these notes and uses our paper?"
local pattern = "\\b\\w+es\\b"
 
local regex = Regex(pattern)
 
local matches = regex:Matches(origin)
 
log(#matches)     -- 3
 
for i, match in pairs(matches) do
    log(match.Text)
end
 
-- (결과)
-- writes
-- notes
-- uses
```

`Matches(String origin, Int32 startIndex)`는 입력 문자열의 탐색 시작 위치부터 정규식 패턴과 일치하는 모든 항목을 검색합니다.

```
-- startIndex 지정
local origin = "Who writes these notes and uses our paper?"
local pattern = "\\b\\w+es\\b"
 
local regex = Regex(pattern)
 
local firstMatch = regex:Match(origin)
 
local matches = regex:Matches(origin, firstMatch.Index + firstMatch.Length)
 
log(#matches)     -- 2
 
for i, match in pairs(matches) do
    log(match.Text)
end
 
-- (결과)
-- notes
-- uses
```

### Replace

`Replace(String origin, String replacement)`는 입력 문자열에서 정규식 패턴과 일치하는 모든 항목을 대체 문자열(replacement)로 변경합니다.

```
-- 일반
local origin = "This is   text with   far  too   much   white space."
local pattern = "\\s+"
 
local regex = Regex(pattern)
 
local result = regex:Replace(origin, " ")
 
log(result) -- "This is text with far too much white space."
```

`Replace(String origin, String replacement, Int32 count)`는 입력 문자열에서 정규식 패턴과 일치하는 항목을 지정된 개수까지 대체 문자열로 변경합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "This is   text with   far  too   much   white space."
local pattern = "\\s+"
  
local regex = Regex(pattern)
  
local result = regex:Replace(origin, " ", 4)
  
log(result) -- "This is text with far  too   much   white space."
```

`Replace(String origin, String replacement, Int32 count, Int32 startIndex)`는 탐색 시작 위치부터 정규식 패턴과 일치하는 항목을 지정된 개수까지 대체 문자열로 변경합니다. 정규식이 실패하면 nil이 반환됩니다.

```
-- 최대 개수와 시작 위치 설정
local origin = "1 3 5 7 9 h e l l o w o r l d"
local pattern = "\\s+"
 
local regex = Regex(pattern)
 
local result = regex:Replace(origin, "", 4, 11)
 
log(result) -- "1 3 5 7 9 hello w o r l d"
```

### ReplaceByEvaluator

`ReplaceByEvaluator(String origin, function<RegexMatch>→string evaluator)`는 정규식 패턴과 일치하는 모든 항목을 evaluator로 반환된 문자열로 변경합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "letter alphabetical missing lack release penchant slack acryllic laundry cease"
local pattern = "\\w+  "
 
local regex = Regex(pattern, RegexOption.IgnorePatternWhitespace)
 
---@param match RegexMatch
---@return string
local function evaluator(match)
    return match.Text.."("..tostring(match.Text:len())..")"
end
 
local result = regex:ReplaceByEvaluator(origin, evaluator)
 
log(result)   
-- "letter(6) alphabetical(12) missing(7) lack(4) release(7) penchant(8) slack(5) acryllic(8) laundry(7) cease(5)"
```

`ReplaceByEvaluator(String origin, function<RegexMatch>→string evaluator, Int32 count)`는 정규식 패턴과 일치하는 항목을 지정된 개수까지 evaluator 로 반환된 문자열로 변경합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "letter alphabetical missing lack release penchant slack acryllic laundry cease"
local pattern = "\\w+  "
   
local regex = Regex(pattern, RegexOption.IgnorePatternWhitespace)
   
---@param match RegexMatch
---@return string
local function evaluator(match)
    return match.Text.."("..tostring(match.Text:len())..")"
end
   
local result = regex:ReplaceByEvaluator(origin, evaluator, 5)
   
log(result)  
-- "letter(6) alphabetical(12) missing(7) lack(4) release(7) penchant slack acryllic laundry cease"
```

`ReplaceByEvaluator(String origin, function<RegexMatch>→string evaluator, Int32 count, Int32 startIndex)`는 탐색 시작 위치부터 정규식 패턴과 일치하는 항목을 지정된 개수까지 evaluator 로 반환된 문자열로 변경합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "letter alphabetical missing lack release penchant slack acryllic laundry cease"
local pattern = "\\w+  "
  
local regex = Regex(pattern, RegexOption.IgnorePatternWhitespace)
  
---@param match RegexMatch
---@return string
local function evaluator(match)
    return match.Text.."("..tostring(match.Text:len())..")"
end
  
local result = regex:ReplaceByEvaluator(origin, evaluator, 5, 21)
  
log(result)   
-- "letter alphabetical missing(7) lack(4) release(7) penchant(8) slack(5) acryllic laundry cease"
```

### Split

`Split(String origin)`는 정규식 패턴과 일치하는 항목을 기준으로 입력 문자열을 분할합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "plum-bear-pear"
local pattern = "-"
     
local regex = Regex(pattern)
     
local texts = regex:Split(origin)
 
log(#texts) -- 3
 
for i, text in pairs(texts) do
    log(text)
end
 
-- (결과)
-- plum
-- bear
-- pear
```

`Split(String origin, Int32 count)`는 정규식 패턴과 일치하는 항목을 기준으로 입력 문자열을 분할하되, 최대 지정 개수(count)까지만 분할합니다. 정규식이 실패하면 nil이 반환됩니다.

```
-- count 지정
local origin = "apple-apricot-plum-pear-banana"
local pattern = "-"
     
local regex = Regex(pattern)
     
local texts = regex:Split(origin, 4)
 
log(#texts) -- 4
 
for i, text in pairs(texts) do
    log(text)
end
 
-- (결과)
-- apple
-- apricot
-- plum
-- pear-banana
```

`Split(String origin, Int32 count, Int32 startIndex)`는 입력 문자열의 탐색 시작 위치부터 정규식 패턴과 일치하는 항목을 기준으로 최대 지정 개수까지만 분할합니다. 정규식이 실패하면 nil이 반환됩니다.

```
local origin = "apple-apricot-plum-pear-banana"
local pattern = "-"
 
local regex = Regex(pattern)
 
local texts = regex:Split(origin, 4, 7)
 
log(#texts) -- 4
 
for i, text in pairs(texts) do
    log(text)
end
 
-- (결과)
-- apple-apricot
-- plum
-- pear
-- banana
```

# 정규식 옵션

`RegexOption`을 활용하면 정규식에 옵션을 설정할 수 있습니다.

| Option | Description |
| :---: | --- |
| IgnoreCase | 대/소문자를 구분하지 않고 일치하는 항목을 검색하도록 합니다. |
| IgnorePatternWhitespace | 이스케이프되지 않은 공백을 패턴에서 무시합니다. |
| RightToLeft | 검색 방향을 변경합니다. 왼쪽→오른쪽이 아니라 오른쪽→왼쪽으로 검색하도록 합니다. |
| ExplicitCapture | 명명되지 않은 그룹을 캡처하지 않습니다. 명시적으로 명명되거나 번호가 매겨진 그룹만 유효한 캡처가 되도록 지정합니다. |
| Multiline | 여러 줄 모드를 사용합니다. 전체 문자열의 시작과 끝 뿐만 아니라 모든 줄의 시작과 끝에서 각각 일치하도록 ^과 $의 의미를 변경합니다. |
| Singleline | 한 줄 모드를 사용합니다. "\n을 제외한 모든 문자"가 아닌 "\n을 포함한 모든 문자"와 일치하도록 점(.)의 의미를 변경합니다. |

각 옵션의 예제를 통해 사용 방법을 살펴봅시다.

### IgnoreCase

대/소문자를 구분하지 않고 일치하는 항목을 검색합니다.

```
-- IgnoreCase 옵션 설정하지 않음
local pattern = "\\bthe\\w*\\b"
local input = "The man then told them about that event."
 
local noOptionRegex = Regex(pattern)
local matches = noOptionRegex:Matches(input)
log(#matches) -- 2
 
 
-- IgnoreCase 옵션 설정함
local optionRegex = Regex(pattern, RegexOption.IgnoreCase)
matches = optionRegex:Matches(input)
log(#matches) -- 3
```

### IgnorePatternWhitespace

이스케이프되지 않은 공백을 패턴에서 무시합니다.

```
-- IgnorePatternWhitespace 옵션 설정하지 않음
local pattern = "\\b \\(? ( (?>\\w+) ,?\\s? )+ [\\.!?] \\)? # Matches an entire sentence."
local input = "This is the first sentence. Is it the beginning of a literary masterpiece? I think not. Instead, it is a nonsensical paragraph."
 
local noOptionRegex = Regex(pattern)
local matches = noOptionRegex:Matches(input)
log(#matches) -- 0
 
-- IgnorePatternWhitespace 옵션 설정함
local optionRegex = Regex(pattern, RegexOption.IgnorePatternWhitespace)
matches = optionRegex:Matches(input)
log(#matches) -- 4
```

### RightToLeft

검색 방향을 변경합니다. 왼쪽→오른쪽이 아니라 오른쪽→왼쪽으로 검색하도록 합니다.

```
-- RightToLeft 옵션 설정하지 않음 
local pattern = "\\bb\\w+\\s"
local input = "build11 band22 tab"
 
local noOptionRegex = Regex(pattern)
local matches = noOptionRegex:Matches(input)
 
log(noOptionRegex.IsRightToLeft)  -- false
 
for i, match in pairs(matches) do
    log(match.Text)
end
 
-- (결과)
-- build11
-- band22
 
-- RightToLeft 옵션 설정함 
local optionRegex = Regex(pattern, RegexOption.RightToLeft)
matches = optionRegex:Matches(input)
 
log(optionRegex.IsRightToLeft)    -- true
 
for i, match in pairs(matches) do
    log(match.Text)
end
 
-- (결과)
-- band22
-- build11
```

### ExplicitCapture

기본적으로 캡처할 그룹은 괄호를 사용하여 정의합니다. 그룹을 정의할 때 `(?<name>...)` 형식으로 그룹 이름을 정할 수 있습니다. `ExplicitCapture` 옵션을 사용하면 명명되지 않은 그룹은 캡처하지 않습니다. 명시적으로 `(?<name>...)` 형식으로 명명되거나 번호가 매겨진 그룹만 캡처합니다.

```
-- ExplicitCapture 옵션 설정하지 않음
local pattern = "^(?<first>\\d{3})-(\\d{4})-(\\d{4})-(\\d{4})-(\\d{4})-(\\d{4})-(\\d{4})-(?<last>\\d{3})$"
local input = "010-1111-2222-3333-4444-5555-6666-777"
 
local noOptionRegex = Regex(pattern)
local match = noOptionRegex:Match(input)
 
---@type table<any, RegexGroup>
local groups = match:GetGroups()
     
for j, group in pairs(groups) do
    log(group.Name)
end
 
-- (결과)
-- 1
-- 2
-- 3
-- 4
-- 5
-- 6
-- 7
-- first
-- last
 
 
-- ExplicitCapture 옵션 설정함
local optionRegex = Regex(pattern, RegexOption.ExplicitCapture)
match = optionRegex:Match(input)
---@type table<any, RegexGroup>
groups = match:GetGroups()
     
for j, group in pairs(groups) do
    log(group.Name)
end
 
-- (결과)
-- 1
-- first
-- last
```

### Multiline

여러 줄로 구성된 입력 문자열을 처리할 수 있습니다. 원래 `^`와 `$`는 전체 입력 문자열의 시작과 끝 부분을 의미합니다. 하지만 `Multiline` 옵션을 사용하면 `^`와 `$`가 전체 입력 문자열이 아니라 각 줄의 시작과 끝 부분과 매치하게 됩니다. 각 줄은 줄 바꿈 문자 `\n`으로 구분합니다.

```
-- Multiline 옵션 사용하지 않음
local pattern = "^(?<Name>\\w+)\\s(?<Number>\\d+)$"
local input = "Joe 164\nSam 208\nAllison 211\nGwen 171\n"
  
local noOptionRegex = Regex(pattern)
local matches = noOptionRegex:Matches(input)
  
log(#matches) -- 0
  
for i, match in pairs(matches) do
      
    ---@type table<any, RegexGroup>
    local groups = match:GetGroups()
      
    local nameCapture = groups["Name"]:GetCaptures()[1]
    local numberCapture = groups["Number"]:GetCaptures()[1]
     
    log("Name : "..nameCapture.Text..", Number : "..numberCapture.Text)
end
  
-- (결과)
-- (없음)
 
-- Multiline 옵션 사용
local optionRegex = Regex(pattern, RegexOption.Multiline)
matches = optionRegex:Matches(input)
  
log(#matches) -- 4
  
for i, match in pairs(matches) do
      
    ---@type table<any, RegexGroup>
    local groups = match:GetGroups()
      
    local nameCapture = groups["Name"]:GetCaptures()[1]
    local numberCapture = groups["Number"]:GetCaptures()[1]
     
    log("Name : "..nameCapture.Text..", Number : "..numberCapture.Text)
end
  
-- (결과)
-- Name : Joe, Number : 164
-- Name : Sam, Number : 208
-- Name : Allision, Number : 211
-- Name : Gwen, Number : 171  
```

### Singleline

입력된 문자열을 한 줄로 구성된 것처럼 처리합니다. 기본적으로 `Match()`는 `\n`을 만나면 끝나지만 `Singleline` 옵션을 사용하면 `\n`을 만나도 계속 진행합니다.

```
-- Singleline 옵션 사용하지 않음 
local pattern = "^.+"
local input = "This is one line and\nthis is the second."
     
local noOptionRegex = Regex(pattern)
local match = noOptionRegex:Match(input)
 
log(match.Text)   -- "This is one line and"
 
 
-- Singleline 옵션 사용함 
local optionRegex = Regex(pattern, RegexOption.Singleline)
match = optionRegex:Match(input)
 
log(match.Text)   -- "This is one line and\nthis is the second."
```

### 다중 옵션 적용

`RegexOption`은 한 번에 여러 가지를 적용할 수 있습니다.

```
local regex = Regex("line\\w+", RegexOption.Singleline | RegexOption.RightToLeft | RegexOption.IgnoreCase)
     
local matches = regex:Matches("lineFirst \n LineSecond \n LineLast")
     
for i, match in pairs(matches) do
    log(match.Text)
end
     
-- (결과)
-- LineLast
-- LineSecond
-- lineFirst
```

Update 2025-11-17 PM 08:15


# 정규식 언어

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

정규식은 입력 텍스트에서 찾으려는 패턴을 의미합니다. 본 과정에서는 정규식을 정의할 때 사용할 수 있는 특정 범주의 문자, 연산자 및 구분을 안내합니다.

# 문자 클래스

문자 클래스(Character Classes)는 문자 집합 중 하나를 찾습니다.

| 문자 클래스 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `[`_character_group_`]` | _character_group_ 내의 모든 단일 문자와 일치하는 항목을 찾습니다. 기본적으로 대/소문자를 구분합니다. | `[ae]` | `"gray"`의 `"a"` <br>`"lane"`의 `"a"`, `"e"` |
| `[^`_character_group_`]` | _character_group_내의 모든 단일 문자와 일치하지 않는 항목을 찾습니다. 기본적으로 대/소문자를 구분합니다. | `[^aei]` | `"reign"`의 `"r"`, `"g"`, `"n"` |
| `[`_첫 번째_`-`_마지막_`]` | _첫 번째_~_마지막_ 범위의 모든 단일 문자와 일치하는 항목을 찾습니다. | `[A-Z]` | `"AB123"`의 `"A"`, `"B"` |
| `.` | `\n`를 제외한 모든 단일 문자와 일치하는 항목을 찾습니다.<br>리터럴 마침표 문자(또는 \u002E)를 찾으려면 앞에 이스케이프 문자(\.)를 지정해야 합니다. | `a.e` | `"nave"`의 `"ave"`<br>`"water"`의 `"ate"` |
| `\\p{`_이름_`}` | 유니코드 일반 범주 또는 _이름_으로 지정된, 명명된 블록의 모든 단일 문자와 일치하는 항목을 찾습니다. | `\\p{Lu}`<br>`\\p{IsCyrillic}` | `"City Lights"`의 `"C"`, `"L"`<br>`"ДЖem"`의 `"Д"`, `"Ж"` |
| `\\P{`_이름_`}` | 유니코드 일반 범주 또는 _이름_으로 지정된, 명명된 블록의 모든 단일 문자와 일치하지 않는 항목을 찾습니다. | `\\P{Lu}`<br>`\\P{IsCyrillic}` | `"City"`의 `"i"`, `"t"`, `"y"`<br>`"ДЖem"`의 `"e"`, `"m"` |
| `\\w` | 단어 문자를 찾습니다. | `\\w` | `"ID A1.3"`의 `"I"`, `"D"`, `"A"`, `"1"`, `"3"` |
| `\\W` | 단어가 아닌 문자를 찾습니다. | `\\W` | `"ID A1.3"`의 `" "`, `"."` |
| `\\s` | 공백 문자를 찾습니다. | `\\w\\s` | `"ID A1.3"` 내 `"D "` |
| `\\S` | 공백이 아닌 문자를 찾습니다. | `\\s\\S` | `"int __ctr"` 내 `" _"` |
| `\\d` | 10진수를 찾습니다. | `\\d` | `"4 = IV"` 내 `"4"` |
| `\\D` | 10진수 이외의 문자와 일치합니다. | `\\D` | `"4 = IV"`의 `" "`, `"="`, `" "`, `"I"`, `"V"` |

# 문자 이스케이프

문자 이스케이프(Character Escapes)는 정규식의 백슬래시 문자(\) 뒤에 오는 문자가 아래 표와 같이 특수 문자나 리터럴로 해석되어야 함을 뜻합니다.

| 이스케이프된 문자 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `\t` | 탭 문자인 \u0009를 찾습니다. | `(\\w+)\t` | `"item1\titem2\t"`의 `"item1\t"`, `"item2\t"` |
| `\r` | 캐리지 리턴 문자인 \u000D를 찾습니다. <br>(`\r`은 줄 바꿈 문자인 `\n`과 다릅니다.) | `\r\n(\\w+)` | `"\r\nThese are\ntwo lines."`의 `"\r\nThese"` |
| `\v` | 세로 탭 문자인 \u000B를 찾습니다. | `[\v]{2,}` | `"\v\v\v"`의 `"\v\v\v"` |
| `\n` | 줄 바꿈 문자인 \u000A를 찾습니다. | `\r\n(\\w+)` | `"\r\nThese are\ntwo lines."`의 `"\r\nThese"` |
| `\\`_Nnn_ | 8진수 표현을 사용하여 문자를 지정합니다. <br>(_nnn_은 두 자리 또는 세 자리로 구성됩니다.) | `\\w\\040\\w` | `"a bc d"`의 `"a b"`, `"c d"` |
| `\\x`_Nn_ | 16진수 표현을 사용하여 문자를 지정합니다. <br>(_nn_은 정확히 두 자리로 구성됩니다.) | `\\w\\x20\\w` | `"a bc d"`의 `"a b"`, `"c d"` |
| `\\u`_Nnnn_ | 16진수 표현(정확히 네 자리로 구성되는 _nnnn_)을 사용하여 유니코드 문자를 찾습니다. | `\\w\\u0020\\w` | `"a bc d"`의 `"a b"`, `"c d"` |
| `\\` | 이 표나 이 항목의 다른 표에 있는 이스케이프된 문자로 인식되지 않는 문자가 뒤에 나올 경우 이 문자를 찾습니다. 예를 들어, `\*`는 `\x2A`와 같고 `\.`는 `\x2E`와 같습니다. 이를 통해 정규식 엔진은 * 또는 ?와 같은 언어 요소와 `\*` 또는 `\?`로 표현되는 문자 리터럴을 구분합니다. | `\\d+[\\+-x\\*]\\d+` | `"(2+2) * 3*9"`의 `"2+2"` 및 `"3*9"` |

# 앵커

앵커(Anchors) 또는 너비가 0인 원자적 어설션(atomic zero-width assertions)은 문자열에서 일치 항목을 찾는 위치를 지정합니다. 앵커를 사용하면 정규식 엔진은 문자열을 통과하거나 문자를 사용하지 않고 지정된 위치에서만 일치 항목을 검색합니다. 예를 들어 `^` 기호는 줄이나 문자열의 시작 부분에서 일치 항목을 찾도록 합니다. `^http:`는 줄의 시작 부분에서만 "http:"를 찾습니다.

| 앵커 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `^` | 문자열의 시작 부분에서 일치 항목을 찾습니다. 문자열이 여러 줄이라면 줄의 시작 부분에서 일치 항목을 찾습니다. | `^\\d{3}` | `"901-333-"`의 `"901"` |
| `$` | 문자열의 끝부분 또는 문자열의 끝부분 `\n` 앞에서 일치 항목을 찾습니다. 문자열이 여러 줄이라면 줄의 끝부분 또는 줄의 끝 `\n` 앞에서 일치 항목을 찾습니다. | `-\\d{3}$` | `"-901-333"`의 `"-333"` |
| `\\A` | 일치 항목이 문자열의 시작 부분에만 있어야 합니다. (여러 줄을 지원하지 않음) | `\\A\\d{3}` | `"901-333-"`의 `"901"` |
| `\\Z` | 일치 항목이 문자열의 끝이나 문자열의 끝에 있는 `\n` 앞에 있어야 합니다. | `-\\d{3}\\Z` | `"-901-333"`의 `"-333"` |
| `\\z` | 일치 항목이 문자열의 끝 부분에만 있어야 합니다. | `-\\d{3}\\z` | `"-901-333"`의 `"-333"` |
| `\\G` | 이전 일치가 종료된 지점에서 일치 항목을 찾습니다. 이전 일치 항목이 없다면 일치가 시작된 문자열의 위치에서 일치 항목을 찾습니다. | `\\G\\(\\d\\)` | `"(1)(3)(5)[7](9)"`의 `"(1)"`, `"(3)"`, `"(5)"` |
| `\\b` | 단어 문자 `\w`와 비단어 문자 `\W`의 경계에서 일치 항목을 찾습니다. | `\\b\\w+\\s\\w+\\b` | `"them theme them them"`의 `"them theme"`, `"them them"` |
| `\\B` | 단어 경계에서 일치 항목을 찾지 않도록 지정합니다. `\\b` 앵커와 반대 작업을 수행합니다. | `\\Bend\\w*\\b` | `"end sends endure lender"`의 `"ends"`, `"ender"` |

# 그룹화 구문

그룹화 구문(Grouping constructs)은 정규식의 하위 식(subexpression)을 나타내며 입력 문자열의 부분 문자열을 캡처합니다.

| 그룹화 구문 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `(`_하위 식_`)` | 일치하는 하위 식을 캡처하고 서수(2부터 시작)를 할당합니다. | `(\\w)` | `"deep"`의 `"d"`,`"e"`, `"e"`, `"p"` |
| `(?<`_이름_`>`_하위 식_`)` 또는 `(?'`_이름_`'`_하위 식_`)` | 일치하는 하위 식을 명령된 그룹에 캡처합니다. | `(?<double>\\w)\\k<double>` | `"deep"`의 `"ee"` |
| `(?<`_이름1_`-`_이름2_`>`_하위 식_`)` 또는 `(?'`_이름1_`-`_이름2_`'`_하위 식_`)` | 균형 조정 그룹을 정의합니다. <br>그룹화 구문의 형식에서 _이름1_은 현재 그룹이고(선택 사항), _이름2_는 이전에 정의된 그룹이며, _하위 식_은 임의의 유효한 정규식 패턴입니다. 균형 조정 그룹 정의는 _이름2_의 정의를 삭제하고 _이름1_에 _이름2_와 _이름1_간의 간격을 저장합니다. | `(((?'Open'\\()[^\\(\\)]*)+((?'Close-Open'\\))[^\\(\\)]*)+)*(?(Open)(?!))$` | `"3+2^((1-3)*(3-1))"`의 <br>`"((1-3)*(3-1))"` |
| `(?:`_하위 식_`)` | 비캡처 그룹을 정의합니다. | `Write(?:Line)?` | `"Console.WriteLine()"`의 <br>`"WriteLine"`<br>`"Console.Write(value)"`의 <br>`"Write"` |
| `(?=`_하위 식_`)` | Positive Lookahead<br>_하위 식_ 앞에 일치하는 패턴을 찾습니다. | `\\b\\w+\\b(?=.+and.+)` | `"cats, dogs and some mice."`의 <br>`"cats"`, `"dogs"` |
| `(?!`_하위 식_`)` | Negative Lookahead<br>_하위 식_ 앞에 일치하지 않는 패턴을 찾습니다. | `\b\w+\b(?!.+and.+)` | `"cats, dogs and some mice."`의 <br>`"and"`, `"some"`, `"mice"` |
| `(?<=`_하위 식_`)` | Positive Lookbehind<br>_하위 식_ 뒤에 일치하는 패턴을 찾습니다. | `\\b\\w+\\b(?<=.+and.+)`<br>———————————<br>`\\b\\w+\\b(?<=.+and.*)` | `"cats, dogs and some mice."`의 <br>`"some"`, `"mice"`<br>————————————<br>`"cats, dogs and some mice."`의<br> `"and"`, `"some"`, `"mice"` |
| `(?<!`_하위 식_`)` | Negative Lookbehind<br>_하위 식_ 뒤에 일치하지 않는 패턴을 찾습니다. | `\\b\\w+\\b(?<!.+and.+)`<br>———————————<br>`\\b\\w+\\b(?<!.+and.*)` | `"cats, dogs and some mice."`의 <br>`"cats"`, `"dogs"`, `"and"`<br>————————————<br>`"cats, dogs and some mice."`의 <br>`"cats"`, `"dogs"` |
| `(?>`_하위 식_`)` | 원자성 그룹(Atomic group)입니다. | `(?>a\|ab)c` | `"ac"` 에서 `"ac"`<br>`"abc"`에는 없음 |

# 수량자

수량자(Quantifiers)는 일치 항목의 입력에 있어야 하는 문자, 그룹 또는 문자 클래스의 인스턴스 수를 지정합니다.

| 수량자 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `*` | 이전 요소를 0개 이상 찾습니다. | `a.*c` | `"abcbc"`의 `"abcbc"` |
| `+` | 이전 요소를 1개 이상 찾습니다. | `be+` | `"been"`의 `"bee"`, `"bent"`의 `"be"` |
| `?` | 이전 요소를 0개 또는 1개 찾습니다. | `rai?` | `"rain"`의 `"rai"` |
| `{`_N_`}` | 이전 요소를 정확히 _n_ 회 찾습니다. | `,\\d{3}` | `"1,043.6"`의 `",043"`, <br>`"9,876,543,210"`의 `",876"`, `",543"` 및 `",210"` |
| `{`_N_`,}` | 이전 요소를 최소한 _n_ 회 찾습니다. | `\\d{2,}` | `"166"`, `"29"`, `"1930"` |
| `{`_N_`,`_M_`}` | 이전 요소를 _n_ 회 이상, _m_ 회 이하로 찾습니다. | `\\d{3,5}` | `"166"`, `"17668"`<br>`"193024"`의 `"19302"` |
| `*?` | 이전 요소를 0개 이상 가능한 한 적은 개수로 찾습니다. | `a.*?c` | `"abcbc"` 의 `"abc"` |
| `+?` | 이전 요소를 1개 이상 가능한 한 적은 개수로 찾습니다. | `be+?` | `"been"`의 `"be"`, `"bent"`의 `"be"` |
| `??` | 이전 요소를 가능한 한 적은 개수로 0개 또는 1개 찾습니다. | `rai??` | `"rain"` 내 `"ra"` |
| `{`_N_`}?` | 이전 요소를 정확히 _n_ 회 찾습니다. | `,\\d{3}?` | `"1,043.6"`의 `",043"`, <br>`"9,876,543,210"`의 `",876"`, `",543"` 및 `",210"` |
| `{`_N_`,}?` | 이전 요소를 최소한 _n_ 회 이상 가능한 한 적은 개수로 찾습니다. | `\\d{2,}?` | `"166"`, `"29"`, `"1930"` |
| `{`_N_`,`_M_`}?` | 이전 요소를 _n_ 회에서 _m_ 회 사이에서 찾으며, 가능한 한 적은 개수로 찾습니다. | `\\d{3,5}?` | `"166"`, `"17668"`<br>`"193024"`의 `"193"`, `"024"` |

# 역참조

역참조(Backreference Constructs)는 문자열 내에서 반복된 문자 또는 부분 문자열을 식별할 때 사용하면 편리합니다.

| 역참조 구문 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `\\k<`_이름_`>` | 명명된 역참조입니다. 명명된 식의 값을 찾습니다. | `(?<char>\\w)\\k<char>` | `"seek"`의 `"ee"` |

# 교체 구문

교체 구문(Alternation Constructs)은 either/or 또는 조건부 일치를 허용하도록 정규식을 수정합니다.

| 교체 구문 | 설명 | 무늬 | 일치 항목 |
| --- | --- | --- | --- |
| `\|` | 세로 막대(\|)로 구분된 한 가지 요소와 일치합니다. | `th(e\|is\|at)` | `"this is the day."`의 `"the"`, `"this"` |
| `(?(`_표현식_`)`_예_`\|`_아니오_`)` 또는<br>`(?(`_표현식_`)`_예_`)` | _표현식_으로 지정한 정규식 패턴이 일치하면 _예_와 일치합니다. 그렇지 않으면 _아니오_ 부분과 일치합니다. _표현식_은 너비가 0인 어설션으로 해석됩니다.<br>명명되거나 번호가 매겨진 캡처 그룹과의 모호성을 방지하려면 필요에 따라 다음과 같이 명시적 어설션을 사용할 수 있습니다.<br>`(?( (?=`_표현식_`) )`_예_`\|`_아니요_`)` | `(?(A)A\\d{2}\\b\|\\b\\d{3}\\b)` | `"A10 C103 910"`의 <br>`"A10"`, `"910"` |
| `(?(`_이름_`)`_예_`\|`_아니오_`)`또는<br>`(?(`_이름_`)`_예_`)` | 명명되거나 번호가 매겨진 캡처링 그룹인 _이름_에 일치하는 항목이 있으면 _예_와 일치합니다. 그렇지 않으면 _아니오_와 일치합니다. | `(?<quoted>\")?(?(quoted).+?\"\|\\S+\\s)` | `"Dogs.jpg \"Yiska playing.jpg\""`의 <br>`"Dogs.jpg "`, `"\"Yiska playing.jpg\""` |

# 대체

대체(Substitutions)는 바꾸기 패턴에서만 인식되는 언어 요소입니다. **입력 문자열 중 일치하는 텍스트를 대체하는 텍스트의 전부 또는 일부**를 정의합니다.

| 문자 | 설명 | 무늬 | 바꾸기 패턴 | 입력 문자열 | 결과 문자열 |
| --- | --- | --- | --- | --- | --- |
| `${`_이름_`}` | 명명된 그룹 이름과 일치하는 부분 문자열을 대체합니다. | `\\b(?<word1>\\w+)(\\s)(?<word2>\\w+)\\b` | `${word2} ${word1}` | `"one two"` | `"two one"` |
| `$$` | "$" 리터럴을 대체합니다. | `\\b(\\d+)\\s?USD` | `$$$1` | `"103 USD"` | `"$103"` |
| `$&` | 일치하는 전체 문자열의 복사본을 대체합니다. | `\\$?\\d*\\.?\\d+` | `**$&**` | `"$1.30"` | `"**$1.30**"` |
| `$`` | 일치하는 문자열 앞에 있는 입력 문자열의 모든 텍스트를 대체합니다. | `B+` | `$`` | `"AABBCC"` | `"AAAACC"` |
| `$'` | 일치하는 문자열 뒤에 있는 입력 문자열의 모든 텍스트를 대체합니다. | `B+` | `$'` | `"AABBCC"` | `"AACCCC"` |
| `$+` | 캡처된 마지막 그룹을 대체합니다. | `B+(C+)` | `$+` | `"AABBCCDD"` | `"AACCDD"` |
| `$_` | 전체 입력 문자열을 대체합니다. | `B+` | `$_` | `"AABBCC"` | `"AAAABBCCCC"` |

Update 2025-11-17 PM 08:15


# UI Group

광부 시뮬레이터를 구성하는 UI Group은 다음과 같습니다.

# HUDGroup

#### MineHUD

광산에 입장하면 활성화되는 HUD입니다. 광산에서의 시야 범위, 탐험 도구, 깊이, 머무른 시간 등이 포함됩니다. ![MineHUD](https://mod-file.dn.nexoncdn.co.kr/bbs/169346279752076c5f4bc384b44568ae7c22d48b73ba3.png)

#### TownHUD

마을에 입장하면 활성화되는 HUD입니다. 메뉴 열기 버튼, 메뉴들이 포함됩니다. ![TownHUD](https://mod-file.dn.nexoncdn.co.kr/bbs/169346282676335d63efb228143d9b1ea4df2b3e37000.png)

#### HUD

항상 활성화되는 HUD입니다. ![HUD](https://mod-file.dn.nexoncdn.co.kr/bbs/169346285181385a664b04a7f40cd89c88401a8d93b6f.png)

# MineralExchangeGroup

#### MineralExchange

광물 상점 UI입니다. ![MineralExchange](https://mod-file.dn.nexoncdn.co.kr/bbs/16934629143267549d6f06eab41189d6d2642040898d0.png)

# EquipmentShopGroup

#### EquipmentShop

장비 상점 UI입니다. ![Equipment](https://mod-file.dn.nexoncdn.co.kr/bbs/16934648407879cbdd32c0e5e438fa34db33bb5635eb6.png)

# InventoryGroup

#### Inventory

인벤토리 UI입니다. ![Inventory](https://mod-file.dn.nexoncdn.co.kr/bbs/1693464954399481442df1149470c9e8bc34edce5e6d0.png)

#### EquipmentStorage

장비 보관함 UI입니다. ![EquipmentStorage](https://mod-file.dn.nexoncdn.co.kr/bbs/1693466011668d0e4a1d3a2bf4f2eb8ae060d7e112fe0.png)

# StatusGroup

#### Status

플레이어의 능력치 확인창 UI입니다. ![StatusGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/169346545486178a5814cd9334c368c703a18248f2bc1.png)

# MineResultGroup

#### GameResult

광산에서 마을로 귀환할 때 나타나는 탐험 결과 화면 UI입니다. ![MineResultGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/1693466059842ea3bbd222e6544aea3aae8878f9035e3.png)

# MiningGameGroup

#### MiningGame

광산에서 광맥과 플레이어가 상호작용하면 활성화되는 미니 게임 UI 입니다. ![MiningGameGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/1693466084729bdcb07ab3ae2430cab42cb4d1e4f09dc.png)

# PopupGroup

#### Popup_KeyBoxSuccess

광산에서 열쇠 상자 채광에 성공했을 때 나타나는 팝업 UI입니다. ![PopupGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/16934661243436a642dca5a7d49519bfef4e1aa5a88f3.png)

# LoadingGroup

#### MineEnterance

마을에서 광산으로 입장할 때 활성화되는 로딩 UI입니다. ![MineEnterance](https://mod-file.dn.nexoncdn.co.kr/bbs/1693466162088a41f941dce3a48a0af02856a284aae37.png)

#### Loading

월드 첫 진입, 마을에서 마을로 이동, 광산에서 마을로 이동 시에 활성화되는 로딩 UI입니다. ![Loading](https://mod-file.dn.nexoncdn.co.kr/bbs/1693466147655f305b6077c894de79c8a50e89834cf81.png)

Update 2025-11-20 PM 02:03


# Tables

# CurrencyInfo

재화 종류를 추가할 때 사용하는 데이터셋입니다. 골드 외의 다른 재화를 추가할 경우 행을 추가해 사용합니다. **Dest** 열에는 Key 값을 입력하고, 번역 결과는 LocalizationTable에 입력합니다.

| 이름 | 설명 |
| --- | --- |
| Name | 재화의 이름입니다. **key** 값을 입력해야 합니다. |
| RUID | 재화를 나타내는 이미지의 RUID입니다. |
| Desc | 재화의 설명을 입력합니다. 인벤토리에서 재화 위에 마우스를 올리면 이 설명을 보여줍니다. **key** 값을 입력해야 합니다. |

# EquipmentInfo

장비 정보를 입력하는 데이터셋입니다. 레벨 5 이후의 장비를 추가할 경우 행을 추가해 사용합니다. **Name, FlavorText** 열에는 **Key** 값을 입력하고, 번역 결과는 LocalizationTable에 입력합니다.

| 이름 | 설명 |
| --- | --- |
| Cost | 장비의 가격입니다. 타입 구분 없이 같은 레벨이라면 같은 가격입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type1_Name | 곡괭이의 이름입니다. **key** 값을 입력해야 합니다. |
| Type1_RUID | 곡괭이의 아이콘 RUID입니다. 인벤토리나 상점에서 표시할 아이콘입니다. **Thumbnail://RUID** 형태로 입력해야 합니다. |
| Type_Ability | 곡괭이의 채광력입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type1_FlavorText | 곡괭이의 플레이버 텍스트입니다. **key** 값을 입력해야 합니다. |
| Type2_Name | 작업복의 이름입니다. **key** 값을 입력해야 합니다. |
| Type2_RUID | 작업복의 아이콘 RUID입니다. 인벤토리나 상점에서 표시할 아이콘입니다. **Thumbnail://RUID** 형태로 입력해야 합니다. |
| Type2_Ability | 작업복의 체력입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type2_FlavorText | 작업복의 플레이버 텍스트입니다. **key** 값을 입력해야 합니다. |
| Type3_Name | 가방의 이름입니다. **key** 값을 입력해야 합니다. |
| Type3_RUID | 가방의 아이콘 RUID입니다. 인벤토리나 상점에서 표시할 아이콘입니다. **Thumbnail://RUID** 형태로 입력해야 합니다. |
| Type3_Ability | 가방의 보관 가능 수량입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type3_FlavorText | 가방의 플레이버 텍스트입니다. **key** 값을 입력해야 합니다. |
| Type4_Name | 신발의 이름입니다. **key** 값을 입력해야 합니다. |
| Type4_RUID | 신발의 아이콘 RUID입니다. 인벤토리나 상점에서 표시할 아이콘입니다. **Thumbnail://RUID** 형태로 입력해야 합니다. |
| Type4_Ability | 신발의 기력 수치입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type4_FlavorText | 신발의 플레이버 텍스트입니다.**key** 값을 입력해야 합니다. |

# LocalizationTable

LocalizationTable에서 사용하는 테이블입니다. 번역이 필요한 문장이 있다면 행을 추가해 사용합니다.

| 이름 | 설명 |
| --- | --- |
| Key | 키 값입니다. |
| Type | 문장의 분류입니다. |
| Source | 문장이 사용된 곳입니다. |
| ko | 한국어 번역 결과입니다. |
| en | 영어 번역 결과입니다. |

# MapInfo

맵 정보에 대한 테이블입니다. 새로운 마을, 광산을 추가하기 위해선 행을 추가해야 합니다. **TownName, MineName** 열에는 **Key** 값을 입력하고, 번역 결과는 LocalizationTable에 입력합니다.

| 이름 | 설명 |
| --- | --- |
| TownName | 마을 이름입니다. **key** 값을 입력해야 합니다. |
| MineName | 광산 이름입니다. **key** 값을 입력해야 합니다. |
| RecPower_min1 | 광산 1층의 최소 권장 채광력입니다. 광산에 필요한 채광력은 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다. |
| RecPower_max1 | 광산 1층의 최대 권장 채광력입니다. 광산의 최대 권장 채광력은 다음 층의 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다. |
| RecPower_min2 | 광산 2층의 최소 권장 채광력입니다. 광산에 필요한 채광력은 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다. |
| RecPower_max2 | 광산 2층의 최대 권장 채광력입니다. 광산의 최대 권장 채광력은 다음 층의 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다. |
| RecPower_min3 | 광산 3층의 최소 권장 채광력입니다. 광산에 필요한 채광력은 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다 |
| RecPower_max3 | 광산 3층의 최대 권장 채광력입니다. 광산의 최대 권장 채광력은 다음 층의 광맥의 체력 기준 1/4 수준으로 책정을 권장합니다. 반드시 **숫자**만 입력해야 합니다. |
| HPUseRateInMine | 초 당 광산에서 소모하는 체력입니다. 층수와 관계 없이 한 광산에서는 소모하는 초 당 체력이 동일합니다. |
| DefaultDepth1 | 광산 1층의 깊이입니다. 광산의 깊이는 광산의 모든 층을 더해 측정합니다. 그러므로 1층의 깊이는 **항상 0**이어야 합니다. |
| DefaultDepth2 | 광산 2층의 깊이 입니다. 1층의 마지막 깊이, 다음 수를 입력합니다. 반드시 **숫자**만 입력해야 합니다. |
| DefaultDepth3 | 광산 3층의 깊이 입니다. 2층의 마지막 깊이, 다음 수를 입력합니다. 반드시 **숫자**만 입력해야 합니다. |

# MineralInfo

광물 정보 데이터셋입니다. 새로운 광물을 추가하려면 행을 추가해야 합니다. 행마다 광물 하나의 정보를 담고 있습니다. 채광 시 기본 보상으로 얻는 광물은 1-3번 인덱스입니다. **Name,Type, Desc** 열에는 Key 값을 입력하고, 번역 결과는 LocalizationTable에 입력합니다.

| 이름 | 설명 |
| --- | --- |
| Name | 광물의 이름입니다. **key** 값을 입력해야 합니다. |
| RUID | 광물의 아이콘 RUID입니다. |
| Cost | 광물을 상점에 팔 때 가격입니다. 반드시 **숫자**만 입력해야 합니다. |
| Type | 광물의 타입입니다. **key** 값을 입력해야 합니다. |
| Desc | 광물의 플레이버 텍스트입니다. **key** 값을 입력해야 합니다. |

# ToolInfo

탐험 도구 정보에 대한 데이터셋입니다. 내용을 변경해 도구 정보를 수정할 수 있습니다. 행마다 탐험도구 하나의 정보를 담고 있습니다. **Name, Desc** 열에는 Key 값을 입력하고, 번역 결과는 LocalizationTable에 입력합니다.

| 이름 | 설명 |
| --- | --- |
| Name | 탐험도구 이름입니다. **key** 값을 입력해야 합니다. |
| RUID | 탐험도구 아이콘 RUID 입니다. |
| Desc | 탐험도구 설명입니다. **key** 값을 입력해야 합니다. |

# VeinInfo

광맥 정보를 담은 데이터셋입니다. 광부 시뮬레이터 리메이크 월드에는 레벨 3까지의 광맥 데이터가 기입되어 있습니다. 더 높은 레벨의 광백이 필요한 경우 행을 추가해 데이터를 입력합니다.

| 이름 | 설명 |
| --- | --- |
| Level | 광맥의 레벨입니다. |
| HP | 광맥의 최대 체력입니다. 반드시 **숫자**만 입력해야 합니다. |
| BonusGameChance | 광맥을 캘 때 보너스 게임이 등장하는 확률입니다. 반드시 **실수**로만 입력해야 합니다. 예) 0.1 |
| Bonus_JewerlyChance | 보너스 게임에 성공했을 때 받는 보상 확률입니다. 반드시 **실수**로만 입력해야 합니다. |
| Bonus_FossilChance | 보너스 게임에 성공했을 때 받는 화석 보상 확률입니다. 반드시 **실수**로만 입력해야 합니다. |
| Bonus_GoldChance | 보너스 게임에 성공했을 때 받는 골드 보상 확률입니다. 반드시 **실수**로만 입력해야 합니다. |
| Bonus_ChairChance | 보너스 게임에 성공했을 때 받는 의자 보상 확률입니다. 반드시 **실수**로만 입력해야 합니다. |
| Bonus_GoldAmount | 보너스 게임에 성공했을 때 받는 골드 보상 수량의 표준값입니다. +- 20% 내에서 무작위로 지급하게 되므로 반드시 **숫자**만 입력해야 합니다. |
| KeyBoxHP | 열쇠 상자인 광맥의 최대 체력입니다. 반드시 **숫자**만 입력해야 합니다. |

Update 2025-11-20 PM 02:03


# DefaultPlayerComponents

# ExtendPlayerControllerComponent

PlayerControllerComponent를 확장해 만든 컴포넌트로 플레이어의 조작을 구현합니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | boolean | IsDashCooltime | 대시 쿨타임 상태인지를 확인합니다. true면 대쉬가 불가능합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | void | ActionDownJump | 다운 점프를 막는 함수입니다. |
| client | void | ActionDash | 플레이어를 대쉬하게 만드는 함수입니다. `KeyDownEventHandler`에서 `LeftShift`를 입력 받을 때 이 함수를 호출합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | `LeftShift` 키를 눌렀을 때 `ActionDash()` 함수를 실행시킵니다. |

# PlayerData

플레이어의 데이터를 기록, 저장, 불러오기하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | boolean | IsLoadedData | 데이터가 정상적으로 불러와졌는지 확인하는 프로퍼티입니다. `SaveData()` 함수에서 플레이어 데이터를 저장할 때 이 프로퍼티의 값이 false라면 저장하지 않습니다. |
| None | SyncTable< number > | Currencies | 플레이어가 가지고 있는 재화의 양을 의미하는 프로퍼티입니다. 예를 들어, `Currencies[1] = 500`이라면 500 골드를 가지고 있습니다. |
| None | SyncTable< number > | Items | 보유한 광물 수량 프로퍼티입니다. 광물 정보는 **MineralInfo 데이터 셋**에서 확인할 수 있습니다. |
| None | SyncTable< number > | Equipments | 보유한 장비의 레벨 정보 프로퍼티입니다. 장비를 구매할 때 반드시 순서대로만 구매해야 합니다. |
| None | SyncTable< number > | EquipedEquipmentsIdx | 현재 장착한 정비의 인덱스 프로퍼티입니다. |
| Sync | number | TownAdmissions | 현재 입장이 허용된 마을의 정보를 나타내는 프로퍼티입니다. 값이 3이라면 마을 3까지 입장할 수 있습니다. 기본값은 1이며, 데이터 불러오기를 시도할 때도 1로 불러옵니다. |
| None | number | SaveRotTime | 지정한 값의 주기로 데이터를 저장하는 프로퍼티입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | void | OnBeginPlay | 최초 접속 시 프로퍼티를 초기화합니다. `LoadData()` 함수를 실행해 데이터를 불러옵니다. |
| client | void | SyncTableClient | 서버에서 **Table** 값이 변경될 때 실행하여 클라이언트와 값을 동기화합니다. |
| client | void | OnChangedTable | `SyncTableClient()`가 실행되었을 때 `OnSyncProperty()`처럼 사용하기 위해 호출하는 함수입니다. 클라이언트에서 프로퍼티가 동기화 되었을 때 실행하는 함수들을 실행합니다. |
| server | void | LoadData | DB에 저장된 플레이어 데이터를 불러오는 함수입니다. `OnBeginPlay()` 실행 시 자동으로 호출됩니다. |
| server | void | SaveData | DB에 현재 플레이어의 데이터를 저장하는 함수입니다.<br><li>tryCount: 저장에서 오류가 발생한 경우, 자동으로 재시도하면 값을 1 올립니다. 5번을 초과해 재시도한 경우 플레이어를 월드에서 강제 퇴장시킵니다.</li> |
| server | void | SetAvatar | 인덱스에 맞는 장비를 플레이어의 아바타에 적용합니다. 아바타 RUID는 **EquipmentInfo** 데이터 셋에서 불러옵니다. |
| server | void | GetItems | 광물을 획득하면 프로퍼티 값을 변경해 광물의 인덱스와 획득한 수량을 기록합니다. 플레이어의 가방 한도보다 광물을 많이 획득하면 수량을 조절합니다. 획득 처리 시 `self:PlayGetItemDirection`을 호출해 아이템 획득 ui를 연출합니다. |
| server | void | RemoveAllItems | 보유한 모든 광물의 수량을 0으로 변경하는 함수입니다. 상점에 광물을 판매할 때 호출합니다. |
| server | void | GetCurrency | 획득한 재화를 기록하는 함수입니다.<ul><li>idx: 재화 인덱스</li><li>amount: 획득 수량</li></ul> |
| server | void | GetTownAdmissions | `TownAdmissions` 프로퍼티 값을 변경하는 함수입니다. 광산에서 열쇠 상자를 부수면 값을 변경합니다. |
| client | void | PlayGetItemDirection | 광물, 재화를 획득할 때 실행되는 UI 연출입니다.<ul><li>idx: 획득한 광물 또는 재화의 인덱스</li><li>amount:수량</li><li>type: 광물인 경우 **item**, 재화인 경우 **currency**</li></ul> |
| server | void | SellAllMinerals | 광물 상점에서 **모든 광물을 판매하기**를 누르면 실행하는 함수입니다. 보유한 모든 광물을 삭제하고, 광물의 가치만큼 골드를 얻습니다. |
| client | void | SellAllMineralsOnClient | 광물을 판매한 플레이어의 클라이언트에서 토스트 메시지를 재생하고, 광물 상점 UI를 새로 고침하는 함수입니다. 서버에서 실행하는 `SellAllMinerals()`에서 실행하는 함수 입니다. |
| server | void | PurchaseEquipment | 장비 상점에서 장비 구매를 시도할 때 실행하는 함수입니다. 서버에서 실행합니다. 장비 구매가 불가능한 경우 return시키고, 경고 메시지를 보여줍니다. <br>구매에 성공하면 `self.Equipments[idx] = level`로 변경하고, 구매한 장비의 가격만큼 `self.Currencies[1]` 값을 변경합니다. 장비 구매 비용은 `EquipmentInfo()`에서 가져옵니다. |
| client | void | PurchaseEquipmentOnClient | `PurchaseEquipment()`에서 호출하는 함수입니다. 구매 실패 시 경고 메시지를 보여주고, 구매 성공 시 구매 성공 연출을 재생합니다. |
| server | void | ChangeEquippedIdx | 장비 보관함 UI에서 장착 장비 변경 시 서버에서 실행하는 함수입니다. `EquippedEquipmentIdx` 프로퍼티를 변경하고, `SetAvatar()` 함수를 실행합니다. |
| server only | void | OnEndPlay | 월드 종료 시 데이터를 저장하는 함수입니다. |
| server only | void | OnUpdate | 250초에서 350초마다 데이터를 자동 저장합니다. |
| client only | void | OnMapEnter | 접속한 맵의 이름에 따라 자신에게 `MapEnterEvent`를 전송합니다. 맵 이름은 아래의 규칙에 따라 정해야 합니다.<ul><li>광산: Mine0-0</li><li>마을: Town0</li></ul> |
| client only | void | OnSyncProperty | `self.TownAdmissions`가 업데이트될 때 호출되는 함수입니다. |

# PlayerMineData

광산에 들어간 플레이어가 사용하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | SyncTable < number > | Tools | 보유한 도구의 수량입니다.<ul><li>Tools[1]: 밧줄 수량</li><li>Tools[2]: 트램펄린 수량</li><li>Tools[3]: 횃불 수량</li><li>Tools[4]: 포션 수량</li></ul> |
| None | number | DefaultDepth | 광산 깊이를 나타내기 위해 더하는 값입니다. **1-1 광산**은 **0m**에서 시작합니다. |
| None | number | Depth | 플레이어가 현재 있는 광산의 깊이를 나타냅니다. |
| None | number | MaxDepth | 플레이어가 도달한 광산의 깊이를 나타냅니다. |
| None | number | Time | 플레이어가 광산에 머무른 시간을 나타냅니다. |
| None | Entity | BlindEntity | 광산용 UI에서 사용하는 엔티티입니다. |
| None | Entity | DepthEntity | 광산용 UI에서 사용하는 엔티티입니다. |
| None | Entity | TimeEntity | 광산용 UI에서 사용하는 엔티티입니다. |

#### Function

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | HUD UI를 갱신하는 합니다. |
| - | void | OnMapEnter | <ul><li>클라이언트: 플레이어가 마을에 있다면 광산 HUD를 끄고, 탐험 도구 수량과 모든 기록을 제거합니다. 플레이어가 광산에 있다면 광산 HUD를 켜고, 스테이지에 맞는 기본 깊이를 결정합니다.</li><li>서버: 사용 중인 횃불 엔티티를 제거합니다.</li></ul> |
| client only | void | OnUpdate | **light** 태그를 가진 엔티티와 플레이어의 거리에 비례해 시야를 조절합니다. 광산에서 보낸 시간과 현재 엔티티의 위치에 따라 도달한 깊이 정보를 갱신합니다. |
| client | void | Die | 광산에서 사망 조건이 된 경우 실행합니다. 광산 플레이 관련 프로퍼티를 종료하고, 게임 종료를 준비합니다.<br> 유령 모션을 재생하고, 채광을 종료합니다. 게임 결과 화면을 활성화하고, 광산에서 획득한 아이템을 전부 삭제합니다. |
| client | void | GetTools | 광산에서 탐험 도구 상자와 상호작용하면 실행하는 함수입니다. 탐험 도구를 획득하고 탐험 도구 UI를 갱신합니다. |
| client | void | UseTools | KeyDownHandler에서 숫자 1 - 4를 눌렀을 때 실행하는 함수입니다. |
| server | void | SpawnRope | `self:UseTool()`에서 호출하는 함수입니다. 밧줄을 소환합니다.<br><li>ownerNickname: 밧줄을 소환한 유저의 닉네임입니다. 밧줄의 NameTag에 **ownerNickname의 밧줄**로 표기합니다.</li> |
| server | void | SpawnTrampoline | `self:UseTool()`에서 호출하는 함수입니다. 트램펄린을 소환합니다.<ul><li>ownerNickname: 트램펄린을 소환한 유저의 닉네임입니다. 트램펄린의 NameTag에 **ownerNickname의 밧줄**로 표기합니다.</li></ul> |
| server | void | SpawnTorch | `self:UseTools()`에서 호출하는 함수입니다. 횃불을 소환하고, 기존 횃불은 제거합니다. |
| client | void | UsePotion | `self:UseTools()`에서 호출하는 함수입니다. 포션을 사용하고 플레이어의 체력을 회복합니다. |
| client | void | SetMineFloorInfo | `OnMapEnter()`에서 호출하는 함수입니다. 입장한 맵에 따라 광산 HUD의 층수, 깊이 정보를 갱신해 UI에 반영합니다. |
| client | void | SetRecord | `OnUpdate()`에서 호출하는 함수입니다. 플레이어가 머물고 있는 광산의 깊이, 머문 시간 정보를 갱신해 UI에 반영합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | 숫자 1 - 4를 눌렀을 때 `UseTools()` 함수를 실행하는 함수입니다. |

# PlayerStatus

플레이어의 스탯 정보 프로퍼티와 함수를 관리하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| Sync | number | Power | 채광력입니다. |
| Sync | number | HP | 현재 체력입니다. |
| Sync | number | HPMax | 최대 체력입니다. |
| Sync | number | MaxStorage | 보관 가능한 광물 최대 수량입니다. |
| Sync | number | MP | 현재 기력 |
| Sync | number | MPMax | 최대 기력 |
| Sync | number | HPUseAmount | 광산에서 초당 소모되는 체력양입니다. |
| Sync | number | HPRecoverRate | 초당 기력을 회복하는 비율입니다. 기본값은 1입니다. |
| None | boolean | IsPlayingMine | 플레이어가 광산에서 탐험 중인지를 기록합니다. false라면 탐험 중이 아닌 것으로 간주합니다. |
| None | Entity | WarningUI | 경고 UI입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnUpdate | 기력을 실시간으로 회복합니다. 광산에서 탐험 중이라면 체력을 닳게합니다. |
| client | void | UseMp | 기력을 매개변수 `amount`만큼 소모하는 함수입니다. 남은 MP가 0미만이라면 0으로 만듭니다. |
| client | void | RecoverMP | OnUpdate에서 호출합니다. 기력을 초 당 `0.2 * self.MPRecoverRate`만큼 회복합니다. |
| client only | void | OnMapEnter | 들어간 맵이 광산이라면 로딩 화면에서 **탐험 시작** 버튼을 활성화합니다. 들어간 맵이 마을이라면 HP, MP를 HPMax, MPMax로 변경합니다. |
| server | void | RefreshStatus | 플레이어가 보유한 아이템에 따라 스탯을 갱신하는 함수입니다. |
| client | void | Hit | 함정에 맞았을 때 HP를 감소시키는 함수입니다. `Damage`만큼 HP를 소모하고, 플레이어를 (5,0) 또는 (-5,0)으로 밀어냅니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | 광산에 입장해 로딩 UI가 떠있을 때 `E` 키를 누르면 로딩을 종료하고, 탐험을 시작합니다. |

Update 2025-11-20 PM 02:03


# InteractionObjectsComponents

# GuideKeyComponent

플레이어가 이 컴포넌트를 가진 엔티티의 범위 내에 들어가면 가이드 UI를 활성화합니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | string | GuideText | 가이드 UI에 표기할 텍스트의 **Key** 값입니다. 엔티티에 달려있는 프로퍼티를 변경해야 합니다. 이 프로퍼티는 자동으로 번역되므로 Key 값으로 작성해야 합니다. 필요한 경우 **LocalizationTable**에 key와 데이터 값을 추가하세요. |
| None | Entity | GuideEntity | 가이드 UI 엔티티를 의미합니다. `OnBeginPlay()`에서 자동으로 지정합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | `self.GuideEntity`를 지정합니다. 번역 결과를 가이드 UI에 넣습니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEnterEvent | 이 컴포넌트를 포함한 엔티티 근처에 플레이어 엔티티가 다가오면 가이드 UI를 활성화합니다. |
| client only | self | InteractionLeaveEvent | 이 컴포넌트를 포함한 엔티티 근처에서 플레이어 엔티티가 떠나가면 가이드 UI를 활성화합니다. |
| client only | self | InteractionEvent | 상호작용을 시작하면 가이드 UI를 비활성화 합니다. |

# MiningTargetObject

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| Sync | number | Level | 광맥 또는 열쇠 상자의 레벨입니다. 프로퍼티 에디터 창에서 값을 변경해야 합니다.<br><ul><li>광맥: 광산의 번호와 동일하게 설정합니다.</li><li>열쇠 상자: 광산의 마을 번호와 동일하게 설정합니다.</li><ul></ul></ul> |
| Sync | boolean | IskeyBox | 엔티티가 열쇠 상자인지 확인하는 프로퍼티입니다. 열쇠 상자인 경우 값은 true입니다. 프로퍼티 값을 직접 변경해 사용합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | `NameTagComponent`의 name을 갱신합니다. **Lv.?광맥 또는 열쇠상자**로 보여집니다. |
| server | void | GiveReward | 채광에 성공한 경우 보상을 지급하는 함수입니다.<br>보너스 게임 성공 여부와 관계 없이 `normalSuccess`가 false라면 함수를 종료합니다. 광맥을 채광했다면 `self.Level`에 맞는 보상을 지급합니다. 열쇠상자를 채광했다면 `Playerdata.TownAdmissions`를 `self.Level + 1`로 변경합니다.<ul><li>normalSuccess: 기본 성공 여부입니다. true인 경우 성공입니다.</li><li>bonusSuccess: 보너스 게임의 성공 여부입니다. true인 경우 성공입니다.</li><li>player: 보상을 지급 받을 플레이어 엔티티입니다.</li></ul> |
| client | void | SetKeyBoxResultUI | `self.GiveReward()`에서 호출하는 함수입니다. 열쇠 상자 획득에 성공했다면 **N번째 마을 해금** 팝업을 활성화 합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 채광 게임을 실행합니다. |
| - | InputService | KeyDownEvent | **N번째 마을 해금** 팝업을 `esc`키를 눌러 닫습니다. |

# NPCInteractionComponent

NPC와 상호 작용해 UI를 활성화하는 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity | TargetUI | 활성화할 UI엔티티입니다. 프로퍼티 에디터 창에서 프로퍼티를 변경해야 합니다. |
| None | string | InteractionSoundRUID | 활성화되면 재생할 음원 RUID입니다. 재생할 사운드가 없다면 비워둡니다. 프로퍼티 에디터 창에서 프로퍼티를 변경해야 합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | override된 함수입니다 |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 UI를 활성화합니다. |

# Portal_MineToMine

광산에서 다음 광산으로 이동하는 포탈에 추가하는 컴포넌트입니다.

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | override된 함수입니다. 이동하는 광산의 이름과 권창 채광력을 표기합니다. MapInfo 데이터 셋에서 정보를 불러옵니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 광산 이동을 실행합니다. |

# Portal_MineToTown

광산에서 마을로 이동하는 귀환 로봇에 추가하는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 실행합니다. 탐험을 종료하고, 탐험 종료 UI를 활성화합니다. |

# Portal_TownToMine

마을에서 광산으로 입장하는 포탈에 추가하는 컴포넌트입니다.

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | override된 함수입니다. 마을에서 광산으로 이동하는 포탈에 광산 이름, 권장 채광력을 표시합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 실행합니다. 광산 로딩 UI를 활성화하고, 플레이어를 광산으로 입장시킵니다. |

# Portal_TownToTown

마을에서 다른 마을로 입장하는 포탈에 추가하는 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| Sync | number | DestinationTownIdx | 목적지 마을의 인덱스입니다. 프로퍼티 에디터 창에서 포털에 값을 직접 입력해야합니다. |
| None | number | UseCooldown | 포탈을 다시 사용할 수 있는 대기 시간입니다. `Portal_TownToTown` 컴포넌트의 Interaction 이벤트 핸들러에서 `UseCooldown` 값이 0 이상이면 return 합니다. |

#### Function

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 마을에서 마을로 이동하는 포탈에 목적지 마을의 이름을 표시합니다. 플레이어가 포털로 이동 가능한지 여부에 따라 자식 엔티티를 활성화/비활성화 합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 이 컴포넌트를 가진 엔티티와 플레이어 엔티티가 상호 작용하면 실행합니다. 플레이어가 입장 권한이 있는 경우 마을로 이동시킵니다. 권한이 없는 경우 잠금 메시지를 보여줍니다. |
| client only | localplayer | TownAdmissionUpdated | **LocalPlayer**의 마을 이동 권한인 `PlayerData.TownAdmission`이 업데이트될 때 실행합니다. 마을 입장 권한이 있다면 포탈의 자물쇠 이미지가 비활성화 됩니다. |

# ToolBoxObject

광산 내에 있는 탐험 도구 상자에 붙이는 컴포넌트입니다. 플레이어가 도구 상자와 상호 작용하면 탐험 도구를 획득합니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | reservatedTimerId | 탐험 도구를 짧은 시간 동안 여러 번 획득하는 상황을 대비하는 프로퍼티입니다. 예약된 **TimerId**를 기록합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | SetEnableToolBoxToastUI | 탐험 도구를 획득할 때 보일 획득 안내 팝업 UI를 갱신하고 활성화하는 함수입니다. 팝업 UI가 4.5초 뒤에 닫히도록 `TimerService`를 활용하고, **id**를 `self.reservatedTimerId`에 기록합니다. 이미 기록된 `self.reservatedTimerId`가 있다면 예약을 제거합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEnterEvent2 | 탐험 도구 상자로부터 플레이어 엔티티가 가까워지면 가이드 UI를 비활성화합니다. |
| client only | self | InteractionEnterLeaveEvent2 | 탐험 도구 상자로부터 플레이어 엔티티가 멀어지면 가이드 UI를 활성화합니다. |
| client only | self | InteractionEvent2 | 탐험 도구 상자와 플레이어 엔티티가 상호 작용할 때 실행합니다. 1번부터 4번까지의 탐험 도구 중 무작위로 하나를 획득하도록 처리합니다. 또한 탐험 도구 상자를 비활성화합니다. |

# Tool_Trampoline

탐험 도구 중 **트램펄린**에 붙여주는 컴포넌트입니다. 상호 작용하면 트램펄린의 사용해 Y축으로 높게 뛰어오릅니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | Cooldown | 트램펄린의 재사용까지 남은 대기 시간을 의미합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnUpdate | 남은 대기 시간을 delta만큼 감소시키는 함수입니다. |
| client | void | UseTool | 트램펄린 사용 효과를 적용하는 함수입니다. 플레이어를 Y축으로 점프시킵니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | self | InteractionEvent2 | 트램펄린과 플레이어 엔티티가 상호 작용할 때 실행합니다. `UseTool()`을 호출합니다. |

Update 2025-11-20 PM 02:03


# UI Components/Logics

# ItemToastMessage Logic

**아이템 ?개 획득**과 같은 토스트 메시지를 띄우는 로직입니다. UI 엔티티를 배치한 상태로 사용하기 위해 SyncTable을 활용해 관리합니다. `{MessageTable, RUIDTable, TimeTable}`이 한 쌍이며, 새로운 메시지를 추가할 때 반드시 3개를 한 쌍으로 추가해야 합니다. 또한 새로운 메시지는 반드시 테이블 맨 앞에 추가해야 합니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | SyncTable < string > | MessageTable | 화면에 띄울 메시지입니다. |
| None | SyncTable < string > | RUIDTable | 화면에 띄울 아이템 아이콘입니다. |
| None | SyncTable < number > | TimeTable | 남은 메시지가 표시될 시간입니다. |
| None | SyncTable < Entity > | messageEntity | 메시지를 표시할 엔티티입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 프로퍼티를 초기화하고 **self.messageEntity**에 넣을 엔티티를 찾아 테이블에 넣습니다. |
| client only | void | OnUpdate | 실시간으로 아이템 획득 로그를 관리합니다. 표시할 메시지와 RUID 정보를 UI에 반영합니다. 남은 시간에 따라 UI 투명도를 설정합니다. |
| client | void | AddMessage | 새로운 메시지를 추가합니다. `PlayerData:PlayGetItemDirection()` 함수에서 호출됩니다.<ul><li>message: 입력할 내용입니다.</li><li>ruid: 해당 로그에 보여질 아이템 또는 재화의 RUID입니다.</li></ul> |

# UI_EquipmentShop

장비 상점 UI 관련 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | FilterIdx | 장비를 타입별로 분류해 상품 목록을 볼 수 있습니다. |
| None | number | ShowingEquipmentLevel | 상품을 눌러 상세 정보를 확인할 수 있습니다. 상세 정보를 확인 중인 장비의 레벨을 표시합니다. 기본값은 0입니다. |
| None | boolean | IsPlayingDirection | 장비 구매 연출이 재생 중인지 판단합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 월드에 진입할 때 UI를 끄는 함수입니다. |
| client | void | RefreshUI | 보유 재화량, 필터 버튼, 상품 목록을 갱신하는 함수입니다. 장비를 구매하거나 장비 상점을 닫았다 다시 열었을 때 혹은 타입 버튼을 눌렀을 때 실행됩니다. |
| client | void | ShowDetailPopup | 플레이어가 상품 목록 중 하나를 눌렀을 때 실행하는 함수입니다. 상세 정보 팝업을 갱신하고 활성화 합니다. 상품의 구매 비용과 내 보유 금액을 비교해 구매 가능하다면 버튼을 활성화 합니다. |
| client | void | PlayPurchaseDirection | 장비 구매 완료 연출을 재생하는 함수입니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | Esc 키를 누르거나, 닫기 버튼을 눌러 UI를 닫습니다. |
| - | [entity] /ui/EquipmentShopGroup/EquipmentShop<br>/DetailInfoPopup/Panel/Button_Buy | ButtonClick | 상세 정보 팝업에 있는 구매 버튼을 눌렀을 때 실행합니다. `self.FilterIdx`와 `self.ShowingEquipmentLevel` 값에 따라 장비 구매를 시도합니다. 구매 시도를 하면 상세 정보 팝업을 닫습니다. |

# UI_EquipmentShop_FilterButton

장비 상점 UI의 **장비 타입 필터** 버튼에 붙어있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | 버튼을 누르면 UI_EquipmentShop의 `FilterIdx`를 변경하고, `RefreshUI()`를 실행합니다. |

# UI_EquipmentShop_SlotButton

장비 상점 UI 내 상품 목록마다 붙어있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | 각 상품 목록을 누르면 `UI_EquipmentShop:ShowDetailPopup()`을 실행합니다. |

# UI_EquipmentStorage Logic

장비 보관함 UI와 관련된 로직입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | FilterIdx | 장비 보관함 UI에 표시할 장비의 1차 유형 분류 번호힙니다. 기본값은 1입니다. |
| None | number | SecondFilterIdx | 장비 보관함 UI에 표시할 장비의 2차 유형 분류 번호입니다. 기본값은 1입니다.<ul><li>1: 곡괭이</li><li>2: 작업복</li><li>3: 가방</li><li>4: 신발</li></ul> |
| None | number | ShowingItemIdx | 장비 상세 정보 팝업에 보이는 아이템의 **Idx**입니다. 기본값은 0입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 월드에 진입할 때 장비 보관함 UI를 끄는 함수입니다. |
| client | void | SetFilterIdx | 장비 보관함 UI에서 1차 타입 필터 버튼을 누르면 장비 목록과 장착 정보를 **idx**에 맞게 변경합니다. |
| client | void | SetSecondFilterIdx | 장비 보관함 UI에서 2차 타입 필터 버튼을 누르면 장비 목록과 장착 정보를 **idx**에 맞게 변경합니다. |
| client | void | RefreshUI | 전체 UI를 현재 데이터에 맞게 변경합니다. 클라이언트에서 데이터가 변경된 경우 수동으로 호출해야 합니다. |
| client | void | ShowDetailInfo | 장비 목록에서 장비를 눌렀을 때 상세 정보 팝업의 내용을 변경하고, UI를 변경합니다. |
| client | void | ShowMessageEquipmentChanged | 장비를 장착하거나 해제한 경우 토스트 메시지를 띄웁니다. |
| client | void | ApplyAvatarEntity | 장착한 장비가 변경되면 장비 보관함 내에 있는 아바타 표시를 변경합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | [entity] /ui/HUDGroup/TownHUD/Panel_menu3<br>/ScrollList/EquipmentButton | ButtonClickEvent | 마을 메뉴 UI에서 **장비 보관함** 버튼을 누르면 호출되는 핸들러입니다. 메뉴 목록을 닫고, 장비 보관함 UI를 새로고침 해 엽니다. |
| - | service | KeyDownEvent | 장비 보관함이 열려 있을 때 Esc 키를 눌러 닫습니다. 상세 정보 창이 열려 있는 경우 상세 정보 창만 닫습니다. |
| - | [entity] /ui/InventoryGroup/EquipmentStorage<br>/DetailInfoPopup/Button_Equip | ButtonClickEvent2 | 상세 정보 팝업에서 '장착하기' 버튼을 눌렀을 때 호출됩니다. 선택한 장비로 장착 장비 **Idx**를 변경하고, 팝업창을 닫습니다. |
| - | [entity] /ui/InventoryGroup/EquipmentStorage<br>/DetailInfoPopup/Button_Equip_dismount | ButtonClickEvent3 | 상세 정보 팝업에서 **장착 해제** 버튼을 눌렀을 때 호출되며 장비 장착을 해제하고 팝업창을 닫습니다. |

# UI_EquipmentStorage_FilterButton

장비 보관함 UI의 1차 필터 버튼마다 붙어있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | 버튼을 누르면 UI_EquipmentStorage의 `SetFilterIdx(idx)`를 호출합니다. |

# UI_EquipmentStorage_SecondFilterButton

장비 보관함 UI의 2차 필터 버튼마다 붙어있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | 버튼을 누르면 UI_EquipmentStorage의 `SetSecondFilterIdx(idx)`를 호출합니다. |

# UI_EquipmentStorage_SlotButton

장비 보관함 UI의 보관 목록 아이템마다 붙어있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | 버튼을 누르면 UI_EquipmentStorage의 `ShowDetailInfo(idx)`를 호출합니다. |

# UI_GameResult

광산에서 탐험 종료될 때 등장하는 결과 UI 관련 컴포넌트입니다.

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 월드에 진입할 때 UI를 끄는 함수입니다. |
| client | void | SetResultUI | 게임 결과 화면을 갱신하는 함수입니다. 광산 내에서 사망하면 `PlayerMineData:Die()`에서 호출합니다. 귀환 로봇을 사용하면 `Portal_MineToTown:HandleInteractionEvent2()`에서 함수를 호출합니다.<ul><li>isSuccess: 성공 여부를 의미합니다. 사망해 호출한 경우 false, 귀환 로봇으로 호출한 경우 true입니다.</li><li>depth: 최대 깊이입니다.</li><li>time: 머무른 시간입니다.</li><li>items: 이번 탐험에서 얻은 또는 잃어버린 광물 목록입니다.</li></ul> |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | 게임 결과 UI가 열려 있을 때 **탐험 종료** 버튼이 활성화 되어 있다면, E 키를 눌러 UI를 닫고 마을로 텔레포트 시킵니다. |

# UI_GameResult_ItemSlotButton

광산 결과 UI 화면에 있는 아이템 목록마다 붙어있는 아이템 정보를 보여주는 컴포넌트입니다. 각 아이템에 마우스를 올리거나 화면을 꾹 누르면 `ButtonStateChangeEvent`를 호출합니다.

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonStateChangeEvent | 아이템을 누르면 아이템 정보를 보여줍니다. PC에서는 목록에 마우스를 올리면 보이고, Mobile에서는 목록을 눌러 볼 수 있습니다. |

# UI_HUD

HUD와 관련된 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity | Power | 채광력을 표시하는 엔티티입니다. |
| None | Entity | Money | 보유한 골드를 표시하는 엔티티입니다. |
| None | Entity | HPFill | 체력을 표시하는 UI 엔티티입니다. |
| None | Entity | HPText | 체력을 텍스트로 표시하는 엔티티입니다. |
| None | Entity | MPFill | 기력을 표시하는 UI 엔티티입니다. |
| None | Entity | MPText | 기력을 텍스트로 표시하는 엔티티입니다. |
| None | Number | UpdateTime | 다음 UI 갱신까지 남은 시간을 의미합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | RefreshUI | HUD를 현재 데이터에 맞게 갱신하는 함수입니다. |
| client only | void | OnUpdate | HUD를 갱신하기 위한 함수입니다. 0.1초마다 RefreshUI를 호출합니다. |
| client | void | RefreshToolUI | 보유한 탐험 도구 수량을 갱신하고, 수량에 따라 이미지를 다르게 표시합니다. 탐험 도구를 획득하거나 소모할 때 호출됩니다. |
| client | void | PlayToolEffect | HUD 탐험 도구 아이콘에서 이펙트를 재생하는 함수입니다. 탐험 도구를 획득하거나 소모할 때 호출합니다. <li>idx: 획득, 소모한 탐험 도구 인덱스</li> |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | 플레이어가 마을에 있을 때 `F3`을 눌러 메뉴를 열고 닫습니다. |

# UI_Inventory

인벤토리 관련 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | ShowingFilterIdx | 표시할 아이템 타입을 분류하는 인덱스입니다. |
| None | number | SelectedSlotIdx | 상세 정보를 보여주고 있는 아이템의 인덱스입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 프로퍼티를 초기화하고, 인벤토리 UI를 닫습니다. |
| client | void | RefreshUI | 인벤토리 UI를 새로고침합니다. `self.ShowingFilterIdx`에 해당하는 아이템들을 보여줍니다. 새로운 아이템을 얻거나, UI를 열거나, 필터 버튼을 누를 때 새로운 정보로 갱신합니다. |
| client | void | ShowDetailPopup | 보유 중인 아이템 목록에서 아이템을 누르면 상세 정보 팝업창을 엽니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | KeyDownEvent | `I` 키를 눌러 UI를 열고, 닫습니다. `Esc` 키를 눌러 UI를 닫습니다. 이때 상세 정보 팝업창이 열려 있다면, 팝업창만 닫습니다. |
| - | [entity] ExitButton (/ui/InventoryGroup/Inventory<br>/Panel/TitlePanel/ExitButton) | ButtonClickEvent | 닫기 버튼을 눌러 UI를 비활성화 합니다. |

# UI_Inventory_FilterButton

인벤토리의 필터 버튼에 달려 있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | `UI_Inventory.ShowingFilterIdx`를 변경하고 `UI_Inventory:RefreshUI()`를 실행합니다. |

# UI_Inventory_SlotButton

인벤토리의 각 아이템에 달려 있는 컴포넌트입니다.

#### Entity Event Handler

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | self | ButtonClickEvent | `UI_Inventory:ShowDetailPopup(idx)`를 실행합니다. |

# UI_Loading Logic

월드에 처음 접속하거나, 마을에서 마을로 이동하거나, 광산에서 마을로 돌아올 때 보여지는 로딩 화면과 관련된 로직입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | boolean | IsLoading | 로딩 창이 열려 있는 상태인지 확인합니다. `SetEnableLoading()`함수에서 값을 변경합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | SetEnableLoadingUI | 로딩 화면을 활성, 비활성하는 함수입니다. 활성화하면 로딩 화면의 모든 UI 투명도를 1로 만들고, 플레이어의 이동을 막습니다. 비활성화 시 0.5초 동안 점진적으로 로딩 UI를 투명하게 만들고, 플레이어 엔티티를 이동할 수 있게 합니다. |
| client only | void | OnBeginPlay | 월드에 처음 접속했을 때 `self:SetEnableLoadingUI(true)`를 호출하고, `TimerService`를 사용해 `self:SetEnableLoadingUI(false)`를 3초 뒤 호출합니다. |

# UI_MapEnteredManager

UI를 비활성화하는 컴포넌트입니다. 마을이나 광산을 이동할 때 사용합니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | boolean | AutoDisableOnTown | LocalPlayer가 마을에 입장할 때 불필요한 UI인 경우 true로 설정합니다. |
| None | boolean | AutoDisableOnMine | LocalPlayer가 광산에 진입할 때 불필요한 UI인 경우 true로 설정합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | LocalPlayer | LocalPlayerMapEntered | 플레이어가 다른 맵에 진입할 때마다 `PlayerData:OnMapEnter()`에서 `LocalPlayerMapEntered` 이벤트를 플레이어 엔티티에 보내고, UI를 비활성화 합니다. |

# UI_MineralExchange

광물 상점 UI와 관련된 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 월드에 처음 진입할 때 엔티티를 `disable`로 변경합니다. |
| client | void | RefreshUI | 광물 상점 UI를 갱신하는 함수입니다. 광물을 모두 판매하거나, 광물 상점 UI를 열 때 호출합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | `E` 키를 눌러 광물 상점에서 보유한 모든 광물을 판매합니다. `Esc` 키를 눌러 광물 상점 UI를 닫습니다. 광물 판매는 서버에서 이뤄집니다. |

# UI_MiningGame

채광 시 실행되는 미니 게임 관련 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | boolean | IsKeyBox | 현재 진행 중인 미니 게임이 열쇠 상자를 획득할 수 있는 게임인지를 확인합니다. |
| None | boolean | IsPlaying | 미니 게임 진행 여부를 판단합니다. 값이 true라면 `OnUpdate()`에서 화살표를 움직입니다. |
| None | number | LeftHitChance | 남은 타격 기회입니다. 일반 광맥 타격 기회는 5회, 열쇠 상자는 10회입니다. <br> Hit()에서 남은 광맥 체력은 0 이상이나, `LeftHitChance` 프로퍼티가 0 이하인 경우 미니 게임을 종료합니다. |
| None | number | OreHPMax | 채광 중인 광맥의 최대 체력입니다. |
| None | number | OreHP | 채광 중인 광맥의 남은 체력입니다. |
| None | boolean | ContainBonusGame | 보너스 게임이 포함된 미니 게임인지 판단합니다. 광맥과 처음 상호 작용 했을 때 보너스 게임 활성화 여부를 결정합니다. 보너스 게임이 있을 경우 값을 true로 변경합니다. |
| None | boolean | IsPlayingBonusGame | 보너스 게임이 진행 중인지 판단합니다. 보너스게임은 `self.ContainBonusGame`이 **true** 이고, 일반 타격을 모두 성공했을 때 진행합니다. `Hit()`에서 채광을 성공했을 때 `self.ContainBonusGame` 이 **true**면 `IsPlayingBounesGame` 값을 true로 변경합니다. |
| None | Entity | TimingArrow | `OnUpdate()`에서 움직일 화살표 UI 엔티티입니다. |
| None | Entity | CurrentTarget | 채광 중인 광맥 엔티티입니다. |
| None | number | PlayingTime | `OnUpdate()`에서 화살표 UI의 위치를 결정하기 위한 시간 값입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | Initialize | 채광 게임을 시작하기 위해 각종 프로퍼티를 초기화하는 함수입니다. 광맥과 상호 작용 시 호출됩니다<ul><li>VeinLevel: 상호 작용한 광맥의 레벨</li><li>VeinEntity: 상호 작용한 광맥 엔티티</li><li>IsKeyBox: 광맥의 열쇠 보유 여부</li></ul> |
| client | void | SetTimingBarPosition | 미니 게임에서 타이밍 영역 위치를 무작위로 조절하는 함수입니다. 보너스 게임이라면 기본 게임 UI를 끄고, 보너스 게임 UI를 활성화합니다. |
| client only | void | OnBeginPlay | `self.TimingArrow`에 엔티티를 할당합니다. |
| client only | void | OnUpdate | 미니 게임 중 화살표 위치를 왕복해 움직이게 합니다. `self.PlayingTime += delta`를 더한 값의 위치로 화살표를 이동시킵니다. |
| client | void | Hit | 타격 적중을 처리하는 함수입니다. 플레이어가 `채광하기` 버튼, `E` 키를 눌렀을 때 호출됩니다. |
| client | void | ExitGame | 미니 게임을 종료시키는 함수입니다. 게임 도중 `Esc`를 누르거나, `self:Hit()`에서 성공/실패 조건에 맞으면 호출됩니다. |
| client | void | ForcedExitGame | 미니 게임을 강제로 종료시키는 함수입니다. 게임 중에 플레이어가 사망하면 호출됩니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | 처음 미니 게임 UI가 활성화 되고, 플레이어가 `E`키를 누르면 미니 게임을 시작합니다. 미니 게임 중엔 `E`키를 눌러 타격합니다. |
| - | InputService | KeyDownEvent2 | 미니 게임 UI를 `Esc` 키를 눌러 닫습니다. 게임이 진행 중이었다면 강제 종료하고 UI를 닫습니다. |

# UI_RainbowText

`TextComponent` 텍스트 컬러가 일정 주기로 변경됩니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Number | Time | 색상을 일정 주기로 변경하기 위해 사용하는 프로퍼티입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnUpdate | 3초 주기로 색상을 변경합니다. |

# UI_Status Logic

내 능력치 UI와 관련된 로직입니다.

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | void | OnBeginPlay | 월드 처음 진입 시 능력치 UI를 닫습니다. |
| client | void | RefreshUI | 능력치 UI를 새로 고침합니다. 서버에서 능력치를 갱신할 때마다 함수를 호출합니다.<ul><li>base: 능력치의 기본값입니다.</li><li>increase: % 증가량입니다.</li><li>final: base에 increase 값을 계산해 적용한 최종값입니다.</li></ul> |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| - | InputService | KeyDownEvent | `Esc`를 눌러 UI를 닫습니다. |
| - | [entity] /ui/HUDGroup/TownHUD/Panel_menu3<br>/ScrollList/StatusButton | ButtonClickEvent | **능력치** 버튼을 누르면 이 핸들러를 실행합니다. 메뉴 UI를 닫고, 능력치 UI를 엽니다. |

Update 2025-11-20 PM 02:03


# Models

# Guide_Key

플레이어가 상호 작용이 가능한 엔티티에 다가가면 활성화되는 가이드UI 모델입니다. NPC, 광맥, 탐험도구 상자 등 상호 작용이 필요한 모델에 가이드 UI가 포함되어 있습니다. ![GuideKey](https://mod-file.dn.nexoncdn.co.kr/bbs/16941518548902bee49148d3c449aa1eb5d18e7dc980a.png)

# Guide_Portal_TownToMine

마을에서 광산으로 연결되는 포탈 가까이 다가가면 활성화되는 가이드UI 모델입니다. ![Portal_TownToMine](https://mod-file.dn.nexoncdn.co.kr/bbs/16941522105747a0e548bffdf43a58f4e1590860898b5.png)

# Guide_Portal_TownToTown

마을에서 마을로 연결된 포탈 가까이 다가가면 활성화되는 가이드 UI 모델입니다. ![PortalTownToTown](https://mod-file.dn.nexoncdn.co.kr/bbs/1694152240385246f4580544b422099d87fcdf49ff317.png)

# Portal_MineToMine

광산에서 광산으로 연결되는 포탈 모델입니다. 이 모델은 가이드 UI가 포함되어 있습니다. ![Portal_TownToMine](https://mod-file.dn.nexoncdn.co.kr/bbs/16941522105747a0e548bffdf43a58f4e1590860898b5.png)

# Portal_TownToMine

마을에서 광산으로 연결되는 포탈 모델입니다. 이 모델은 가이드 UI가 포함되어 있습니다. ![Portal_TownToMine](https://mod-file.dn.nexoncdn.co.kr/bbs/1696491598419c4b21bd086e4415992666435fa6d7364.png)

# Portal_TownToTown

마을에서 마을로 연결되는 포탈 모델입니다. 이 모델은 가이드 UI가 포함되어 있습니다. ![PortalTowntoTown](https://mod-file.dn.nexoncdn.co.kr/bbs/1694152465297023c65f89637414586456e9e3b646434.png)

# npc_returnRobot

광산에서 마을로 연결되는 귀환 로봇 모델입니다. ![npcReturnRobot](https://mod-file.dn.nexoncdn.co.kr/bbs/169415373372374e59a2bb8374b0695902e9b263b9df8.png)

# npc_weaponShop

장비 상인 NPC 모델입니다. 외형을 변경할 때는 **SpriteRendererComponent**의 **SpriteRUID**를 변경해야 합니다. NPC 이름을 변경할 때는 **NameTagComponent**의 **Name**을 변경해야 합니다. ![npc_weaponShop](https://mod-file.dn.nexoncdn.co.kr/bbs/169415227281286f5a729f9264e1bb9045f99baef1a0e.png)

# npc_sell

광물 상인 NPC 모델입니다. 외형을 변경할 때는 **SpriteRendererComponent의 SpriteRUID**를 변경해야 합니다. NPC 이름을 변경할 때는 **NameTagComponent**의 **Name**을 변경해야 합니다. ![npcSell](https://mod-file.dn.nexoncdn.co.kr/bbs/16941538202550ed807a540594e9d9e2a9a17f8029083.png)

# MiningTarget

광산 내에 배치되는 광맥입니다. 광산에 배치한 뒤 레벨에 맞게 **MiningTargetObject 컴포넌트**의 **Level**를 변경합니다. ![MiningTarget](https://mod-file.dn.nexoncdn.co.kr/bbs/16941478714945063532b851f4c54b17a7ae1a6abb71f.png)

# ToolBox

광산에 배치하는 탐험 도구 상자입니다. ![ToolBox](https://mod-file.dn.nexoncdn.co.kr/bbs/16941481697741fb75c3bf93e46bbb58fbc9cb2bdac32.png)

# Tools_Rope

플레이어가 소환하는 밧줄 모델입니다. ![ToolRope](https://mod-file.dn.nexoncdn.co.kr/bbs/1694149116046de39e3497b1546b287e60f56d190520f.png)

# Tools_Torch

플레이어가 소환하는 횃불 모델입니다. ![toolTorch](https://mod-file.dn.nexoncdn.co.kr/bbs/169414913950497f66e725c574435ac280410bbece203.png)

# Tools_Trampoline

플레이어가 소환하는 트램펄린 모델입니다. ![ToolTrampoline](https://mod-file.dn.nexoncdn.co.kr/bbs/16941517867250038a69591ed4c3290d020a798cac81f.png)

# object_light

광산에서 가까이 다가가면 시야를 밝혀주는 오브젝트 모델입니다. ![object_light](https://mod-file.dn.nexoncdn.co.kr/bbs/1694151820475703fe08bbc4c4b4c8d73159265730dc7.png)

Update 2025-11-20 PM 02:03


# 스크립트 없이 리메이크 월드 확장하기

# 포탈 만들기

#### 마을에서 마을로 이동 포탈

`Portal_TownToTown` 모델을 배치하고, 프로퍼티 값을 변경해 마을에서 마을로 이동할 수 있게 만들어 봅시다.

1. 마을로 이동할 수 있는 포탈 모델을 **Workspace - MyDesk - Models - Portal - Portal_TownToTown**을 Scene에 배치합니다. ![PortalTownToTown](https://mod-file.dn.nexoncdn.co.kr/bbs/169407345576958fcb84b535b476a9deaedaa9ea14e18.png)
2. `SpriteRendererComponent`의 SortingLayer 값을 **Layer1**로 변경합니다. ![SortingLayer](https://mod-file.dn.nexoncdn.co.kr/bbs/1694073479466ef8f252e06344befadd2ee708c83327c.png)
3. 프로퍼티 에디터 창에서 `Portal_TownToTown` 컴포넌트의 **DestinationTownIndex** 프로퍼티 값을 이동할 마을의 index 값으로 변경합니다. ![DestinationTownIndex](https://mod-file.dn.nexoncdn.co.kr/bbs/1694073499868138d82902ac64200b8f654dcd9c1e864.png)

#### 마을에서 광산 이동 포탈

`Portal_TownToMine` 모델을 배치하고, 프로퍼티 값을 변경해 마을에서 광산으로 이동할 수 있게 만들어 봅시다. 광산 포탈은 마을 위치에 따라 맞는 광산으로 이동하게 만들어져 있습니다. 예를 들어 Town1 마을에서는 Mine1-1 광산으로, Town2 마을에서는 Mine2-1 광산으로 이동합니다. 그러므로 마을과 광산을 새롭게 추가할 때는 기존 map의 이름 규칙과 동일하게 지어야 합니다.

1. **Workspace - Models - Portal - Portal_TownToMine**을 Scene에 배치합니다. ![PortalTownToMine](https://mod-file.dn.nexoncdn.co.kr/bbs/16940741976881e5bf9d0e3b842859f49ce086b1339e4.png)
2. SpriteRendererComponent의 SortingLayer 값을 **Layer1**로 변경합니다. ![SortingLayer](https://mod-file.dn.nexoncdn.co.kr/bbs/1694073479466ef8f252e06344befadd2ee708c83327c.png)

#### 마을 귀환 시 도착할 장소 정하기

광산에서 마을로 돌아올 때 캐릭터가 도착하는 장소를 오브젝트를 활용해 지정할 수 있습니다.

1. **Preset List - Object**에서 적절한 프리셋을 찾아 배치합니다.
2. **object_returnPoint**로 이름을 변경합니다.

> **더 알아보기** `UI_GameResult`의 **HandleKeyDownEvent**에서 `_TeleportService:TeleportToEntityPath(_UserService.LocalPlayer, string.format("/maps/Town%d/object_returnPoint",townIdx))` 코드로 인해 이름을 **object_returnPoint**로 변경하기만 하면, 광산에서 마을로 돌아올 위치를 찾게 됩니다.

![object_returnPoint](https://mod-file.dn.nexoncdn.co.kr/bbs/1694078193760f07ab3174fa044399b114e8d2426ae1a.png)

# NPC 배치하기

NPC 모델을 배치해 마을에 광물 상점과 무기 상점을 만들어 봅시다. NPC 모델은 별도의 수정이 필요하지 않습니다. 원하는 위치에 자유롭게 배치하고 이름을 변경합니다.

1. **Workspace - MyDesk - NPC**에서 **npc_sell, npc_weaponShop**을 Scene에 배치합니다. ![NpcModel](https://mod-file.dn.nexoncdn.co.kr/bbs/16940782193189b10e64e079d4283beb0c5575f6f7c8d.png)
2. NameTagComponent의 **Name**에서 이름을 변경합니다.
3. SpriteRendererComponent의 SortingLayer 값을 **Npc**로 변경합니다.

# 광산 꾸미기

#### 사다리 설치

1. **Preset List - Ladder**에서 사다리를 선택해 Scene에 배치합니다.
2. **ClimbableComponent의 SpeedFactor** 값을 조정해 사다리 위에서의 이동 속도를 조절합니다. ![SpeedFactor](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069458364c5f11bdc69db4bc2a111fe6021becf54.png)

#### 귀환 로봇 배치하기

귀환 로봇 모델을 광산에 배치해 마을로 돌아갈 수 있게 만들어 봅시다. 원하는 위치에 자유롭게 배치합니다.

1. **WorkSpace - MyDesk - Models - Portal - npc_returnRobot**을 찾아 배치합니다. ![returnRobotModel](https://mod-file.dn.nexoncdn.co.kr/bbs/169407140336819164d4d5e52455dac917aaf7c2163b8.png)
2. SpriteRendererComponent의 SortingLayer 값을 **Npc**로 변경합니다.

#### 광맥 레벨 추가하기

1. **Workspace - MyDesk - Models - MiningTarget**을 찾아 배치합니다. ![MiningTargetModel](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069983687de4b328c30cb459ab644cfb00b0fbdc4.png)
2. **MiningTargetObject** 컴포넌트에서 **Level** 프로퍼티 값을 변경하면 채광에 필요한 체력을 변경할 수 있습니다. 광맥의 레벨은 광맥의 순서와 동일한 난이도로 설정해야 합니다. Mine1-3의 광맥 레벨은 **3**이어야 하고, Mine2-1의 광맥 레벨은 **4**여야 합니다.. 광맥의 Level을 추가할 때는 보너스 게임에서 획득하는 보석의 레벨도 추가되어야 합니다. ![MiningTarget](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069434204dda5f137834b447da7553a3b0c8f91f4.png)
3. **WorkSpace - MyDesk - Tables - VeinInfo**를 열어 데이터를 추가합니다. 레벨에 따라 모든 열의 데이터를 작성합니다. 각 행의 정보는 [Tables](docs?postId=1083)를 참고하세요.

# 새로운 장비 추가하기

1. **Workspace - MyDesk - Tables - EquipmentInfo**을 선택해 데이터 셋을 엽니다. 새로운 장비를 추가했다면 행을 추가하고, 장비의 정보를 추가 입력해야 합니다. 각 행의 정보는 [Tables](docs?postId=1083)를 참고하세요. ![EquipmentInfo](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069696514b1df5a9962da49089547f6f611dba76f.png)
2. 곡괭이 정보는 **Type1_RUID**에 추가합니다. 사용할 장비는 반드시 **Resource Storage - avataritem - 2H Weapon** 카테고리의 리소스를 사용해야 합니다. ![2HWeapon](https://mod-file.dn.nexoncdn.co.kr/bbs/169406904564767dd825f2d7d40a29e273ea33177e1f7.png)
3. 작업복 정보는 **Type2_RUID**에 추가합니다. 사용할 장비는 반드시 **Resource Storage - avataritem - Coat** 카테고리 리소스를 사용해야 합니다. ![coat](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069672235d137c4011a3146a0a7d62d7b6d4b0a89.png)
4. 가방은 **Type3_RUID**에 추가합니다. 사용할 장비는 반드시 **Resource Storage - avataritem - Cape** 카테고리의 리소스를 사용해야 합니다. ![cape](https://mod-file.dn.nexoncdn.co.kr/bbs/1694069086498047f12667fd7476d9fa437eff33e8972.png)
5. 신발은 **Type4_RUID**에 추가합니다. 사용할 장비는 반드시 **Resource Storage - avataritem - Shoes** 카테고리의 리소스를 사용해야 합니다.

> **Tip.** RUID를 섬네일로 사용할 때는 RUID 앞에 **thumbnail://** 를 붙여 사용합니다.

Update 2025-11-20 PM 02:03


# 스크립트로 리메이크 월드 확장하기

광부 시뮬레이터의 기존 컴포넌트 내용을 수정하거나, 새로운 엔티티, 컴포넌트를 추가해 나만의 색다른 재미를 만들어봅시다.

# 포션 효과 변경하기

광산에서 포션을 얻어 사용하면 HP 대신 MP를 회복하도록 만들어 봅시다. **Workspace - MyDesk - Components - DefaultPlayerComponents - PlayerMineData** 컴포넌트의 `UsePotion()`함수를 수정합니다. ![mp](https://mod-file.dn.nexoncdn.co.kr/bbs/169441955335422b6690d1eab4fa09f37984661a38032.gif)

```
local recoveryAmount = self.Entity.PlayerStatus.MPMax * 0.2

if recoveryAmount > (self.Entity.PlayerStatus.MPMax - self.Entity.PlayerStatus.MP) then
    recoveryAmount = self.Entity.PlayerStatus.MPMax - self.Entity.PlayerStatus.MP
end

-- 이펙트 재생
_EffectService:PlayEffectAttached("015d476c71a3403ca6bab62c26888d4b", self.Entity, Vector3.zero, 0, Vector3.one)

-- 데미지 스킨
_DamageSkinService:Play(self.Entity, "0910d8fa5eac47dbbff4f30e9fb07a50", 0, {recoveryAmount}, DamageSkinTweenType.Default, false)
    
self.Entity.PlayerStatus.MP += recoveryAmount
```

# 함정 만들기

특정 영역에 플레이어 엔티티가 들어오면 솟아오르는 함정을 만들어 봅시다. ![trap](https://mod-file.dn.nexoncdn.co.kr/bbs/169449983411878a425308beb41d0a2f10740703d1591.gif)

1. **Preset List - Trap - trap-26을** Scene에 배치합니다.
2. **trap-26** 엔티티의 SpriteRendererComponent의 SortingLayer를 **Background**로 변경합니다.
3. 새로운 **Trap_RiseupTrap** 엔티티를 생성합니다. **SpriteRendererComponent, TransformComponent, TriggerComponent**를 추가하고, 배치한 함정 위쪽으로 배치합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16944195854068319f10165a0477eb4f38d05250c0506.png)
4. **trap-26** 위치를 Trap_RiseupTrap 엔티티 하위로 이동시킵니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1694419605271fc93377519cf4b748cee4b09710805a9.png)
5. 새로운 `Trap_RiseupTrap` 컴포넌트를 생성하고, **Trap_RiseupTrap 엔티티**에 추가합니다.
6. Entity Event Handler에 `TriggerEnterEvent`를 추가하고 아래와 같이 작성합니다. 함정에 로컬 플레이어가 닿았을 때만 충돌이 발생하게 됩니다.```
Event Handler:
[self]
HandleTriggerEnterEvent(TriggetEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity    
    ---------------------------------------------------------

    if TriggerBodyEntity ~= _UserService.LocalPlayer then
        return
    end
}
```
7. 함정이 일정한 높이로 올라올 수 있게 **boolean** 타입의 `IsActivated` 프로퍼티를 추가합니다.```
Property:
[None]
boolean IsActivated = false
```
8. **HandleTriggerEnterEvent** 아래에 이어 작성합니다.```
if self.IsActivated == true then
    return
end

self.IsActivated = true
local trap = self.Entity:GetChildByName("trap-26")

local riseUp = function()
    trap.TransformComponent:Translate(0,0.5)
end

-- 0.5초 뒤에 올라옴
_TimerService:SetTimerOnce(riseUp, 0.5)

local down = function()
    trap.TransformComponent:Translate(0,-0.5)
    self.IsActivated = false
end

-- 2초 뒤에 내려감
_TimerService:SetTimerOnce(down,2)
```
9. **trap-26** 엔티티에 `TrapTriggerComponent`를 추가하고, 충돌체 크기를 적절하게 저장합니다.
10. TrapTriggerComponent의 `Damage` 프로퍼티 값을 변경해 트랩에 닿았을 때 닳는 데미지 양을 변경할 수 있습니다.

# 공중 점프 수정하기

![DoubleJump](https://mod-file.dn.nexoncdn.co.kr/bbs/169450346531860fedc0682f64970aa3bab855a382db4.gif)

1. `ExtendPlayerControllerComponent` Entity Event Handler에 **KeyDownEvent**를 추가합니다. `UserService`를 활용해 키를 입력한 플레이어만 공중 점프할 수 있도록 조건을 추가해야 합니다.```
Event Handler:
[service: InputService]
HandleKeyDownEvent(KeyDownEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: InputService
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local key = event.key
    ---------------------------------------------------------

    -- 키를 입력한 플레이어의 아바타만 움직일 수 있도록 UserService를 활용해 조건을 추가함.
    if _UserService.LocalPlayer ~= self.Entity then
        return
    end
    if key == KeyboardKey.Space or key == KeyboardKey.LeftAlt then
        if self.Entity.RigidbodyComponent:IsOnGround() == false then
            self:ActionDoubleJump()
        end
    end
}
```
  > **Tip.** [KeyboardKey](/apiReference/Enums/KeyboardKey)에서 입력할 수 있는 Key를 확인 할 수 있습니다.
2. **ExtendPlayerController** 컴포넌트에 새로운 **LeftAirJumpCount** 프로퍼티를 추가합니다.```
Property:
 [None]
 number LeftAirJumpCount = 1
```
3. **ExtendPlayerControllerComponent**에 `ActionDoubleJump()` 함수를 새로 생성합니다.```
Method:
[client]
void ActionDoubleJump()
{
    if self.LeftAirJumpCount <= 0 then
        return
    end

    local currentSpeed = self.Entity.RigidbodyComponent.RealMoveVelocity

    self.Entity.RigidbodyComponent:SetForce(Vector2(currentSpeed.x,10))
    self.LeftAirJumpCount -= 1
}
```
4. `FootholdEnterEvent`를 추가하고 플레이어 아바타가 지형에 닿은 후 다시 더블 점프 할 수 있도록 아래와 같이 작성합니다. `UserService`를 활용해 LocalPlayer가 지형에 닿으면, **LeftAirJumpCount** 값을 다시 1로 초기화합니다.```
Event Handle:
[client only]
HandleFootholdEnterEvent(FootholdEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: RigidbodyComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    local Foothold = event.Foothold
    ---------------------------------------------------------

    if _UserService.LocalPlayer ~= self.Entity then
        return
    end

    self.LeftAirJumpCount = 1
}
```
5. 점프 때마다 효과음과 이펙트를 재생하도록 `ActionDoubleJump()` 함수에 아래와 같이 작성합니다.```
_SoundService:PlaySound("2eb793d54f25463dba5917b8b518f0e5", 1)
_EffectService:PlayEffectAttached("e7addadf676d415cab98b6bd867eaf82", self.Entity, Vector3.zero, 0, Vector3.one)
```

# UI 툴팁 만들기

#### 체력바 가이드 UI 만들기

체력 바에 마우스를 올리거나, 터치했을 때 설명 UI가 나타나게 만들어 봅시다. ![DescPanel](https://mod-file.dn.nexoncdn.co.kr/bbs/1694495925525ab55bbc6c25b4713b8ccc053cfcb73a3.gif)

1. **Workspace - MyDesk - Component - UI**에 새로운 **UI_MouseHoverGuide** 컴포넌트를 추가합니다.```
Property:
[None]
Entity TargetPanel = nil

Event Handler:
[self]
HandleButtonStateChangedEvent(ButtonStateChangeEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local state = event.state
    ---------------------------------------------------------

    if (Environment:IsMobilePlatform() == true and state == ButtonState.Pressed) 
    or (Environment:IsPCPlatform() == true and state == ButtonState.Hover) then    

        if self.TargetPanel == nil then
            return
        end

        self.TargetPanel.Enable = true
    else
        if self.TargetPanel == nil then
            return
        end

        self.TargetPanel.Enable = false
    end
}
```

1. **Hierachy - ui - HUDGroup - HUD - PlayerInfo - HP**에 `UI_MouseHoverGuide`컴포넌트를 추가합니다.
2. 프로퍼티 에디터 창에서 **TargetPanel** 프로퍼티에 **HPDescPane 또는 MPDescPanel**로 지정합니다.

#### 무작위로 메시지 노출하기

마을에서 광산으로 입장할 때 나타나는 로딩 화면의 팁 메시지를 변경해봅시다. DataSet의 메시지가 무작위로 나타나게 할 수 있습니다. ![RandomeTipMessage](https://mod-file.dn.nexoncdn.co.kr/bbs/1694495955844212538efd0384a5c8412f6df5678f977.gif)

1. 새로운 **TipMessageInfo** DataSet을 생성합니다.
2. **Message** 열을 생성하고, 말풍선에 무작위로 나타날 내용들을 작성합니다. ![TipMessageDataSet](https://mod-file.dn.nexoncdn.co.kr/bbs/169448376328415bd77dd50a74edc9f5b7638786f7641.png)
3. **Portal_TownToMine** 컴포넌트의 `HandleInteractionEvent2()`에 아래 코드를 추가합니다.```
local tipMessageTable = _DataService:GetTable("TipMessageInfo")

local tipMessageEntity = _EntityService:GetEntityByPath("/ui/LoadingGroup/MineEnterance/TipMessage")

-- 1-3번 무작위로 노출
local messageIdx = _UtilLogic:RandomIntegerRange(1,3)
local message = tipMessageTable:GetCell(messageIdx,1)

tipMessageEntity.TextComponent.Text = message
```

Update 2025-11-20 PM 02:03


# UI Group

# 000_BroadCastGroup

작은 사이즈의 시스템 메시지 패널입니다. ![BroadcastPannel](https://mod-file.dn.nexoncdn.co.kr/bbs/1701683683489e40c2853ec124a39866d513272e9e80d.png)

# 000_LoadingGroup

맵을 이동할 때 사용하는 로딩 화면 UI입니다. ![LoadingGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/1701684186994778565c639f144da9f6e52017a4b59e2.png)

# 001_LobbyGroup

로비에서 사용하는 UI입니다. 모바일 조작 버튼, 게임 준비, 매칭 정보 등을 보여줍니다. ![LobbyGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/1701684199129813bc47b4b9f4895b7e4db7ee2b692dd.png)

# 002_IntroGroup

인트로 맵에서 준비 시간과 준비 버튼을 보여주는 버튼입니다. ![IntroGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/1701684210563547da42814384db5bfd64732feb9b5ef.png)

# 003_InGameGroup

게임에서 사용하는 UI입니다. 조작 버튼, 미니맵, 플레이어 상태 등을 보여줍니다. ![InGameGroup](https://mod-file.dn.nexoncdn.co.kr/bbs/17017444928907419bd63b049485189149d014771abb4.png)

# 004_OutroGroup

게임 결과 UI입니다. 플레이어 아바타, 승패 결과, 획득한 재화, 랭크 포인트 등을 보여줍니다. ![Outrogroup](https://mod-file.dn.nexoncdn.co.kr/bbs/17017445364593ce978520f6c45dd95e3c051bd534b9d.png)

Update 2025-11-17 PM 08:15


# 01_Player_Component

폴더 아래의 모델, 컴포넌트, 로직입니다.

# PlayerInGameStatus

#### Property

| 동기화 | Type | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | teamNumber | 플레이어의 팀 숫자를 나타냅니다. 1은 술래인 A팀, 2는 도망자인 B팀입니다. |
| None | number | hp | 플레이어의 체력을 나타냅니다. |
| None | boolean | alive | 플레이어의 생존 여부를 나타냅니다. |
| None | SyncTable<string, string> | playerInteractionState | 플레이어의 상호작용 상태를 관리하는 테이블입니다. |
| None | SyncTable<string, boolean> | playerStatusEffect | 플레이어의 상태 이상을 관리하는 테이블입니다. |
| None | SyncTable<string, number> | playerStatusEffectStack | 플레이어의 상태 이상 스택을 관리하는 테이블입니다. |
| None | SyncTable<string, number> | playerStatusEffectAmount | 플레이어의 상태 이상 변화량을 관리하는 테이블입니다. |
| None | SyncTable<string, number> | playerStatusEffectTime | 플레이어의 상태 이상 지속 시간을 관리하는 테이블입니다. |
| None | SyncTable<string, number> | playerStatusEffectTimer | 플레이어의 상태 이상 지속 타이머를 관리하는 테이블입니다. |

#### Functions

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server | void | InteractionStateChangeUI | 현재 상태와 맞는 상호작용 상태를 확인합니다. 상호작용과 맞는 UI를 호출합니다. |
| server | void | InvicibleSet | 플레이어를 무적 상태로 바꾸는 함수입니다. |
| server | void | ChangeSpeedSet | 플레이어의 속도를 변경하는 함수입니다. |
| server only | void | OnEndPlay | 인게임이나, 인트로 맵에서 플레이어가 나간 경우를 확인합니다. |

#### Entity Event Handler

| 동기화 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | self | TriggerEnterEvent | 플레이어의 피격을 확인하는 이벤트입니다. |

# PlayerInfo

아웃 게임의 플레이어의 상태를 관리하는 컴포넌트입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | money | 플레이어의 재화 값입니다. |
| None | number | rankPoint | 플레이어의 랭크 점수 값입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | OnMapEnter | 맵을 이동할 때마다 맵에 맞는 `MapEnterLogic`의 함수를 호출하는 함수입니다. |
| client only | void | OnInitialize | `W`, `A`, `S`, `D` 키의 액션을 제거하는 함수입니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | InputService | KeyDownEvent | 감정 표현 함수를 호출하는 함수 입니다. |

Update 2025-11-17 PM 08:15


# 02_Player_Logic

# MapEnterLogic

플레이어가 맵을 이동하는 경우 호출하는 함수들을 모아둔 로직입니다. OnMapEnter 함수에서 해당 로직에 있는 함수들 중 이동한 맵에 맞는 함수를 호출합니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity (/ui/000_LoadingGroup) | loadingUI | 로딩 화면 UI입니다. |
| None | Entity (/ui/001_LobbyGroup) | lobbyUI | 로비 그룹 UI입니다. |
| None | Entity (/ui/002_IntroGroup) | introUI | 인트로 그룹 UI 입니다. |
| None | Entity (/ui/003_InGameGroup) | ingameUI | 인게임 그룹 UI 입니다. |
| None | Entity (/ui/004/004_OutroGroup) | outroUI | 아웃트로 그룹 UI 입니다. |
| None | ComponentRef | ingameInfo | common에 있는 InGameInfo 컴포넌트입니다. ComponentRef는 InGameInfo 컴포넌트로 지정합니다. 값은 /common으로 지정합니다. |
| None | ComponentRef | introManager | 인트로 맵에 있는 IntroManager 컴포넌트입니다. ComponentRef는 IntroManager 컴포넌트로 지정합니다. 값은 /maps/002_Intro으로 지정합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | UISetting | 이동한 맵의 이름을 비교해 알맞은 UI를 Enable해주는 역할을 하는 함수입니다. |
| server only | void | LobbyMapEnter | 이동한 맵이 로비 맵이라면 호출되며, 재화와 랭크 점수 값을 가져오고, 매칭 관련 UI를 세팅합니다. |
| server only | void | IntroMapEnter | 이동한 맵이 인트로 맵이라면 호출되며, 플레이어가 인트로 맵에 접속한 것을 체크하기 위해 inPlayerNum의 값을 1 올립니다. |
| server only | void | InGameMapEnter | 이동한 맵이 인게임 맵이라면 호출되며, 게임 준비를 위한 플레이어 세팅을 위해`InGameManager:PlayerSetting()` 함수를 호출합니다. |
| server only | void | OutroMapEnter | 이동한 맵이 아웃트로 맵이라면 호출되며, 게임의 결과에 따라 보상을 받도록`ingameInfo:GetGameReward()` 함수를 호출합니다. |
| client | void | LoadingUISet | 로딩 화면 UI를 활성/비활성화하는 함수입니다. |

# PlayerDataLogic

플레이어의 재화와 랭크 데이터/UI를 관리하는 로직입니다.

#### Property

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity (/ui/001_LobbyGroup/Money/MoneyTxt) | moneyTxtUI | 로비 UI에서 사용하는 재화/랭크 점수의 값을 보여주는 텍스트 UI입니다. |
| None | Entity (/ui/001_LobbyGroup/RankPoint/RankPointTxt) | rankPointTxtUI | 로비 UI에서 사용하는 재화/랭크 점수의 값을 보여주는 텍스트 UI입니다. |
| None | boolean | getRewardMoneyCheck | 게임 결과에 따라 재화 보상을 받았는지 체크하는 변수입니다. |
| None | boolean | getRewardRankPointCheck | 게임 결과에 따라 랭크 점수 보상을 받았는지 체크하는 변수입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | GetMoneyData | DB에서 플레이어의 재화를 가져오는 함수입니다. 가져온 재화값으로 가져오는 함수입니다. UI정보를 가져온 재화값으로 갱신합니다. |
| server only | void | SetMoneyData | DB에서 플레이어의 재화를 가져와 매개변수 `addMoney`를 적용해 다시 데이터를 저장하는 합수입니다. UI 정보를 함께 갱신합니다. |
| server only | void | GetRankPointData | DB에서 플레이어의 랭크 점수를 가져오는 함수입니다. |
| server only | void | SetRankPointData | DB에서 플레이어의 랭크 점수를 가져오고, 변경된 랭크 점수를 다시 DB에 저장하는 함수입니다. |
| client | void | MoneyUIUpdate | 재화 UI를 갱신하는 함수입니다. |
| client | void | RankPointUIUpdate | 랭크 UI를 갱신하는 함수입니다. |
| server only | void | RankIn | 랭킹 등록 함수입니다. 변경된 랭크 점수, 플레이어 ID, 닉네임을 랭킹DB에 저장하고 UI 갱신용 함수를 호출합니다. |
| server | void | RankUpdate | 저장한 랭킹 DB를 불러옵니다. DB의 점수를 내림차순으로 정렬해 랭킹 UI를 갱신하는 함수입니다. |

Update 2025-11-17 PM 08:15


# 03_Player_Emoticon

# EmoticonData

플레이어가 사용하는 감정표현과 관련된 데이터를 관리하는 테이블입니다.

| 이름 | 설명 |
| --- | --- |
| Key | 감정 표현을 호출하는 키 값으로, 해당 값을 KeyboardKey로 변환해 사용합니다. |
| RUID | 감정 표현의 RUID 값입니다. |
| Scale | RUID 마다 크기 값이 다르므로, 과하게 크거나 작은 이미지를 조절하기 위한 값입니다. |
| PivotY | RUID 마다 피벗 또한 다르므로, y축 위치를 조절하기 위한 값입니다. |
| Explain | 해당 이미지를 설명하는 참고 값입니다. 월드 동작에 사용되지 않는 값입니다. |

# EmoticonLogic

레이어가 사용하는 감정표현 관련 함수를 가진 로직입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | SyncTable<string, boolean> | PlayerEmotionOn | 현재 감정표현을 사용하고 있는지 체크하는 테이블이며, key 값에는 플레이어의 ID, value 값에는 현재 사용 중인지를 체크하는 true/false 값이 들어갑니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server | void | SpawnEmoticon | 머리 위에 띄울 감정표현 entity를 생성하는 함수로 현재 감정 표현이 이미 재생 중이거나, 플레이어가 존재하지 않으면 함수를 return 시킵니다. |
| client | void | EmoticonClient | 아바타의 머리 위에 감정 표현을 띄워주는 함수로 인게임에서 플레이어의 체력이 0이 됐을 때만 감정 표현을 띄우지 않고 함수를 return 시킵니다. |

Update 2025-11-17 PM 08:15


# 001_Lobby

# LobbyMatchManager

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | number | matchInterval | 매칭 대기 시간을 설정해주는 변수입니다. |
| None | number | minPlayerNum | 매칭에 필요한 최소 인원을 설정해주는 변수입니다. |
| None | number | maxPlayerNum | 한 게임에 매칭되는 최대 인원을 설정해주는 변수입니다. |
| None | SyncTable<string, string> | playerReadyState | 플레이어의 준비 상태를 저장하는 변수 테이블입니다. key 값에는 플레이어의 ID, value 값에는 플레이어의 상태가 "Ready", "Idle", "Quit" 등의 상태로 저장됩니다. |
| None | SyncTable<string, number> | playerReadyTimeStamp | 각 플레이어가 준비 했을 때의 서버 시간을 저장해주는 변수 테이블로, 매칭 우선 순위를 잡아주기 위한 용도로 쓰입니다. key 값에는 플레이어의 ID, value 값에는 플레이어가 준비 했을 때의 서버시간이 저장됩니다. |
| None | string | LobbyState | 현재 로비의 상태를 저장하는 변수입니다. 매칭 가능한 상태에서는 "Start", 그렇지 않으면 "Idle" 상태를 저장합니다. |
| None | number | instanceRoomNumber | 인스턴스 룸의 넘버를 설정해주는 변수로, 매칭 이후 인스턴스 룸을 생성할 때, 겹치지 않도록 지금까지 만들어진 인스턴스 룸의 개수에 1을 더해 생성합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | OnInitialize | 월드가 처음으로 생성되면 여러 설정 값들을 초기화 해주는 함수의 역할을 합니다. |
| server | void | SetPlayerReadyState | 플레이어의 준비 상태를 playerReadyState에 저장하고, 서버시간 또한 playerReadyTimeStamp에 저장한 후, 플레이어 수를 체크하기 위해서 ReadyPlayerCountCheck를 호출합니다. |
| server only | void | ReadyCountTimer | 플레이어가 준비 상태인 경우, 준비 중인 시간을 체크해주는 함수로 TimerService를 이용해 몇 초간 매칭 중인지 기록하고 `ReadyStateTxtUI()` 함수로 UI에 호출해줍니다. |
| server | void | ReadyPlayerCountCheck | 준비 상태인 플레이어의 수를 체크해주는 함수로, playerReadyState를 확인해 매칭 가능한 수 이상이 되면 게임 준비를, 매칭 가능한 수가 되지 않으면 다시 매칭 상태를 유지합니다. |
| server | void | StartCountDownTimer | 매칭 가능한 인원 수가 준비를 하게 되면, 해당 함수를 호출해 게임 준비 카운트를 해주는 함수입니다.카운트가 0이 되면 `LaunchRoom()` 함수를 호출합니다. |
| server only | void | LaunchRoom | 인스턴스 룸을 생성하고 매칭된 인원을 그 룸으로 보내는 역할을 하는 함수입니다. 이 함수에서는 준비 인원의 매칭 우선순위를 체크하고, 맵과 역할을 랜덤으로 지정해 생성한 룸으로 플레이어를 이동 시킴과 동시에 관련 게임 데이터를 전송해줍니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | UserService | UserEnterEvent | 플레이어가 게임에 접속하면 준비 상태를 "Idle", 대기 상태로 설정해줍니다.이 이벤트를 포함해서 아래 이벤트 핸들러들은 전부 `SetPlayerReadyState()` 함수를 호출해줍니다. |
| server only | UserService | UserLeaveEvent | 플레이어가 게임에서 나가면 준비 상태를 "Quit", 나감 상태로 설정해줍니다. |
| client only | [entity] ReadyBtn(/ui/001_LobbyGroup/ReadyState/ReadyBtn | ButtonClickEvent | 플레이어가 게임 준비 버튼을 눌렀을 때, 플레이어의 준비 상태를 "Ready" 상태로 설정해줍니다. |
| client only | [entity] CancelBtn(/ui/001_LobbyGroup/ReadyState/CancelBtn) | ButtonClickEvent2 | 플레이어가 게임 준비 버튼을 눌렀을 때, 플레이어의 준비 상태를 "Idle" 상태로 설정해줍니다. |

# LobbyUI

로비 맵에서 쓰이는 UI 중 매칭 관련 UI를 제외한 나머지 부분을 관리하는 로직입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity (/ui/001_LobbyGroup//MenuBtn) | menuBtn | 메뉴 버튼입니다. |
| None | Entity (/ui/001_LobbyGroup/MenuPanel) | menuPanel | 메뉴 패널입니다. |
| None | Entity (/ui/001_LobbyGroup/RankList/popup/Leaderboard/ScrollLayout) | rankScrollLayout | 순위 목록 패널입니다. |
| None | Entity (/ui/001_LobbyGroup/RankList/popup/Leaderboard/ScrollLayout/rank0) | rank0 | 순위 목록 샘플입니다. |
| None | Entity (/ui/001_LobbyGroup/RankList/popup/Leaderboard/My_rank) | myrankBoard | 플레이어 정보 UI입니다. |
| None | Entity (/ui/001_LobbyGroup/RankList | rankPanel | 랭크 패널입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | RankingUpdateUI | 데이터 로직에서 받은 랭크 순위 테이블을 변수로 가져와서 UI에 노출해주는 함수입니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | [entity] MenuBtn (ui/001_LobbyGroup/MenuBtn) | ButtonClickEvent | 메뉴 버튼을 누르면 메뉴 패널이 나타나는 이벤트입니다. |
| client only | [entity] RankBtn (ui/001_LobbyGroup/MenuPanel/RankBtn) | ButtonClickEvent2 | 메뉴 패널 내 랭크 버튼을 누르면 랭크 패널이 나타나는 이벤트입니다 |
| client only | [entity] XBtn (/ui/001_LobbyGroup/RankList/popup/XBtn) | ButtonClickEvent3 | 랭크 패널 내 X 버튼을 누르면 랭크 패널이 꺼지는 이벤트입니다. |

# MatchUI

로비 맵에서 쓰이는 매칭 관련 UI를 관리하는 로직입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity (/ui/001_LobbyGroup/ReadyState/TimeTxt) | readyStateTxtUI | 현재 플레이어의 매칭 상태를 표시하는 텍스트 UI |
| None | Entity (/ui/001_LobbyGroup/ReadyState/ready_count) | readyCountTxtUI | 현재 준비 상태인 플레이어의 숫자를 표시하는 텍스트 UI |
| None | Entity (/ui/001_LobbyGroup/ReadyState/ReadyBtn) | readyBtn | 준비 버튼입니다. |
| None | Entity (/ui/001_LobbyGroup/ReadyState/CancelBtn) | cancelBtn | 준비 취소 버튼입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | ReadyStateTxtUI | readyStateTxtUI 에 현재 매칭 상태를 표시해주는 함수입니다. <br>Start: n초 후 매칭됩니다. <br> Ready: n초 간 매칭 중..<br>Idle: 게임 준비 버튼을 눌러주세요 |
| client | void | ReadyCountUI | readyCountTxtUI에 현재 준비 상태 인원을 표시하는 함수입니다. |
| client | void | ReadyBtnStateChange | 플레이어의 준비 상태에 맞게, 준비/준비 취소 버튼을 노출시키는 함수입니다. |

Update 2025-11-17 PM 08:15


# 002_Intro

# IntroManager

인트로 맵의 시스템을 관리하는 컴포넌트입니다.

#### Property

| 동기화 | Type | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Component | ingameInfo | common의 InGameInfo 컴포넌트를 가진 변수입니다. |
| None | SyncTable<string, string> | playerIntroReadyState | 인트로 맵에서 플레이어의 준비 상태를 확인합니다. key는 플레이어Id, value는 플레이어의 상태를 Ready, Idle로 저장합니다. |
| None | number | inPlayerNum | 매칭된 플레이어 수입니다. |
| None | number | readyCount | 인트로 맵에서 준비를 마친 플레이어 수입니다. |
| None | number | introTime | 인트로 맵의 준비 제한 시간입니다. |
| None | Entity (/maps/002_Intro/ASpawnSet) | aSpawnSet | a팀 SpawnLocation의 부모 엔티티입니다. |
| Sync | Entity (/maps/002_Intro/BSpawnSet) | bSpawnSet | b팀 SpawnLocation의 부모 엔티티입니다. |
| None | boolean | gameStop | 게임이 정상적으로 진행 중인지 확인합니다. 인트로 준비 중 플레이어가 게임을 이탈하면 true 값으로 변경합니다. |

#### Method

| 동기화 | Type | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | OnBeginPlay | 모든 플레이어가 정상 접속 했는지 확인하는 함수입니다. `IntroStart()` 함수를 호출합니다. |
| server only | void | IntroStart | 플레이어의 시작 위치로 이동시키고, 인트로 타이머를 키는 함수입니다. |
| server | void | IntroReadyStateChange | 인트로 맵에서 플레이어의 준비 상태를 변경하는 함수입니다. |
| server | void | InGameMove | 인게임 맵으로 플레이어를 이동시키는 함수입니다. |

#### Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | [entity] ReadyBtn (/ui/001_IntroGroup/ReadyBtn) | ButtonClickEvent | 준비 버튼을 누르면, 인트로 맵에서 게임 준비 상태를 "Ready" 상태로 변경하는 이벤트입니다. |

# IntroUI

인트로 맵의 모든 UI를 관리하는 로직입니다.

#### Property

| 동기화 | Type | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity (/ui/002_IntroGroup/IntroTimer) | timeTxtUI | 남은 시간을 표시하는 텍스트UI입니다. |
| None | Entity (/ui/002_IntroGroup/ReadyBtn) | readyBtnUI | 인트로 준비 버튼UI 입니다. |
| None | Entity (/ui/002_IntroGroup/UserCharacterPanel/ATeamScroll) | aTeamScrollLayout | A팀의 팀원 패널 스크롤 레이아웃입니다. |
| None | Entity (/ui/002_IntroGroup/UserCharacterPanel/ATeamScroll/ATeamScroll0) | aTeamScroll0 | A팀의 팀원 표시 패널입니다. |
| None | Entity (/ui/002_IntroGroup/UserCharacterPanel/BTeamScroll) | bTeamScrollLayout | B팀의 팀원 패널 스크롤 레이아웃입니다. |
| None | Entity (/ui/002_IntroGroup/UserCharacterPanel/BTeamScroll/BTeamScroll0) | bTeamScroll0 | B팀의 팀원 표시 패널입니다. |
| None | Component | ingameInfo | common의 InGameInfo 컴포넌트입니다. |

#### Method

| 실행제어 | Type | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | ReadyCheckUI | 플레이어의 준비 상태를 확인해 플레이어 스크롤 패널에 준비 마크를 활성/비활성하는 함수입니다. |
| client | void | IntroTimerUI | 인트로 남은 준비 시간을 표시해주는 함수입니다. |
| client | void | PlayerScrollSet | 매칭 인원을 체크해서, 팀에 맞게 상단 TeamScroll에 플레이어의 아바타 및 닉네임 등 정보를 UI에 갱신하는 함수입니다. |

Update 2025-11-17 PM 08:15


# 003_InGame

# InGameManager

인게임의 전반적인 시스템을 관리하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Component | ingameInfo | common이 가진 InGameInfo 컴포넌트를 가진 변수입니다. |
| None | string | inGameState | 인게임의 진행 상태를 가지고 있는 변수입니다. "Ready", "Play", "End" 등의 상태를 가지고 있습니다. |
| None | number | inGameTime | 인게임 플레이 시, 남은 시간을 가지고 있는 변수입니다. |
| None | number | aliveBTeamPlayerCount | 인게임 플레이 시, 현재 살아있는 B팀의 플레이어 숫자를 가지고 있는 변수입니다. |
| None | number | clearTargetCount | 인게임 플레이 시, 현재 B팀이 막은 구멍의 숫자를 가지고 있는 변수입니다. |
| None | number | closeTargetNum | 인게임 플레이 시, B팀이 막아야하는 구멍의 숫자를 가지고 있는 변수입니다. |
| None | SyncTable< Entity > | deathPlayers | 인게임 플레이 시, 죽은 B팀 플레이어의 엔티티를 가지고 있는 변수 테이블입니다. |
| None | number | ATeamPlayerCount | A팀의 인원 수를 가지고 있는 변수입니다. |

#### Method

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | PlayerSetting | 플레이어가 인게임 맵으로 이동하면 호출되는 함수로, 팀에 맞는 플레이어의 스테이터스 변경 및 접속 확인 등의 역할을 합니다. |
| server only | void | TargetSetting | 게임 시작 시, 총 플레이어 인원 수에 맞게 구멍의 개수를 세팅하는 함수입니다. |
| server only | void | GameReadyCheck | 플레이어가 인게임 맵으로 이동하면 호출되는 함수로, 모든 플레이어가 로딩이 완료되었는지 체크하고 완료되었으면 게임 시작 함수인 GameStart()를 호출합니다. |
| server only | void | GameStart | 인게임을 시작하는 역할을 하는 함수로, 게임 시작과 관련된 스크립트를 가지고 있으며, UI 세팅, 플레이어 위치 이동, 구멍 세팅 함수 등을 호출하고 인게임 타이머를 가지고 있는 함수입니다. |
| server only | void | GameOver | 게임이 종료되면, 승패 데이터를 저장하고 아웃트로 맵으로 플레이어를 보내주는 함수입니다. |
| server only | void | PlayerAttack | A팀 플레이어와 B팀 플레이어가 충돌하면 호출되는 함수로 B팀의 플레이어 체력을 깎고, 체력에 맞는 추가 처리 이후, 두 명을 서로 반대 방향으로 넉백 시키는 역할을 합니다. |
| server only | void | PlayerDeath | B팀 플레이어의 체력이 0이 되거나, 탈주를 한 경우 호출되는 함수로 플레이어는 죽음 상태가 되도록 설정해주는 역할을 합니다. (투명화 처리, 모션/말풍선/감정표현 안보이도록) |
| server only | void | PlayerPosCheck | 플레이어의 위치를 받아 실시간으로 미니맵에 표시하도록 타이머로 반복해MinimapPlayerUIUpdate()함수를 호출하는 역할을 하는 함수입니다. |
| server only | void | PlayerSpawn | 게임 시작 시, 플레이어 시작 위치를 랜덤으로 잡아 이동시켜주는 함수입니다. |

# TargetComponent

구멍 오브젝트을 관리하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | boolean | Clear | 해당 구멍이 막아졌는지 확인합니다. targetGage가 100이되면 값을 true로 변경합니다. |
| None | SyncTable<Entity, boolean> | playerInteraction | 현재 몇 명의 플레이어가 상호작용 중인지 확인합니다. |
| None | number | targetGage | 해당 구멍의 게이지입니다. 100이 되면 구멍이 막힌 것으로 간주합니다. |
| None | number | gageOnTimer | 구멍의 게이지를 올리는 타이머를 넣어두는 변수입니다. |
| None | number | gagePerSecond | 빈도 당 올라가는 게이지의 값을 넣어두는 변수입니다. |
| None | number | timerCycle | 게이지를 올리는 타이머의 빈도 값을 넣어두는 변수입니다. |

#### Method

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | OnBeginPlay | 초기화가 필요한 변수의 값을 지정해주는 함수입니다. |
| server only | void | gageUp | 상호작용 중인 플레이어가 있다면, 게이지를 올리는 타이머를 호출하는 함수입니다. |
| server only | void | playerInteractionCheck | 플레이어의 상호작용 상태를 확인하는 함수입니다. |
| server | void | TargetClear | 게이지가 100이되면 호출되는 함수입니다. 구멍을 전부 막은 상태로 변경하는 함수입니다. |
| server | void | TargetLightSet | 상호작용 시 구멍 엔티티에서 보이는 이펙트를 제어하는 함수입니다. |

#### Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | self | InteractionEnterEvent | 플레이어와 닿을 때, 플레이어가 상호작용할 수 있는 상태로 변경해주는 이벤트입니다. |
| server only | self | InteractionEvent | 플레이어가 상호작용 할 때, 플레이어의 상태를 구멍 막기 중으로 변경하고, `playerInteracitonCheck()`를 호출하는 이벤트입니다. |
| server only | self | InteractionLeaveEvent | 플레이어가 멀어질 때, 상호작용 상태를 false로 변경하고, 플레이어가 상호작용할 수 없는 상태로 변경해주는 이벤트입니다. |

# InGameUI

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity | resultScreen | 게임의 결과를 보여주는 화면 UI |
| None | Entity | targetGageUI | 타겟 게이지를 표시해주는 UI |
| None | Entity | targetGageBar | 게이지 바 UI (보라색 부분) |
| None | Entity | interactionUI | 인터렉션이 가능한 상태일 때 노출되는 가이드 UI |
| None | Entity | ingameTimeTxt | 남은 시간을 표시해주는 UI입니다. |
| None | Entity | bTeamScrollUI | B팀의 플레이어 상태 등 정보를 표시해주는 UI |
| None | Entity | targetListUI | 현재 막아야하는 구멍의 상태를 표시해주는 UI |
| None | Entity | EmoticonPCUI | PC에서 쓰이는 이모티콘 Ui |
| None | Entity | EmoticonMobileUI | 모바일에서 쓰이는 이모티콘 리스트 UI |
| None | Entity | chatAndEmoPanelOffBtnUI | 이모티콘 리스트 UI가 노출된 상태일 때, 주변을 클릭해도 리스트 UI Enable이 false가 될 수 있도록 사용하는 전체 화면 크기의 투명한 버튼 UI |
| None | Entity | minMapPanel | 미니 맵 패널 UI |
| None | Entity | miniMapBackGround | 미니 맵 배경 UI |
| None | Entity | minMapTargetIcon0 | 미니맵 구펑 샘플 아이콘UI |
| None | Entity | minMapATeamIcon0 | 미니 맵 A팀의 플레이어 위치 샘플 아이콘 UI |
| None | Entity | miniMapBTeamIcon0 | 미니 맵 B팀의 플레이어 위치 샘플 아이콘 UI |
| None | SyncTable<string, number> | mapInfo | 인게임 맵 크기 및 미니맵 패널 크기 정보를 담아두는 변수 테이블입니다. (정보 항목 : Left, Right, Top, Bottom, Width, Height) key 값에는 맵 정보 항목이, value 값에는 항목에 맞는 값이 들어있습니 |

#### Method

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | ResultScreenUpdate | 게임 결과에 맞는 결과 창을 띄우는 함수입니다. |
| client | void | InGameTimerUIUpdate | 인게임 타이머를 UI에 보여주는 함수입니다. |
| client | void | TargetGageUIUpdate | 플레이어가 구멍과 상호작용할 때 게이지 UI를 보여주는 함수입니다. |
| client | void | InteractionUIUpdate | 플레이어가 다른 엔티티와 상호작용이 가능한 경우 상호작용 가이드 UI를 업데이트 하는 함수입니다. |
| client | void | TeamBHpUIUpdate | B팀 플레이어의 체력이 변경될 때마다, 그 정보를 스크롤 UI에 업데이트 해주는 함수입니다. |
| client | void | TeamBInfoUIUpdate | B팀 플레이어의 기본적인 정보(아바타, 닉네임)를 UI에 업데이트 해주는 함수입니다. |
| client | void | TeamBListUIUpdate | B팀 플레이어의 스크롤 레이아웃을 설정해주는 함수입니다. |
| client | void | TargetListUpdate | 막아야하는 남은 구멍 개수를 UI에 보여주는 함수입니다. |
| client | void | EmoticonListUpdate | PC, Mobile 환경에 따라 이모티콘 리스트를 UI에 갱신하는 함수입니다. |
| client | void | MinimapSetUIUpdate | 맵의 정보를 mapinfo 테이블에 저장하고, 미니맵 배경을 UI에 갱신하는 함수입니다. |
| client | void | MinimapPlayerUIUpdate | 플레이어의 위치를 미니 맵에 갱신하는 함수입니다. |
| client | void | MinimapTargetUIUpdate | 구멍 위치를 미니 맵에 갱신하느 함수입니다. |

#### Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | [entity] EBtn(/ui/003_InGameGroup/Mobile_only_UI/EBtn) | ButtonClickEvent | 모바일에서 이모티콘 패널을 열어주는 버튼 클릭 이벤트입니다. |
| client only | [entity] ChatAndEmoOffBtn(/ui/003_InGameGroup/ChatAndEmoOffBtn) | ButtonClickEvent2 | 모바일 이모티콘 패널 주변을 클릭하면 이모티콘 패널이 닫히도록 하는 버튼 클릭 이벤트입니다. |

Update 2025-11-17 PM 08:15


# 004_Outro

# OutroManager

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | SyncTable<string, number> | playerOutroTime | 플레이어 별 결과 확인 시간을 관리합니다. key는 플레이어Id, value는 결과 확인 시간 값입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | OutroTimerSet | 결과 확인 시간 타이머를 호출하는 함수입니다. 시간이 끝나면 플레이어를 로비로 이동시킵니다. |
| server | void | MoveToLobby | 플레이어를 로비로 이동시키는 함수입니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| client only | [entity] NextPhaseBtn (/ui/004_OutroGroup/ResultFrame/PageControllers/NextPhaseBtn) | ButtonClickEvent | 버튼 클릭 시 로비로 이동시키는 `MoveToLobby()` 함수를 호출합니다. |

# OutroUI

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity | outroTimer | 타이머 숫자 UI입니다. |
| None | Entity | resultUI | 승패 이미지가 나타나는 UI입니다. |
| None | Entity | getRankPointUI | 랭킹 포인트 UI입니다. |
| None | Entity | getMoneyUI | 재화 UI입니다. |
| None | Entity | playerAvatarUI | 아바타 UI입니다. |
| None | Entity | nickNameTxtUI | 닉네임 UI입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | outroTimerUI | 결과 확인 시간을 UI에 보여주는 함수입니다. |
| client | void | outroGameResultUI | 결과 승패 표시 및 UI 아바타의 표정을 변경하는 함수입니다. |
| client | void | outroGetRankPointUI | 게임 결과에 따른 랭크 포인트를 UI에 보여주는 함수입니다. |
| client | void | outroGetMoneyUI | 게임 결과로 획득한 재화를 UI에 보여주는 함수입니다. |

# InGameInfo

인트로, 인게임, 아웃트로 시스템 전체를 관리하는 컴포넌트입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | string | ingameMapName | 무작위로 지정된 인게임 맵 이름을 저장합니다. |
| None | SyncTable<string, number> | playerTeamNumber | 플레이어의 팀 숫자를 저장합니다. key는 플레이어Id, value는 플레이어의 팀 숫자 값입니다. |
| None | SyncTable<string, number> | playerNumber | 플레이어의 팀 번호입니다. |
| None | SyncTable<string, boolean> | playerLoadingCheck | 플레이어들이 인게임에 들어왔는지 확인합니다. |
| None | number | playerCount | 게임에 매칭된 인원 수를 저장합니다. |
| None | string | winnerTeam | 게임 종료 시 승리 팀을 저장합니다. |
| None | number | aTeamNum | A팀의 인원 수 입니다. |
| None | number | bTeamNum | B팀의 인원 수 입니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | void | GetGameReward | 게임의 결과를 확인하고 재화와 링크 포인트 값을 저장하는 함수를 호출합니다. |

#### Entity Event Handler

| 실행제어 | 이벤트 중계자 | 이름 | 설명 |
| --- | --- | --- | --- |
| server only | RoomService | PlayerTeamSetEvent | 플레이어의 팀 번호와 팀 내 번호를 저장합니다. |
| server only | RoomService | InGameSetEvent | 무작위로 지정된 인게임 맵 이름, 매칭된 인원 수를 저장합니다. |

Update 2025-11-17 PM 08:15


# Broadcast

# BroadcastLogic

시스템 메시지 시스템을 관리하는 로직입니다.

#### Property

| 동기화 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| None | Entity | broadcastSType | 작은 메시지 UI입니다. |
| None | Entity | broadcastLType | 큰 메시지 UI입니다. |
| None | SyncTable | sTypeMessageTable | BroadcastPanel_S을 사용하는 메시지입니다. |
| None | SyncTable | lTypeMessageTable | BroadcastPanel_L을 사용하는 메시지입니다. |
| None | boolean | sTypeBroadcastOn | BroadcastPanel_S을 사용 중인지 확인합니다. |
| None | boolean | lTypeBroadcastOn | BroadcastPanel_L을 사용 중인지 확인합니다. |

#### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | BroadCastMessageLocalization | 메시지 입력 전 로컬라이제이션을 진행하는 함수입니다. |
| client | void | BroadCastMessageIn | 시스템 메시지를 호출할 수 있도록 확인하는 함수입니다. |
| client | void | PlayingMessage | type에 맞는 메시지를 호출해 UI에 보여주는 함수입니다. |

# SoundLogic

다양한 효과음을 호출하는 로직입니다.

### Function

| 실행제어 | 타입 | 이름 | 설명 |
| --- | --- | --- | --- |
| client | void | HitSound | 피격 효과음을 호출하는 함수입니다. |
| client | void | TargetEndSound | 구멍이 막혔을 때의 효과음을 호출하는 함수입니다. |
| client | void | GameResultSound | 게임 결과에 따른 효과음을 호출하는 함수입니다. |
| client | void | SystemMessageSound | 시스템 메시지 효과음을 호출하는 함수입니다. |
| client | void | HurtSound | 다친 플레이어의 위치를 기준으로 효과음을 호출하는 함수입니다. |
| client | void | ClockSound | 정해진 타입에 맞춰 시계 효과음을 호출하는 함수입니다. |
| client | void | DeathSound | 죽은 플레이어 위치를 기준으로 효과음을 호출하는 함수입니다. |

Update 2025-11-17 PM 08:15


# 월드 확장해보기

# 매칭 인원 변경하기

데이터 셋과 프로퍼티 값을 변경해 매칭 인원을 변경할 수 있습니다.

1. **Workspace - MyDesk - 02_InstanceRoom - GameSetting - matchTeamData**를 선택합니다.
2. 새로운 행을 추가하고, 데이터를 추가합니다. | PlayerNum | TeamA | TeamB | CloseTargetNum | EnableTargetNum | PlayTime |
| --- | --- | --- | --- | --- | --- | | 9 | 3 | 6 | 7 | 10 | 600 |
3. **Workspace - MyDesk - 01_StaticRoom - 001_Lobby - LobbyCompo - LobbyMatchManager**을 선택합니다.
4. 매칭 최대 인원 **maxPlayerNum** 프로퍼티의 값을 **9**로 변경합니다.```
Property:
[None]
number maxPlayerNum = 9
```

# 캐릭터 특징 변경하기

TeamStatusData 데이터 셋 값을 변경해 캐릭터의 특성을 변경할 수 있습니다.

1. **Workspace - MyDesk - 02_InstanceRoom - GameSetting - TeamStatusData**를 선택합니다,
2. 변경하고자 하는 팀의 **Scale** 값을 변경합니다. Jump을 추가로 변경해 캐릭터의 점프 탄성을 변경할 수 있습니다. ![SCALE](https://mod-file.dn.nexoncdn.co.kr/bbs/1702034269711ea3ecf72ae954d5d804d5b87df71c6d7.png)

#### 캐릭터 중력 변경하기

DataSet에 새로운 값을 추가하고, **InGameManager** `PlayerSetting()`함수의 코드를 변경해 플레이어에게 중력을 부여할 수 있습니다.

1. **Workspace - MyDesk - 02_InstanceRoom - GameSetting - TeamStatusData**를 선택합니다.
2. 새로운 행에 **Gravity**를 추가합니다. ![GRAVITY](https://mod-file.dn.nexoncdn.co.kr/bbs/17020342901120a226f57d7f94cb3ba50c6556e0ca32f.png) | Status | TeamA(1) | TeamB(2) |
| --- | --- | --- | | Gravity | 0.8 | 1.3 |
3. **Workspace - MyDesk - 02_InstanceRoom - 003_InGame - InGameCompo - InGameManager**를 선택해 엽니다.
4. `PlayerSetting()` 함수의 `local teamAjump = tonumber(teamStatusData:FindRow("Status", "Jump"):GetItem("TeamA(1)"))` 바로 아래에 Gravity 값이 적용되도록 아래와 같이 작성합니다.```
local teamAGravity = tonumber(teamStatusData:FindRow("Status", "Gravity"):GetItem("TeamA(1)"))
```
5. TeamB에도 중력값이 적용되어야 하므로 아래와 같이 작성합니다.```
local teamBGravity = tonumber(teamStatusData:FindRow("Status", "Gravity"):GetItem("TeamB(2)"))
```
6. **Workspace - MyDesk - 00_Player - 01_Player_Component - PlayerInGameStatus** 컴포넌트에 새로운 함수 `ChangeGravitySet()` 함수를 추가합니다. number 타입의 매개변수 **amount**를 추가하고 아래와 같이 작성합니다.```
[client]
void ChangeGravitySet (number amount)
{
    self.Entity.RigidbodyComponent.Gravity = amount
}
```
7. **InGameManager** 컴포넌트의 `PlayerSetting()` 함수 `player.MovementComponent.JumpForce = teamAjump` 아래에 다음과 같이 입력합니다.```
player.PlayerInGameStatus:ChangeGravitySet(teamAGravity)
```
8. TeamB에도 중력을 적용해야하므로 `player.MovementComponent.JumpForce = teamBjump`아래에 다음과 같이 입력합니다.```
player.PlayerInGameStatus:ChangeGravitySet(teamBGravity)
```

# 이모티콘 추가

1. **Workspace - MyDesk - 00-Player - 03_Player_Emoticon - EmoticonData**를 선택합니다.
2. 새로운 행을 추가하고, 키 값과 데이터를 입력합니다. | Key | RUID | Scale | PivotY | Explain |
| --- | --- | --- | --- | --- | | Alpha6 | c62a931bade449f0a6487e5bb2160469 | 1 | 1.2 | Slime |
3. **Preset List - Monster** 중 하나의 프리셋 RUID를 입력합니다.

# 맵 만들기

#### 맵 생성, 바운드 지정

1. 게임을 실행하는 맵은 Instance Map이므로, `MapComponent`의 `InstanceMap`을 활성화해야 합니다. ![INSTANCEMAP](https://mod-file.dn.nexoncdn.co.kr/bbs/1702034473605b61243e921a1491f82f209e23ad151bc.png)
2. MapComponent의 UseCustomBound 프로퍼티를 편집합니다. 맵의 특정 영역만 사용할 수 있도록 한정합니다. ![CUSTOMBOUND](https://mod-file.dn.nexoncdn.co.kr/bbs/17020344485213310bbd9b8594f40b3b34bfba4152dbe.png)
  > **Tip.** `Tap` 키를 눌러 맵의 좌표를 확인할 수 있습니다.

#### 모델 배치

1. **Workspace - MyDesk - 02_InstanceRoom - 003_InGame - InGameObj**의 3가지 모델을 배치합니다.
  - ASpawnLocation: A 팀 멤버가 소환 될 위치로 지정합니다.
  - BSpawnLocation: B팀이 소환될 위치로 지정합니다.
  - Target: 메워야하는 구멍 엔티티입니다. 게임을 하는 인원에 맞는 수가 소환되어야 하므로. MatchTeamData의 EnableTargetNum행의 가장 큰 수만큼 배치해야합니다.
2. 새로 만든 맵으로 바로 이동하고 싶을 경우 `LobbyMatchManager`컴포넌트의 `LaunchRoom()` 함수 내용을 수정합니다. 2.2. 랜덤 맵 지정 주석 부분의 `local randomMapName = mapData(_UtilLogic:RandomIntegerRanger(1,mapCount):GetItem("MapName"))` 아래에 이동할 맵을 지정해 입력합니다. `LaunchRoom()`에는 2개의 2.2 랜덤 맵 지정 주석이 있습니다. 두 부분을 모두 수정해야 합니다.```
randomMapName = "003_InGame_003"
```

Update 2025-11-17 PM 08:15


# 장애물 만들기

# 장애물 및 충돌 구현

장애물 엔티티를 만들어 충돌체를 추가해봅시다. 충돌체까지 구현한 엔티티는 모델로 만들어 추후 월드에 동적으로 불러옵니다.

#### 장애물 엔티티 만들기

1. 새로운 EmptyEntity를 생성하고 이름을 **Model_Obstacle**로 변경합니다.
2. Model_Obstacle에 **TransformComponent**를 추가합니다.
3. 새로운 **Top, Bottom** 엔티티를 생성하고, **Model_Obstacle의 자식 엔티티**로 만듭니다. 부모-자식 관계로 만들어 더욱 관리가 용이합니다. ![model_Obstacle](https://mod-file.dn.nexoncdn.co.kr/bbs/17067536195231a919e3f9fca42ceaff3c2366a26707e.png)
4. Top, Bottom 엔티티에 **TransformComponent, SpriteRendererComponent**를 추가합니다.
5. 두 엔티티에 SpriteRendererComponent의 **SpriteRUID**에 RUID를 입력합니다.
  - RUID: 8290994289524b3eb5f760c839e66121
6. Top 엔티티의 **FlipY**값을 변경해 두 장애물을 상하로 배치합니다. ![Obstacle_Entity](https://mod-file.dn.nexoncdn.co.kr/bbs/17071165519473b7ece1269b94dd1866002aa8efa4e63.png)
  > **Tip.** TransformComponent의 Scale 값을 조정해 장애물 크기를 키울 수 있습니다.

#### 장애물 충돌 판정 만들기

1. **Top, Bottom** 엔티티에 **TriggerComponent**를 추가합니다.
2. ColliderType을 **Polygon**으로 변경하고, 충돌 영역을 스프라이트에 맞게 조정합니다. ![PolygonPoints](https://mod-file.dn.nexoncdn.co.kr/bbs/170321219966855437ce191d6470a980968d8306aa6d7.png)

#### 플레이어 충돌 판정 만들기

플레이어와 장애물이 부딫히기 위해서는 DefaultPlayer도 충돌체가 필요합니다.

1. DefaultPlayer에 **TriggerComponent**를 추가하고, ColliderType을 **Circle**로 변경합니다.
2. 스프라이트 크기에 맞게 **ColliderRadius, ColliderOffset**을 조정합니다.
  - ColliderRadius: 0.265
  - ColliderOffset: X 0.1 , Y 0.445![CircleCollider](https://mod-file.dn.nexoncdn.co.kr/bbs/1703213748330c86431a5087d409c9fce0f0f55f6193a.png)
3. 새로운 **ObstacleComponent**를 생성하고, **Model_Obstacle** 엔티티에 추가합니다.
4. 새로운 **top, bottom** 프로퍼티를 추가합니다.```
Property:
[None]
Entity top = nil
[None]
Entity bottom = nil
```
5. `OnBeginPlay()` 함수를 추가합니다. 게임을 시작할 때 `GetChildByName()` 함수를 활용해 Top, Bottom 엔티티를 찾습니다.```
Function:
[client only]
void OnBeginPlay()
{
    self.top = self.Entity:GetChildByName("Top")
    self.bottom = self.Entity:GetChildByName("Bottom")
}
```
6. 콘텍스트 메뉴를 눌러 **Create Model From Entity**를 눌러 만든 엔티티를 모델화합니다.

# 장애물 불러오기

게임이 실행될 때 만든 Model_Obstacle를 5개 소환하도록 만들어 봅시다.

1. 새로운 **GameLogic**을 생성합니다.
2. 새로운 table 타입의 **obstacles** 프로퍼티를 생성합니다.```
Property:
[None]
table obstacles = {}
```
3. `OnBeginPlay()` 와 `Init()` 함수를 추가합니다. `SpawnService:SpawnByModelId()`를 활용해 장애물을 불러올 수 있도록 아래와 같이 작성합니다.```
Method:
[client only]
void OnBeginPlay()
{
    self:Init()
}

[client only]
void Init()
{
    -- 장애물 스폰 간격
    local intervalX = 4.5


    -- 5개를 소환하도록 obstacles 테이블에 값을 추가합니다.
    for i = 1,5 do
        local entity = _SpawnService:SpawnByModelId(_EntryService:GetModelIdByName("Model_Obstacle"),"obstacle",Vector3(i*intervalX,0,0),_UserService.LocalPlayer.CurrentMap)

        table.insert(self.obstacles, entity)
    end
}
```
4. 시작을 눌러 장애물이 일정한 간격으로 5개가 소환되었는지 확인합니다. ![Obstacle5](https://mod-file.dn.nexoncdn.co.kr/bbs/1703149484170498ee418e7b540899f2ec1d21a2dea16.png)

#### 장애물 스폰 방식 변경

게임에 필요한 장애물을 모두 배치하거나, 한 번에 불러오는 방식은 성능에 부하를 줄 수 있습니다. 일정 개수의 엔티티를 만들어 다시 사용하는 것이 성능 향상에 도움이 됩니다. 5개의 장애물을 재활용해봅시다. 5개의 엔티티를 불러온 뒤, 가장 먼저 생성된 장애물을 맨 뒤로 가져와 생성할 수 있도록 합니다.

1. **GameLogic**에 새로운 **intervalX, startPosX, index** 프로퍼티를 생성합니다.```
Property:
[None]
number intervalX = 4.5
[None]
integer startPosX = 5
[None]
integer index = 1
```
2. **GameLogic**에 새로운 `Init()` 함수를 생성하고, 장애물이 소환될 위치를 아래와 같이 작성합니다.```
Method:
[client only]
void Init()
{
    if #self.obstacles < 1 then
        for i = 1, 5 do
            local entity = _SpawnService:SpawnByModelId(_EntryService:GetModelIdByName("Model_Obstacle"),"obstacle", Vector3(i * self.intervalX + self.startPosX, 0 ,0), _UserService.LocalPlayer.CurrentMap)

            table.insert(self.obstacles, entity)

            self.index = i
        end

    else

        local i = 1

        for _, entity in pairs(self.obstacles) do

            ---@type Entity
            local newEntity = entity

            newEntity.TransformComponent.Position = Vector3(i * self.intervalX + self.startPosX, 0, 0)
            i += 1

        end

        -- 인덱스 초기화
        self.index = 1 
    end
}
```
3. **ObstacleComponent**에 새로운 `Init()` 함수를 생성하고, 아래와 같이 작성합니다.```
[client only]
void Init(integer index)
{
    self.Entity.TransformComponent.Position = Vector3(index * _GameLogic.intervalX + _GameLogic.startPosX + 1, 0, 0)
}
```
4. 매 프레임마다 장애물이 있어야하므로 **ObstacleComponent**에 `OnUpdate()`를 추가합니다.```
[client only]
void OnUpdate(number delta)
{
    local playerPos = _UserService.LocalPlayer.TransformComponent.Position
    local position = self.Entity.TransformComponent.Position

    if playerPos.x - 5 > position.x then
       _GameLogic.index += 1
       self:Init(_GameLogic.index)       
    end
}
```

#### 장애물 조정

Model_Obstacle이 들쭉날쭉 생성되도록 만들어봅시다. 모델을 직접 Scene에 배치해 만드는 것이 아닌, UtilLogic의 `RandomIntegerRange()` 함수를 활용해 생성되는 범위를 무작위로 지정하도록 만듭니다.

1. **ObstacleComponent**의 `Init()`함수에 아래 내용을 이어 작성합니다.```
[client only]
void Init(integer index)
{
    local offset = _UtilLogic:RandomDouble() * 2 * _UtilLogic:RandomIntegerRange(-2,1)
    local space = _UtilLogic:RandomDouble() * 3 + 5

    self.top.TransformComponent.Position.y = offset + space + 1
    self.bottom.TransformComponent.Position.y = offset -3
}
```
2. **GameLogic**의 `Init()` 함수를 수정합니다. `table.insert(self.obstacles, entity)` 아래에 장애물을 소환할 수 있도록 아래 내용을 추가합니다.```
entity.ObstacleComponent:Init(i)
```
  > **Tip.** 화면에 장애물이 꽉 차지 않는다면, 장애물 크기를 키워 해결할 수 있습니다.

Update 2025-12-03 PM 03:40


# 시작, 종료 구현하기

# 죽음 판정

1. **GameLogic**의 `OnBeginPlay()` 함수를 수정합니다. 풀링된 장애물 중 마지막 인덱스의 다음 인덱스로 초기화할 수 있도록 아래와 같이 코드를 변경합니다.```
[client only]
void OnBeginPlay()
{
    for i = 1, 5 do
    	local entity = _SpawnService:SpawnByModelId(_EntryService:GetModelIdByName("Model_Obstacle"), "obstacle", Vector3(i * self.intervalX + self.startPosX, 0, 0), _UserService.LocalPlayer.CurrentMap)

    	table.insert(self.obstacles, entity)

    	entity.ObstacleComponent:Init(i)
    end

    self.index = #self.obstacles + 1
}
```
2. `Init()`함수를 변경합니다.```
local i = 1

for _, entity in pairs(self.obstacles) do
	---@type Entity
	local newEntity = entity

	newEntity.TransformComponent.Position = Vector3(i * self.intervalX + self.startPosX, 0, 0)
	newEntity.ObstacleComponent:Init(i)

	i += 1
end

self.index = #self.obstacles + 1
```
3. **ObstacleComponent**의 `OnUpdate()`함수를 수정합니다. `if playerPos.x - 5 > position.x then` 아래를 수정합니다.```
[client only]
void OnUpdate(number delta)
{
    self:Init(_GameLogic.index)
    _GameLogic.index += 1       
}
```

#### 장애물 엔티티에 죽음 판정 컴포넌트 만들기

1. Scene에 **Model_Obstacle**을 배치합니다.
2. 새로운 **TouchAndDieComponent**를 생성하고, Top, Bottom 엔티티에 추가합니다.
3. Hierarchy에서 Model_Obstacle의 콘텍스트 메뉴를 **Create Model From Entity**를 눌러 모델화 합니다.
  > **Tip.** 기존의 Model_Obstacle을 지운 뒤에 모델화를 권장합니다.
4. FishPlayerComponent에서 새로운 **isDead** 프로퍼티를 생성합니다.```
Property:
[None]
boolean isDead = false
```
5. 새로운 `Die()` 함수를 생성합니다. isDeath 프로퍼티를 활용해 움직임을 멈추고, 제자리로 돌아갈 수 있도록 아래와 같이 작성합니다.```
Method:
[client only]
void Die ()
{
    if self.isDead then
        return 
    end    

    self.isDead = true
    self.Entity.TransformComponent.Position = Vector3.zero

    wait(1)

    self.isDead = false
}
```
6. **TouchAndDieComponent**에 `TriggerEnterEvent` 핸들러 내용을 다음과 같이 수정합니다. 플레이어가 TriggerComponent와 부딪치면 `Die()` 함수를 호출합니다.```
Event Handler:
[client only] [self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{

    if TriggerBodyEntity == _UserService.LocalPlayer then
        _UserService.LocalPlayer.FishPlayerComponent:Die()
    end
}
```
7. **FishPlayerComponent**의 `Die()` 함수를 수정합니다. `wait 1` 아래에서 `Init()` 함수를 호출합니다.```
_GameLogic:Init()
```

#### 일정 구간 아래로 떨어지면 죽게 판정하기

**FishPlayerComponent**에 새로운 함수 `CheckPosY()`를 추가합니다. 엔티티의 Y 좌표가 특정 값보다 작아지면 `Die()` 함수를 호출해 게임이 끝나도록 만들어 봅시다.

```
[client only]
void CheckPosY ()
{
    if self.Entity.TransformComponent.Position.y < -15 then
        self:Die()
    end
}
```

#### 충돌 연출

장애물에 물고기가 부딫히면 카메라를 흔들어 충돌 효과를 느낄 수 있도록 만들어 봅시다. `Die()` 함수에서 `CameraComponent:ShakeCamera()`를 활용해, 장애물에 충돌할 때 카메라가 흔들리도록 만듭니다. FishPlayerComponent의 `Die()`함수에서 isDead가 true가 되면 카메라를 흔듭니다.

```
[client only]
void Die()
{
    if self.isDead then
        return
    end
    
    self.isDead = true
    -- 카메라 충돌 연출 추가
    self.Entity.CameraComponent:ShakeCamera(1,0.2)
    
    wait(1)
    
    self.isDead = false
    self.Entity.CameraComponent.Position = Vector3.zero
}
```

# 게임 시작, 종료 구현

#### 터치하면 시작하기

1. **FishPlayerComponent**에 새로운 **started** 프로퍼티를 생성합니다.```
[None]
boolean started = false
```
2. `OnUpdate` 함수 내용을 수정합니다.```
if not self.isDead and self.started then 
	self:Move(delta)
end

self:CheckPosY()
```
3. `Floating()` 함수 첫 줄에 아래 내용을 작성합니다. started가 true가 아닐 경우, true로 변경합니다.```
if not self.started then 
    self.started = true
end
```
4. `Die()` 함수를 수정해 죽은 경우 started를 false로 변경할 수 있게 합니다. `self.Entity.CameraComponent:ShakeCamera(1,0.2)` 아랫줄에 내용을 추가합니다.```
self.started = false
```

Update 2025-11-17 PM 08:15


# 점수 획득 구현하기

# 점수 획득 구현

Model_Obstacle의 부모 엔티티에 충돌체를 추가합니다. 해당 충돌체와 플레이어 엔티티가 충돌할 때 점수를 획득할 수 있도록 만들어 봅시다.

1. **Workspace - MyDesk - Model_Obstacle**에 **TriggerComponent**를 추가합니다.
2. **[Edit]** 버튼을 눌러 Collider를 추가합니다. 장애물의 중앙을 통과하도록 길게 세로로 Collider를 만듭니다.
  - ColiderType: Box
  - BoxSize: X 0.05, Y 20![Model_Obstacle_Collider](https://mod-file.dn.nexoncdn.co.kr/bbs/1707114688801b7dda01f91ba4739b2b0ba9c25873f71.png)
  > **Tip** DefaultPlayer와 ModelObstacle 모두 CollisionGroup이 **TriggerBox**로 설정되어야 합니다.
3. **ObstacleComponent**에 **TriggerEnterEvent**를 추가합니다.```
Event Handler:
[client only] [self]
HandleTriggerEnterEvent (TriggerEnterEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: TriggerComponent
    -- Space: Server, Client
    ---------------------------------------------------------

    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    ---------------------------------------------------------
    if isvalid(TriggerBodyEntity.FishPlayerComponent) then
        TriggerBodyEntity.FishPlayerComponent:AddScore()
    end   
}
```
4. **FishPlayerComponent**에 새로운 **score** 프로퍼티를 추가합니다.```
Property:
[None]
integer score = 0
```
5. `Die()` 함수에 스코어를 초기화할 수 있도록 `wait(1)` 아랫줄에서 score를 0으로 초기화합니다.```
self.score = 0
```
6. **FishPlayerComponent**에 새로운 `AddScore()` 함수를 추가하고, score를 1씩 올릴 수 있도록 작성합니다. log를 추가적으로 작성해 장애물을 통과할 때마다 로그가 정상적으로 증가하며 나오는지 확인합니다.```
[client]
void AddScore()
{
    self.score += 1
    log(self.score)
}
```

#### 점수 UI에 보여주기

1. ui에 **ScoreText** UI엔티티를 추가합니다.
2. **FishPlayerComponent**에 새로운 프로퍼티를 추가합니다.```
[None]
Entity scoreText = /ui/DefaultGroup/ScoreText
```
3. `AddScore()`에서 로그 부분을 삭제합니다. 동일한 위치에 점수가 **ScoreText**의 `TextComponent.Text`에서 보이도록 아래와 같이 작성합니다.```
self.scoreText.TextComponent.Text = string.format("점수:%d", self.score)
```
4. 장애물에 부딪혀 게임이 종료되면 점수도 초기화 해야 합니다. `Die()` 함수에도 동일한 내용을 추가합니다. `self.score = 0` 아래에 작성합니다.```
self.scoreText.TextComponent.Text = string.format("점수:%d", self.score)
```

Update 2025-11-17 PM 08:15


# 인내의 숲 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.1&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=5%EB%B6%84&amp;color=green)

# 학습 과정 소개

"인내의 숲"을 알고 계신가요? 인내의 숲을 검색해보면 많은 모험가들의 이야기를 찾아볼 수 있습니다.

인내의 숲은 점프를 이용해 발판을 넘어가며 목적지로 올라가는 게임입니다.  여러분은 인내의 숲을 보다 재미있게 만들 수 있는 색다른 아이디어를 갖고 있을지도 모릅니다.

- 기존 인내의 숲은 너무 쉬운데?
- 이렇게 하면 더 재미있을 것 같아.
- 순위를 매기면 더 재미있지 않을까?
- 서로 공격할 수 있으면 좋겠어.

메이플스토리 월드에서 이러한 아이디어를 현실화할 수 있습니다. 만약 여러분이 메이플스토리의 팬이라면 인내의 숲에서 평소 만나고 싶었던 NPC들의 이야기도 함께 풀어갈 수 있습니다. 아래처럼 말입니다. 인내의 숲을 비틀기 위해 조금 더 어두운 배경을 사용하고, 검은 마법사를 배치했습니다. 간단한 수정이지만 영상과 분위기가 달라졌습니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1636093094351729ce90b8f3e4fcfbf55585e7225343a.png)  이번 가이드에서는 인내의 숲을 만들어보고 크리에이터만의 인내의 숲을 제작하기 위한 몇 가지 시도를 해보겠습니다.

# 배경 꾸미기

먼저 배경을 변경해 봅시다.

1. **Preset List - Background**에서 인내의 숲의 배경인 **back-56**을 클릭합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1660035281651d4afe23885ac457a8587cfb3aa0a9a7b.png)
2. **Scene**에 배경이 변경된 것을 확인합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1660035424150f41f0b35ee5242e4a52737c09038c024.png) 반드시 **back-56**을 선택할 필요는 없습니다.다음과 같이 개인 취향에 따라 원하는 배경을 선택해 보세요!

# 타일 배치하기

이번에는 캐릭터가 돌아다닐 수 있는 타일을 배치해 봅시다.

1. **Preset List - Tile**에서 **tile-132**를 클릭합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1660035591312fa0c8c01d63a465ba40646a7e3479e92.png)
2. **tile-132**을 선택한 상태로 원하는 위치를 클릭해 타일을 배치합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1660035656369af8021fb31874c4aaf32c355bfdaf187.png) 이번엔 클릭한 상태로 드래그하여 타일을 배치합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/166003572116378a2cad79b154b478c81502158883c13.png)
3. **[박스 칠하기]** 버튼을 클릭합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/1683014163114615fa0accc994885b084f2da23d4a670.png) 박스 칠하기가 선택된 상태에서 드래그하면 아래와 같이 영역 표시가 되는데, 마우스에서 손을 떼면 선택된 영역에 타일이 배치됩니다.![14](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092514103e87dce09603c476b969ed783676bc8ce.png) 박스 칠하기 선택을 해제하면 다시 영역 배치가 아닌, 드래그한 위치에 타일이 하나씩 배치됩니다.  이제 다음과 같이 타일을 배치해 봅시다.![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16360925318318dbe599a114a4c829d0398538e036c5f.png)
4. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다.![17](https://mod-file.dn.nexoncdn.co.kr/bbs/163609254063076f491e458ed4541abb9c5133856e854.png) 플레이를 할 때마다 그동안 제작했던 내용들이 자동 저장됩니다.최초 저장이라면 아래와 같이 월드 이름을 입력하라는 팝업이 열립니다. 아래와 같이 원하는 이름을 입력하고 [확인] 버튼을 클릭합니다.![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16830144106040238fa3f931a465489c05ee3f01ef544.png) 의도대로 타일이 배치되었는지, 게임 진행에 막힘은 없는지 확인합니다.![19](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092557762f09ec2e7140b4919af93dfe7b8635623.png)

> 더 알아보기 메이플스토리 월드에서는 메이플스토리 맵을 쉽게 제작할 수 있도록 **메이플스토리 맵 불러오기** 기능을 제공합니다. **Window - MapleStory Map**에서 메이플스토리 맵을 불러올 수 있습니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092567082dade62280fd04202b45f97506dcc1175.png)

# 엔티티 배치하기

타일 위에 Object와 Foothold, NPC 등을 배치하여 맵을 꾸며봅시다.

#### Foothold 배치하기

**Preset List - Foothold**에서 **foothold-1972**를 선택해 배치합니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/166003635510122996c4d8e264df4ab29e67ab6d7c51b.png)

> **더 알아보기** 풋홀드 엔티티는 일반 오브젝트 엔티티와는 달리 **CustomFootholdComponent**가 적용되어있어 캐릭터가 밟고 올라설 수 있습니다. 일반 오브젝트 엔티티에도 **CustomFootholdComponent**를 추가하고 발판을 설정하면 풋홀드 엔티티로 변경할 수 있습니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092598266fcc894e2b1c74141a3af370d3e4f138f.png)  자세한 내용은 아래 가이드를 참고하세요. [발판 만들기](https://mod-developers.nexon.com/docs?postId=71)

# NPC 배치하기

1. **Preset List - NPC**에서 **npc-2412**를 선택합니다. ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/166003643766456517c0e13814359bb8310c76b4bdd1d.png) 
  > **Tip.** 만일 NPC를 찾기 힘들다면 Preset List 검색창을 이용하세요. NPC 이름(npc-2412)을 입력하면 쉽고 빠르게 원하는 NPC를 찾을 수 있습니다.
2. 원하는 위치에 NPC를 배치합니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092640320394a6606f48848b89fdbc4e5c73fc9bf.png)
3. 배치한 NPC를 선택합니다. ![28](https://mod-file.dn.nexoncdn.co.kr/bbs/163609265030356d046261b0a45baac597994993ce089.png)
4. **npc-2412**의 프로퍼티 에디터에서 **NameTagComponent - Name**에 아래와 같이 입력합니다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092667003c5aafab7a9b3460e8a77557cc744f6c4.png)
5. 입력한 Name 값이 NPC 하단 네임택에 나오는 것을 확인합니다.![31](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092675695c3ca4a8a13874812be72d58a37a3c856.png)

#### 함정 배치하기

이번에는 캐릭터를 공격하는 함정을 곳곳에 설치하여 게임의 난이도를 올려보겠습니다.

1. **Preset List - Trap**에서 원숭이 함정을 선택합니다. 이 함정은 바나나를 던져 캐릭터를 공격합니다. ![33](https://mod-file.dn.nexoncdn.co.kr/bbs/1660036660663df86ba9f25b3408e8acdc844b7156499.png) 맵 곳곳에 추가 타일과 원숭이 함정을 배치합니다. ![34](https://mod-file.dn.nexoncdn.co.kr/bbs/16360927069699f7be46079844c90bb4222bd8f12326d.png)
2. 원숭이 함정은 기본적으로 오른쪽에서 왼쪽으로 바나나를 던지기 때문에, 캐릭터의 오른쪽에 오도록 배치할 수밖에 없습니다. 바나나를 왼쪽에서 오른쪽으로 던지도록 수정해 봅시다.원숭이 함정을 다음과 같이 왼쪽에 배치합니다. ![35](https://mod-file.dn.nexoncdn.co.kr/bbs/16360927154443da0f74814694fbe8430d837cccbaf50.png)  원숭이 함정을 선택하고 **프로퍼티 에디터 - SpriteRendererComponent - FlipX**의 체크박스를 클릭하여 ![Editbox_Check](https://mod-file.dn.nexoncdn.co.kr/bbs/16346176407708cb3de01eaaf48a68ab2dd6fe1b1183f.png) 체크 상태로 만들어 줍니다. ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092723032f4b70f1a759b4d81b958170c2e19ebe6.png)  Scene에서 원숭이 함정의 방향이 왼쪽에서 오른쪽으로 변경된 것을 확인합니다. ![37](https://mod-file.dn.nexoncdn.co.kr/bbs/163609273198592ca59a84fd14d34a230b9809ff33904.png)

> **더 알아보기** 만일 원숭이가 던진 바나나에 캐릭터가 닿았을 때 피격되도록 하려면, 다음 가이드를 참고하여 구현해 보세요. [공격과 피격](https://mod-developers.nexon.com/docs?postId=206)

# 게임 시작 위치 설정

게임이 시작될 때 캐릭터 위치를 설정해보겠습니다. 현재는 플레이를 시작할 때 캐릭터가 맵 중간에 스폰됩니다. 시작 위치를 설정하여 왼쪽 아래 위치에서 캐릭터가 스폰되도록 하겠습니다. ![38](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092751698f23e24cabeff4901b01875e8bab3ee4f.png)

1. **Preset List - Special**을 선택합니다. ![39](https://mod-file.dn.nexoncdn.co.kr/bbs/1660037369729769a1e38f0b1472ebab082fd8f63d2c1.png)
2. **SpawnLocation**을 선택하고 하단 타일 좌측에 아래와 같이 배치합니다. ![40](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092769152e641a8b479b7486f8cfd2e5cf503b3d4.png)
3. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다.시작할 때 캐릭터가 **SpawnLocation**이 배치된 위치에서 스폰됩니다. ![41](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092778305c9d93c08fdfc40f39d9f519d96b418f8.png)

# 캐릭터 속성 설정

캐릭터의 점프력이 커지면 더 높이 뛸 수 있습니다. 또한 이동 속도가 빨라지면 점프 거리가 길어지고 조작 난이도가 높아집니다. 캐릭터의 이동 속도와 점프력을 수정하여 게임 난이도에 변화를 주겠습니다.

1. **Workspace - DefaultPlayer**를 선택합니다. ![42](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092791473d2f4ef1b25264e33aa03736e143f829d.png)
2. **프로퍼티 에디터 - MovementComponent**에서 **InputSpeed, JumpForce**를 확인합니다. ![43](https://mod-file.dn.nexoncdn.co.kr/bbs/1636092799102b630e690bb184702bbc1fd2028b8360e.png) **InputSpeed**는 캐릭터의 이동 속도에, **JumpForce**는 캐릭터의 점프력에 영향을 주는 프로퍼티입니다.해당 프로퍼티의 값을 다음과 같이 변경합니다. ![44](https://mod-file.dn.nexoncdn.co.kr/bbs/16360928082385428e930a6e649779bdbd54fd5c28aaf.png)  ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png) **[시작]** 버튼을 누른 뒤 테스트해 봅시다.캐릭터의 이동 속도와 점프력이 바뀐 것을 확인합니다.캐릭터의 변경된 속성값으로 인해 플레이가 막히는 구간이 없는지도 꼼꼼히 확인합니다.

# 출시

제작한 게임을 출시하여 다른 유저들과 함께 플레이해 볼 수 있습니다.

1. **File - Release**를 선택합니다. ![45](https://mod-file.dn.nexoncdn.co.kr/bbs/16838873916111a64161531c14b74a2b5fdb0bd0a08ba.png)
2. **Release** 창에서 출시할 게임의 정보, 섬네일 이미지를 올릴 수 있습니다.게임에 참여 가능한 인원과 공개 여부, 플레이 가능 기기, 섬네일을 설정하고 설명을 기재하여 게임의 정보를 효과적으로 전달합니다. 마지막으로 제목을 검토한 후 **[출시]** 버튼을 누릅니다. ![46](https://mod-file.dn.nexoncdn.co.kr/bbs/1683888033467905a1a800346441aae8bc7e0a0e842de.png)
3. 출시한 게임은 **플레이 - 나의 제작 월드**에서 확인할 수 있습니다. ![47](https://mod-file.dn.nexoncdn.co.kr/bbs/16838886901806941aba3fb1b4c6ba38a24e8da0db388.png)

Update 2025-11-17 PM 08:15


# NPC 대화창 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정에서는 NPC들의 대화를 표현하기 위한 대화창을 제작해볼 것입니다. UI 편집기를 이용해 대화창을 구성하고 데이터 테이블에 데이터를 세팅 후 스크립트를 이용해 호출할 것입니다.

과정의 진행 순서는 다음과 같습니다.

1. UI 디자인
2. 데이터 테이블 추가
3. 스크립트 제작

제작 예시는 다음과 같습니다. ![example](https://mod-file.dn.nexoncdn.co.kr/bbs/165690897977350020568198c48719639694105dfebca.gif)

# UI 디자인

1. ![Tool_UI](https://mod-file.dn.nexoncdn.co.kr/bbs/163453120840744616a62243642e889159a68a78a56c2.png)UI 편집기 버튼을 클릭합니다.  ![01](https://mod-file.dn.nexoncdn.co.kr/bbs/1660788007767080808545143493cb100805a6b9a61c2.png)
2. UI 디자인을 진행할 새로운 **UIGroup**을 추가합니다. UIGroup을 추가한 적이 없다면 UIGroup이 추가됩니다. ![02](https://mod-file.dn.nexoncdn.co.kr/bbs/1637231482321b6a1c3aa189b489cb747a38976838514.png)
3. **UIGroup**의 프로퍼티 에디터에서 **DefaultShow 값을 true**로 변경합니다. ![03](https://mod-file.dn.nexoncdn.co.kr/bbs/1659506015421476d2911ed06452493719b1af0dfceb8.png)
4. 생성한 UIGroup에 ![Ui_Image](https://mod-file.dn.nexoncdn.co.kr/bbs/16345251504813fd79a27d20049e9ac1e72847ba736fd.png) 이미지 엔티티를 추가합니다.  ![04](https://mod-file.dn.nexoncdn.co.kr/bbs/1660788197640318f22d7b5134e31a667acb83318a7f6.png)
5. 추가한 이미지 엔티티를 선택하고 이름을 **TalkPanel**로 변경합니다.  ![05](https://mod-file.dn.nexoncdn.co.kr/bbs/1659506127922faec4b37f0a24ccabbe88d817d365bbc.png)
6. **TalkPanel**의 Anchor Presets을 **Bottom, Center**로 설정합니다.  ![06](https://mod-file.dn.nexoncdn.co.kr/bbs/163723199675809230c8976c94d44b278c796374982b1.png)
7. **TalkPanel**의 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 0 | | PosY | 150 | | Width | 1600 | | Height | 200 | | SpriteGUIRendererComponent | Color | RGB 0, 0, 0 <br> A 60 <br> 검은색, 투명도 60% |
8. 새로운 이미지 엔티티를 추가하고 이름을 **Portrait**로 변경합니다.![TabWorkspace](https://mod-file.dn.nexoncdn.co.kr/bbs/1634524705528846307a3a2ea422d817319d54a31b94c.png) **Hierarchy**에서 **Portrait**를 **TalkPanel**로 드래그하여 **TalkPanel 자식**으로 설정합니다.  ![08](https://mod-file.dn.nexoncdn.co.kr/bbs/1659505222470e81a04d47eb54c02b4b3f5f731209a0b.png)
9. **Portrait**의 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -600 | | PosY | 220 | | Width | 250 | | Height | 250 | | SpriteGUIRendererComponent | Color | RGB 255, 255, 255 <br> A 255 <br> 흰색, 투명도 100% | 결과물은 다음과 같습니다. ![9-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637296984764488870270fa0441e8ecb2ae066c401e3.png)
10. 새로운 텍스트 엔티티를 추가합니다. 추가한 텍스트 엔티티를 클릭하고 이름을 **Name**으로 변경합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/163729705658874b1b29f49f449059271ceffda3c02c3.png)
11. **Name** 엔티티를 **TalkPanel**로 드래그하여 **TalkPanel**의 자식으로 설정합니다.
12. **Name** 엔티티의 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -600 | | PosY | 110 | | Width | 300 | | Height | 100 | | SpriteGUIRendererComponent | Color | RGB 255, 255, 255 <br> A 0 <br> 흰색, 투명도 0% | | TextComponent | FontColor | RGB 255, 255, 255 <br> A 100 <br> 흰색, 투명도 100% | | FontSize | 36 | | OutlineColor | RGB 0, 0, 0 <br> A 100 <br> 검은색, 투명도 100% | | UseOutLine | true | 결과물은 다음과 같습니다. ![12-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163729711384407c9884921b44d4ab670c0e8f2407286.png)
13. **Name** 엔티티의 콘텍스트 메뉴에서 **Duplicate**를 클릭하여 복제합니다. 복제한 엔티티의 이름을 **Text**로 변경합니다.
14. **Text** 엔티티의 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 0 | | PosY | 0 | | Width | 1550 | | Height | 150 | | TextComponent | Alignment | UpperLeft | 결과물은 다음과 같습니다. ![14-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16372973124240a1115e177034fcb9f90e436392ba93c.png)
15. 앞서 제작한 **TalkPanel** 엔티티를 선택하고 **Enable 체크 해제**하여 보이지 않는 상태로 변경합니다.

# 데이터 테이블 추가

1. 새로운 데이터를 추가합니다. 데이터의 이름을 **NPCTalk**으로 변경합니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/163723344112648f1cde6a18545029a10e3a23634e26e.png)
2. 2개의 컬럼을 추가하고 각 컬럼 이름으로 **name, portrait, text** 를 입력합니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/16372334787405ab202b8fd8f4b0398139e4c51bb652a.png)
3. 사용하고 싶은 이름이나 텍스트, RUID를 사용하여 대사를 구성합니다. 예시의 경우 다음과 같은 값을 사용했습니다. | name | portrait | text |
| --- | --- | --- | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 내가 이 역할을 맡게 될 줄이야. | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 어...어서오시죠. 이곳은 대화 템플릿 예제를 위해 만들어진 세계입니다. | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 여러분은 이러한 형태로 원하는 스토리를 풀어나갈 수 있습니다. | | 루시드 | f80b400198bc40dd947d7eb0c5935491 | 하하, 안내역이 멋지군요, 윌. 거울 세계의 지배자라는 이명이 아주 잘 어울려요. | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 어쩔 수 없지요. 이곳에서 우리의 운명은 모두 MOD 크리에이터의 손에 달려있으니까요. | | 윌 | 8263388ee54a4a90a0bf5ef8991eb623 | 꿈속에서 밖에 바램을 이룰 수 없는 당신에게는 더할 나위 없이 좋은 세계일지도. | | 루시드 | dcbd5c0508b4471a836a806245dc7a3f | 흥... | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 이러한 형태로 원하는 스토리를 만들어나갈 수 있습니다. | | 윌 | 641962d7a2db445c9f1c58cfbec790a3 | 당신이 거울 세계보다 나은 세계를 만들어낼 수 있을지, 흥미롭게 지켜보도록 하죠. | 실제 입력창 예시입니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/16372941763835abff5e2f5dd4f33b4890252f0fb063a.png)

# 스크립트 추가

스크립트에서 구현해야 할 주요 항목은 다음과 같습니다.

- 특정 키를 입력하면 대화창이 출력됩니다.
- 키를 입력할 때 마다 데이터의 내용이 대화창에 갱신됩니다.
- 더 이상 사용할 데이터가 없으면 대화창을 닫습니다.

먼저 키 입력을 체크하여 대화창이 출력되도록 하겠습니다.

1. 새로운 스크립트 컴포넌트를 추가합니다. 컴포넌트 이름을 **NPCTalk**로 변경합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/16372943757898ccda6030c2a4c6da35f6549be0e91e6.png)
2. **Workspace**에서 **NPCTalk** 스크립트를 열고, Entity Event Handler에 **KeyDownEvent**를 추가하고 아래 내용을 입력합니다.```
local key = event.key
--------------------------------------------------------
if key == KeyboardKey.Z then
    self:ShowNextText()
end
```
3. 현재 `ShowNextText()` 함수가 없어 에러가 출력됩니다.`ShowNextText()` 함수와 log를 추가하고, 정상적으로 호출되는지 테스트합니다.```
log("Z key Down")
``` 결과는 다음과 같습니다.![18](https://mod-file.dn.nexoncdn.co.kr/bbs/16372341515894403c1232ac5431f97f98239a6f5cf76.png)
4. ![TabWorkspace](https://mod-file.dn.nexoncdn.co.kr/bbs/1634524705528846307a3a2ea422d817319d54a31b94c.png)**Hierarchy에서 ![workspace_world](https://mod-file.dn.nexoncdn.co.kr/bbs/1634520188174b448bb50e5c64320bb3c882a5b438d6d.png) World - ![icon_asset](https://mod-file.dn.nexoncdn.co.kr/bbs/163451962580666b43144ad504f8e9e4a7cc01771207a.png) common**를 클릭하고 **Add Component**를 클릭하여 앞서 제작한 스크립트 컴포넌트 **NPCTalk**를 추가합니다.  ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16595058192181c0194d1789c49c89a3f6f1057333367.png)
5. 플레이를 하고 Z키를 눌러 로그 창에**Z Key Down**이 정상 출력되는지 확인합니다.  ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16372343956955ec785c4f783489fb11dded9ac234f9d.png)
6. 로그가 정상 출력된다면 플레이를 종료하고 **NPCTalk** 스크립트를 다시 열고, 아래와 같이 제작에 필요한 프로퍼티를 추가합니다. | type | name | value | Sync | 설명 |
| --- | --- | --- | --- | --- | | number | count | 0 | none | 스크립트에서 참조할 데이터의 rowIndex를 결정하기 위해 사용합니다.<br>데이터를 셋팅할때 마다 값을 1씩 증가시켜 다음줄의 데이터를 참조할 수 있도록 합니다. | | any | npcTalkData | nil | none | 참조할 데이터 테이블을 할당합니다. OnBeginPlay 에서 값을 설정할 예정입니다.<br>초기값은 nil을 사용합니다. | | Entity | uiNameEntity | nil | none | Name 엔티티의 값을 수정하거나 Enable을 제어하기 위해 사용합니다. | | Entity | uiMessageEntity | nil | none | Text엔티티의 값을 수정하거나 Enable을 제어하기 위해 사용합니다. | | Entity | uiTalkPanel | nil | none | TalkPanel 엔티티의 Enable을 제어하기 위해 사용합니다. | | Entity | uiPortraitEntity | nil | none | Portrait엔티티의 값을 수정하거나 Enable을 제어하기 위해 사용합니다. |
7. **+** 버튼을 클릭하여 `OnBeginPlay()` 함수를 추가합니다. ![7-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163781675592619b16165adee45298636a2f972e97f68.png) `OnBeginPlay()` 함수 오른쪽 **[⋮] 메뉴 - Excution Space Setting**를 클릭합니다. ![7-2](https://mod-file.dn.nexoncdn.co.kr/bbs/166078883036715c2ef01a89349dd938635d783a48dda.png) **ClientOnly** 를 클릭합니다. ![7-3](https://mod-file.dn.nexoncdn.co.kr/bbs/16607891579412fbd5aa5c6c748bbb0b850ee6d2e563c.png) `OnBeginPlay()` 함수에 아래 내용을 추가합니다.```
[Client only]
void OnBeginPlay() 
{
    self.count = 1
    self.npcTalkData = _DataService:GetTable("NPCTalk")
    self.uiNameEntity = _EntityService:GetEntityByPath("/ui/UIGroup/TalkPanel/Name")
    self.uiMessageEntity = _EntityService:GetEntityByPath("/ui/UIGroup/TalkPanel/Text")
    self.uiTalkPanel = _EntityService:GetEntityByPath("/ui/UIGroup/TalkPanel")
    self.uiPortraitEntity = _EntityService:GetEntityByPath("/ui/UIGroup/TalkPanel/Portrait")
}
```
8. 앞서 추가했던 `ShowNextText()` 함수에 로그를 찍기 위한 구문을 삭제하고 아래 내용을 추가합니다.```
void ShowNextText()
{
    local isNameEnable = false
    local isPortraitEnable = false

    local message = self.npcTalkData:GetCell(self.count, "text")

    if message == nil then
        self.uiTalkPanel.Enable = false
        return
    else
        self.uiTalkPanel.Enable = true
        self.uiMessageEntity.TextComponent.Text = message
    end

    local name = self.npcTalkData:GetCell(self.count, "name")
    local portrait = self.npcTalkData:GetCell(self.count, "portrait")

    if name ~= "" then
        isNameEnable = true
        self.uiNameEntity.TextComponent.Text = name
    end

    if portrait ~= "" then
        isPortraitEnable = true
        self.uiPortraitEntity.SpriteGUIRendererComponent.ImageRUID = portrait
    end

    self.uiNameEntity.Enable = isNameEnable
    self.uiPortraitEntity.Enable = isPortraitEnable

    self.count = self.count + 1
}
````ShowNextText()` 함수의 작동 방식은 다음과 같습니다.  이름과 포트레이트의 활성화 여부를 결정하기 위해 **로컬 변수 isNameEnable, isPortraitEnable를 선언 후 기본값을 false로 초기화**합니다.  데이터에서 `GetCell()` 함수를 이용해 self.count 줄의 'text' 컬럼에 해당하는 값을 가져와 로컬 변수인 message에 할당합니다. 만약 text 값을 가져오지 못했을 경우 nil이 반환되며, 텍스트 창 동작을 진행할 수 없는 상태로 판단하고 대화창을 닫고 `ShowNextText()`의 작동을 종료합니다. 이후 데이터에서 name과 portrait 값을 가져옵니다.  이 값은 존재하지 않더라도 대화창의 진행에 영향을 주지 않습니다. 포트레이트나 이름 없이 본문에만 텍스트가 사용될 수도 있기 때문입니다. 빈 셀의 경우 nil이 아닌 빈 문자열이 할당됩니다. 값이 있다면 name의 경우 Name 엔티티의 Text를, portrait의 경우 Portrait 엔티티의 ImageRUID에 값을 할당하고 해당 엔티티의 활성화 여부를 결정할 로컬변수에 true를 할당합니다. 이후 Name 엔티티와 Portrait 엔티티의 Enable에 앞서 선언했던 로컬변수의 값을 할당하고 count 프로퍼티의 값을 1 증가 시켜 다음 데이터 호출 시 다음 줄의 값을 가져올 수 있도록 합니다.
9. 결과물을 저장하고 플레이를 해봅니다. Z키를 누를 때마다 대화창의 정보가 변경되며 대화의 진행이 가능합니다. 모든 대화가 출력되면 대화창은 종료됩니다.  결과는 아래와 같습니다. ![9-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637299865370cc7610a0411f41a78b3f6873f67b770a.png)

Update 2025-11-17 PM 08:15


# 물체의 이동 Ⅰ

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

용감한 시그너스 기사단 소속 아잘린이 먼저 고통의 미궁으로 출발한 나이트워커 부대에 합류할 수 있도록 택시를 불러봅시다. 부른 택시가 아잘린을 지나치지 않고 아잘린 앞에서 멈춰서 아잘린이 탑승할 수 있도록 만들어야 합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1747902531299ee5bec9350ac458d9f255a76eba57191.gif)

# StaticNPC 모델 수정하기

StaticNPC 모델에서 RigidbodyComponent를 제거합니다. StaticNPC에는 RigidbodyComponent와 TransformComponent가 모두 포함되어 있습니다. 둘 중 하나를 지우지 않으면 Position 값을 변경했을 때 두 값이 충돌해 원하는 방식으로 움직이지 않을 수 있기 때문입니다.

1. **WorkSpace - NativeModel - StaticNPC**를 선택합니다.
2. 프로퍼티 에디터에서 `RigidbodyComponent`의 콘텍스트 메뉴를 누르고 **Remove Component**를 선택합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/174790275979588a9e7fb27374ba083dfe66aa85f8f4c.png)

# 택시와 아잘린 배치

타일을 먼저 배치하고 왼쪽에는 택시를, 오른쪽에는 아잘린을 배치해봅시다.

![2](https://mod-file.dn.nexoncdn.co.kr/bbs/174790263914923ddf9288460433e9ba2857f9be5736d.png)

1. **Preset List - NPC**에서 **npc-3539**를 검색합니다. 택시를 맵 왼쪽에 배치합니다.
2. `SpriteRendererComponent`의 **FlipX** 값을 **True**로 변경합니다.
3. 엔티티의 이름을 **Taxi**로 변경합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1747906441205a91842e506844436baf2fb7b232b02e7.png)
4. **Preset List - NPC**에서 **npc-5537**을 검색해 맵 오른쪽에 배치합니다.
5. 엔티티 이름을 **Azallin**로 변경합니다.

> **Tip.** 엔티티의 이름을 변경하면 보다 쉽게 식별하고, 스크립트에서 간결한 경로로 엔티티를 호출할 수 있습니다.

# 택시 이동시키기

택시를 이동시키기 위해서는 `TransformComponent`의 **Position** 값을 변경해야 합니다. 맵에 배치되는 모든 엔티티는 위치 정보를 가지고 있습니다. 이 위치 정보는 TransformComponent에서 Position x, y, z 값으로 표현됩니다. 오른쪽으로 이동시키기 위해서는 x 값이 커지도록 만들어야 합니다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1747902531299ee5bec9350ac458d9f255a76eba57191.gif)

1. **![workspace](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tab/icon_workspace.png)Workspace - ![MyDesk](https://mod-file.dn.nexoncdn.co.kr/storage/icons/workspace/icon_user_folder_no.png) MyDesk - Create Scripts - Create Component**를 선택해 새로운 스크립트 컴포넌트를 생성합니다. 컴포넌트 이름을 **TaxiComponent**로 변경합니다.
2. 맵에 배치된 **Taxi** 엔티티를 선택하고, 프로퍼티 창에서 **TaxiComponent**를 추가합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1747906917428bf8e9ca2f016463ca3ca1f839b59d363.png)
3. 새로운 프로퍼티를 추가하고, 이름을 **TaxiTransform**으로 변경합니다. 타입을 **Component**로 변경합니다.```
Property:
[Sync]
Component TaxiTransform = nill
```
4. **Method**에서 `OnBeginPlay()` 함수를 추가합니다, 스크립트가 작동하는 시점에 가장 먼저 1회 호출되는 함수입니다.```
[server only]
void OnBeginPlay()
{
    local taxi = self.Entity
    self.TaxiTransform = taxi.TransformComponent
}
```
5. `OnUpdate()` 함수를 추가합니다. 택시의 `Position`이 **0.02**씩 움직이도록 아래와 같이 작성합니다.```
[server only]
void OnUpdate()
{
    local pos = self.TaxiTransform.Position
    pos.x = pos.x + 0.02
    self.TaxiTransform.Position = pos
}
```

> **더 알아보기.** `Position` 대신`Translate()`함수를 사용해 택시를 이동시킬 수도 있습니다. `self.TaxiTransform:Translate(0.02, 0)` 와 같은 방식으로 사용합니다.

1. 택시가 이동하는지 확인합니다.

# 택시 멈추기

만든 택시는 멈추지 않고 계속 이동하고 있습니다. 택시는 아잘린이 서 있는 곳에서 멈춰야 하므로, 아잘린의 위치 정보를 이용해야 합니다. 택시가 이동하다 아잘린과의 거리가 가까워지면, 멈추도록 조건을 추가해봅시다.

1. **Taxi**컴포넌트에 새로운 **AzallinTransform** 프로퍼티를 추가하고, 타입을 **Component**로 변경합니다.```
Property:
[Sync]
Component AzallinTransform = nil
```
2. `OnBeginPlay()` 함수에 아래 내용을 이어서 작성합니다. 아잘린 엔티티를 엔티티 경로로 가져와, 위치 정보를 활용할 수 있게 합니다.```
[server only]
void OnBeginPlay()
{ 
    local azallin = _EntityService:GetEntityByPath("/maps/map01/Azallin") 
    self.AzallinTransform = azallin.TransformComponent
}
```
3. `OnUpdate()` 함수를 아래와 같이 수정합니다. 이동하던 택시가 아잘린의 위치에 가까워지면, 멈추게 됩니다.```
[server only]
void OnUpdate() 
{
    local pos = self.TaxiTransform.Position 
    local targetPos = self.AzallinTransform.Position 

    if pos.x < targetPos.x then
        pos.x = pos.x + 0.02 
        self.TaxiTransform.Position = pos 
    end
}
```
4. 택시가 아잘린 앞에서 멈추는지 확인합니다.

Update 2025-11-17 PM 08:15


# 물체의 이동 Ⅱ

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 가이드는 [물체의 이동 Ⅰ](/docs?postId=123)을 따라 만든 월드에서 이어서 제작해야 정상적으로 동작합니다. 택시가 아잘린을 태우러 가야하는데 원숭이가 길을 가로 막고 있습니다. `TransformComponent`의 `Translate`를 이용하여 택시를 이동시키고 `RigidbodyComponent`의 `Translate` 함수를 사용하여 원숭이를 밀어내봅시다.

![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/17479080177867bce6cbfb0bd4a4d9233d6f9f549cc6d.gif)

# 원숭이 배치

1. **Preset List - Monster**에서 **monster-1415**를 찾아 맵에 배치합니다.
2. 엔티티 이름을 **Monkey**로 변경합니다. ![[object Object]](https://mod-file.dn.nexoncdn.co.kr/bbs/1747967206328c03a4eb0cf424e2ca5471b700991cefa.png)

# 원숭이 밀어내기

RigidbodyComponent를 활용해 질주하는 택시가 원숭이를 밀어낼 수 있도록 만들어 봅시다. 원숭이를 밀어내기 위해서는 원숭이가 택시 위치를 확인하고, 택시가 원숭이게 근접하면 원숭이의 RigidbodyComponent에 힘을 주도록 만들어봅시다.

1. **Workspace - MyDesk - Create Scripts - Create Component**을 선택해 새 스크립트 컴포넌트를 추가하고 이름을 **Monkey**로 변경합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16354916990243da854927fa84124a5c9b80e0f2aa9d3.png)
2. **Monkey** 엔티티에 **Monkey 컴포넌트**를 추가합니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1659681951398202605997c4d41c7aca3d4776d71e806.png)
3. **Monkey** 컴포넌트에 아래 4개의 프로퍼티를 추가합니다.
  - **MonkeyTransform**: 원숭이의 Transform 컴포넌트의 참조 값을 할당
  - **TaxiTransform**: 택시의 Transform 컴포넌트의 참조 값을 할당
  - **MonkeyRigidbody**: 원숭이의 Rigidbody 컴포넌트의 참조 값을 할당
  - **IsHit**: 원숭이에게 택시가 접근하면 Rigidbody에 원숭이에게 힘을 가하고, 한 번만 힘을 가하도록 처리```
Property:
Component MonkeyTransform = nil    
Component TaxiTransform = nil
Component MonkeyRigidbody = nil 
boolean IsHit = false
```
4. `OnBeginPlay()` 함수를 추가하고 아래와 같이 스크립트를 작성합니다.```
Method:
OnBeginPlay()
{
    local taxi = _EntityService:GetEntityByPath("/maps/map01/Taxi")
    local monkey = self.Entity

    self.TaxiTransform = taxi.TransformComponent
    self.MonkeyTransform = monkey.TransformComponent
    self.MonkeyRigidbody = monkey.RigidbodyComponent
}
```
5. `OnUpdate` 함수를 추가하고 아래와 같이 작성합니다.
  - 프로퍼티 **isHit**의 기본값이 **false**인 경우 이동하는 택시와 원숭이의 거리를 확인합니다.
  - 만약 monkeyPos의 x 값에서 0.8만큼 뺀 값보다 taxiPos의 x 값이 크면, 원숭이의 TransformComponent이 `(8,8)`만큼의 힘을 받아 원숭이를 밀어냅니다.
  - 원숭이가 힘을 받아 밀려나면, **isHit** 값을 **true**로 변경해 반복적으로 밀어낼 수 없도록 제한합니다.```
OnUpdate()
{
    if self.IsHit == false then
        local taxiPos = self.TaxiTransform.Position
        local monkeyPos = self.MonkeyTransform.Position
        if taxiPos.x > monkeyPos.x -0.8 then
            self.MonkeyRigidbody:SetForce(Vector2(8,8))
            self.IsHit = true
        end
    end
}
```

Update 2025-11-17 PM 08:15


# Maple GYM 만들기 Ⅰ

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

이번 과정은 함께 메이플 GYM을 만들어보겠습니다. 메이플 GYM은 운동하며 근육을 키우는 간단한 게임입니다. 공격하면 운동 효과로 힘이 증가하고 몸의 크기가 힘의 수치만큼 증가합니다. 카라반 피난처에 배치한 엘윈에게 다가가면 힘을 돈으로 바꿀 수 있습니다. 획득한 돈으로 운동 기술을 증가시키거나 누적할 수 있는 최대 운동량을 증가시켜 몸짱이 되는 것이 이번 게임의 목표입니다.  플레이 영상은 다음과 같습니다.

일반적인 횡스크롤 액션 게임처럼 위아래로 걸어 다닐 수 있습니다. 다른 유저와 함께 플레이할 때 더 큰 몸집으로 자신을 뽐낼 수 있습니다. 이번 과정을 통해 스크립트를 이용한 전반적인 게임 제작의 흐름을 체험해보시기를 바랍니다.  1편에서는 다음 기능을 구현합니다.

- 기본 맵 제작
- 공격 시 힘이 증가
- 힘이 증가함에 따라 몸의 크기가 증가
- 증가한 몸의 크기를 UI로 확인
- 증가한 힘을 판매하여 게임 머니를 획득

# #1. 기본 맵 제작

1. "새로 만들기"로 게임을 생성합니다.![2](https://mod-file.dn.nexoncdn.co.kr/bbs/163521088774495a7e443f33246b9a1be3a7972b60c70.png)게임이 생성되면 아래 과정을 진행합니다.
2. 메이커 상단 Window 메뉴에서 'MapleStory Map' 메뉴를 클릭합니다.![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16352108965824ed0df1a6a6d4737829ddb3326a29660.png)
3. 팝업된 메이플스토리 맵의 검색창에 '카라반 피난처'를 입력합니다.![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16352132983010a42ba2048a04811866aa2cd6848f082.png)카라반 피난처를 선택한 후 '맵 불러오기' 버튼을 클릭합니다.
4. 맵을 불러오게 되면 저장하는 과정을 진행합니다. 게임의 이름을 자유롭게 입력해주세요.![5](https://mod-file.dn.nexoncdn.co.kr/bbs/1635213318018ea417c794897423daaa1ade29b923244.png)아름다운 카라반 피난처가 만들어졌지만 현재 버전에서는 조금 손을 봐야 합니다. 빨간색으로 표시해놓은 NPC들이나 포탈의 배치 등이 깔끔하지 않습니다. 따라서 해당 요소들을 삭제합니다. 아래와 같은 형태로 수정했습니다.![6](https://mod-file.dn.nexoncdn.co.kr/bbs/163521333466752cfbc210c5d47c2aee8f4be26ad06a8.png)

# #2. 쿼터뷰 형태로 이동할 수 있도록 처리하기

1. 시작 버튼을 클릭하여 플레이를 해보겠습니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/16352109729188dc724cfb00846a4af5d0fef455c4f19.png)  플레이어는 카라반 피난처를 돌아다닐 수 있지만 상/하로 이동은 안 됩니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/163521098405539f2ea666f8c433aa2a57960b23c65c4.png)  플레이를 종료 후 상/하 이동이 가능하도록 수정해보겠습니다.
2. 우측 상단의 워크스페이스에서 'DefaultPlayer'를 클릭합니다. 프로퍼티 창에서 Player의 프로퍼티가 출력됩니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/163581573692942c05fb7ab2c450f9e85d6732f24c2fb.png)
3. ![player](https://mod-file.dn.nexoncdn.co.kr/bbs/1636357430620486e701f5b2d4d1599e7c72705e23f50.png)DefaultPlayer의 RigidBody의 컴포넌트에서 IsQuarterViewMove 값을 체크하고 QuarterViewAccelerationX, QuarterViewAccelerationY 값을 각 3씩 입력합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/1637560421500cbfac5af72444a4a8d134ded5cad8565.png)  다시 플레이를 해봅니다. 이제 상/하로 자유로운 이동이 가능합니다. (중력으로부터 자유로워졌습니다) ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/16352133521507dee5b69b4574275aa0f83b117b57fdf.png)  하지만 캐릭터가 이동할 수 있는 영역은 통제가 되지 않는 상태입니다. 아래 이미지와 지면으로 되어 있는 영역만 이동하는 것이 자연스러울 것입니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/163521337800221cc64f569ab415d98799b8ab5d9005f.png)  캐릭터가 일정 거리 이상을 올라가거나 내려가지 못하도록 스크립트를 이용하여 처리해보겠습니다.
4. 워크스페이스에서 새로운 스크립트 컴포넌트를 추가합니다. ![12-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635815747247c4aad51c0ce34d7aaec022ed80e29014.png)  컴포넌트의 이름은 "PlayerController"로 입력하고, "PlayerController" 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/16358158244946509c1f100be48dcb4ac99f48525d17a.png)
5. 아래와 같이 프로퍼티를 추가합니다. ![13-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163521107362304aadbb7903e43b69de83faa5d41e7a8.png)
6. OnBeginPlay 함수를 추가하고 코드를 다음과 같이 작성해 줍니다.```
--void OnBeginPlay()
self.Transform = self.Entity.TransformComponent
self.Movement = self.Entity.MovementComponent
```
7. 이어서 OnUpdate 함수를 추가하고 코드를 다음과 같이 작성합니다.```
--void OnUpdate (number delta)
self:MoveArea()
```먼저 OnBeginPlay 함수와 OnUpdate 함수는 실행 공간을 비활성화하였습니다. 이의 경우 서버와 클라이언트 양쪽에서 호출할 수 있습니다. ![14](https://mod-file.dn.nexoncdn.co.kr/bbs/16607943872494ea521f5da494263a53aa610fd1c9e36.png) ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/166079440286612038bd1f15a43269c6296dc06c354cb.png)
8. 새 함수를 추가하고 이름을 MoveArea로 지어줍니다. 실행 공간을 client only로 설정하고 코드를 다음과 같이 작성합니다.```
--void MoveArea() [client only] 
local pos = self.Transform.Position
if pos.y > -1.23 then
    self.Movement:SetPosition(Vector2(pos.x, -1.23))
elseif pos.y < -2.6 then
    self.Movement:SetPosition(Vector2(pos.x, -2.6))
end
```OnUpdate 함수에서 호출하는 MoveArea 함수의 실행 공간은 Client로 설정했습니다. 프레임마다 위치를 체크하고 보정하는데 이를 서버에서 처리하면 조금 튀어 보일 수 있습니다. 좌/우는 별다른 처리를 하지 않았지만 이미 로드한 맵에서 풋홀드가 좌우 폭을 결정하고 있기 때문에 자연스럽게 이동이 제한됩니다. 지금까지 작성한 스크립트는 다음과 같습니다. ![16-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211203200d239d44e4daa4629a26aa6e855e4f577.png)작성한 PlayerController 컴포넌트를 플레이어에게 추가하겠습니다.워크스페이스에서 DefaultPlayer를 우클릭 후 Add Component를 클릭하여 PlayerController 컴포넌트를 추가합니다.![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1635815833027bde0364ea3a24a7693531f00a1402a27.png)
9. 플레이를 해봅니다. 캐릭터가 이동할 수 있는 범위 내에서 움직임을 확인할 수 있습니다.

# #3. 스탯 컴포넌트 추가

Maple Gym에는 힘과 최대 누적 가능한 힘, 게임머니, 등급 등 다양한 스탯 정보가 필요합니다. 이 정보를 저장하고 관리할 컴포넌트를 추가하겠습니다.

1. 새로운 스크립트 컴포넌트를 추가합니다. 컴포넌트의 이름을 "PlayerStats"라고 입력합니다. ![18](https://mod-file.dn.nexoncdn.co.kr/bbs/1635815846858e64d7594543d4b058f4d3a3d1c9b1b3e.png)
2. PlayerStats에 아래 프로퍼티를 추가합니다. | 타입 | 이름 | 초깃값 | 설명 |
| --- | --- | --- | --- | | number | CurrentPow | 0 | 현재 캐릭터의 힘 | | number | MaxPow | 15 | 최대 누적 가능한 힘 | | number | CurrentMoney | 0 | 현재 캐릭터의 돈 | | number | CurrentSkillGrade | 1 | 현재 캐릭터의 운동 등급 | | number | CurrentDnaGrade | 1 | 현재 캐릭터의 DNA 등급 | | number | WeightBonus | 1 | 운동 시 증가하는 힘의 양 |결과물은 다음과 같습니다. ![19-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163521124487163ebbadaf21c4c14b37f25a1d0f0aea2.png)

# #4. 운동 구현

Ctrl키를 눌러 캐릭터가 공격할 때마다 힘이 증가해야 합니다. 따라서 Attack 을 체크하고 힘이 증가하도록 스크립트를 구현해보겠습니다.

1. 앞서 추가했던 PlayerController 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16358158582908e359d1dfe0b4963ba0102b75b4b3221.png)
2. 앞서 만든 PlayerStats 컴포넌트를 PlayerController 컴포넌트가 참고할 수 있도록 합니다. PlayerController 내 Component 타입의 Stats 프로퍼티를 추가합니다. ![21-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16352112763652d192865582344028234f5125b6cc06a.png)
3. 이미 추가되어 있던 OnBeginPlay 함수를 아래와 같이 PlayerStats를 받아오는 코드를 추가해줍니다.```
--void OnBeginPlay()
--기존 코드
self.Transform = self.Entity.TransformComponent
self.Movement = self.Entity.MovementComponent

--추가된 코드
self.Stats = self.Entity.PlayerStats
``` 이제 PlayerController 에서 stats 프로퍼티를 통해 PlayerStats에 접근할 수 있습니다.
4. 스크립트 에디터에서 Entity Event Handler 메뉴 우측의 + 버튼을 클릭한 후 검색창에서 "PlayerActionEvent"을 검색하여 PlayerActionEvent에 대한 핸들러를 추가합니다.PlayerActionEvent 캐릭터의 상태 변화가 발생하는 이벤트를 감지하여 호출하는 함수입니다.![22](https://mod-file.dn.nexoncdn.co.kr/bbs/163581586894899c2f58b2cf441559d275c1d30047cb2.png)
5. HandlePlayerActionEvent 함수 내용을 아래와 같이 수정합니다.```
--HandlePlayerActionEvent(PlayerActionEvent event) [self]
-- Parameters
local ActionName = event.ActionName
local PlayerEntity = event.PlayerEntity
--------------------------------------------------------
if ActionName == "Attack" then
    self:WorkOut()
end
```Attack 상태가 감지될 때마다 운동이 되었음을 확인하고 WorkOut 함수를 호출합니다. 이제 WorkOut 함수를 추가하겠습니다.
6. PlayerController 컴포넌트 내 새로운 함수를 추가합니다. 함수의 이름은 WorkOut을 사용합니다. HandlePlayerActionEvent은 클라이언트와 서버 공간 모두 호출됨으로 WorkOut 함수도 실행 공간을 설정하지 않으면 클라이언트/서버 양쪽에서 호출됩니다. 서버 공간에서만 호출될 수 있도록 실행 공간을 ServerOnly로 설정합니다.
7. WorkOut 함수 내 아래 내용을 추가합니다.```
--void WorkOut() [server only]
local calePow = self.Stats.CurrentPow + self.Stats.WeightBonus

if calePow > self.Stats.MaxPow then
    calePow = self.Stats.MaxPow
end

self.Stats:SetPow(calePow)
``` WorkOut 함수가 호출되면 PlayerStats 컴포넌트에 있는 현재 힘과 운동 시 증가하는 힘을 더합니다. if 문에서는 MaxPow를 초과하는 힘이 누적될 때 더 이상 힘이 누적되지 않도록 합니다. 누적될 힘이 결정됐다면 PlayerStats 컴포넌트의 SetPow 함수에 결정된 힘 값을 넘겨줍니다.  지금까지 작성된 PlayerController 컴포넌트는 다음과 같습니다. ![24-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635213980013464eb64389aa42aebd31ec5bbfafcae2.png)
8. PlayerStats 컴포넌트로 이동합니다. PlayerStats 컴포넌트에서 새로운 함수를 추가합니다. 함수의 이름은 "SetPow"를 사용하며 매개 변수를 추가하여 number 타입의 currentPow 값을 전달받을 수 있도록 합니다. ![25](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211377864f84bc461a73d4630b614a2066a5e5fcb.png)  SetPow 함수는 PlayerController 컴포넌트의 WorkOut 함수에서 호출됩니다. WorkOut 함수가 Server에서 실행되는 함수이므로 별다른 설정이 없으면 SetPow 함수도 서버에서 실행됩니다. 하지만 SetPow 함수 호출 시 UI를 갱신하는 함수도 함께 호출할 것임으로 클라이언트/서버 양측의 공간에서 실행할 수 있도록 실행 공간을 Multicast로 설정합니다.  SetPow 함수 내 아래 내용을 추가 합니다.```
--void SetPow(number currentPow) [multicast]
self.CurrentPow = currentPow
log(self.CurrentPow)
```전달받은 인수를 CurrentPow 프로퍼티에 할당하고 현재 CurrentPow 값을 로그로 찍습니다. 지금까지 작성된 PlayerStats 컴포넌트는 다음과 같습니다. ![27-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211771145b12492e4032f4e6abb83265ac04fc45d.png)
9. 이제 제작한 PlayerStats 컴포넌트와 PlayerController 컴포넌트를 플레이어에게 추가하겠습니다. 워크스페이스에서 'DefaultPlayer'를 우클릭 후 'Add Component'를 선택합니다. 제작한 PlayerStats 컴포넌트와 PlayerController 컴포넌트를 검색하여 각각 추가합니다. ![29](https://mod-file.dn.nexoncdn.co.kr/bbs/163581587905950dd938b2b8a4ababa6bb9f62c4d819f.png)  이제 플레이를 해봅시다. Ctrl 키를 눌러 Attack을 할 때 마다 클라이언트, 서버 각각 힘 수치가 누적됨을 확인할 수 있습니다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/16352118271803971a92709f64c119b21457b0955af21.png)

# #5. 커지는 몸 사이즈 구현하기

증가하는 힘의 크기만큼 캐릭터의 사이즈가 증가하는 기능을 구현하겠습니다. PlayerController 컴포넌트 내 새로운 함수를 추가합니다. 함수의 이름은 SizeSet 이라고 입력합니다. ![31](https://mod-file.dn.nexoncdn.co.kr/bbs/163521184304293281b5711994b1a92ea556698a95249.png)

1. 함수에 아래 내용을 추가합니다.```
--void SizeSet()
local size = 1 + (0.1 * self.Stats.CurrentPow)
self.Transform.Scale = Vector3(size, size, 1)
``` 힘 1당 Scale를 0.1씩 증가시킵니다.
2. 기존 WorkOut 함수에 SizeSet 함수를 호출하도록 수정합니다.```
--void WorkOut() [server only]
-- 기존 문구
local calePow = self.Stats.CurrentPow + self.Stats.WeightBonus

if calePow > self.Stats.MaxPow then
    calePow = self.Stats.MaxPow
end

self.Stats:SetPow(calePow)

-- 추가
self:SizeSet()
```PlayerController에 추가된 코드는 다음과 같습니다. ![32-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163521186588796423f5143ad4e48b706751674180efa.png)
3. Scene로 돌아가 플레이를 해보겠습니다. 이제 공격할 때마다 캐릭터의 사이즈가 커지는 것을 확인할 수 있습니다. ![33](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211887402e75dad0c44ad45e1bd94ea51826e0cdf.png)

# #6. 힘&게임머니 UI 추가

힘이 증가하면 몸의 크기도 함께 커짐으로 힘이 증가함을 체감할 수 있게 됐습니다. 더 명확하게 힘 수치를 표기하는 UI를 추가하도록 하겠습니다.

1. Scene 창을 클릭하고 메이커 상단의 'UI' 버튼을 눌러 UI 편집기로 이동합니다. ![34](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211899345d1a5602a16e94398b6b9c7ab362f63ab.png)
2. 'DefaultGroup'이 선택된 상태에서 'Text' 버튼을 클릭해 화면에 텍스트를 추가합니다. ![35](https://mod-file.dn.nexoncdn.co.kr/bbs/163521350241816d8e9b0114d4b2f94d347d3cd1577ee.png)  배치한 텍스트를 클릭하고 엔티티의 이름을 "UIPower" 로 변경합니다. ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/163521192682993cc1035d0904860a7bfee2f8f4f0d8a.png) | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransform | PosX | -700 | | PosY | 65 | | Width | 300 | | Height | 100 | | SpriteGUIRendererComponent | ImageRUID | 0c80d52cfe5626b4ca1bb5067c0c6938 | | Color | R 255, G 255, B 255, A 100%<br> 흰색, 투명 해제 | | Text | FontSize | 30 |
  > **Tip**. 이 프로퍼티는 UI 엔티티를 할당해 사용하므로 Sync 값이 None이어야 정상 동작합니다. UI 작업을 진행하는 김에 게임머니가 표시될 UI도 같이 추가하겠습니다.위 프로퍼티 수정으로 완성된 UI를 클릭하고 마우스 오른쪽 버튼을 클릭하면 "Duplicate" 메뉴를 확인할 수 있습니다. ![37](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211942934c9c755880b9e4916a45837a048cc2def.png)  해당 버튼을 클릭합니다.
3. 만들었던 Text UI가 복제되었음을 확인할 수 있습니다. 복제된 UI를 클릭하고 이름을 "UIMoney" 라고 입력합니다. ![38](https://mod-file.dn.nexoncdn.co.kr/bbs/1635211967579c040e2f4ccaf40e28b72fdfa8d4aefc1.png)  "UIMoney"의 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransform | PoxX | -700 | | PosY | -40 | 아래와 같이 작업이 완료됐습니다. ![Tool_UI](https://mod-file.dn.nexoncdn.co.kr/bbs/163453120840744616a62243642e889159a68a78a56c2.png)버튼을 클릭하여 UI 에디터를 종료합니다. ![39](https://mod-file.dn.nexoncdn.co.kr/bbs/163521198367072bb7f3213004a7dabdcea2d27373534.png)

# #7. 캐릭터의 스탯과 UI 연결

전반적인 UI 관리를 위한 UIManager 스크립트 컴포넌트를 추가하고 PlayerStats 컴포넌트에서 힘을 증가시킬 때마다 UIManager의 힘 UI 셋팅 함수를 호출하는 방식으로 구현하겠습니다.

1. 새로운 스크립트 컴포넌트를 추가합니다. 컴포넌트의 이름은 "UIManager"를 사용합니다. ![40](https://mod-file.dn.nexoncdn.co.kr/bbs/1635815893958818b3d248f8f4b0f865635a668a69329.png)
2. UIManager 컴포넌트를 클릭하여 스크립트 에디터를 활성화합니다. 스크립트 에디터에서 아래와 같이 3개의 프로퍼티를 추가합니다. | 타입 | 이름 | 동기화(Sync) | 초깃값 | 설명 |
| --- | --- | --- | --- | --- | | Component | UiPowerText | None | nil | UIPower 엔티티의 Text 컴포넌트 정보 | | Component | UiMoneyText | None | nil | UIMoney 엔티티의 Text 컴포넌트 정보 | | Component | Stats | None | nil | 캐릭터의 PlayerStats 컴포넌트 정보 |결과는 다음과 같습니다. ![41-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16376317734643c515797da414eb3b7bfb815697ba6b6.png)
3. OnBeginPlay 함수를 추가합니다. OnBeginPlay 함수는 UI 관련 정보를 참조할 것임으로 실행 공간을 ClientOnly로 설정합니다.  함수 내 아래 내용을 추가합니다.```
--void OnBeginPlay() [client only]
self.UiPowerText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIPower").TextComponent
self.UiMoneyText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIMoney").TextComponent
self.Stats = _UserService.LocalPlayer.PlayerStats

self:UISetPower()
self:UISetMoney()
```참조할 텍스트 엔티티와 플레이어 엔티티 경로를 찾아 각각의 프로퍼티에 할당합니다. 이후 시작 시점에서 힘과 돈의 UI를 셋팅하는 UISetPower, UISetMoney 함수를 각각 호출하고 있습니다.  이제 UISetPower, UISetMoney 함수를 각각 추가하겠습니다.
4. 새로운 함수를 추가합니다. 함수의 이름은 UISetPower를 사용하며 아래 내용을 추가합니다.```
--void UISetPower()
self.UiPowerText.Text = "힘 : "..math.floor(self.Stats.CurrentPow).." / "..math.floor(self.Stats.MaxPow)
```위 작업이 마무리되면 새로운 함수를 하나 더 추가합니다. 함수의 이름은 UISetMoney를 사용하며 아래 내용을 추가합니다.```
--void UISetMoney()
self.UiMoneyText.Text = "돈 : "..math.floor(self.Stats.CurrentMoney)
```힘과 돈의 갱신이 필요한 경우 이 함수를 각각 호출하면 됩니다. UIManager 에서 진행할 작업은 마무리됐습니다. ![43-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1639026923307523bbb3954c843cd8f2405dce8337d79.png)
5. PlayerStats 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다.아래 프로퍼티를 추가합니다. | 타입 | 이름 | 초깃값 | 설명 |
| --- | --- | --- | --- | | component | UiManager | nil | UiManager 컴포넌트 정보 |
  > **Tip**. 이 프로퍼티는 UI 엔티티를 할당해 사용하므로 Sync 값이 None이어야 정상 동작합니다. 이후 OnBeginPlay 함수를 추가합니다. 함수의 실행 공간을 "사용하지 않음"으로 설정하여 클라이언트/서버 모두 사용할 수 있도록 합니다.  OnBeginPlay 함수에 아래 내용을 추가합니다.```
--void OnBeginPlay()
if self:IsClient() then
    self.UiManager = _EntityService:GetEntityByPath("/ui/DefaultGroup").UIManager  
end
``` RenewPow, RenewMoney 함수를 각각 추가합니다. 두 함수의 실행 공간은 ClientOnly로 설정합니다. 그리고 RenewPow 함수에 아래 내용을 추가합니다.```
--void RenewPow() [client only]
self.UiManager:UISetPower()
``` RenewMoney 함수에 아래 내용을 추가합니다.```
--void RenewMoney() [client only]
self.UiManager:UISetMoney()
``` 힘이 증가할 때마다 힘 UI를 갱신해야 하므로 PlayerStats 컴포넌트의 SetPow 함수에 아래 내용을 추가합니다.```
--void SetPow() [multicast]
self.CurrentPow = currentPow
log(self.CurrentPow)
--추가
self:RenewPow()
``` 지금까지 수정된 PlayerStats 스크립트는 다음과 같습니다. ![46-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637564692911a2caecc0dbcf46f799065bec5e397ea0.png)
6. 완성한 UIManager 컴포넌트를 엔티티에 추가하겠습니다. Hierarchy에서 ui → DefaultGroup 을 선택합니다. DefaultGroup을 우클릭한 후 Add Component를 선택해 UIManager 컴포넌트를 추가합니다. ![48](https://mod-file.dn.nexoncdn.co.kr/bbs/1659507470565386887b295a74624aee895d62cf09d99.png)  이제 Scene으로 돌아가 플레이를 합니다. 공격을 해보면 힘이 증가함을 확인할 수 있습니다.

# #8. 힘 판매하기

힘을 Gold로 환전하는 기능을 제작하겠습니다. 환전을 담당하고 있는 NPC를 배치하고 NPC에게 다가가면 힘을 0으로 셋팅하고 감소한 힘 수치만큼 돈을 증가시킵니다.

1. 먼저 판매를 담당할 NPC를 배치하겠습니다. 평소에 사용하고 싶던 NPC를 배치합니다. 작성자의 경우 엘윈을 사용했습니다. ![49](https://mod-file.dn.nexoncdn.co.kr/bbs/16352135741317282882d53464f6c9292abc653bfe289.png)  배치한 NPC의 이름을 SellNPC 로 변경합니다. ![50](https://mod-file.dn.nexoncdn.co.kr/bbs/16352127476757bd4ffc4d7084241a62dab1f468764ab.png)  만약 배치한 NPC가 맵에 배치된 오브젝트들의 뒤에 배치된다면 해당 NPC의 SpriteRenderer 컴포넌트의 Sorting Layer 값을 Layer7로 변경해주세요.
2. 쿼터뷰 형 게임에서는 엔티티들이 리지드바디의 영향을 받아 낙하해서는 안 됩니다. 따라서 배치한 NPC를 클릭하고 RigidBody 컴포넌트의 Gravity 프로퍼티의 값을 0으로 변경합니다. ![51](https://mod-file.dn.nexoncdn.co.kr/bbs/1637631798121a1ebc47ce547412b80da9a9e02bf3fcb.png)  만약 배치한 엔티티가 NPC가 아닌 오브젝트 등의 엔티티로 RigidBody가 없다면 이 항목을 진행하지 않아도 괜찮습니다.
3. 다가온 NPC를 감지하고 함수를 실행하는 컴포넌트를 제작하겠습니다. 워크스페이스의 Component 에서 TriggerComponent 를 찾아 마우스 오른 클릭을 한 후, Extend를 클릭하여 TriggerComponent 를 확장합니다. 확장된 컴포넌트의 이름을 "NPCSellPow"라고 입력 후 Enter키를 누릅니다. ![52](https://mod-file.dn.nexoncdn.co.kr/bbs/16607937626065c5ee04d632841ed829bb4e2e14e9fe3.png)
4. 생성한 NPCSellPow 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. TriggerComponent를 확장한 컴포넌트이므로 함수 생성 시 리스트에서 확장 함수인 "OnEnterTriggerBody"를 확인할 수 있습니다. 이를 클릭하여 추가합니다. ![53](https://mod-file.dn.nexoncdn.co.kr/bbs/1635815943418a9a064434b80473389a959a69704e51a.png)  OnEnterTriggerBody는 Trigger 영역 안에 TriggerBody를 가진 엔티티가 들어오면 호출하는 함수입니다.이 함수를 이용해 NPC에게 다가온 유저를 체크할 수 있습니다. 함수에 아래 내용을 추가합니다. 기존 "__base:OnEnterTriggerBody(enterEvent)" 구문은 삭제합니다.```
--override void OnEnterTriggerBody(TriggerEnterEvent enterEvent)
local entity = enterEvent.TriggerBodyEntity
log(entity)
if entity.PlayerStats == nil then
    return
else
    entity.PlayerStats:SellPow()
end
```작업 결과는 다음과 같습니다. ![54-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635212799021abde75fe54814351a3e1eb96b4e991dd.png)  triggerBody에 들어온 대상이 플레이어라는 보장이 없습니다. 따라서 PlayerStats 컴포넌트를 가졌는지 체크함을 통해 식별합니다. 만약 플레이어가 맞는다면 들어온 PlayerStats 컴포넌트의 SellPow 함수를 호출합니다.
5. 기존 작성했던 PlayerStats 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. 새로운 함수를 추가하고 함수 이름을 "SellPow" 로 입력합니다. 아래 내용을 SellPow 함수에 추가합니다.```
--void SellPow() 
self:SetMoney(self.CurrentMoney + self.CurrentPow)
self:SetPow(0)
self.Entity:GetComponent("PlayerController"):SizeSet()
```현재 힘을 돈에 더하고 힘을 0으로 초기화 합니다. 이후 힘이 줄었음으로 캐릭터의 사이즈 셋팅을 다시 합니다. 이제 위 함수에서 호출한 SetMoney 함수를 추가합니다. number 타입의 매개 변수를 추가하고 이름을 currentMoney로 지어줍니다. 추가한 함수에 number 타입의 currentMoney 매개 변수를 추가하고 함수의 실행 공간을 Multicast 로 설정합니다.  아래 내용을 SetMoney 함수에 추가합니다.```
--void SetMoney(number currentMoney) [multicast]
self.CurrentMoney = currentMoney
self:RenewMoney()
```전달받은 값을 현재 돈에 셋팅하고 앞서 만들어놓은 UI 갱신 함수를 호출합니다. 현재까지 작성된 PlayerStats 컴포넌트는 다음과 같습니다. ![56-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637570606890eb27d56adfcd4bb7bf85fa2e484da16b.png)  힘을 상점에 판매하는 과정의 스크립트 제작은 마무리됐습니다.
6. 제작한 NPCSellPow 컴포넌트를 배치한 NPC에 추가합니다. 플레이를 해봅니다.공격해서 힘을 누적하고 NPC에 다가가면 힘이 0이 되며 감소한 힘만큼 돈이 증가합니다.

Update 2025-11-17 PM 08:15


# Maple GYM 만들기 Ⅱ

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.4&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=60%EB%B6%84&amp;color=green)

# 학습 과정 소개

> Maple GYM 만들기는 아래 과정에서 이어지는 가이드입니다. [Maple GYM 만들기 (1편)](https://mod-developers.nexon.com/docs?postId=126)

지난편에서는 기본 맵의 제작과 운동 시 증가하는 힘, 증가한 힘에 따른 캐릭터/UI 변화와 힘의 판매를 구현했습니다. 이번 과정에서는 다음 기능을 구현합니다.

- 힘 판매 지역으로 이동
- 간단한 상점 UI
- 기술과 DNA 업그레이드

# #1. 힘 판매 지역으로 이동

매번 힘을 판매하기 위해 NPC에게 이동하기 번거롭습니다. NPC에게 순간 이동하는 버튼을 추가하겠습니다.

1. 메이커 좌측 상단에 UI 버튼을 클릭하여 UI 편집기를 클릭합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1657682976342e7641537e0b44db9961e5a5ce7632650.png)
2. DefaultGroup를 선택한 상태에서 버튼을 클릭하여 UI 내 버튼을 배치합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/1657683323722561138acd2044d0bba77f401a933a42f.png)
3. 배치한 버튼을 클릭하고 버튼의 이름을 ShopButton으로 변경합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/163524426112196b3d5d72d1644c7ba214b331a3482dc.png)  프로퍼티 에디터에서 Add Component를 클릭하여 TextComponent를 추가합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1635819509779d4ed9fde88eb4674aabee1e32605392e.png)  이후 각 컴포넌트별 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -770 | | PosY | -130 | | Width | 120 | | Height | 70 | | SpriteGUIRendererComponent | ImageRUID | 869b38cc8e41f9649923b8877f0f22a5 | | TextComponent | FontSize | 30 | | Text | SHOP |결과물은 아래와 같습니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16352442882368f40585300fa4380b5b23950d7b82599.png)
4. SELL 버튼도 함께 제작하겠습니다. 제작한 SHOP 버튼을 선택 후 마우스 우 클릭 합니다. 팝업 메뉴에서 Duplicate 버튼을 클릭합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/16352443038356025402f2c214c7c9528c5fdb2c0499e.png)  버튼이 복제되면 복제한 버튼의 이름을 SellButton으로 변경합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/163524431559522d53269007147ec923e89d746d40500.png)  복제한 버튼을 클릭하고 아래와 같이 프로퍼티를 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -630 | | PosY | -130 | | TextComponent | Text | SELL |결과물은 다음과 같습니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16352443271625229640eeb4f4bdbb6eb5ad31867ef4a.png)
5. SELL 버튼을 클릭 시 플레이어 캐릭터를 NPC를 배치한 위치로 이동시키면 됩니다. Workspace에서 **UIManager**를 더블클릭하여 스크립트 에디터를 엽니다. 실제 위치 이동은 PlayerController 에서 진행할 것이기 때문에 UIManager에서 PlayerController를 참조할 수 있도록 아래 프로퍼티를 추가합니다. | 타입 | 프로퍼티 | 동기화 | 초깃값 | 내용 |
| --- | --- | --- | --- | --- | | component | Controller | None | nil | PlayerController 컴포넌트를 할당합니다.<br>프로퍼티 Sync는 None으로 설정합니다. |UI작업 진행 간 버튼 엔티티의 컴포넌트를 참조하고 OnClickEvent 핸들러 연결하는 과정이 반복적으로 일어나므로 이를 위한 함수를 추가하겠습니다. UIManager 내 새로운 함수를 추가합니다. 함수의 이름은 "SetButtonHandler"를 입력하고 string 타입의 buttonPath 매개 변수를 추가합니다. ![9](https://mod-file.dn.nexoncdn.co.kr/bbs/163524434037247fe79d3f5bb4dde946227f748fc51df.png)  함수 내 아래 내용을 추가합니다.```
void SetButtonHandler(string buttonPath)
{
    local button = _EntityService:GetEntityByPath(buttonPath)
    button:ConnectEvent(ButtonClickEvent, self.OnClickButton)
}
```이제 OnBeginPlay 함수에서 추가한 SetButtonHandler 함수를 호출하도록 하겠습니다. OnBeginPlay 함수 내 아래 내용을 추가합니다.```
self.UiPowerText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIPower").TextComponent
self.UiMoneyText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIMoney").TextComponent
self.Stats = _UserService.LocalPlayer.PlayerStats

self:UISetPower()
self:UISetMoney()

--추가
local buttonPaths = {
    "/ui/DefaultGroup/ShopButton",
    "/ui/DefaultGroup/SellButton",
}

for i, path in pairs(buttonPaths) do
    self:SetButtonHandler(path)
end

local localPlayer = _UserService.LocalPlayer
self.Controller = localPlayer.PlayerController
```buttonPaths 테이블에 ButtonEntity들의 path를 입력합니다. 이후 반복문에서는 ButtonPath를 순회하며 앞서 만든 SetButtonHandler 함수를 이용해 입력한 Path의 Button 컴포넌트를 가져온 후 이벤트를 연결합니다. 앞으로 버튼이 추가될 때마다 buttonPaths 테이블에 해당 버튼의 Path를 추가해주면 됩니다.  덤으로 앞서 추가한 Controller 프로퍼티에 PlayerController 컴포넌트 정보를 할당했습니다.
6. SetButtonHandler 함수에서는 ButtonClickEvent를 체크해서 OnClickButton 함수를 호출하고 있습니다. 새로운 함수를 추가하고 이름을 OnClickButton 이라고 입력합니다. 함수에 any 타입의 event 인수를 받을 수 있도록 매개 변수를 추가합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/163524435776493b1eb9fb5b24bd093952a599ed7f477.png)  함수 내 아래 내용을 추가합니다.```
--void OnClickButton(any event)
local buttonName = event.Entity.Name

if buttonName == "ShopButton" then

elseif buttonName == "SellButton" then
    self.Controller:MoveSellPosition()
end
```전달받은 인수를 이용해 눌린 버튼 이름을 체크하고 이름에 맞춰 분기합니다. 이제 UIManager는 버튼이 눌리면 PlayerController 컴포넌트의 MoveSellPosition 함수를 호출할 것입니다.  지금까지 작성된 UIManager 컴포넌트는 다음과 같습니다. ![11-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16395312117420aea50ebdf254bb09a97dac9d395416a.png)
7. 워크스페이스에서 PlayerController 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. 새로운 함수를 추가하고 함수의 이름을 MoveSellPosition 이라고 입력합니다.  MoveSellPosition 함수 내 아래 내용을 추가합니다.```
--void MoveSellPosition()
local npcPos = _EntityService:GetEntityByPath("/maps/map01/SellNPC").TransformComponent.Position
self.Movement:SetPosition(Vector2(npcPos.x, npcPos.y))
```![12-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16352444092796739c3cec4c6404d8399226889705403.png)scene으로 돌아가 플레이를 해봅니다. SELL 버튼을 클릭하면 배치한 NPC에게 이동하는 것을 확인할 수 있습니다.

# #2. 상점과 업그레이드 UI 디자인

SHOP 버튼을 클릭하면 팝업되는 상점을 디자인해보겠습니다. 아래와 같은 구성으로 진행하려고 합니다. ![13](https://mod-file.dn.nexoncdn.co.kr/bbs/163524442387746483d763ef7443395250d7cd8e3db48.png)  디자인은 진행하시면서 취향에 맞게 변경하시면 됩니다.

1. 좌측 상단 메뉴에서 UI 버튼을 클릭하여 UI 편집 모드로 이동합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1657682976342e7641537e0b44db9961e5a5ce7632650.png)
2. 우측 하단에서 새로운 UI Group을 추가하겠습니다. UI Group 리스트에서 + 버튼을 눌러 새로운 UI Group을 추가합니다. ![15](https://mod-file.dn.nexoncdn.co.kr/bbs/1635819521289dac8a8a7fea84a7abb4bdd5f30ecc85b.png)  UIGroup이 추가되면 해당 Group을 클릭합니다. UIGroup의 UIGroupComponent의 DefaultShow 프로퍼티의 값을 true로 변경합니다. ![16](https://mod-file.dn.nexoncdn.co.kr/bbs/1637720583796bf3d7baac2c6465ead9ea17be43cdf56.png)
3. UI 배경이 될 패널을 추가하겠습니다. 이미지 버튼을 클릭하여 이미지를 배치합니다. 배치한 이미지를 클릭하고 아래와 같이 프로퍼티를 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | Width | 1200 | | Height | 700 | | SpriteGUIRendererComponent | ImageRUID | 8122dd6f67f3d9b4db8a3152172f9063 |
4. 닫기 버튼을 배치하겠습니다. 버튼을 클릭해 버튼을 배치합니다. 버튼을 클릭하고 버튼의 이름을 ShopCloseButton로 변경합니다. ![17](https://mod-file.dn.nexoncdn.co.kr/bbs/1635244963786f9add6c451134bbebd130bf08fa36d3c.png)  배치한 버튼의 프로퍼티를 아래와 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 540 | | PosY | 290 | | Width | 70 | | Height | 70 | | SpriteGUIRendererComponent | ImageRUID | c25813e3ecb203146b24f48b2bebb891 |
5. 텍스트 버튼을 클릭해 텍스트를 배치합니다. 배치한 텍스트를 클릭하고 아래와 같이 프로퍼티를 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -300 | | PosY | 200 | | Width | 350 | | Height | 100 | | TextComponent | FontColor | RGB(255,0,0 / 빨간색) | | FontSize | 60 | | OutLineColor | RGB(255,255,255 / 흰색) | | OutLineDistance X | 2 | | OutLineDistance Y | -2 | | Text | 운동 기술 | | UseOutLine | true(체크) |
6. 5항에서 배치한 텍스트를 오른쪽 클릭합니다. Duplicate 버튼을 클릭하여 복제 후 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 300 | | PosY | 200 | | Width | 350 | | Height | 100 | | TextComponent | FontColor | RGB(0,0,255 / 파란색) | | Text | DNA |
7. 텍스트 버튼을 클릭해 새로운 텍스트를 배치합니다. 이 텍스트는 운동 기술의 레벨을 표시합니다. 레벨에 따라 다른 텍스트가 표기됨으로 엔티티의 이름을 참조합니다. 따라서 엔티티의 이름을 클릭하여 SkillLevelText로 변경합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/163524499743527d6478794f34defad44ea7df016f9b2.png)  이후 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -300 | | PosY | 135 | | Width | 350 | | Height | 60 | | TextComponent | FontColor | RGB(255,255,0 / 노랑색) | | FontSize | 35 | | OutLineDistance X | 2 | | OutLineDistance Y | -2 | | Text | (기술 레벨 : 1레벨) | | UseOutLine | true(체크) |
8. 7항에서 작성한 텍스트를 마우스 우 클릭 후 팝업 메뉴에서 Duplicate를 클릭하여 복제합니다. 이 텍스트는 DNA 등급을 표시할 텍스트임으로 이름을 DnaLevelText로 변경합니다. ![20](https://mod-file.dn.nexoncdn.co.kr/bbs/16352450122335c48da47779946deb837091a9ba57a58.png)  이후 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 300 | | PosY | 135 | | TextComponent | Text | (DNA : 쿼크) |
9. 8항에서 작성한 텍스트를 마우스 우 클릭 후 팝업메뉴에서 Duplicate를 클릭하여 복제합니다. 이후 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -300 | | PosY | 80 | | TextComponent | FontColor | RGB(255,255,255 / 흰색) | | Text | 운동 시 힘 증가량 상승 |
10. 다시 9항에서 작성한 텍스트를 마우스 우 클릭 후 팝업 메뉴에서 Duplicate를 클릭하여 복제합니다. 이후 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 300 | | PosY | 80 | | TextComponent | Text | 최대 힘 누적량 상승 |
11. 이미지 버튼을 클릭하여 새로운 이미지를 추가합니다. 추가한 이미지를 클릭하고 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -300 | | PosY | -30 | | Width | 300 | | Height | 300 | | SpriteGUIRendererComponent | ImageRUID | 37d80af03df343d59b575fa37f6140a9 |다만 배치한 이미지가 정렬상의 문제로 텍스트를 가리게 되는데요. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1635245030212252b2843a55a49ff8cd9ea8d1118182c.png)  Hierarchy에서 해당 이미지를 드래그하여 렌더링 순서를 정할 수 있습니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1637800364977c7253062e7bf41ab8737dcd9e80d852e.png)
12. 이미지 버튼을 클릭하여 새로운 이미지를 추가합니다. 추가한 이미지를 클릭하고 프로퍼티를 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 300 | | PosY | -30 | | Width | 300 | | Height | 300 | | SpriteGUIRendererComponent | ImageRUID | 28eab0401d8b43a1a2865841ddad0a8f |
13. 새 버튼 엔티티를 추가합니다. 버튼 엔티티는 스크립트에서 참조해야 함으로 이름을 SkillUpButton으로 변경합니다. ![23](https://mod-file.dn.nexoncdn.co.kr/bbs/16352450546579b0410cb21c04887aa77d406781105ba.png)  추가로 프로퍼티 에디터에서 Add Component 버튼을 클릭하여 TextComponent를 추가합니다. 프로퍼티의 값을 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | -300 | | PosY | -250 | | Width | 230 | | Height | 60 | | SpriteGUIRendererComponent | ImageRUID | 869b38cc8e41f9649923b8877f0f22a5 | | TextComponent | FontColor | RGB(255,255,255 / 흰색) | | FontSize | 35 | | OutLineColor | RGB(0,0,0 / 검은색) | | OutLineDistance X | 2 | | OutLineDistance Y | -2 | | UseOutLine | true(체크) |버튼에는 업그레이드 비용이 표기될 예정입니다. 텍스트의 내용은 스크립트에서 수정할 것임으로 어떠한 내용이 들어가도 상관없습니다.
14. 13항에서 생성한 버튼 엔티티를 마우스 우 클릭 후 팝업메뉴에서 Duplicate를 클릭하여 복제합니다. 버튼 엔티티는 스크립트에서 참조해야 함으로 이름을 DnaUpButton으로 변경합니다. ![24-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637729504554e51308b651bc4869b59ee005514a1b51.png)  프로퍼티의 값을 다음과 같이 수정합니다. | 컴포넌트 | 프로퍼티 | 값 |
| --- | --- | --- | | UITransformComponent | PosX | 300 | | PosY | -250 |

UI 배치가 완료됐습니다. 이제 각각의 기능들을 스크립트를 통해 추가해보겠습니다.

# #3. 상점/닫기 버튼 연결

UI 작업 과정에서 3개의 버튼이 더 추가됐습니다. 이 버튼들의 핸들러를 연결하도록 하겠습니다.

1. UIManager 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다.
2. 새로운 프로퍼티를 추가합니다. | 타입 | 프로퍼티 이름 | 동기화 | 초깃값 | 내용 |
| --- | --- | --- | --- | --- | | Entity | ShopGroup | None | nil | UIGroup의 Entity를 할당하고 Enable 여부를 스크립트에서 제어할 예정입니다.<br>프로퍼티 Sync는 None으로 설정합니다. |
3. OnBeginPlay 함수에 buttonPaths를 정의한 부분을 살펴봅니다. ![24](https://mod-file.dn.nexoncdn.co.kr/bbs/1635245071039e81f10b5ce764b319b08a0c45701ff35.png) 이 부분에 추가한 버튼들의 Path를 넣고, 앞서 할당한 shopGroupTransform 프로퍼티에 UIGroup의 RectTransform 컴포넌트를 할당하겠습니다.```
[client only]
void OnBeginPlay()
{
    self.UiPowerText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIPower").TextComponent
    self.UiMoneyText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIMoney").TextComponent
    self.Stats = _UserService.LocalPlayer.PlayerStats

    self:UISetPower()
    self:UISetMoney()

    local buttonPaths = {
    "/ui/DefaultGroup/ShopButton",
    "/ui/DefaultGroup/SellButton",
    "/ui/UIGroup/ShopCloseButton", --추가
    "/ui/UIGroup/SkillUpButton", --추가
    "/ui/UIGroup/DnaUpButton" --추가
    }

    for i, path in pairs(buttonPaths) do
        self:SetButtonHandler(path)
    end

    local localPlayer = _UserService.LocalPlayer
    self.Controller = localPlayer.PlayerController

    self.ShopGroup= _EntityService:GetEntityByPath("/ui/UIGroup") --추가
}
```
4. UIManager의 OnClickButton 함수에 각 버튼에 대한 분기 문을 추가합니다. 기존 작성된 부분의 수정이 필요합니다.```
void OnClickButton(any event)
{
    local buttonName = event.Entity.Name

    if buttonName == "ShopButton" then
        self.ShopGroup:SetVisible(true, false)
    elseif buttonName == "SellButton" then
        self.Controller:MoveSellPosition()
    elseif buttonName == "ShopCloseButton" then --변경
        self.ShopGroup:SetVisible(false, false)
    elseif buttonName == "SkillUpButton" then -- 추가
         --self.Stats:SkillUpGrade() -- 추가
    elseif buttonName == "DnaUpButton" then -- 추가
         --self.Stats:DnaUpGrade() -- 추가
    end -- 추가
}
```![26-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635245101395612e1a88e7de4ac18f61f6589722bed0.png)

Scene으로 돌아와 플레이합니다. Shop 버튼을 누르면 상점이 팝업되는 것을 확인할 수 있습니다. 또한 상점에서 X 버튼을 클릭하면 상점이 닫힙니다. ![27](https://mod-file.dn.nexoncdn.co.kr/bbs/16377294058687a47715e9f9542ec9e9bfd016edb3b72.png)

# #4. 운동 기술과 DNA 정보 구성

운동과 DNA는 돈을 통해 업그레이드할 수 있고 증가하는 힘의 양과 누적 가능한 힘의 정보량을 늘려줍니다. 그렇다면 각각의 등급에서 증가하는 힘과 누적 가능한 힘, 필요한 금액 정보를 어디선가 가지고 있어야 합니다. 이 방법에는 다양한 방식을 사용할 수 있지만 (공식을 사용하거나, 데이터 테이블을 사용하거나, 스크립트에 정의하거나) 여기서는 스크립트에 직접 정의하겠습니다.

1. PlayerStats 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. 아래 두 개의 프로퍼티를 추가합니다. | 타입 | 프로퍼티 이름 | 초깃값 | 내용 |
| --- | --- | --- | --- | | table | SkillGradeTable | {} | 운동 스킬 관련 테이블 정보를 저장합니다. | | table | DnaGradeTable | {} | dna 관련 테이블을 저장합니다. |
2. PlayerStats 컴포넌트에 새로운 함수를 추가합니다. 함수의 이름은 SetTable을 사용합니다. SetTable 함수 내 아래 내용을 추가합니다.```
void SetTable()
{
    self.SkillGradeTable = {
        {["Cost"] = 0, ["WeightBonus"] = 1, ["GradeName"] = "1단계"},
        {["Cost"] = 15, ["WeightBonus"] = 2, ["GradeName"] = "2단계"},
        {["Cost"] = 45, ["WeightBonus"] = 3, ["GradeName"] = "3단계"},
        {["Cost"] = 90, ["WeightBonus"] = 4, ["GradeName"] = "4단계"},
        {["Cost"] = 187, ["WeightBonus"] = 5, ["GradeName"] = "5단계"},
        {["Cost"] = 315, ["WeightBonus"] = 6, ["GradeName"] = "6단계"},
        {["Cost"] = 600, ["WeightBonus"] = 7, ["GradeName"] = "7단계"},
        {["Cost"] = 1200, ["WeightBonus"] = 8, ["GradeName"] = "8단계"},
        {["Cost"] = 2150, ["WeightBonus"] = 9, ["GradeName"] = "9단계"},
        {["Cost"] = 3475, ["WeightBonus"] = 15, ["GradeName"] = "10단계"}
    }

    self.DnaGradeTable = {
        {["Cost"] = 0, ["MaxPow"] = 15, ["GradeName"] = "쿼크"},
        {["Cost"] = 15, ["MaxPow"] = 45, ["GradeName"] = "원자"},
        {["Cost"] = 45, ["MaxPow"] = 90, ["GradeName"] = "미세먼지"},
        {["Cost"] = 90, ["MaxPow"] = 187, ["GradeName"] = "지렁이"},
        {["Cost"] = 187, ["MaxPow"] = 315, ["GradeName"] = "개"},
        {["Cost"] = 315, ["MaxPow"] = 600, ["GradeName"] = "인간"},
        {["Cost"] = 600, ["MaxPow"] = 1200, ["GradeName"] = "모험가"},
        {["Cost"] = 1200, ["MaxPow"] = 2150, ["GradeName"] = "영웅"},
        {["Cost"] = 2150, ["MaxPow"] = 3475, ["GradeName"] = "대적자"},
        {["Cost"] = 3475, ["MaxPow"] = 5200, ["GradeName"] = "MVP레드"}
    }
}
```
3. PlayerStats 컴포넌트의 OnBeginPlay 함수에서 SetTable 함수를 호출하도록 합니다.```
if self:IsClient() then
    self.UiManager = _EntityService:GetEntityByPath("/ui/DefaultGroup").UIManager  
end
self:SetTable() -- 추가
```필요한 기초정보를 세팅했습니다. 다음은 SHOP 페이지에서 각각의 정보들이 대응되게 표시되도록 처리하겠습니다.

# #5. 상점 페이지에 정보 표기

상점에 표시되는 각각의 텍스트 엔티티 정보를 참조 후 플레이어 스탯 정보에 맞는 값을 세팅해보겠습니다.

1. UIManager 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다.UIManager에 아래 4개 프로퍼티를 추가합니다. 추가하는 모든 **프로퍼티 Sync는 None**입니다. | 타입 | 프로퍼티 이름 | 동기화 | 초깃값 | 내용 |
| --- | --- | --- | --- | --- | | Component | SkillLevelText | None | nil | 아래 이미지 참조 | | Component | DnaLevelText | None | nil | 아래 이미지 참조 | | Component | SkillUpButtonText | None | nil | 아래 이미지 참조 | | Component | DnaUpButtonText | None | nil | 아래 이미지 참조 |이 프로퍼티들은 아래 이미지의 엔티티의 TextComponent 정보를 가집니다. ![30](https://mod-file.dn.nexoncdn.co.kr/bbs/16352451553271c846d5cd2e84597a5363ff13e4beba4.png)
2. UIManager 컴포넌트의 OnBeginPlay 함수를 열어 다음과 같이 수정해줍니다.```
[client only]
void OnBeginPlay()
{
    self.UiPowerText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIPower").TextComponent
    self.UiMoneyText = _EntityService:GetEntityByPath("/ui/DefaultGroup/UIMoney").TextComponent
    self.Stats = _UserService.LocalPlayer.PlayerStats

    self:UISetPower()
    self:UISetMoney()

    local buttonPaths = {
        "/ui/DefaultGroup/ShopButton",
        "/ui/DefaultGroup/SellButton",
        "/ui/UIGroup/ShopCloseButton",
        "/ui/UIGroup/SkillUpButton",
        "/ui/UIGroup/DnaUpButton"
    }

    for i, path in pairs(buttonPaths) do
        self:SetButtonHandler(path)
    end

    local localPlayer = _UserService.LocalPlayer
    self.Controller = localPlayer.PlayerController

   self.ShopGroup= _EntityService:GetEntityByPath("/ui/UIGroup")

    self.SkillLevelText = _EntityService:GetEntityByPath("/ui/UIGroup/SkillLevelText").TextComponent --추가
    self.DnaLevelText = _EntityService:GetEntityByPath("/ui/UIGroup/DnaLevelText").TextComponent --추가
    self.SkillUpButtonText = _EntityService:GetEntityByPath("/ui/UIGroup/SkillUpButton").TextComponent --추가
    self.DnaUpButtonText = _EntityService:GetEntityByPath("/ui/UIGroup/DnaUpButton").TextComponent --추가

    self.ShopGroup:SetVisible(false, false) --추가
}
```![30-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1637717326151973defc1d98d41bc9a1bc4b04b6d1576.png)
3. UIManager 내 새로운 함수를 추가합니다. 함수 이름은 SetShopInfo 를 사용합니다. 함수 내 아래 내용을 추가합니다.```
void SetShopInfo()
{
    local skillGrade = math.floor(self.Stats.CurrentSkillGrade)
    local dnaGrade = math.floor(self.Stats.CurrentDnaGrade)

    self.SkillLevelText.Text = ("(기술 레벨 : "..skillGrade.."레벨)")
    self.DnaLevelText.Text = ("(DNA : "..self.Stats.DnaGradeTable[dnaGrade]["GradeName"]..")")

    local hasMoney = math.floor(self.Stats.CurrentMoney)

    local skillFontColor = nil
    local dnaFontColor = nil

    local skillButtonMessage = ""
    local dnaButtonMessage = ""

    if skillGrade >= #self.Stats.SkillGradeTable then
        skillButtonMessage= "최종 등급 달성"
        skillFontColor = Color(1,0,0,1)
    else
        local nextSkillMoney = math.floor(self.Stats.SkillGradeTable[skillGrade+1]["Cost"])
        skillButtonMessage = "필요금액 : ".. nextSkillMoney
        if hasMoney >= nextSkillMoney then
            skillFontColor = Color(1,1,1,1)
        else
            skillFontColor = Color(1,0,0,1)
        end
    end

    if dnaGrade >= #self.Stats.DnaGradeTable then
        dnaButtonMessage= "최종 등급 달성"
        dnaFontColor = Color(1,0,0,1)
    else
        local nextDnaMoney = math.floor(self.Stats.DnaGradeTable[dnaGrade+1]["Cost"])
        dnaButtonMessage = "필요금액 : ".. nextDnaMoney
        if hasMoney >= nextDnaMoney then
            dnaFontColor = Color(1,1,1,1)
        else
            dnaFontColor = Color(1,0,0,1)
        end
    end

    self.SkillUpButtonText.Text = skillButtonMessage
    self.SkillUpButtonText.FontColor = skillFontColor

    self.DnaUpButtonText.Text = dnaButtonMessage
    self.DnaUpButtonText.FontColor = dnaFontColor
}
```PlayerStats에 정의된 테이블 정보를 기반으로 현재 금액을 체크하고 상황에 맞게 글자의 색상을 변경합니다. 이 함수는 상점 정보를 호출할 때마다 호출하면 됩니다.
4. UIManager 의 OnClickButton 함수를 다음과 같이 수정합니다.```
void OnClickButton(any event)
{
    local buttonName = event.Entity.Name

    if buttonName == "ShopButton" then
        self:SetShopInfo() -- 추가
        self.ShopGroup:SetVisible(true, false)
    elseif buttonName == "SellButton" then
        self.Controller:MoveSellPosition()
        self:SetShopInfo() -- 추가
    elseif buttonName == "ShopCloseButton" then
        self.ShopGroup:SetVisible(false, false)
    elseif buttonName == "SkillUpButton" then
        --self.Stats:SkillUpGrade()
    elseif buttonName == "DnaUpButton" then
        --self.Stats:DnaUpGrade()
    end
}
```이제 Scene으로 돌아가 플레이를 해봅시다. 전반적인 구매 및 UI 갱신 등이 정상적으로 처리됩니다.

# #6. 구매 처리

실제 돈이 있는 상태에서 운동 기술과 DNA를 필요금액 버튼을 클릭했을 때 업그레이드가 되도록 처리하겠습니다.

1. 현재 UIManager에서 OnClickButton에서 SkillUpGrade 함수와 DnaUpGrade 함수를 주석 처리해놨습니다. 이 함수를 구현하고 주석을 풀면 됩니다. ![33-2](https://mod-file.dn.nexoncdn.co.kr/bbs/16576900229411c83b859e8404e3391d539f3d4b44fa6.png)
2. 워크스페이스에서 PlayerStats 컴포넌트를 더블클릭하여 스크립트 에디터를 엽니다. 새로운 함수를 추가하고 함수의 이름을 SkillUpGrade로 입력합니다. 함수 내 아래 내용을 추가합니다.```
void SkillUpGrade()
{
    if self.CurrentSkillGrade >= #self.SkillGradeTable then
        return
    end

    local nextSkillMoney = self.SkillGradeTable[self.CurrentSkillGrade+1]["Cost"]
    if  self.CurrentMoney >= nextSkillMoney then
        self:SetMoney(self.CurrentMoney - nextSkillMoney)
        self.CurrentSkillGrade = self.CurrentSkillGrade + 1
        self.WeightBonus = self.SkillGradeTable[self.CurrentSkillGrade]["WeightBonus"]
    end
    self:RenewUI()
}
```![34-1](https://mod-file.dn.nexoncdn.co.kr/bbs/1635245215063b566a0f2e5494b09b0b974815141eea8.png)운동 레벨을 증가시킨 후 해당 운동 레벨에 맞는 운동량을 세팅해주고 있습니다.  새로운 함수를 추가합니다. 함수의 이름은 DnaUpGrade를 사용합니다. 함수 내 아래 내용을 추가합니다.```
void DnaUpGrade()
{
    if self.CurrentDnaGrade >= #self.DnaGradeTable then
        return
    end
    local nextDnaMoney = self.DnaGradeTable[self.CurrentDnaGrade+1]["Cost"]
    if self.CurrentMoney >= nextDnaMoney then
        self:SetMoney(self.CurrentMoney - nextDnaMoney)
        self.CurrentDnaGrade = self.CurrentDnaGrade + 1
        self:SetMaxPow(self.DnaGradeTable[self.CurrentDnaGrade]["MaxPow"])
    end
    self:RenewUI()
}
```![35-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16352452269435022a1d1c5d04c2aad9cb953c2021d16.png)DnaUpGrade 함수도 돈을 차감하고 Dna 등급을 올려줍니다. 최대 힘은 최대 힘을 갱신하기 위한 함수를 호출해서 처리하는 데, 이는 힘 UI 갱신을 한 함수에서 같이 처리하기 위함입니다.  앞서 추가한 두 함수(SkillUpGrade , DnaUpGrade )가 서버 공간에서 실행될 수 있도록 실행공간을 server로 변경합니다. ![36](https://mod-file.dn.nexoncdn.co.kr/bbs/16607951128460126e39b95694841a47fdc7e92b6fcf0.png)
3. 각각의 업그레이드 함수는 처리가 완료되면 RenewUI 함수를 호출하여 상점 UI를 최신화합니다. 새로운 함수를 추가하고 함수의 이름을 RenewUI를 사용합니다. 함수의 내용을 아래와 같이 수정합니다.```
void RenewUI()
{
    self.UiManager:SetShopInfo()
}
```![36-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16352452528725939a9040421400b95c77e0af00f6a08.png)또한 서버 함수에서 호출될 수 있도록 실행 공간을 client로 변경합니다.
4. 이제 마지막 처리가 남았습니다. DnaUpGrade 함수에서 최대 힘을 증가시키는 함수를 호출하는데, 이 함수를 추가하겠습니다. 새로운 함수를 추가합니다. 함수의 이름을 SetMaxPow로 입력하고 number 타입의 매개 변수 maxPow를 받도록 합니다. ![38](https://mod-file.dn.nexoncdn.co.kr/bbs/1635245283834e671ad9ea141499b98ecde8a7e896a5c.png)  힘 UI 최신화도 함께 진행함으로 실행 공간을 multicast로 설정하여 두 작업을 이 함수에서 같이 처리합니다.  함수에 아래 내용을 추가합니다.```
void SetMaxPow(number maxPow)
{
    self.MaxPow = maxPow
    self:RenewPow()
}
```![40-1](https://mod-file.dn.nexoncdn.co.kr/bbs/163524531207450440ad7ccff43869d255bc253571998.png)이제 모든 작업이 마무리됐습니다. 진행 과정에 큰 문제가 없었다면 상점을 이용한 능력 업그레이드와 게임머니의 소모가 정상적으로 이루어집니다.

Update 2025-09-15 PM 04:38


# 점프대 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

점프대에 닿으면 캐릭터가 높이 솟아오르는 점프대를 만들어 봅니다. 이번 예제를 통해 확장 스크립트 작성법과 스크립트를 통해 물체와의 충돌 및 충돌 시 처리, 그리고 물체에 물리적인 힘을 가하는 방법에 대해 알아봅니다. 추가로 컴포넌트에 프로퍼티를 추가하고, 오브젝트별로 다른 프로퍼티 값을 설정하는 방법을 알아봅니다.

# 점프대 배치하기

1. **Preset List**에서 스프링 모양의 모델(object-4575)을 찾아 맵에 배치합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/165604935001714611bdebb36466091d47d17fb16a24a.png)

# TriggerComponent로 충돌 기능 활용하기

물체와 충돌했을 때 특정 처리를 하려면 충돌 감지 기능을 활용해야 합니다. 메이플스토리 월드에는 충돌했을 때 특정 액션을 발생시킬 수 있는 **TriggerComponent**를 제공하고 있습니다. **TriggerComponent**를 확장하여 **충돌 이벤트가 발생하면 캐릭터가 점프하는 기능**을 만들어봅시다.

1. **Workspace**에서 **TriggerComponent**를 검색합니다.
2. **TriggerComponent**의 콘텍스트 메뉴에서 **Extend**를 클릭합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/165604959095153cfca57050245b38749c711113ff227.png)
3. 새 스크립트 컴포넌트의 이름으로 **Spring**을 입력합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/163542033144502adadc09f744c09917af9217755b545.png)
4. **Spring** 스크립트를 더블 클릭하여 스크립트 에디터를 엽니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1635420361509dad37849139e4c5798eb5b68431f70dc.png)

# 스크립트 작성 및 엔티티에 컴포넌트 적용하기

캐릭터가 점프대에 닿으면 높이 점프시키는 기능을 스크립트로 작성합니다.

1. **Method** 옆 **[+]** 버튼을 누르고, `OnEnterTriggerBody` 함수를 추가합니다. ![[5]](https://mod-file.dn.nexoncdn.co.kr/bbs/173949930506311bf9917c12346bcb94c6a915d5244d7.png)
2. `OnEnterTriggerBody` 함수의 내용을 다음과 같이 작성합니다.```
override void OnEnterTriggerBody(TriggerEnterEvent enterEvent) 
{
    __base:OnEnterTriggerBody(enterEvent)

    --점프대와 충돌한 대상(플레이어)을 받아옵니다.
    local player = enterEvent.TriggerBodyEntity
    log(player.Name)
    --플레이어의 MovementComponent 컴포넌트를 받아옵니다. 만일 대상에 MovementComponent 없으면 함수를 끝냅니다.
    local rigidbody = player.RigidbodyComponent
    if rigidbody == nil then
    	return
    end

    --플레이어의 PlayerControllerComponent 컴포넌트를 받아옵니다. 만일 대상에 PlayerControllerComponent 없으면 함수를 끝냅니다.
    local controller = player.PlayerControllerComponent
    if controller == nil then
    	return
    end

    --캐릭터가 바라보는 방향으로 밀어줍니다. LookDirectionX가 양수라면 오른쪽, 음수라면 왼쪽입니다.
    if controller.LookDirectionX > 0 then
        rigidbody:SetForce(Vector2(10,10))    
    else
        rigidbody:SetForce(Vector2(-10,10))
    end
}
```
3. 작성한 스크립트를 저장하고, 맵에 배치했던 스프링 엔티티를 선택합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1659682364643e700e1fcbcd549539f62f219cdc00b24.png)
4. 프로퍼티 에디터 하단에 **[Add Component]** 버튼을 클릭한 후, **Spring** 컴포넌트를 추가합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1635317761426ae2b93a52a6f47cfa0fbb58e9c90c16f.png)
5. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 캐릭터가 점프대에 닿았을 때, 멀리 날아가는 것을 확인합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1656049685585a94042b540df4073af62cc5fa37abf20.png)

Update 2025-11-17 PM 08:15


# 원거리 발사체 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. **▶ 1편.** [**원거리 발사체 만들기**](/docs?postId=935) 2편. [캐릭터가 발사체로 몬스터 공격하기](/docs?postId=937)

원거리 발사체를 날려서 몬스터를 처치하는 월드를 만들어 보기 위한 첫 번째 과정입니다. 원거리 발사체 모델을 만들고 관련 스크립트 컴포넌트를 작성하는 예제를 살펴봅시다.

# 월드 템플릿

제작 편의를 위해 "기본" 템플릿으로 월드 생성하는 것을 권장합니다. ![0](https://mod-file.dn.nexoncdn.co.kr/bbs/163667952682877954e0badb445beac64d4a1155c6b8a.png)

# 발사체 모델

먼저 발사체 모델을 만들어 보겠습니다.

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Model**을 클릭해 새 모델을 만듭니다. 이름으로 **Model_Projectile_Arrow**를 입력합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/166994502327614339c1a63774655a2339847ccd8525b.png)
2. **Model_Projectile_Arrow**의 프로퍼티 에디터에서 **SpriteRendererComponent**를 추가하고 아래의 프로퍼티를 변경합니다.
  - **PlayRate : 2.5**
  - **SpriteRUID : 82013caa86844d32853f8433266ef25e**  **SpriteRUID**는 원하는 것을 사용해도 무방합니다. 본 예제에서는 화살 형태의 스프라이트를 사용했습니다. ![001](https://mod-file.dn.nexoncdn.co.kr/bbs/16702272716982b32e3b2a0b540b6befb662b8ceebdf6.gif)
3. **TransformComponent**를 추가하고 아래의 프로퍼티를 변경합니다.
  - **Scale : X = 0.3, Y = 0.3**
4. **TriggerComponent**를 추가하고 아래의 프로퍼티를 변경합니다.
  - **BoxSize : X = 2, Y = 0.3**
5. **TriggerComponent**의 **CollisionGroup** 프로퍼티에서 **[패널 열기]** 버튼을 누릅니다. **Collision Groups** 패널에서 **[Add Collision Group]** 버튼을 클릭해 **Projectile** 그룹을 추가합니다. 이후 **Matrix** 탭으로 이동해 아래 그림과 같이 설정합니다. ![2](https://mod-file.dn.nexoncdn.co.kr/bbs/166994619267247363ed2f25843fca7aef047bf291548.png)
6. **TriggerComponent**의 **CollisionGroup**을 **Projectile**로 설정합니다. ![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1670219112140feba1dbd76e54493bd2cd951c5d3755d.png)

# 발사체 스크립트 컴포넌트

발사체 스크립트 컴포넌트를 작성하고 발사체 모델에 연결해 봅시다.

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create Scripts - Create Component**를 클릭해 새 스크립트 컴포넌트를 만듭니다. 이름으로 **Projectile**를 입력합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/1669946572981601adb06667c4da180580b8863e708ca.png)
2. 발사체 모델 **Model_Projectile_Arrow**에 **Projectile** 컴포넌트를 추가합니다.
3. **Projectile** 스크립트 컴포넌트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:  
[Sync]
number DestroyAfterSec = 2 -- 발사된 시점으로부터 터질 때까지의 시간(초)
[Sync]
number Speed = 7.5 -- 발사체 속도
[Sync]
string ExplodeSpriteRUID = "47a613712de34f9ba2ea25ef40894756" -- 폭발 이펙트 RUID
[Sync]
Vector2 ExplodeEffectOffset = Vector2(0,0) -- 이펙트 오프셋 (수정이 필요한 경우에만 수정)
[Sync]
number EffectScale = 1 -- 폭발 이펙트 스케일
[None]
boolean ToLeft = false -- 발사체의 진행 방향
[None]
Entity Firer = nil -- 발사체를 발사하는 주체
```
4. 발사체는 처음에는 움직이지 않다가 일단 발사가 된 뒤부터 움직여야 합니다. 그러므로 `OnBeginPlay()` 함수를 추가한 뒤 아래와 같이 작성합니다. 실행 공간은 **사용하지 않음**으로 설정합니다.```
void OnBeginPlay()
{
    -- 발사체가 발사되기 전에는 움직이지 않도록 일단 false로 설정
    self._T.Fired = false
}
```
5. 발사체가 시간에 따라 진행 방향으로 나아가도록 처리하기 위해 `OnUpdate()` 함수를 추가합니다. 실행 공간은 **server only**로 설정합니다.```
void OnUpdate(number delta)
{
    if not self._T.Fired then
    	return
    end

    local xDelta = self.Speed * delta
    if self.ToLeft then
    	xDelta = xDelta * -1
    end 

    self.Entity.TransformComponent:Translate(xDelta, 0)
}
```
6. 발사체의 발사를 제어하는 `Fire()` 함수를 추가합니다.```
void Fire()
{
    local destroySelf = function()
    	self:Explode()
    end

    -- DestroyAfterSec 시간 이후에 destroySelf가 실행되도록 타이머 설정
    _TimerService:SetTimerOnce(destroySelf, self.DestroyAfterSec) 

    -- 왼쪽으로 발사할 때는 발사체의 스프라이트 방향 전환
    self.Entity.SpriteRendererComponent.FlipX = not self.ToLeft 

    self._T.Fired = true
}
```
7. 발사체의 공격 영역을 설정하고 폭발 이펙트를 재생하기 위해 `Explode()` 함수를 추가합니다.```
void Explode()
{
    local shape = BoxShape(Vector2.zero, Vector2.one, 0)

    -- 폭발 이펙트 sprite 사이즈를 가져와 공격 영역으로 설정
    _ResourceService:PreloadAsync({self.ExplodeSpriteRUID}, function()
    	if not isvalid(self.Firer) and not isvalid(self.Firer.PlayerAttack) then
    		return
    	end

    	local clip = _ResourceService:LoadAnimationClipAndWait(self.ExplodeSpriteRUID)
    	local firstFrameSprite = clip.Frames[1].FrameSprite
    	local firstSpriteSizeInPixel = Vector2(firstFrameSprite.Width, firstFrameSprite.Height)
    	local ppu = firstFrameSprite.PixelPerUnit

    	local spriteSize = firstSpriteSizeInPixel / ppu
    	local positionOffset = (firstSpriteSizeInPixel / 2 - firstFrameSprite.PivotPixel:ToVector2()) / ppu

    	-- 오프셋 보정
    	local effectOffset = self.ExplodeEffectOffset
    	if self.ToLeft then
    		effectOffset.x = -effectOffset.x
    	end
}
```
8. 폭발 이펙트의 영역 만큼 공격하도록 처리하기 위해 `Explode()` 함수의 위 내용에 이어서 아래 내용을 작성합니다.```
-- 폭발 이펙트의 영역만큼 공격함
local transform = self.Entity.TransformComponent
local worldPosition = transform.WorldPosition
local scale = self.EffectScale
local radian = math.rad(transform.ZRotation)
local offsetX = math.cos(radian) * positionOffset.x * scale - math.sin(radian) * positionOffset.y * scale
if not self.ToLeft then
    offsetX = -offsetX
end
local offsetY = math.sin(radian) * positionOffset.x * scale + math.cos(radian) * positionOffset.y * scale
shape.Size = Vector2(spriteSize.x * math.abs(scale), spriteSize.y * math.abs(scale))
shape.Position = Vector2(worldPosition.x + offsetX + effectOffset.x, worldPosition.y + offsetY + effectOffset.y)
shape.Angle = transform.ZRotation

self.Firer.PlayerAttack:AttackFast(shape, nil, CollisionGroups.Monster)
```
9. 폭발 이펙트를 재생하고 발사체를 없애기 위해 `Explode()` 함수의 위 내용에 이어서 아래 내용을 작성합니다.```
-- 폭발 이펙트 재생
local effectPosition = Vector3(transform.Position.x + effectOffset.x, transform.Position.y + effectOffset.y, transform.Position.z)
local options = { ["FlipX"] = not self.ToLeft }
_EffectService:PlayEffect(self.ExplodeSpriteRUID, self.Entity, effectPosition, 0, Vector3.one * self.EffectScale, false, options)	

-- 발사체 제거	
self.Entity:Destroy()
end)
```완성된 `Explode()` 함수 전체는 아래와 같습니다.```
void Explode()
{
    local shape = BoxShape(Vector2.zero, Vector2.one, 0)

    -- 폭발 이펙트 sprite 사이즈를 가져와 공격 영역으로 설정
    _ResourceService:PreloadAsync({self.ExplodeSpriteRUID}, function()
    	if not isvalid(self.Firer) and not isvalid(self.Firer.PlayerAttack) then
    		return
    	end

    	local clip = _ResourceService:LoadAnimationClipAndWait(self.ExplodeSpriteRUID)
    	local firstFrameSprite = clip.Frames[1].FrameSprite
    	local firstSpriteSizeInPixel = Vector2(firstFrameSprite.Width, firstFrameSprite.Height)
    	local ppu = firstFrameSprite.PixelPerUnit

    	local spriteSize = firstSpriteSizeInPixel / ppu
    	local positionOffset = (firstSpriteSizeInPixel / 2 - firstFrameSprite.PivotPixel:ToVector2()) / ppu

    	-- 오프셋 보정
    	local effectOffset = self.ExplodeEffectOffset
    	if self.ToLeft then
    		effectOffset.x = -effectOffset.x
    	end

    	-- 폭발 이펙트의 영역만큼 공격함
    	local transform = self.Entity.TransformComponent
    	local worldPosition = transform.WorldPosition
    	local scale = self.EffectScale
    	local radian = math.rad(transform.ZRotation)
    	local offsetX = math.cos(radian) * positionOffset.x * scale - math.sin(radian) * positionOffset.y * scale
    	if not self.ToLeft then
    	    offsetX = -offsetX
    	end
    	local offsetY = math.sin(radian) * positionOffset.x * scale + math.cos(radian) * positionOffset.y * scale
    	shape.Size = Vector2(spriteSize.x * math.abs(scale), spriteSize.y * math.abs(scale))
    	shape.Position = Vector2(worldPosition.x + offsetX + effectOffset.x, worldPosition.y + offsetY + effectOffset.y)
    	shape.Angle = transform.ZRotation

    	self.Firer.PlayerAttack:AttackFast(shape, nil, CollisionGroups.Monster)		

    	-- 폭발 이펙트 재생
    	local effectPosition = Vector3(transform.Position.x + effectOffset.x, transform.Position.y + effectOffset.y, transform.Position.z)
    	local options = { ["FlipX"] = not self.ToLeft }
    	_EffectService:PlayEffect(self.ExplodeSpriteRUID, self.Entity, effectPosition, 0, Vector3.one * self.EffectScale, false, options)	

    	-- 발사체 제거
    	self.Entity:Destroy()
    end)
}
```
10. 발사체가 몬스터에 충돌하면 폭발하도록 처리하기 위해 이벤트 핸들러에 **TriggerEnterEvent**를 추가합니다. 실행 공간은 **server only**로 설정합니다.```
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    if isvalid(TriggerBodyEntity.Monster) == false then
    	return
    end
      self:Explode()
}
```

지금까지 발사체 관련 스크립트를 만들어 보았습니다. 다음 과정에서는 캐릭터가 발사체로 몬스터를 공격하도록 만들어 봅시다. [캐릭터가 발사체로 몬스터 공격하기](/docs?postId=937)

Update 2025-11-17 PM 08:15


# 캐릭터가 발사체로 몬스터 공격하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. 1편. [원거리 발사체 만들기](/docs?postId=935) **▶ 2편.** [**캐릭터가 발사체로 몬스터 공격하기**](/docs?postId=937)

원거리 발사체를 날려서 몬스터를 처치하는 월드를 만들어보는 마지막 과정입니다. 이제 캐릭터가 발사체로 몬스터를 공격하도록 만들어봅시다.

# 공격 키 누르면 발사체 날리기

1. **PlayerAttack** 스크립트를 열고 아래와 같이 프로퍼티를 추가합니다.```
Property:
[Sync]
Vector3 ProjectileOffset = Vector3(0, 0, 0)
[None]
string ProjectileModel = ""
[Sync]
number Damage = 10
```
2. **Workspace - DefaultPlayer**의 프로퍼티 에디터에서 **PlayerAttack** 컴포넌트의 프로퍼티를 아래와 같이 수정합니다.
  - **ProjectileOffset : X = 0.4, Y = 0.4**
  - **ProjectileModel : Model_Projectile_Arrow**의 콘텍스트 메뉴에서 **Copy Entry ID**를 선택하여 복사한 값을 붙여 넣습니다.  **Offset** 값은 **Model_Projectile_Arrow**에서 사용하는 스프라이트에 따라 적절히 조절하면 됩니다.
3. 다시 **PlayerAttack** 스크립트를 열고 `AttackNormal()` 함수 내용을 다음과 같이 수정합니다. 실행 공간은 **server only**로 설정합니다.```
[server only]
void AttackNormal()
{
    local playerController = self.Entity.PlayerControllerComponent
    local transform = self.Entity.TransformComponent
    if playerController and transform then
    	-- 캐릭터가 공격 키를 누르면 발사체를 발사하도록 수정
    	local lookLeft = playerController.LookDirectionX == -1
    	local projectileOffset = self.ProjectileOffset:Clone()
    	if lookLeft then
    		projectileOffset.x = -projectileOffset.x
    	end
    	local projectileEntity = _SpawnService:SpawnByModelId(self.ProjectileModel, "Projectile", 
    						   transform.Position + projectileOffset, self.Entity.Parent)
    	local projectile = projectileEntity.Projectile
    	projectile.ToLeft = lookLeft
    	projectile.Firer = self.Entity
    	projectile:Fire()
    end
}
```
4. `CalcDamage()` 함수를 아래와 같이 수정합니다.```
override int CalcDamage(Entity attacker, Entity defender, string attackInfo)
{
    return self.Damage
}
```

# 몬스터 충돌 그룹 설정

발사체와 몬스터가 충돌하는 것을 체크할 수 있도록 충돌 그룹을 설정합니다.

1. **Workspace - BaseEnvironment - NativeModel**에서 **StaticMonster, MoveMonster, ChaseMonster**에 각각 **TriggerComponent**를 추가하고 **CollisionGroup**을 **Monster**로 설정합니다. ![moster](https://mod-file.dn.nexoncdn.co.kr/bbs/1670223867214138f17c5c5b4411e9fb273e06a5e11e6.png)
2. 맵에 원하는 몬스터를 적절히 배치합니다.

# 테스트

![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 공격 키를 누르면 발사체가 날아가고 몬스터에게 닿거나 일정 시간이 지나면 폭발합니다.

![play](https://mod-file.dn.nexoncdn.co.kr/bbs/16702265790943edc4c6330464a22afeb191890f81346.gif)

# 응용하기

발사체 및 이펙트의 **SpriteRUID**를 변경하거나 대미지, 속도 등 여러 가지 프로퍼티를 변경하여 크리에이터가 원하는 원거리 공격을 구현할 수 있습니다.  본 가이드를 참고하여 크리에이터의 개성을 살린 원거리 공격 스킬을 만들어봅시다.

Update 2025-11-20 PM 02:03


# 몬스터를 스폰해 보자

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

몬스터를 스폰한 뒤, 몬스터를 처치하면 아이템을 드랍하고 이 아이템을 인벤토리에 저장하는 일련의 과정을 구현해 봅시다.

> 본 가이드는 아래의 순서로 이어지는 과정입니다. **▶ 1편.** [**몬스터를 스폰해보자**](/docs?postId=204) 2편. [몬스터 드랍 아이템과 인벤토리 UI 만들기](/docs?postId=943) 3편. [인벤토리 스크립트 작성하기](/docs?postId=942) 4편. [인벤토리 UI 스크립트 작성하기](/docs?postId=946) 5편. [아이템 스크립트 작성하기](/docs?postId=947)

위의 순서대로 진행했을 때 만들어질 게임의 최종 모습은 아래와 같습니다. ![game](https://mod-file.dn.nexoncdn.co.kr/bbs/1672128051320c8efeb0f27e4436bb7cc30156f965407.gif)

먼저 몬스터 스폰 시스템을 간단하게 만들어 보겠습니다. 메이플 스토리의 필드를 보면 몬스터를 아무리 잡아도 특정 마릿수 내에서 몬스터가 지속적으로 스폰되는 것을 볼 수 있습니다. 각 필드 단위 별로 스폰할 몬스터와 스폰할 몬스터의 수를 설정하면, 해당 조건에 맞춰 몬스터가 생성되는 스폰 시스템이 있기 때문입니다. 아래 예제를 통해 몬스터를 스폰해봅시다.

# 월드 템플릿

제작 편의를 위해 "기본" 템플릿으로 월드 생성하는 것을 권장합니다. ![0](https://mod-file.dn.nexoncdn.co.kr/bbs/163667952682877954e0badb445beac64d4a1155c6b8a.png)

# 스폰 규칙

이번 과정에서 만들어볼 스폰 규칙은 다음과 같습니다.

- 스폰 개체 수: 맵에 최대 10마리
- 리스폰: 5초마다 맵에 있는 몬스터 수 체크 후, 최대 수량에 비해 부족한 만큼 리스폰.
- 스폰 위치: 특정 영역 내 랜덤한 위치
- 스폰할 몬스터: Preset List에서 원하는 몬스터 사용

# 스폰할 몬스터 추가

다음과 같이 스폰하려는 몬스터를 **Workspace**에 추가해 줍니다.

1. **Preset List**에서 스폰할 몬스터를 우클릭 - **Add to Workspace**를 선택합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16600442197122526676a43b54c8b87db279545ec6cf1.png)
2. **Workspace**에 추가된 것을 확인합니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/1636441681835eec75b87dc70415c86afa51d3f5dca8f.png)

# 몬스터 스폰

이제 스크립트를 통해 몬스터 스폰 기능을 만들어보겠습니다. 우선은 특정 좌표에 몬스터를 스폰해 보고 점차 기능을 확장해 봅시다.

1. 새 스크립트 컴포넌트 **MonsterSpawn**을 생성합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/16354075070807ead5f6f39d04bcd83c84cf04fcbb1b5.png)
2. **MonsterSpawn** 스크립트를 열어 `SpawnMonster()` 함수를 추가합니다.
3. `SpawnMonster()` 함수를 다음과 같이 작성합니다.```
void SpawnMonster()
{
    local parent = _EntityService:GetEntityByPath("/maps/map01")
    _SpawnService:SpawnByModelId(
        "Entry ID", 
        "SpawnedMonster",
        Vector3(0,0,0),
        parent)
}
```
4. 위에서 **Workspace**에 추가했던 몬스터 모델 우클릭 - **Copy Entry ID**를 눌러 **Entry ID**를 복사합니다. ![10](https://mod-file.dn.nexoncdn.co.kr/bbs/16708311988051c41e3516d2e4bde8d9ded17c148fb45.png)  그 다음 `SpawnMonster()` 함수의 **"Entry ID"** 부분에 **복사한 Entry ID**를 붙여넣습니다. model://를 삭제해도 정상작동합니다. 
  > **더 알아보기** `SpawnByModelId`는 `_SpawnService`가 제공하는 스폰 관련 함수 중 하나입니다. `_SpawnService:SpawnByModelId`를 사용하기 위해서는 엔티티로 생성할 모델이 **Workspace**에 추가되어 있어야 하며, 추가된 **Entry ID**를 매개 변수로 넘겨주어야 합니다. 원하는 모델의 콘텍스트 메뉴에서 **Copy Entry ID**를 눌러 **Entry ID**를 클립보드에 복사할 수 있습니다. 해당 함수에 대한 상세 내용은 [엔티티의 생성과 삭제, 유효성 체크](https://mod-developers.nexon.com/docs?postId=290)를 참고해 주세요.
5. 위에 작성한 **SpawnMonster**의 동작을 확인하기 위해 `OnBeginPlay()` 함수를 추가하고, 다음과 같이 `SpawnMonster()` 함수를 호출합니다.```
[server only]
void OnBeginPlay() 
{
    self:SpawnMonster()
}
```
6. **Hierarchy - common**의 프로퍼티 에디터에서 **MonsterSpawn** 컴포넌트를 추가합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/16595093911235aa8eff487344aeab5d2f65f28cfa2e9.png)
7. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 몬스터가 스폰되는지 확인합니다.

# 스폰 영역 설정

맵에 타일을 배치하고, 스폰 영역을 설정해 보겠습니다.

1. **Preset List**에서 마음에 드는 타일을 선택하고 다음과 같이 배치합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16600444158945ddd4856b7ca481e83e302d49635ef4f.png)
2. 이번에는 몬스터의 스폰 영역을 고민해 봅시다. 아래 이미지와 같이 하단 타일 양 끝에 Tab 키를 누르고 마우스 커서를 올려 좌표를 확인합니다. 각 양 끝 점 사이에 몬스터가 스폰되도록 할 것이기 때문에 일단 x, y 좌표를 따로 기록해 둡니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/165579543869079a43790709245ee92fd3c6b10bc2b13.png)

# 지정한 영역 내 랜덤 위치 스폰

지정한 영역 안에서 랜덤한 위치에 몬스터를 스폰하는 기능을 추가하겠습니다. 위에 확인했던 좌표를 기준으로 스폰 영역을 정의하고, 영역 내 랜덤한 위치에 몬스터를 스폰해 봅시다.

1. **MonsterSpawn**을 스크립트 에디터에서 열고 **Vector3** 타입의 새 함수 `GetRandomPosition()`을 추가합니다.
2. `GetRandomPosition()` 함수를 다음과 같이 작성합니다. 위에서 기록해두었던 좌표를 함수에 활용합니다.```
Vector3 GetRandomPosition()
{
    local leftX = -3.571 -- 스폰 영역 왼쪽의 x좌표
    local rightX = 2.688 -- 스폰 영역 오른쪽의 x좌표
    local y = 0.170 -- 스폰 영역 y좌표
    local areaWidth = rightX - leftX

    local randomX = (_UtilLogic:RandomIntegerRange(0,100) / 100) * areaWidth + leftX

    return Vector3(randomX, y, 0)
}
```
3. `SpawnMonster()` 함수를 다음과 같이 수정합니다.```
void SpawnMonster()
{
    local parent = _EntityService:GetEntityByPath("/maps/map01")
    _SpawnService:SpawnByModelId(
        "Entry ID",
        "SpawnedMonster",
        self:GetRandomPosition(),
        parent)
}
```
4. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 몬스터가 스폰 영역 내 랜덤한 위치에서 스폰되는 것을 확인합니다.

# 몬스터 스폰 주기 및 최대 수량 제한

이번에는 5초마다 몬스터를 한 마리씩 추가로 스폰하되, 최대 10개까지만 생성하는 기능을 만들어보겠습니다.

1. **MonsterSpawn**을 열고 프로퍼티를 추가합니다.```
Property:
[Sync]
number MaxSpawnCount = 10
[Sync] 
number Time = 0
[None]
table MonsterArray = {}
```
2. `OnBeginPlay()` 함수를 다음과 같이 수정합니다.```
[server only]
void OnBeginPlay() 
{
    self.MonsterArray = {}
}
```
3. `SpawnMonster()` 함수를 다음과 같이 수정합니다.```
void SpawnMonster()
{
    local parent = _EntityService:GetEntityByPath("/maps/map01")
    local nextNum = #self.MonsterArray + 1

    self.MonsterArray[nextNum] = _SpawnService:SpawnByModelId(
        "Entry ID",
        "SpawnedMonster",
        self:GetRandomPosition(),
        parent)
}
```
4. **number** 타입의 새 함수 `GetCurMonsterCount()`를 추가하고 다음과 같이 작성합니다.```
number GetCurMonsterCount()
{
    local i = 1
    while i <= #self.MonsterArray do
        if isvalid(self.MonsterArray[i]) == true then
            i = i + 1
        else
            table.remove(self.MonsterArray,i)
        end
    end

    return #self.MonsterArray
}
```
5. `OnUpdate()` 함수를 추가하고 다음과 같이 작성합니다.```
[server only]
void OnUpdate(number delta) 
{
    self.Time = self.Time + delta

    if self.Time >= 5 then
        self.Time = 0
        local curMonsterCnt = self:GetCurMonsterCount()
        if curMonsterCnt == nil then
            return
        end
        if curMonsterCnt < self.MaxSpawnCount then
            self:SpawnMonster()
        end
    end
}
```
6. **common** 엔티티의 프로퍼티 에디터에서 **MonsterSpawn** 컴포넌트의 **MaxSpawnCount** 값이 제대로 들어가 있는지 확인합니다. 만일 0으로 되어 있으면 10으로 수정합니다. ![19](https://mod-file.dn.nexoncdn.co.kr/bbs/16354076592684e9f1701f1b349dc80c5df15763778a8.png)
7. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 몬스터가 5초마다 다른 위치에서 최대 10마리까지 스폰되는 것을 확인합니다.

# 일정 시간마다 부족한 수량만큼 스폰

이번에는 5초마다 한 마리씩 스폰하는 것이 아니라, 5초마다 현재 몬스터 수량을 체크하여 최대 몬스터 수량보다 부족한 만큼 생성하도록 수정해 봅시다.

1. **MonsterSpawn**의 `GetRandomPosition()` 함수에 매개 변수를 하나 추가합니다. ![21](https://mod-file.dn.nexoncdn.co.kr/bbs/1655797605759f3d7410839674ad9b99040ab832c18fa.png)
2. 매개 변수 타입은 **number**로, 이름은 **spawnCount**로 설정하고, 리턴 타입을 **table**로 변경합니다. 함수는 다음과 같이 수정합니다.```
table GetRandomPosition(number spawnCount)
{
    local leftX = -3.571 -- 스폰 영역 왼쪽의 x좌표
    local rightX = 2.688 -- 스폰 영역 오른쪽의 x좌표
    local y = 0.170 -- 스폰 영역 y좌표
    local areaWidth = rightX - leftX
    local positions = {}

    for i = 1, spawnCount do
        local randomX = (_UtilLogic:RandomIntegerRange(0,100) / 100) * areaWidth + leftX
        positions[i] = Vector3(randomX, y, 0)
    end

    return positions
}
```
3. 위와 같이 `SpawnMonser()` 함수에도 매개 변수를 추가하고, 타입은 **number**, 이름은 **spawnCount**로 설정합니다. 함수는 다음과 같이 수정합니다.```
void SpawnMonster(number spawnCount)
{
    local parent = _EntityService:GetEntityByPath("/maps/map01")
    local nextNum = 0
    local positions = self:GetRandomPosition(spawnCount)

    for i = 1, #positions do
    	nextNum = #self.MonsterArray + 1
    	self.MonsterArray[nextNum] = _SpawnService:SpawnByModelId(
    	    "Entry ID",
    	    "SpawnedMonster",
    	    positions[i],
    	    parent)
    end
}
```
4. 마지막으로 `OnUpdate()` 함수의 내용을 다음과 같이 수정합니다.```
[server only]
void OnUpdate(number delta) 
{
    self.Time = self.Time + delta

    if self.Time >= 5 then
        self.Time = 0
        local curMonsterCnt = self:GetCurMonsterCount()
        if curMonsterCnt == nil then
            return
        end
        local spawnCount = self.MaxSpawnCount - curMonsterCnt
        if spawnCount > 0 then
            self:SpawnMonster(spawnCount)
        end
    end
}
```
5. ![play](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)시작을 눌러 몬스터 수가 줄었을 때, 일정 시간마다 최대 수량만큼 몬스터가 스폰되는 것을 확인합니다.

Update 2025-11-20 PM 02:03


# 몬스터 드롭 아이템과 인벤토리 UI 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=10%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. 1편. [몬스터를 스폰해보자](/docs?postId=204) **▶ 2편.** [**몬스터 드롭 아이템과 인벤토리 UI 만들기**](/docs?postId=943) 3편. [인벤토리 스크립트 작성하기](/docs?postId=942) 4편. [인벤토리 UI 스크립트 작성하기](/docs?postId=946) 5편. [아이템 스크립트 작성하기](/docs?postId=947)

지난 시간에 이어 이번 과정에서는 몬스터를 처치했을 때 드롭될 아이템을 아이템 테이블에서 정의해 봅시다. 그리고 인벤토리 UI를 추가하겠습니다.

# 아이템 테이블 만들기

먼저 아이템을 만들어봅시다. 개별 아이템은 **DataSet**의 아이템 테이블로 만들 수 있습니다.

1. **Workspace - MyDesk**의 콘텍스트 메뉴에서 **Create DataSet**을 클릭한 후, 이름으로 **UserItemDataSet**을 입력합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1659661729006e5721ddcf57b483b988411014b023136.png)
  > **더 알아보기** 스크립트에서 `_ItemService`를 이용한다면 데이터 셋의 이름을 반드시 **UserItemDataSet**으로 생성해야 합니다. `_ItemService`를 이용하지 않는다면 이름을 자유롭게 정해도 됩니다. 본 가이드에서는 `_ItemService` 대신 `_DataStorageService`를 사용할 예정이나, 편의 상 **UserItemDataSet**으로 사용하겠습니다.
2. **UserItemDataSet**을 열고 데이터 에디터에서 아래와 같이 설정합니다. | ID | Name | IconRUID |
| :---: | --- | --- | | 1 | RedPotion | 323920d2805d4ec1aa85eca9e3e1cab2 | | 2 | BluePotion | 7e9b39b73f4945b1a8d77db6c99a6946 | | 3 | IronSword | 682ef6cc7aa64076820f7e1da4dd54f8 |![1](https://mod-file.dn.nexoncdn.co.kr/bbs/16938261287833ee862abd59f4b74930a7f94ff6ad946.png)

# 인벤토리 UI 추가

아이템이 들어갈 인벤토리 UI를 만듭니다.

1. ![ui](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_ui.png)버튼을 눌러 UI 에디터를 엽니다.
2. **Preset List**에서 **버튼모음**, **인벤토리**를 클릭해 UI를 추가합니다. 기존 UI와 겹치지 않게 드래그하여 위치를 이동합니다. ![22](https://mod-file.dn.nexoncdn.co.kr/bbs/1659959415239e86dd162e65c4b1e82086102ba82efd4.png)  만일 **Inventory** 엔티티의 **프로퍼티 에디터 - UIInventory 컴포넌트**에 **InventoryBtnPath**가 다음과 같이 비어있으면 버튼을 눌러도 인벤토리가 열리지 않습니다. 오른쪽 햄버거 버튼(![Common_menu](https://mod-file.dn.nexoncdn.co.kr/bbs/163453706197553d527cb3ea34392bc2829f15976f3d8.png))을 누르고 **Reset All Properties**를 클릭하여 버튼을 눌렀을 때 인벤토리 창이 열리도록 연결해 줍니다. ![22-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16373057873214e1d4994f8834292a9904f34fb279d3c.png)

Update 2025-11-20 PM 02:03


# 인벤토리 스크립트 작성하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. 1편. [몬스터를 스폰해보자](/docs?postId=204) 2편. [몬스터 드롭 아이템과 인벤토리 UI 만들기](/docs?postId=943) **▶ 3편.** [**인벤토리 스크립트 작성하기**](/docs?postId=942) 4편. [인벤토리 UI 스크립트 작성하기](/docs?postId=946) 5편. [아이템 스크립트 작성하기](/docs?postId=947)

지난 시간에 이어 이번 과정에서는 인벤토리 스크립트를 작성해 보겠습니다. 인벤토리 스크립트에서는 인벤토리의 동작을 제어하고 인벤토리 UI에 변경되는 아이템 정보를 전달하며 DB에 아이템 정보를 저장하도록 처리할 것입니다.

# 인벤토리 스크립트

인벤토리의 동작을 제어할 인벤토리 스크립트를 작성합니다.

1. 새 스크립트 컴포넌트를 생성하고 이름을 **LiteInventory**로 설정합니다.
2. **Workspace - DefaultPlayer**의 콘텍스트 메뉴에서 **Add Component**를 클릭한 후 **LiteInventory** 컴포넌트를 추가합니다.
3. **LiteInventory** 스크립트를 열고 스크립트 에디터에서 프로퍼티를 추가합니다.```
Property:
[Sync]
boolean IsInitialized = false
```
4. `OnBeginPlay()` 함수를 추가하고 실행 공간은 **server only**로 설정합니다. 먼저 **inventoryData**에 **UserItemDataSet**을 가져와 사용하겠다는 것을 정의합니다. 그리고 **userDataStorage**에 **ItemData**라는 키로 저장된 데이터를 불러옵니다. 아직 저장된 데이터가 없다면 **nil** 값이 반환됩니다.```
[server only]
void OnBeginPlay()
{
    -- inventoryData에 UserItemDataSet를 불러옴
    self._T.inventoryData = {}
    for i = 1, _DataService:GetRowCount("UserItemDataSet") do
    	self._T.inventoryData[i] = 0
    end

    local userDataStorage = _DataStorageService:GetUserDataStorage(self.Entity.PlayerComponent.UserId)
    local errorCode, itemData = userDataStorage:GetAndWait("ItemData")

    -- 데이터 로드에 실패하면 에러 코드 출력
    if errorCode ~= 0 then
    	log(errorCode)
    	return
    end

    -- 로드된 데이터가 있다면 적용
    if itemData ~= nil then
    	local itemArr = _UtilLogic:Split(itemData, ",")
    	for i, v in ipairs(itemArr) do
    		self._T.inventoryData[i] = tonumber(v)
    	end
    end
}
```
  > **더 알아보기** 월드에서 사용하는 아이템 생성 및 저장, 관리를 할 때는 [ItemService](/apiReference/Services/ItemService)를 이용할 수도 있습니다. 하지만 월드 내 A 캐릭터가 가진 아이템 정보를 A 캐릭터 본인의 클라이언트와 서버만 알고 있어도 되는 수준의 가벼운 인벤토리는 [DataStorageService](/apiReference/Services/DataStorageService)로도 충분히 구현할 수 있습니다. 본 예제에서는 `DataStorageService`를 활용하여 인벤토리를 구현하는 방법을 소개합니다.
5. 로드된 데이터가 있다면 UI에도 해당 정보를 전달해야 합니다. 이를 전달하기 위해 이벤트 타입을 추가합니다. **MyDesk - Create Scripts - Create EventType**을 클릭하고 신규 이벤트 이름을 **OnInventoryInitialized**로 설정합니다.
6. **OnInventoryInitialized** 스크립트를 연 뒤, 아래와 같이 프로퍼티를 추가합니다. 프로퍼티 타입으로 SyncTable<v>를 선택하고, v를 **number**로 설정하면 됩니다.```
Property:
SyncTable<number> AllItemCounts
```
7. 다시 **LiteInventory** 스크립트로 돌아갑니다. 이제 인벤토리 UI에 로드된 데이터를 전달해야 합니다. 위에서 작성한 `OnBeginPlay()` 함수에 아래 내용을 추가합니다.```
local initEvent = OnInventoryInitialized()
for i, v in ipairs(self._T.inventoryData) do
    initEvent.AllItemCounts[i] = v
end

self._T.userDataStorage = userDataStorage
```
8. `SendInitializedEvent()` 함수를 추가하고 실행 공간은 **multicast**로 설정합니다. **Add Parameter**를 클릭하고 매개 변수를 추가합니다. 타입으로 **EventType**를 선택한 뒤 **OnInventoryInitialized**를 클릭합니다. **arg1**에는 **event**를 입력합니다. 아래와 같이 작성합니다.```
[multicast]
void SendInitializedEvent (OnInventoryInitialized event)
{
    self.Entity:SendEvent(event)
}
```
9. 다시 `OnBeginPlay()` 함수로 돌아가 봅시다. 이전에 작성한 부분에 이어서 아래 내용을 작성합니다.```
-- 기존 내용
self._T.userDataStorage = userDataStorage

-- 아래 내용을 이어서 작성합니다.
self:SendInitializedEvent(initEvent)
self.IsInitialized = true
```
10. `_TimerService`를 이용해 인벤토리 정보를 주기적으로 저장해 봅시다. 위의 `OnBeginPlay()` 함수 내용에 이어서 아래 내용을 작성합니다.
  - **ItemData**를 키로 사용할 것입니다.
  - 저장할 데이터 포맷은 "아이템 인덱스 별 소지 개수를 쉼표로 구분한 문자열"입니다.
  - 예를 들어, 1번 인덱스의 빨간 포션을 3개, 2번 인덱스의 파란 포션을 5개 가지고 있다면 **ItemData**라는 키에 **"3, 5"** 형태의 문자열을 저장합니다. 본 예제에서는 저장 주기를 300초로 설정하였습니다. 저장 주기를 더 짧게 설정하면 인벤토리 데이터 정보 유실의 위험은 줄어들겠지만 불필요하게 자주 `_DataStorageService`를 호출하면 부하가 발생할 수 있고, 추후 DB 저장에 제약이 생길 수 있기 때문에 적당한 주기로 설정해야 합니다.```
-- 인벤토리 정보를 저장하도록 설정
local saveInventory = function()
	local dataConcatString = table.concat(self._T.inventoryData, ",")
	self._T.userDataStorage:SetAsync("ItemData", dataConcatString, function() log("저장 완료") end)
	log("저장 중...")
end

-- 저장 주기 설정
local saveInterval = 300
_TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
```
11. `Event Handler`에 UserLeaveEvent를 추가하고 실행 공간은 **server only**로 설정합니다. 플레이를 종료할 때마다 캐릭터의 인벤토리 정보를 저장하겠습니다.```
Event Handler:
[server only] [service UserService]
HandleUserLeaveEvent(UserLeaveEvent event)
{
    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------

    local thisUserId = self.Entity.PlayerComponent.UserId

    if thisUserId ~= UserId then
        return
    end

    -- 플레이를 끝낼 때 인벤토리 데이터 정보를 저장함
    if self._T.userDataStorage then
        local dataConcatString = table.concat(self._T.inventoryData, ",")
        self._T.userDataStorage:SetAndWait("ItemData", dataConcatString)
    end
}
```
12. 캐릭터가 새로운 아이템을 획득하면 소유한 아이템 개수가 변경됩니다. 이렇게 변경된 아이템 정보를 처리할 함수를 만들어 봅시다. `ModifyItem()` 함수를 추가하고 실행 공간은 **server only**로 설정합니다. 매개 변수로 **number** 타입의 **itemIndex**와 **deltaAmount**를 추가합니다. 아래와 같이 내용을 작성합니다. **deltaAmount**에 양수를 전달하면 아이템 개수가 증가하고 음수를 전달하면 감소합니다.```
[server only]
void ModifyItem(number itemIndex, number deltaAmount)
{
    -- 아이템 인덱스가 정상인지 확인
    if itemIndex < 1 or itemIndex > #self._T.inventoryData then
    	log_error("itemIndex error")
    	return
    end

    -- 변경 이전 아이템 개수 확인
    local prevAmount = self._T.inventoryData[itemIndex]
    -- 변경된 값을 계산함
    local amountResult = prevAmount + deltaAmount

    -- amountResult가 정상인지 체크함. 0보다 작으면 비정상이므로 0으로 변경
    if amountResult < 0 then
    	log_error("Item amount is less then zero")
    	amountResult = 0
    end

    --amountResult가 정상이면 inventoryData를 amountResult로 변경
    self._T.inventoryData[itemIndex] = amountResult
}
```
13. 변경된 아이템 정보를 전달해 줄 이벤트 타입을 추가합니다. **MyDesk - Create Scripts - Create EventType**을 클릭하고 신규 이벤트 타입의 이름을 **OnInventoryModified**로 설정합니다.
14. **OnInventoryModified**를 열고 스크립트 에디터에서 프로퍼티를 추가합니다.```
Property: 
number ItemIndex = 0
number ItemCount = 0
```
15. 다시 **LiteInventory** 스크립트로 돌아갑니다. `SendModifiedEvent()` 함수를 추가하고 실행 공간은 **multicast**로 설정합니다. 그리고 아래와 같이 매개 변수를 추가한 뒤, 클라이언트에도 아이템 변경 정보를 전달할 함수를 호출합니다.```
[multicast]
void SendModifiedEvent (OnInventoryModified event)
{
    self.Entity:SendEvent(event)
}
```
16. `ModifyItem()` 함수로 돌아갑니다. 이전에 작성한 부분에 이어서 아래 내용을 작성합니다.```
-- 기존 내용
self._T.inventoryData[itemIndex] = amountResult

-- 아래 내용을 이어서 작성합니다.
local modifiedEvent = OnInventoryModified()
modifiedEvent.ItemIndex = itemIndex
modifiedEvent.ItemCount = amountResult
-- UI에 SendModifiedEvent를 전달
self:SendModifiedEvent(modifiedEvent)
```

# 인벤토리 비우기

테스트 편의를 위해 캐릭터가 게임에 새로 접속할 때마다 인벤토리를 비우도록 설정해 봅시다.

1. 아이템 삭제를 처리하기 위해 **LiteInventory**에 `RemoveItem()` 함수를 추가합니다. 실행 공간은 **server only**로 설정합니다. 매개 변수로 **number** 타입의 **itemIndex**를 추가합니다. 그리고 아래와 같이 작성합니다.```
[server only]
void RemoveItem(number itemIndex)
{
    if itemIndex < 1 or itemIndex > #self._T.inventoryData then
    	log_error("itemIndex error")
    	return
    end

    self._T.inventoryData[itemIndex] = 0

    local modifiedEvent = OnInventoryModified()
    modifiedEvent.ItemIndex = itemIndex
    modifiedEvent.ItemCount = 0
    self:SendModifiedEvent(modifiedEvent)
}
```
2. 새 스크립트 컴포넌트를 생성하고 이름을 **ClearInventoryOnBeginPlay**로 설정합니다.
3. **DefaultPlayer**에 **ClearInventoryOnBeginPlay** 컴포넌트를 추가합니다.
4. **ClearInventoryOnBeginPlay**를 열고 `OnBeginPlay()` 함수를 추가합니다. 실행 공간은 **server only**로 설정합니다. 그리고 아래와 같이 내용을 작성합니다.```
[server only]
void OnBeginPlay()
{
    if self.Enable == false then
    	return
    end

    local inven = self.Entity.LiteInventory

    while not inven.IsInitialized do
    	wait(0.5)
    end

    for i = 1, _DataService:GetTable("UserItemDataSet"):GetRowCount() do
    	inven:RemoveItem(i)
    end
}
```
5. **DefaultPlayer**에서 **ClearInventoryOnBeginPlay**의 Enable을 **true**로 설정하고 테스트하면 새로 게임을 시작할 때마다 캐릭터의 인벤토리를 비웁니다. **ClearInventoryOnBeginPlay**의 Enable을 **false**로 설정하면 새로 게임을 시작해도 인벤토리를 비우지 않기 때문에 이전에 DB에 저장된 아이템 정보가 인벤토리에 보이게 됩니다.

# 전체 스크립트

지금까지 작성한 스크립트를 확인해 봅시다.

## LiteInventory 컴포넌트

```
Property:
[Sync]
boolean IsInitialized = false

Function:
[server only]
void OnBeginPlay()
{
    -- inventoryData에 UserItemDataSet를 불러옴
    self._T.inventoryData = {}
    for i = 1, _DataService:GetRowCount("UserItemDataSet") do
    	self._T.inventoryData[i] = 0
    end

    local userDataStorage = _DataStorageService:GetUserDataStorage(self.Entity.PlayerComponent.UserId)
    local errorCode, itemData = userDataStorage:GetAndWait("ItemData")
    
    if errorCode ~= 0 then
    	log(errorCode)
    	return
    end
    
    if itemData ~= nil then
    	local itemArr = _UtilLogic:Split(itemData, ",")
    	for i, v in ipairs(itemArr) do
    		self._T.inventoryData[i] = tonumber(v)
    	end
    end
    
    local initEvent = OnInventoryInitialized()
    for i, v in ipairs(self._T.inventoryData) do
		initEvent.AllItemCounts[i] = v
    end

    self._T.userDataStorage = userDataStorage
    self:SendInitializedEvent(initEvent)
    self.IsInitialized = true
    
    local saveInventory = function()
    	local dataConcatString = table.concat(self._T.inventoryData, ",")
    	self._T.userDataStorage:SetAsync("ItemData", dataConcatString, function() log("저장 완료") end)
    	log("저장 중...")
    end
    
    local saveInterval = 300
    _TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
}

[multicast]
void SendInitializedEvent(OnInventoryInitialized event)
{
    self.Entity:SendEvent(event)
}
  
[server only]
void ModifyItem(number itemIndex, number deltaAmount)
{
    if itemIndex < 1 or itemIndex > #self._T.inventoryData then
    	log_error("itemIndex error")
    	return
    end
    
    local prevAmount = self._T.inventoryData[itemIndex]
    local amountResult = prevAmount + deltaAmount
    
    if amountResult < 0 then
    	log_error("Item amount is less then zero")
    	amountResult = 0
    end
    
    self._T.inventoryData[itemIndex] = amountResult
    
    local modifiedEvent = OnInventoryModified()
    modifiedEvent.ItemIndex = itemIndex
    modifiedEvent.ItemCount = amountResult
    self:SendModifiedEvent(modifiedEvent)
}

[multicast]
void SendModifiedEvent(OnInventoryModified event)
{
    self.Entity:SendEvent(event)
}

[server only]
void RemoveItem(number itemIndex)
{
    if itemIndex < 1 or itemIndex > #self._T.inventoryData then
    	log_error("itemIndex error")
    	return
    end
    
    self._T.inventoryData[itemIndex] = 0
    
    local modifiedEvent = OnInventoryModified()
    modifiedEvent.ItemIndex = itemIndex
    modifiedEvent.ItemCount = 0
    self:SendModifiedEvent(modifiedEvent)
}
    
Event Handler:
[server only] [service UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
 -- Parameters
local UserId = event.UserId
---------------------------------------------------------

local thisUserId = self.Entity.PlayerComponent.UserId

if thisUserId ~= UserId then
    return
end

-- 플레이를 끝낼 때 인벤토리 데이터 정보를 저장함
if self._T.userDataStorage then
    local dataConcatString = table.concat(self._T.inventoryData, ",")
    self._T.userDataStorage:SetAndWait("ItemData", dataConcatString)
end
}
```

## OnInventoryInitialized 이벤트

```
Property:
SyncTable<number> AllItemCounts
```

## OnInventoryModified 이벤트

```
Property : 
number ItemIndex = 0
number ItemCount = 0
```

Update 2025-12-03 PM 03:40


# 인벤토리 UI 스크립트 작성하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. 1편. [몬스터를 스폰해보자](/docs?postId=204) 2편. [몬스터 드롭 아이템과 인벤토리 UI 만들기](/docs?postId=943) 3편. [인벤토리 스크립트 작성하기](/docs?postId=942) **▶ 4편.** [**인벤토리 UI 스크립트 작성하기**](/docs?postId=946) 5편. [아이템 스크립트 작성하기](/docs?postId=947)

지난 시간에 이어 이번 과정에서는 인벤토리 UI 스크립트를 작성해 보겠습니다.

# UIInventory 수정

[몬스터 드롭 아이템과 인벤토리 UI 만들기](/docs?postId=943)를 진행했다면 **Workspace**에서 **UIInventory** 스크립트를 찾을 수 있을 것입니다. 아이템을 획득하면 아이템이 들어갈 슬롯이 생성되도록 **UIInventory** 스크립트를 수정해 봅시다.

1. **UIInventory** 스크립트를 엽니다.
2. 아이템 종류만큼 아이템 슬롯을 미리 생성해 봅시다. `OnBeginPlay()` 함수 마지막에 아래 내용을 작성합니다.```
-- 아이템 종류만큼 슬롯을 미리 생성
-- slotList로 인벤토리 UI에서 슬롯 리스트를 관리함
self._T.slotList = {}

for i = 1, _DataService:GetRowCount("UserItemDataSet") do
    self._T.slotList[i] = self:AddSlot(i, 0)
end
```
3. `AddSlot()` 함수를 추가합니다. 리턴 타입은 **Entity**로 설정하고 **number** 타입의 매개 변수 **itemIndex**와 **itemCount**를 추가합니다. 이와 같이 작성하면 `SetData()` 함수에 빨간 밑줄로 에러가 표시될 것입니다. 아직 **UIItemSlot** 스크립트의 `SetData()` 함수를 의도한 대로 수정하지 않았기 때문입니다. 이후 단계에서 수정할 것이므로 일단은 그대로 두고 다음 순서를 진행합니다.```
Entity AddSlot(number itemIndex, number itemCount)
{
    local itemSlot =_SpawnService:SpawnByEntity(self.itemUI, "Item", Vector3.zero, self.scrollView)
    itemSlot.UIItemSlot:SetData(itemIndex, itemCount)
    return itemSlot
}
```
4. 이벤트 핸들러에 있는 아래의 이벤트를 모두 삭제합니다.
  - InventoryItemInitEvent
  - InventoryItemAddedEvent
  - InventoryItemRemovedEvent
  - InventoryItemModifiedEvent
5. 이전 가이드인 [인벤토리 스크립트 작성하기](/docs?postId=942)에서 **LiteInventory** 스크립트를 작성했습니다. 이 스크립트에서는 캐릭터가 게임에 접속할 때, DB에 저장된 아이템 정보가 있다면 이를 `OnInventoryInitialized` 이벤트를 통해 인벤토리 UI에 전달하도록 설정했습니다.  **UIInventory** 스크립트에서는 이 정보를 전달받기 위해 이벤트 핸들러에 `OnInventoryInitialized` 이벤트를 추가하겠습니다. 그리고 핸들러 상단의 이벤트 중계자는 **localplayer**로 설정합니다. 보유 중인 아이템을 UI에 보여주기 위해 아래와 같이 작성합니다.```
[localplayer]
HandleOnInventoryInitialized(OnInventoryInitialized event)
{
    -- Parameters
    local AllItemCounts = event.AllItemCounts
    ---------------------------------------------------------

    for i, itemCount in pairs(AllItemCounts) do
        self._T.slotList[i].UIItemSlot:SetData(i, itemCount)
    end
}
```
6. 또한 캐릭터가 몬스터를 처치한 후 드롭된 아이템을 획득하면 소유한 아이템 개수가 변경됩니다. 변경된 정보를 **UIInventory**에서도 전달받아야 합니다. 이를 위해 이벤트 핸들러에 `OnInventoryModified` 이벤트를 추가하고 핸들러 상단의 이벤트 중계자는 **localplayer**로 설정합니다.```
[localplayer]
HandleOnInventoryModified(OnInventoryModified event)
{
    -- Parameters
    local ItemIndex = event.ItemIndex
    local ItemCount = event.ItemCount
    ---------------------------------------------------------

    -- 슬롯 리스트가 정상인지 확인
    if self._T.slotList == nil then
        return
    end

    local slot = self._T.slotList[ItemIndex]

    if slot == nil then
        self._T.slotList[ItemIndex] = self:AddSlot(ItemIndex, ItemCount)
    end

    -- 슬롯에 표시되는 아이템 개수 변경
    slot.UIItemSlot:SetCount(ItemCount)
}
```

# UIItemSlot 수정

캐릭터의 아이템 보유 정보를 토대로 개별 슬롯에 아이템을 보여주기 위해 **UIItemSlot** 스크립트를 수정하겠습니다.

1. **UIItemSlot** 스크립트를 열고 기존의 프로퍼티는 모두 제거합니다. 그리고 아래와 같이 **number** 타입의 **ItemIndex**, **ItemCount** 프로퍼티를 추가합니다.```
Property:
[None]
number ItemIndex = 0
[None]
number ItemCount = 0
```
2. `SetData()` 함수를 수정합니다. 기존 매개 변수는 삭제하고, 새로 **number** 타입의 **itemIndex**, **itemCount**를 추가합니다. 기존 함수의 내용은 모두 삭제한 뒤, 아래의 내용을 새로 작성합니다. 아이템을 획득하면 슬롯을 활성화하고 아이템과 개수를 보여줍니다. 아이템을 잃으면 슬롯을 비활성화해 아이템이 보이지 않게합니다.```
void SetData(number itemIndex, number itemCount)
{
    -- 슬롯에 아이템 정보를 설정함

    self.ItemIndex = itemIndex
    self.ItemCount = itemCount

    local imageEntity = self.Entity:GetChildByName("img_slot")
    local iconRUID = _DataService:GetTable("UserItemDataSet"):GetCell(itemIndex, "IconRUID")
    imageEntity.SpriteGUIRendererComponent.ImageRUID = iconRUID

    imageEntity:GetChildByName("item_count").TextComponent.Text = tostring(math.floor(itemCount))

    -- 아이템 개수가 0보다 클 경우 슬롯을 보여주고, 아닐 경우 숨김
    if itemCount > 0 then
        self.Entity:SetEnable(true)
    else
        self.Entity:SetEnable(false)
    end
}
```
3. `SetCount()` 함수를 추가합니다. 매개 변수로 **number** 타입의 **count**를 추가합니다.```
void SetCount(number count)
{
    -- 아이템 수량 변경
    self.ItemCount = count

    local textEntity = self.Entity:GetChildByName("item_count", true)
    textEntity.TextComponent.Text = tostring(math.floor(count))

    -- 아이템 개수가 0보다 클 경우 슬롯을 보여주고, 아닐 경우 숨김
    if count > 0 then
        self.Entity:SetEnable(true)
    else
        self.Entity:SetEnable(false)
    end
}
```
4. 이벤트 핸들러의 **ButtonClickEvent**를 아래와 같이 수정합니다.```
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------

    if self.ItemIndex == 0 then
    	return
    end

    -- TODO: item logic
}
```

# 전체 스크립트

지금까지 작성한 스크립트를 확인해 봅시다.

## UIInventory 스크립트

```
Property:
[None]
Entity itemUI = nil
[None]
Entity scrollView = nil
[None]
SyncTable<string, Entity> SlotItems
[None]
string inventoryBtnPath = "/ui/DefaultGroup/RPGButtons/btn_inventory"
    
Method:
[client only]
void OnBeginPlay
{
    self.itemUI =_EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/Inventory_ScrollView/item_slot")
    self.itemUI:SetEnable(false)
    self.scrollView = _EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/Inventory_ScrollView")
    
    local inventoryButton = _EntityService:GetEntityByPath(self.inventoryBtnPath)
    if inventoryButton ~= nil then
    	local openFunc = function()
    		self.Entity.Enable = true
    	end
    	if inventoryButton.ButtonComponent == nil then
    		inventoryButton:AddComponent("MOD.Core.ButtonComponent")
    	end
    	inventoryButton:ConnectEvent(ButtonClickEvent, openFunc)
    end
    
    
    local closeButton = _EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/CloseButton")
    local closeFunc = function()
    	self.Entity.Enable = false
    end
    
    closeButton:ConnectEvent(ButtonClickEvent, closeFunc)
    
    -- 아이템 종류만큼 슬롯을 미리 생성
    -- slotList로 인벤토리 UI에서 슬롯 리스트를 관리함
    self._T.slotList = {}
     
    for i = 1, _DataService:GetRowCount("UserItemDataSet") do
        self._T.slotList[i] = self:AddSlot(i, 0)
    end
}

Entity AddSlot(number itemIndex, number itemCount)
{
    local itemSlot =_SpawnService:SpawnByEntity(self.itemUI, "Item", Vector3.zero, self.scrollView)
    itemSlot.UIItemSlot:SetData(itemIndex, itemCount)
    return itemSlot
}

vent Handler:
[localplayer]
HandleOnInventoryInitialized(OnInventoryInitialized event)
{
    -- Parameters
    local AllItemCounts = event.AllItemCounts
    ---------------------------------------------------------
 
    for i, itemCount in pairs(AllItemCounts) do
        self._T.slotList[i].UIItemSlot:SetData(i, itemCount)
    end
}

[localplayer]
HandleOnInventoryModified(OnInventoryModified event)
{
    -- Parameters
    local ItemIndex = event.ItemIndex
    local ItemCount = event.ItemCount
    ---------------------------------------------------------
 
    -- 슬롯 리스트가 정상인지 확인
    if self._T.slotList == nil then
        return
    end
 
    local slot = self._T.slotList[ItemIndex]
 
    if slot == nil then
        self._T.slotList[ItemIndex] = self:AddSlot(ItemIndex, ItemCount)
    end
 
    -- 슬롯에 표시되는 아이템 개수 변경
    slot.UIItemSlot:SetCount(ItemCount)
}
```

## UIItemSlot 스크립트

```
Property:
[None]
number ItemIndex = 0
[None]
number ItemCount = 0

Method:
void SetData(number itemIndex, number itemCount)
{
    -- 슬롯에 아이템 정보를 설정함
 
    self.ItemIndex = itemIndex
    self.ItemCount = itemCount
 
    local imageEntity = self.Entity:GetChildByName("img_slot")
    local iconRUID = _DataService:GetTable("UserItemDataSet"):GetCell(itemIndex, "IconRUID")
    imageEntity.SpriteGUIRendererComponent.ImageRUID = iconRUID
 
    imageEntity:GetChildByName("item_count").TextComponent.Text = tostring(math.floor(itemCount))
 
    -- 아이템 개수가 0보다 클 경우 슬롯을 보여주고, 아닐 경우 숨김
    if itemCount > 0 then
        self.Entity:SetEnable(true)
    else
        self.Entity:SetEnable(false)
    end
}
    
void SetCount(number count)
{
    -- 아이템 수량 변경
    self.ItemCount = count
 
    local textEntity = self.Entity:GetChildByName("item_count", true)
    textEntity.TextComponent.Text = tostring(math.floor(count))
 
    -- 아이템 개수가 0보다 클 경우 슬롯을 보여주고, 아닐 경우 숨김
    if count > 0 then
        self.Entity:SetEnable(true)
    else
        self.Entity:SetEnable(false)
    end
}
    
Event Handler:
[self]
HandleButtonClickEvent(ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------
    if self.ItemIndex == 0 then
        return
    end
    
    -- TODO: item logic
}
```

Update 2025-11-20 PM 02:03


# 아이템 스크립트 작성하기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.2&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=20%EB%B6%84&amp;color=green)

# 학습 과정 소개

> 본 가이드는 아래의 순서로 이어지는 과정입니다. 1편. [몬스터를 스폰해보자](/docs?postId=204) 2편. [몬스터 드롭 아이템과 인벤토리 UI 만들기](/docs?postId=943) 3편. [인벤토리 스크립트 작성하기](/docs?postId=942) 4편. [인벤토리 UI 스크립트 작성하기](/docs?postId=946) **▶ 5편.** [**아이템 스크립트 작성하기**](/docs?postId=947)

지난 시간에 이어 이번 과정에서는 몬스터가 드롭할 아이템 관련 스크립트를 작성해 보겠습니다.

# 아이템 스크립트

아이템 스크립트에서는 아래 내용들을 처리할 것입니다.

- 몬스터가 드롭할 아이템의 정보 설정
- 드롭된 아이템에 캐릭터가 닿았을 때 캐릭터의 인벤토리에 아이템을 넣음
- 아이템이 시각적으로 자연스럽게 드롭되는 모습 연출

아래의 순서대로 진행해 봅시다.

1. **Preset List**에서 원하는 아이템을 선택합니다. 어떤 아이템을 선택해도 상관없습니다. 아이템의 콘텍스트 메뉴에서 **Add to Workspace**를 클릭합니다. 그리고 이름을 **Model_Item**으로 변경합니다.
2. **Item** 이라는 이름으로 새 스크립트 컴포넌트를 생성합니다. 그리고 위에서 추가한 **Model_Item**에 **Item** 컴포넌트를 추가합니다.
3. **Item** 스크립트를 열고 **Property**에 **number** 타입의 **ItemIndex**를 추가합니다.```
Property:
[Sync]
number ItemIndex = 0
```
4. 드롭되는 아이템 정보를 설정하기 위해 `InitItem()` 함수를 추가합니다. 매개 변수로 **number** 타입의 **itemIndex**를 추가합니다. 이후 아래와 같이 내용을 작성합니다.```
void InitItem(number itemIndex)
{
    self.ItemIndex = itemIndex

    -- 드롭된 아이템이 어떤 모습으로 보일지 스프라이트 설정
    local sprite = self.Entity.SpriteRendererComponent
    local itemDataSet = _DataService:GetTable("UserItemDataSet")
    local ruid = itemDataSet:GetRow(self.ItemIndex):GetItem("IconRUID")
    sprite.SpriteRUID = ruid
}
```
5. **Model_Item**의 프로퍼티 에디터에서 **TriggerComponent**를 추가합니다.
6. **Item** 스크립트의 이벤트 핸들러에 **TriggerEnterEvent**를 추가하고 실행 공간을 **server only**로 설정합니다. 그리고 아이템 엔티티와 충돌한 엔티티(캐릭터)의 인벤토리를 받고, 인벤토리가 없으면 리턴하도록 처리합니다. 이후 아이템 개수 변경 관련 처리를 위해 **LiteInventory** 스크립트 - `ModifyItem()` 함수를 호출한 후, 충돌한 아이템 엔티티는 더 이상 보이지 않도록 파괴합니다.```
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    --아이템 엔티티와 충돌한 엔티티의 인벤토리를 받고, 인벤토리가 없으면 리턴
    local inventory = TriggerBodyEntity.LiteInventory
    if inventory == nil then return end

    -- 아이템 개수 변경 처리를 위해 ModifyItem() 함수 호출
    inventory:ModifyItem(self.ItemIndex, 1)

    -- 충돌한 아이템 엔티티는 파괴
    self.Entity:Destroy()
}
```

# 몬스터 아이템 드롭

몬스터가 죽을 때 아이템을 드롭하도록 처리합니다.

1. **Monster** 스크립트를 엽니다.
2. `Dead()` 함수의 기존 내용에 이어서 아래 내용을 추가합니다. 이때 **Entry ID** 부분에는 **Model_Item**의 **Entry ID**를 복사 - 붙여 넣기 해야 합니다. **Model_Item**의 콘텍스트 메뉴에서 **Copy Entry ID** 클릭 후 **Entry ID** 부분에 붙여 넣기 합니다.```
-- 몬스터가 UserItemDataSet에서 설정한 아이템을 무작위로 떨어뜨리게 처리
local itemCount = _DataService:GetTable("UserItemDataSet"):GetRowCount()

local index = _UtilLogic:RandomIntegerRange(1,itemCount)
-- Model_Item의 Entry ID를 복사하여 "Entry ID" 부분에 붙여 넣기
local itemEntity = _SpawnService:SpawnByModelId("Entry ID", "Item", self.Entity.TransformComponent.WorldPosition, self.Entity.Parent)
itemEntity.Item:InitItem(index)
```

# 아이템 드롭 연출

1. **Model_Item**에 **TweenFloatingComponent**를 추가합니다. 각 프로퍼티는 아래와 같이 설정합니다. ![tween](https://mod-file.dn.nexoncdn.co.kr/bbs/167211880171701aca471f6134260a22ab98b6c4a145c.png)
2. **Item** 스크립트를 열고 **number** 타입의 새 프로퍼티 **DropTweenTime**을 추가합니다.```
Property:
[Sync]
number ItemIndex = 0

-- 추가
[Sync]
number DropTweenTime = 0.8
```
3. `OnBeginPlay()` 함수를 추가하고 실행 공간은 **사용하지 않음**을 선택합니다. 클라이언트와 서버에서 각각 필요한 일을 처리할 수 있도록 `OnBeginPlayClient()`와 `OnBeginPlayServer()`를 호출합니다.```
void OnBeginPlay()
{
    if self:IsClient() then
      	self:OnBeginPlayClient()
    else
    	self:OnBeginPlayServer()
    end
}
```
4. `OnBeginPlayClient()` 함수를 추가하고 아래와 같이 내용을 작성합니다. 아이템이 드롭될 때 위로 한번 붕 떴다가 내려오는 연출이 나오도록 설정합니다.```
void OnBeginPlayClient()
{
    -- Tween
    local totalTweenTime = self.DropTweenTime
    local jumpHeight = 1.1
    -- 아이템 드롭될 때 jumpHeight 만큼 위로 한번 붕 뜨도록 함
    local tween = _TweenLogic:MoveOffset(self.Entity, Vector2(0, jumpHeight), totalTweenTime / 2, EaseType.QuadEaseOut)
    -- 올라간 만큼 내려오도록 함
    tween:SetOnEndCallback(function() 
    	local tween2 = _TweenLogic:MoveOffset(self.Entity, Vector2(0, -jumpHeight), totalTweenTime / 2, EaseType.QuadEaseIn) 
    	tween2:SetOnEndCallback(function() self.Entity.TweenFloatingComponent.Enable = true end)
    end)
}
```
5. `OnBeginPlayServer()` 함수를 추가하고 아래와 같이 내용을 작성합니다. 아이템이 위로 한번 붕 떴다가 떨어지는 연출이 나오는 동안은 캐릭터에 닿아도 인벤토리에 들어가지 않도록 합니다. 연출이 끝나면 TriggerComponent를 활성화하여 캐릭터와 닿았을 때 인벤토리에 들어가도록 합니다.```
void OnBeginPlayServer()
{
    -- Tween이 끝난 후에 TriggerComponent 활성화
    _TimerService:SetTimerOnce(function() self.Entity.TriggerComponent.Enable = true end, self.DropTweenTime + 0.1) 
}
```
6. ![start](https://mod-file.dn.nexoncdn.co.kr/storage/icons/tool/icon_play.png)**[시작]** 버튼을 누른 뒤 테스트해 봅시다. 몬스터 스폰, 처치 시 아이템 드롭, 아이템을 획득하고 인벤토리에 저장하는 일련의 과정이 잘 진행되는지 확인합니다. ![game](https://mod-file.dn.nexoncdn.co.kr/bbs/1672128051320c8efeb0f27e4436bb7cc30156f965407.gif)

# 전체 스크립트

지금까지 작성한 스크립트를 확인해 봅시다.

## Item 스크립트

```
Property:
[Sync]
number ItemIndex = 0
[Sync]
number DropTweenTime = 0.8

Method:
void InitItem(number itemIndex)
{
    self.ItemIndex = itemIndex

    local sprite = self.Entity.SpriteRendererComponent
    local itemDataSet = _DataService:GetTable("UserItemDataSet")
    local ruid = itemDataSet:GetRow(self.ItemIndex):GetItem("IconRUID")
    sprite.SpriteRUID = ruid
}

void OnBeginPlay()
{
    if self:IsClient() then
      	self:OnBeginPlayClient()
    else
    	self:OnBeginPlayServer()
    end
}

void OnBeginPlayClient()
{
    local totalTweenTime = self.DropTweenTime
    local jumpHeight = 1.1
    local tween = _TweenLogic:MoveOffset(self.Entity, Vector2(0, jumpHeight), totalTweenTime / 2, EaseType.QuadEaseOut)
    tween:SetOnEndCallback(function() 
    	local tween2 = _TweenLogic:MoveOffset(self.Entity, Vector2(0, -jumpHeight), totalTweenTime / 2, EaseType.QuadEaseIn) 
    	tween2:SetOnEndCallback(function() self.Entity.TweenFloatingComponent.Enable = true end)
    end)
}

void OnBeginPlayServer()
{
    _TimerService:SetTimerOnce(function() self.Entity.TriggerComponent.Enable = true end, self.DropTweenTime + 0.1) 
}

Event Handler:
[server only] [self]
HandleTriggerEnterEvent(TriggerEnterEvent event)
{
    -- Parameters
    local TriggerBodyEntity = event.TriggerBodyEntity
    --------------------------------------------------------
    local inventory = TriggerBodyEntity.LiteInventory
    if inventory == nil then return end

    inventory:ModifyItem(self.ItemIndex, 1)


    self.Entity:Destroy()
}
```

Update 2025-11-20 PM 02:03


# 1. 인벤토리 UI 만들기

# 인벤토리 추가

인벤토리 프리셋을 활용해 간단하게 인벤토리 UI를 만들 수 있습니다. 프리셋을 사용하면 UIInventory, UIItemSlot 컴포넌트가 자동으로 MyDesk에 추가됩니다. 이번 가이드에서는 두 컴포넌트를 수정해 활용합니다.

1. **Preset List - UI - 인벤토리**를 눌러 **ui - DefaultGroup**에 배치합니다. ![1](https://mod-file.dn.nexoncdn.co.kr/bbs/169811073881557986fbbbf224f6485962f4c08921a30.png)
2. **Inventory** 엔티티의 **프로퍼티 에디터 - UIInventory 컴포넌트**에 **InventoryBtnPath** 값이 비어 있으면 버튼을 눌러도 인벤토리가 열리지 않습니다. 오른쪽 햄버거 버튼(![Common_menu](https://mod-file.dn.nexoncdn.co.kr/bbs/163453706197553d527cb3ea34392bc2829f15976f3d8.png))을 누르고 **Reset All Properties**를 클릭하여 버튼을 눌렀을 때 인벤토리 창이 열리도록 연결해줍니다. ![22-1](https://mod-file.dn.nexoncdn.co.kr/bbs/16373057873214e1d4994f8834292a9904f34fb279d3c.png)

# 버튼 모음 추가

이후에 만들 인벤토리와 상점 UI를 열고 닫을 수 있도록 버튼 모음을 배치합니다. **Preset List - 버튼모음**을 눌러 **ui - DefaultGroup**에 배치합니다.

![RPGButton](https://mod-file.dn.nexoncdn.co.kr/bbs/1702293231521003ffdd71ed44af0ae8bc7560a25aa55.png)

Update 2025-11-17 PM 08:15


# 2. 아이템 데이터 만들기

# ItemTableDataSet 만들기

1. **Workspace - MyDesk - Create DataSet**을 선택해 새로운 **ItemTableDataSet** 데이터 셋을 생성합니다.
2. **id, Name, IconRUID, MaxStackCount, Price** 열을 생성하고 행을 추가해 데이터를 입력합니다.

| Id | Name | IconRUID | MaxStackCount | Price |
| --- | --- | --- | --- | --- |
| potion_red | 빨간 포션 | 323920d2805d4ec1aa85eca9e3e1cab2 | 5 | 40 |
| potion_redpill | 빨간 알약 | a821ee95c9c6486d9db0b6458eeaa549 | 10 | 50 |
| potion_blue | 파란 포션 | 7e9b39b73f4945b1a8d77db6c99a6946 | 5 | 190 |
| potion_bluepill | 파란 알약 | f95f8f220d8d42aeb0dd8698a209c8c8 | 10 | 200 |
| arrow | 화살 | b4d01db53b424753b1596cf6a63be944 | 99 | 1 |

# ItemInfo 만들기

1. **Workspace - MyDesk - Create Scripts - Create StructType**에서 새로운 **ItemInfo**를 생성합니다. ![ItemInfo](https://mod-file.dn.nexoncdn.co.kr/bbs/169811338823755f360e38fcf467286282a5b882d6943.png)
2. **ItemInfo** 타입에 아래와 같이 프로퍼티를 추가합니다.```
Property:
integer Index = 0
string Id = ""
string Name = ""
string IconRUID = ""
integer MaxStackCount = 0
integer Price = 0
```

# Data 로직 작성

1. **Workspace - MyDesk - Create Scripts - Create Logic**을 선택해 새로운 `Data` 로직을 생성합니다.
2. **ItemTable, ItemTableRowCount** 프로퍼티를 추가합니다.```
Property:
[None]
table ItemTable = {}
[None]
integer ItemTableRowCount = 0
```
3. **OnBeginPlay()** 함수를 추가하고, `ItemTableDataSet`의 데이터를 가져올 수 있도록 아래와 같이 작성합니다.```
Method:
void OnBeginPlay ()
{
    local dataset = _DataService:GetTable("ItemTableDataSet")
    local rowCount = dataset:GetRowCount()

    for i = 1, rowCount do
    	---@type string
    	local id = dataset:GetCell(i, "Id")
    	---@type string
    	local name = dataset:GetCell(i, "Name")
    	---@type string
    	local iconRUID = dataset:GetCell(i, "IconRUID")
    	---@type integer
    	local maxStackCount = math.tointeger(tonumber(dataset:GetCell(i, "MaxStackCount")))
    	---@type integer
    	local price = math.tointeger(tonumber(dataset:GetCell(i, "Price")))

    	local data = ItemInfo()
    	data.Index = i
    	data.Id = id
    	data.Name = name
    	data.IconRUID = iconRUID
    	data.MaxStackCount = maxStackCount
    	data.Price = price

    	if self.ItemTable[id] ~= nil then
    		log_warning ("[SimpleInventoryItemTable] 중복 아이템 Id: " .. id)
    	end

    	self.ItemTable[id] = data
    end

    -- 전체 아이템 수
    self.ItemTableRowCount = rowCount
}
```

Update 2025-11-17 PM 08:15


# 3. 인벤토리 데이터 저장 및 불러오기

DataStorage에서 불러온 데이터로 인벤토리를 초기화할 수 있도록 컴포넌트를 만들어 봅시다. SimpleInventory 컴포넌트, SimpleInventoryInitializedEvent, ItemStack을 활용해 인벤토리 데이터를 저장하고, 불러올 수 있도록 만들어봅시다.

# ItemStack 만들기

1. **Workspace - MyDesk - Create Scripts - Create StructType**을 눌러 **ItemStack**을 생성합니다. ![ItemStack](https://mod-file.dn.nexoncdn.co.kr/bbs/1698114090988887824c2a5924ca6bb1a8653e5dab760.png)
2. **SlotIndex, ItemId, Count** 프로퍼티를 추가합니다.```
Property:
integer SlotIndex = 0
string ItemId = ""
integer Count = 0
```
3. 새로운 `ToTable()` 함수를 생성합니다.```
Function:
table ToTable()
{
    return { SlotIndex = self.SlotIndex, ItemId = self.ItemId, Count = self.Count }
}
```
4. 새로운 `FromTable()` 함수를 생성하고 아래와 같이 작성합니다.```
void FromTable (table data)
{
    self.SlotIndex = data.SlotIndex
    self.ItemId = data.ItemId
    self.Count = data.Count
}
```

# SimpleInventoryInitializedEvent 만들기

1. **Workspace - MyDesk - Create Scripts - Create EventType** 선택해 새로운 `SimpleInventoryInitializedEvent`를 생성합니다.
2. 생성한 이벤트에 **Meso, ItemStacks** 프로퍼티를 추가합니다.```
Property:
integer Meso = 0
table ItemStacks = {}
```

# SimpleInventory 컴포넌트 만들기

1. **Workspace - MyDesk - Create Scripts - Create Component**에서 새로운 `SimpleInventory` 컴포넌트를 생성합니다. `SimpleInventory` 컴포넌트를 **DefaultPlayer**에 추가합니다. ![simpleinventory](https://mod-file.dn.nexoncdn.co.kr/bbs/169862850366621dfa2f5ce5246e7bb3f80d634c199c3.png)
2. **Meso, ItemStacks** 프로퍼티를 추가합니다.```
Property:
[None]
integer Meso = 10000
[None]
table ItemStacks = {}
```
3. `OnBeginPlay()` 함수를 추가합니다. 인벤토리를 초기화하고 데이터를 저장하고 불러올 수 있도록 아래와 같이 작성합니다.
  - DataStorage에서 가져온 데이터로 인벤토리를 초기화 합니다.
  - 만약 데이터가 없을 경우에는 기본값으로 초기화 합니다.
  - HttpService의 `JsonEncode()`, `JsonDecode()` 함수를 이용해 데이터를 저장하고 불러옵니다.```
[server only]
void OnBeginPlay()
{
    -- 데이터 스토리지에서 인벤토리 데이터 불러오기
    local userId = self.Entity.PlayerComponent.UserId
    local userDataStorage = _DataStorageService:GetUserDataStorage(userId)
    local errorCode, loadData = userDataStorage:GetAndWait("SimpleInventoryData")

    -- 데이터 로드 실패 시 에러 코드 출력
    if errorCode ~= 0 then
    	log_error("[SimpleInventory] 데이터 로딩 실패:" .. tostring(errorCode))
    	return
    end              
}
```
4. `Deserialize()` 함수를 생성하고, string 타입의 매개변수 **dataString**를 추가합니다. Json 포맷의 문자열을 테이블로 변환해 메소, 아이템 데이터를 읽을 수 있게 아래와 같이 작성합니다.```
void Deserialize (string dataString)
{         
    if dataString == nil or dataString == "" then
    	return
    end

    local dataTable = _HttpService:JSONDecode(dataString)
    local meso = dataTable.Meso
    local stacks = dataTable.ItemStacks

    self.Meso = math.tointeger(meso)

    if stacks ~= nil then
    	for _, stackData in pairs(stacks) do
    		local stack = ItemStack()
    		stack:FromTable(stackData)
    		self.ItemStacks[stack.SlotIndex] = stack
    	end
    end
}
```
5. `OnBeginPlay()`함수에서 `Deserialized()` 함수를 호출하도록 아래와 같이 맨아래에 작성합니다.```
    -- 로드된 데이터가 있다면 적용
    if loadData ~= nil then
    	self:Deserialize(loadData)
    end
```
6. `SendInitializedEvent()` 함수를 추가합니다.```
[server only]
void SendInitializedEvent ()
{
    local event = SimpleInventoryInitializedEvent()
    event.Meso = self.Meso
    event.ItemStacks = self.ItemStacks
    self.Entity:SendEvent(event)
}
```
7. `SimpleInventory` 컴포넌트에서 `SendInitializedEventToClient()` 함수를 생성합니다. 매개변수 **event**를 추가합니다. 매개변수 타입은 **EventType - SimpleInventoryInitializedEvent**를 선택합니다.```
[client]
void SendInitializedEventToClient (SimpleInventoryInitializedEvent event)
{
    self.Meso = event.Meso
    self.ItemStacks = event.ItemStacks
    self.Entity:SendEvent(event)
}
```
8. `SendInitializedEvent()` 함수 맨아래에 로컬 플레이어에게만 이벤트를 전달할 수 있도록 함수 호출을 추가합니다.```
    -- 로컬 플레이어에게만 전달
    self:SendInitializedEventToClient(event, self.Entity.PlayerComponent.UserId)
```
9. `OnBeginPlay()` 함수의 '로드된 데이터가 있다면 적용' 단락 아래에 아래 코드를 작성합니다. 데이터 로드 실패 시 인벤토리 초기화 이벤트가 발생하도록 `SendInitializedEvent()` 함수를 호출합니다.```
-- 인벤토리 초기화 이벤트 발생
self:SendInitializedEvent()
```
10. Event Hanlder에 `UserLeaveEvent`를 추가합니다. 월드에서 플레이어가 나갈 때 인벤토리 정보를 저장할 수 있도록 작성합니다.```
Event Handler
[service: UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------

    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------

    local thisUserId = self.Entity.PlayerComponent.UserId

    if thisUserId ~= UserId then
    	return
    end

    -- 플레이를 끝낼 때 인벤토리 데이터 정보를 저장함
    local userDataStorage = _DataStorageService:GetUserDataStorage(thisUserId)
    if userDataStorage ~= nil then
    	local saveData = self:Serialize()
    	userDataStorage:SetAndWait("SimpleInventoryData", saveData)
    end
}
```
11. 새로운 string 타입의 `Serialize()` 함수를 추가합니다. 메소와 아이템 데이터를 DataStorage에 저장할 수 있도록 아래와 같이 작성합니다. 메소와 아이템을 하나의 테이블에 담고 Json 포맷으로 변환합니다.```
string Serialize ()
{       
    local dataTable = {}
    local itemStacks = {}

    dataTable.Meso = self.Meso

    for _, stack in pairs(self.ItemStacks) do
    	local stackData = stack:ToTable()
    	table.insert(itemStacks, stackData)
    end

    if #itemStacks > 0 then
    	dataTable.ItemStacks = itemStacks
    end

    return _HttpService:JSONEncode(dataTable)
}
```
12. `OnBeginPlay()` 함수 맨 아래에 일정시간마다 데이터를 자동 저장할 수 있도록 아래와 같이 작성합니다.```
    -- 일정 시간마다 데이터 자동 저장
    local saveInventory = function()
    local saveData = self:Serialize()
    userDataStorage:SetAsync("SimpleInventoryData", saveData, function() log ("[SimpleInventory] 저장 완료") end)
    	log ("[SimpleInventory] 저장 중...")
    end

    local saveInterval = 300
    _TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
```

# 전체 스크립트

#### SimpleInventory

```
Property:
[None]
integer Meso = 10000
[None]
table ItemStacks = {}

Method:
[server only]
void OnBeginPlay()
{  
    -- 데이터 스토리지에서 인벤토리 데이터를 불러옴
    local userId = self.Entity.PlayerComponent.UserId
    local userDataStorage = _DataStorageService:GetUserDataStorage(userId)
    local errorCode, loadData = userDataStorage:GetAndWait("SimpleInventoryData")
    
    -- 데이터 로드에 실패하면 에러 코드 출력
    if errorCode ~= 0 then
    	log_error("[SimpleInventory] 데이터 로딩 실패:" .. tostring(errorCode))
    	return
    end
    
    -- 로드된 데이터가 있다면 적용
    if loadData ~= nil then
    	self:Deserialize(loadData)
    end
    
    -- 인벤토리 초기화 이벤트 발생
    self:SendInitializedEvent()
    
    -- 일정 시간마다 자동 저장
    local saveInventory = function()
        local saveData = self:Serialize()
        userDataStorage:SetAsync("SimpleInventoryData", saveData, function() log ("[SimpleInventory] 저장 완료") end)
    	    log ("[SimpleInventory] 저장 중...")
    end
    
    local saveInterval = 300
    _TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
}
    
string Serialize()
{
    local dataTable = {}
    local itemStacks = {}
    
    dataTable.Meso = self.Meso
    
    for _, stack in pairs(self.ItemStacks) do
    	local stackData = stack:ToTable()
    	table.insert(itemStacks, stackData)
    end
    
    if #itemStacks > 0 then
    	dataTable.ItemStacks = itemStacks
    end
    
    return _HttpService:JSONEncode(dataTable)
}

void Deserialize (string dataString)
{
    if dataString == nil or dataString == "" then
    	return
    end
    
    local dataTable = _HttpService:JSONDecode(dataString)
    local meso = dataTable.Meso
    local stacks = dataTable.ItemStacks
    
    self.Meso = math.tointeger(meso)
    
    if stacks ~= nil then
    	for _, stackData in pairs(stacks) do
    		local stack = ItemStack()
    		stack:FromTable(stackData)
    		self.ItemStacks[stack.SlotIndex] = stack
    	end
    end
}

[server only]
void SendInitializedEvent()
{
    local event = SimpleInventoryInitializedEvent()
    event.Meso = self.Meso
    event.ItemStacks = self.ItemStacks
    self.Entity:SendEvent(event)
    
    -- 로컬 플레이어에게만 전달
    self:SendInitializedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendInitializedEventToClient (SimpleInventoryInitializedEvent event)
{
    self.Meso = event.Meso
    self.ItemStacks = event.ItemStacks
    self.Entity:SendEvent(event)
}

Event Handler:
[service: UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------
    
    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------
    
    local thisUserId = self.Entity.PlayerComponent.UserId
    
    if thisUserId ~= UserId then
    	return
    end
    
    -- 플레이를 끝낼 때 인벤토리 데이터 정보를 저장함
    local userDataStorage = _DataStorageService:GetUserDataStorage(thisUserId)
    if userDataStorage ~= nil then
    	local saveData = self:Serialize()
    	userDataStorage:SetAndWait("SimpleInventoryData", saveData)
    end
}
```

Update 2025-11-17 PM 08:15


# 4. 아이템을 인벤토리에 추가하기

상점에서 상품을 구매하면, 인벤토리에 담길 수 있게 만들어 봅시다. 인벤토리 슬롯 하나에는 최대 10개의 아이템을 담을 수 있습니다. 최대 수량이 찬 뒤에 다음 슬롯에 아이템을 저장하게 됩니다. 예를 들어 빨간포션을 인벤토리에 이미 5개 가지고 있을 때, 10개를 추가로 구매하면 5개가 있던 슬롯에 먼저 5개를 저장하고, 나머지 5개를 새로운 슬롯에 저장합니다.

# SimpleInventoryItemAddedEvent 만들기

1. **Workspace - MyDesk - Create Scripts - Create EventType** 선택해 새로운 `SimpleInventoryItemAddedEvent` 생성합니다.
2. 프로퍼티를 추가합니다.```
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```

# SimpleInventoryItemModifiedEvent 만들기

1. **Workspace - MyDesk - Create Scripts - Create EventType** 선택해 `SimpleInventoryItemModifiedEvent`를 생성합니다.
2. 프로퍼티를 추가합니다.```
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```

# SimpleInventoryItemRemovedEvent 만들기

1. **Workspace - MyDesk - Create Scripts - Create EventType** 선택해 새로운 `SimpleInventoryItemRemovedEvent`를 생성합니다.
2. 프로퍼티를 추가합니다.```
Property:
integer SlotIndex = 0
string ItemId = ""
```

# SimpleInventoryMesoModifiedEvent 만들기

1. **Workspace - MyDesk - Create Scripts - Create EventType** 선택해 `SimpleInventoryMesoModifiedEvent`를 생성합니다.
2. 프로퍼티에 추가합니다.```
Property:
integer Meso = 0
```

# 아이템 추가하기

`SimpleInventory` 컴포넌트 아이템을 인벤토리에 추가할 수 있도록 만들어 봅시다.

1. **Capacity** 프로퍼티를 추가합니다.```
[None]
integer Capacity = 16
```
2. 새로운 integer 타입의 `AddItem()` 함수를 추가합니다. 매개변수 **itemId, itemCount**를 추가합니다. 인벤토리에 아이템을 추가할 수 있도록 작성합니다. `AddItem()` 함수는 아래와 같이 동작합니다
  - **itemId**에 해당하는 아이템을 **itemCount**만큼 인벤토리에 담습니다.
  - 인벤토리의 아이템이 들어있는 슬롯의 최대치가 차지 않았다면 해당 슬롯에 아이템을 채웁니다. 그 후 남은 아이템을 새 슬롯에 담습니다.
  - 인벤토리에 아이템을 모두 담은 경우 0을 반환합니다.
  - 아이템을 담을 수 있는 인벤토리 슬롯이 없는 경우 남은 아이템의 개수를 반환합니다.
  - 하나의 슬롯에는 **MaxStackCount**보다 많은 양이 담길 수 없습니다.
  - **ItemModifiedEvent**와 **ItemAddedEvent**를 발생시킵니다.```
[server only]
integer AddItem (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[SimpleInventory] (AddItem) 아이템 Id 오류: " .. itemId)
    	return
    end

    if itemCount <= 0 then
    	log_error("[SimpleInventory] (AddItem) 아이템 Count 오류: " .. itemCount)
    	return
    end

    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount

    -- 기존 슬롯에 아이템 채우기
    for i = 1, self.Capacity do
    	if remain <= 0 then
    		break
    	end

    	---@type ItemStack
    	local stack = self.ItemStacks[i]

    	if stack == nil then
    		continue
    	end

    	if stack.ItemId == itemId then
    		local addCount = math.min(maxStackCount - stack.Count, remain)
    		stack.Count = stack.Count + addCount
    		remain = remain - addCount

    	end
    end

    -- 새로운 슬롯을 생성해 남은 아이템을 담기
    for i = 1, self.Capacity do
    	if remain <= 0 then
    		break
    	end

    	if self.ItemStacks[i] ~= nil then
    		continue
    	end

    	local addCount = math.min(maxStackCount, remain)

    	local newStack = ItemStack()
    	newStack.SlotIndex = i
    	newStack.ItemId = itemId
    	newStack.Count = addCount
    	self.ItemStacks[i] = newStack

    	remain = remain - addCount
    end

    -- 모두 채워 넣고 남은 개수를 반환함
    return remain
}
```
3. `SendItemAddedEventToClient()` 함수를 생성합니다. 매개변수 타입은 **EventType - SimpleInventoryAddedEvent** 타입으로 설정하고, 매개변수 **event**를 추가합니다.```
[client]
void SendItemAddedEventToClient (SimpleInventoryItemAddedEvent event)
{
    local stack = ItemStack()
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount
    self.ItemStacks[event.SlotIndex] = stack

    self.Entity:SendEvent(event)
}
```
4. `SendItemAddedEvent()` 함수를 생성합니다. 매개변수 타입은 **StructType - ItemStack** 으로 설정하고, 매개변수 **stack**을 추가합니다.```
[server only]
void SendItemAddedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemAddedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendItemAddedEventToClient(event, self.Entity.PlayerComponent.UserId)
}
```
5. AddItem() 함수의 새로운 슬롯을 생성해 남은 아이템을 담기 단락의 `remain = remain - addCount` 아래에서 `SendItemAddedEvent()` 함수를 호출합니다.```
self:SendItemAddedEvent(newStack)
```

# 아이템 데이터 변경하기

1. `SendItemModifiedEventToClient()` 함수를 생성합니다. 매개변수 타입은 **EventType - SimpleInventoryItemModifiedEvent** 로 설정하고, 매개변수 **event**를 추가합니다.```
[client]
void SendItemModifiedEventToClient (SimpleInventoryItemModifiedEvent event)
{
    ---@type ItemStack
    local stack = self.ItemStacks[event.SlotIndex]
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount

    self.Entity:SendEvent(event)
}
```
2. `SendItemModifiedEvent()` 함수를 추가합니다. 매개변수 타입은 **StructType - ItemStack**으로 성정하고, 매개변수 **stack**을 추가합니다. 아이템 변경 이벤트인 `SimpleInventoryItemModifiedEvent`를 발생시키도록 작성합니다.```
[server only]
void SendItemModifiedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemModifiedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendItemModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}
```
3. `AddItem()` 함수의 기존 슬롯에 아이템 채우기 단락의 `remain = remain - addCount` 아래에서 `SendItemModifiedEvent()` 함수를 호출합니다.```
 self:SendItemModifiedEvent(stack)
```
4. 새로운 `HasSpaceFor()` 함수를 생성하고, 매개변수 **itemId, itemCount**를 추가합니다. itemId에 해당하는 아이템을 itemCount만큼 인벤토리에 담을 수 있는지 확인할 수 있도록 아래와 같이 작성합니다.```
[server only]
boolean HasSpaceFor (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[SimpleInventory] (HasSpaceFor) 아이템 Id 오류: " .. itemId)
    	return
    end

    if itemCount <= 0 then
    	log_error("[SimpleInventory] (HasSpaceFor) 아이템 Count 오류: " .. itemCount)
    	return
    end

    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount

    for i = 1, self.Capacity do
    	if remain <= 0 then
    		break
    	end

    	---@type ItemStack
    	local stack = self.ItemStacks[i]

    	if stack == nil then
    		remain = remain - maxStackCount
    	elseif stack.ItemId == itemId then
    		remain = remain - math.min(maxStackCount - stack.Count, remain)
    	end
    end

    return (remain <= 0)
}
```

# 아이템 제거하기

1. `SendItemRemovedEventToClient()` 함수를 추가합니다.```
[client]
void SendItemRemovedEventToClient (SimpleInventoryItemRemovedEvent event)
{
    self.ItemStacks[event.SlotIndex] = nil

    self.Entity:SendEvent(event)
}
```
2. `SendItemRemovedEvent()` 함수를 추가합니다. ItemsStack 타입의 매개변수 **stack**을 추가합니다.```
[server only]
void SendItemRemovedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemRemovedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendItemRemovedEventToClient(event, self.Entity.PlayerComponent.UserId)
}
```
3. 새로운 `RemoveItemAt()` 함수를 생성하고 매개변수 **slotIndex, itemCount**를 추가합니다. 이 함수는 특정 슬롯의 아이템을 제거합니다. **slotIndex**에 해당하는 슬롯의 아이템 수를 **itemCount**만큼 감소시킬 수 있도록 아래와 같이 작성합니다.
  - 제거 후에도 아이템이 남아있다면 `SendItemRemovedEvent()`에서 `SimpleInventoryItemRemovedEvent` 이벤트를 발생시킵니다.
  - 아이템이 모두 제거되면 아이템 제거 이벤트 `SimpleInventoryItemRemovedEvent`를 발생시킵니다.
  - 아이템 제거에 성공하면 true, 실패하면 false를 반환합니다.```
[server only]
boolean RemoveItemAt (integer slotIndex, integer itemCount)
{
    if slotIndex < 1 or slotIndex > self.Capacity then
    	log_error("[SimpleInventory] (RemoveItemAt) 슬롯 인덱스 오류: " .. slotIndex)
    	return false
    end

    if itemCount < 1 then
    	log_error("[SimpleInventory] (RemoveItemAt) 아이템 Count 오류: " .. itemCount)
    	return false
    end

    ---@type ItemStack
    local stack = self.ItemStacks[slotIndex]

    if stack == nil then
    	log_error("[SimpleInventory] (RemoveItemAt) 슬롯에 아이템이 없습니다.")
    	return false
    end

    if stack.Count < itemCount then
    	log_error("[SimpleInventory] (RemoveItemAt) 아이템 개수가 부족합니다.")
    	return false
    end

    stack.Count -= itemCount

    if stack.Count > 0 then
    	self:SendItemModifiedEvent(stack)
    else
    	self.ItemStacks[slotIndex] = nil
    	self:SendItemRemovedEvent(stack)
    end

    return true
}
```

# 메소 데이터 변경하기

1. `SendMesoModifiedEventToClient()` 함수를 추가합니다.```
[client]
void SendMesoModifiedEventToClient (SimpleInventoryMesoModifiedEvent event)
{
    self.Meso = event.Meso

    self.Entity:SendEvent(event)
}
```
2. `SendMesoModifiedEvent()` 함수를 추가합니다.```
[server only]
void SendMesoModifiedEvent (integer meso)
{
    local event = SimpleInventoryMesoModifiedEvent()
    event.Meso = meso
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendMesoModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}
```
3. `SetMeso()` 함수를 추가하고, 매개변수 **meso**를 추가합니다.```
[server only]
void SetMeso (integer meso)
{
    self.Meso = meso
    self:SendMesoModifiedEvent(meso)
}
```

# 전체 스크립트

#### SimpleInventory

```
Property:
[None]
integer Meso = 10000
[None]
table ItemStacks = {}
[None]
integer Capacity = 16

Method:
[server only]
void OnBeginPlay()
{    
    -- 데이터 스토리지에서 인벤토리 데이터를 불러옴
    local userId = self.Entity.PlayerComponent.UserId
    local userDataStorage = _DataStorageService:GetUserDataStorage(userId)
    local errorCode, loadData = userDataStorage:GetAndWait("SimpleInventoryData")
    
    -- 데이터 로드에 실패하면 에러 코드 출력
    if errorCode ~= 0 then
    	log_error("[SimpleInventory] 데이터 로딩 실패:" .. tostring(errorCode))
    	return
    end
    
    -- 로드된 데이터가 있다면 적용
    if loadData ~= nil then
    	self:Deserialize(loadData)
    end
    
    -- 인벤토리 초기화 이벤트 발생
    self:SendInitializedEvent()
    
    -- 일정 시간마다 자동 저장
    local saveInventory = function()
    	local saveData = self:Serialize()
    	UserDataStorage:SetAsync("SimpleInventoryData", saveData, function() log ("[SimpleInventory] 저장 완료") end)
    	log ("[SimpleInventory] 저장 중...")
    end
    
    local saveInterval = 300
    _TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
}
    
string Serialize()
{
    local dataTable = {}
    local itemStacks = {}
    
    dataTable.Meso = self.Meso
    
    for _, stack in pairs(self.ItemStacks) do
    	local stackData = stack:ToTable()
    	table.insert(itemStacks, stackData)
    end
    
    if #itemStacks > 0 then
    	dataTable.ItemStacks = itemStacks
    end
    
    return _HttpService:JSONEncode(dataTable)
}

void Deserialize (string dataString)
{
    if dataString == nil or dataString == "" then
    	return
    end
    
    local dataTable = _HttpService:JSONDecode(dataString)
    local meso = dataTable.Meso
    local stacks = dataTable.ItemStacks
    
    self.Meso = math.tointeger(meso)
    
    if stacks ~= nil then
    	for _, stackData in pairs(stacks) do
    		local stack = ItemStack()
    		stack:FromTable(stackData)
    		self.ItemStacks[stack.SlotIndex] = stack
    	end
    end
}

[server only]
integer AddItem (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]
    
    if itemInfo == nil then
    	log_error("[SimpleInventory] (AddItem) 아이템 Id 오류: " .. itemId)
    	return
    end
    
    if itemCount <= 0 then
    	log_error("[SimpleInventory] (AddItem) 아이템 Count 오류: " .. itemCount)
    	return
    end
    
    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount
    
    -- 기존 슬롯에 채워 넣음
    for i = 1, self.Capacity do
        if remain <= 0 then
            break
        end
    
    ---@type ItemStack
    local stack = self.ItemStacks[i]
    
    if stack == nil then
        continue
    end
    
        if stack.ItemId == itemId then
            local addCount = math.min(maxStackCount - stack.Count, remain)
            stack.Count = stack.Count + addCount
            remain = remain - addCount
    
            self:SendItemModifiedEvent(stack)
        end
    end
    
    -- 남은 것은 새로운 슬롯을 생성해 채워 넣음
    for i = 1, self.Capacity do
    if remain <= 0 then
        break
    end

    if self.ItemStacks[i] ~= nil then
        continue
    end
    
    local addCount = math.min(maxStackCount, remain)
    
    local newStack = ItemStack()
    newStack.SlotIndex = i
    newStack.ItemId = itemId
    newStack.Count = addCount
    self.ItemStacks[i] = newStack
    
    remain = remain - addCount
    
    self:SendItemAddedEvent(newStack)
    end
    
    -- 모두 채워 넣고 남은 개수를 반환함
    return remain
}

[server only]
boolean HasSpaceFor (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[SimpleInventory] (HasSpaceFor) 아이템 Id 오류: " .. itemId)
    	return
    end

    if itemCount <= 0 then
    	log_error("[SimpleInventory] (HasSpaceFor) 아이템 Count 오류: " .. itemCount)
    	return
    end

    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount

    for i = 1, self.Capacity do
    	if remain <= 0 then
    		break
    	end

    	---@type ItemStack
    	local stack = self.ItemStacks[i]

    	if stack == nil then
    		remain = remain - maxStackCount
    	elseif stack.ItemId == itemId then
    		remain = remain - math.min(maxStackCount - stack.Count, remain)
    	end
    end

    return (remain <= 0)
}


[server only]
boolean RemoveItemAt (integer slotIndex, integer itemCount)
{
    if slotIndex < 1 or slotIndex > self.Capacity then
    	log_error("[SimpleInventory] (RemoveItemAt) 슬롯 인덱스 오류: " .. slotIndex)
    	return false
    end

    if itemCount < 1 then
    	log_error("[SimpleInventory] (RemoveItemAt) 아이템 Count 오류: " .. itemCount)
    	return false
    end

    ---@type ItemStack
    local stack = self.ItemStacks[slotIndex]

    if stack == nil then
    	log_error("[SimpleInventory] (RemoveItemAt) 슬롯에 아이템이 없습니다.")
    	return false
    end

    if stack.Count < itemCount then
    	log_error("[SimpleInventory] (RemoveItemAt) 아이템 개수가 부족합니다.")
    	return false
    end

    stack.Count -= itemCount

    if stack.Count > 0 then
    	self:SendItemModifiedEvent(stack)
    else
    	self.ItemStacks[slotIndex] = nil
    	self:SendItemRemovedEvent(stack)
    end

    return true
}

[server only]
void SetMeso (integer meso)
{
    self.Meso = meso
    self:SendMesoModifiedEvent(meso)
}

[server only]
void SendInitializedEvent()
{
    local event = SimpleInventoryInitializedEvent()
    event.Meso = self.Meso
    event.ItemStacks = self.ItemStacks
    self.Entity:SendEvent(event)
    
    -- 로컬 플레이어에게만 전달
    self:SendInitializedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendInitializedEventToClient (SimpleInventoryInitializedEvent event)
{
    self.Meso = event.Meso
    self.ItemStacks = event.ItemStacks
    self.Entity:SendEvent(event)
}

[server only]
void SendItemAddedEvent(ItemStack stack)
{
    local event = SimpleInventoryItemAddedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)
    
    -- 로컬 플레이어에게만 전달
    self:SendItemAddedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendItemAddedEventToClient (SimpleInventoryItemAddedEvent event)
{
    local stack = ItemStack()
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount
    self.ItemStacks[event.SlotIndex] = stack
    
    self.Entity:SendEvent(event)
}

[server only]
void SendItemModifiedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemModifiedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendItemModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[Client]
void SendItemModifiedEventToClient (SimpleInventoryItemModifiedEvent event)
{
    ---@type ItemStack
    local stack = self.ItemStacks[event.SlotIndex]
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount
    
    self.Entity:SendEvent(event)
}


[server only]
void SendMesoModifiedEvent (integer meso)
{
    local event = SimpleInventoryMesoModifiedEvent()
    event.Meso = meso
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendMesoModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendMesoModifiedEventToClient (SimpleInventoryMesoModifiedEvent event)
{
    self.Meso = event.Meso
    
    self.Entity:SendEvent(event)    
}

[server only]
void SendItemRemovedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemRemovedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    self.Entity:SendEvent(event)

    -- 로컬 플레이어에게만 전달
    self:SendItemRemovedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendItemRemovedEventToClient (SimpleInventoryItemRemovedEvent event)
{
    self.ItemStacks[event.SlotIndex] = nil
    
    self.Entity:SendEvent(event)
}

Entity Event Handler:
[service: UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------
    
    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------
    
    local thisUserId = self.Entity.PlayerComponent.UserId
    
    if thisUserId ~= UserId then
    	return
    end
    
    -- 플레이를 끝낼 때 인벤토리 데이터 정보를 저장함
    local userDataStorage = _DataStorageService:GetUserDataStorage(thisUserId)
    if userDataStorage ~= nil then
    	local saveData = self:Serialize()
    	userDataStorage:SetAndWait("SimpleInventoryData", saveData)
    end
}
```

#### SimpleInventoryItemAddedEvent

```
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```

#### SimpleInventoryItemModifiedEvent

```
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```

#### SimpleInventoryItemRemovedEvent

```
Property:
integer SlotIndex = 0
string ItemId = ""
```

#### SimpleInventoryMesoModifiedEvent

```
Property:
integer Meso = 0
```

Update 2025-11-20 PM 02:03


# 5. 인벤토리 스크립트 작성

메소와 아이템 데이터가 변경될 때 인벤토리 UI도 변경될 수 있도록 만들어 봅시다. 이번 과정에서는 `UIInventory` 컴포넌트만 수정합니다.

# 인벤토리 변경값 UI에 반영하기

인벤토리 메소와 아이템 값 변경에 맞춰 UI가 갱신될 수 있도록 만들어봅시다. `UIInventory` 컴포넌트는 인벤토리 프리셋 추가 시 함께 자동으로 추가되는 컴포넌트입니다.

> **Tip.** 이 컴포넌트의 기존 **Event Handler를 모두 삭제**한 뒤 아래 과정을 따라 만들어 봅시다.

1. 기존 프로퍼티를 유지한 채, 새로운 **MesoUI, SlotList** 프로퍼티를 추가합니다.```
Property:
[None]
Entity MesoUI = nil
[None]
table SlotList = {}
```
2. `OnBeginPlay()` 함수 내용을 삭제하고, 아래와 같이 변경합니다.```
Method:
[client only]
void OnBeginPlay()
{
    self.itemUI =_EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/Inventory_ScrollView/item_slot")
    self.itemUI:SetEnable(false)
    self.scrollView = _EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/Inventory_ScrollView")
    self.MesoUI = _EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/CoinPanel/coin_count")

    -- add UI Preset/Buttons
    local inventoryButton = _EntityService:GetEntityByPath(self.inventoryBtnPath)
    if inventoryButton ~= nil then
    	local openFunc = function()
    		self.Entity.Enable = true
    	end
    	if inventoryButton.ButtonComponent == nil then
    		inventoryButton:AddComponent("MOD.Core.ButtonComponent")
    	end
    	inventoryButton:ConnectEvent(ButtonClickEvent, openFunc)
    end

    -- 닫기 버튼
    local closeButton = _EntityService:GetEntityByPath(self.Entity.Path .. "/InventoryPanel/CloseButton")
    local closeFunc = function()
    	self.Entity.Enable = false
    end

    closeButton:ConnectEvent(ButtonClickEvent, closeFunc)

    -- 인벤토리 용량만큼 슬롯을 미리 생성
    local capacity = _UserService.LocalPlayer.SimpleInventory.Capacity
    for i = 1, capacity do
    	local itemSlot = _SpawnService:SpawnByEntity(self.itemUI, "Slot", Vector3.zero, self.scrollView)
    	itemSlot.UIInventoryItemSlot:Clear()

    	self.SlotList[i] = itemSlot
    end
}
```
3. 새로운 함수 `SetSlot()`를 추가합니다. 매개 변수 **slotIndex, itemId, itemCount**를 추가합니다. slotIndex에 해당하는 슬롯에 표시할 아이템과 개수를 설정합니다.```
[client only]
void SetSlot (integer slotIndex, string itemId, integer itemCount)
{
    local slot = self.SlotList[slotIndex]
    slot.UIInventoryItemSlot:SetData(slotIndex, itemId, itemCount)
}
```
4. 새로운 함수 `ClearSlot()`를 추가하고 slotIndex에 해당하는 슬롯 내용을 비울 수 있도록 아래와 같이 작성합니다.```
void ClearSlot (integer slotIndex)
{
    local slot = self.SlotList[slotIndex]
    slot.UIInventoryItemSlot:Clear()
}
```
5. 새로운 함수 `SetMeso()`를 추가하고 메소UI에 메소 값이 나타날 수 있도록 아래와 같이 작성합니다.```
[client only]
void SetMeso (integer meso)
{
    self.MesoUI.TextComponent.Text = tostring(meso)
}
```

#### Entity Event Handler 추가

1. `SimpleInventoryInitializedEvent`를 추가합니다. 이벤트 중계자를 localPlayer로 변경합니다.```
[localplayer]
HandleSimpleInventoryInitializedEvent (SimpleInventoryInitializedEvent event)
{
    -- Parameters
    local Meso = event.Meso
    local ItemStacks = event.ItemStacks
    ---------------------------------------------------------

    self:SetMeso(Meso)

    for _, stack in pairs(ItemStacks) do
    	if stack ~= nil then
    		self:SetSlot(stack.SlotIndex, stack.ItemId, stack.Count)
    	end
    end    
}
```
2. `SimpleInventoryItemAddedEvent`를 추가합니다. 이벤트 중계자를 localPlayer로 변경합니다.```
[localplayer]
HandleSimpleInventoryItemAddedEvent (SimpleInventoryItemAddedEvent event)
{
    -- Parameters
    local SlotIndex = event.SlotIndex
    local ItemId = event.ItemId
    local ItemCount = event.ItemCount
    ---------------------------------------------------------

    self:SetSlot(SlotIndex, ItemId, ItemCount)
}
```
3. `SimpleInventoryItemModifiedEvent`를 추가합니다. 이벤트 중계자를 localPlayer로 변경합니다.```
[localplayer]
HandleSimpleInventoryItemModifiedEvent (SimpleInventoryItemModifiedEvent event)
{
    -- Parameters
    local SlotIndex = event.SlotIndex
    local ItemId = event.ItemId
    local ItemCount = event.ItemCount
    ---------------------------------------------------------

    if ItemCount > 0 then
    	self:SetSlot(SlotIndex, ItemId, ItemCount)
    else
    	self:ClearSlot(SlotIndex)
    end
}
```
4. `SimpleInventoryMesoModifiedEvent`를 추가합니다. 이벤트 중계자를 localPlayer로 변경합니다.```
[localplayer]
HandleSimpleInventoryMesoModifiedEvent (SimpleInventoryMesoModifiedEvent event)
{
    -- Parameters
    local Meso = event.Meso
    ---------------------------------------------------------

    self:SetMeso(Meso)
}
```
5. `SimpleInventoryItemRemovedEvent`를 추가합니다. 이벤트 중계자를 localPlayer로 변경합니다.```
[localplayer]
HandleSimpleInventoryItemRemovedEvent (SimpleInventoryItemRemovedEvent event)
{
    -- Parameters
    local SlotIndex = event.SlotIndex
    local ItemId = event.ItemId
    ---------------------------------------------------------

    self:ClearSlot(SlotIndex)
}
```

Update 2025-11-17 PM 08:15


# 6. UIInventoryItemSlot 수정

UIInventoryItemSlot 컴포넌트 내용을 변경해 UI 인벤토리에서 아이템 섬네일과 개수를 표시할 수 있도록 아래와 같이 작성합니다. 중간 확인을 위해 인벤토리에서 아이템을 누르면 삭제되도록 만들어봅시다.

# UIInventoryItemSlot 수정

1. **UIItemSlot** 컴포넌트의 이름을 `UIInventoryItemSlot` 로 변경합니다.
  > **Tip.** **ui - DefaultGroup - Inventory - InventoryPanel - Inventory_ScrollView - item_Slot**에 `UIInventoryItemSlot` 컴포넌트가 추가되어 있습니다.
2. 기존 프로퍼티를 모두 **삭제**한 뒤, 새로운 **SlotIndex, ItemId, ItemCount** 매개변수를 추가합니다.```
Property:
[None]
integer SlotIndex = 0
[None]
string ItemId = ""
[None]
integer ItemCount = 0
```
3. `SetData()`함수를 수정합니다. 기존 매개변수를 삭제하고, **slotIndex, itemId, itemCount** 매개변수를 추가합니다. ---@ 어노테이션을 사용해 변수 타입을 명시적으로 지정해 활용합니다.```
void SetData (integer slotIndex, string itemId, integer itemCount)
{
    ---@type ItemInfo
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[UIInventoryItemSlot] (SetData) 아이템 Id 오류")
    	return
    end

    local imageEntity = self.Entity:GetChildByName("img_slot")
    local countEntity = imageEntity:GetChildByName("item_count")

    imageEntity.SpriteGUIRendererComponent.ImageRUID = itemInfo.IconRUID
    countEntity.TextComponent.Text = tostring(itemCount)
    countEntity:SetEnable(true)

    self.SlotIndex = slotIndex
    self.ItemId = itemId
}
```
4. 새로운 `Clear()` 함수를 추가합니다.```
void Clear ()
{
    local imageEntity = self.Entity:GetChildByName("img_slot")
    imageEntity.SpriteGUIRendererComponent.ImageRUID = "129f02486c2baef49a41b31ce16171f6"
    local countEntity = imageEntity:GetChildByName("item_count")
    countEntity.TextComponent.Text = nil
    countEntity:SetEnable(false)

    self.ItemId = ""
    self.ItemCount = 0
}
```

# 중간 확인

지금까지 만든 인벤토리가 정상적으로 작동하는지 확인해봅시다. 임의의 데이터를 추가해 인벤토리의 슬롯을 눌러 지울 수 있는지 확인합니다. 정상적으로 작동하는 것을 확인했으면 확인용을 추가한 코드와 설정을 다시 변경합니다.

![InventoryTest](https://mod-file.dn.nexoncdn.co.kr/bbs/1698641029156ec062c74233147f7ae9c793faf306d00.gif)

1. `UIInventoryItemSlot` 컴포넌트의 Event Handler에 `ButtonClickEvent` 내용을 수정합니다.```
[self]
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------

    -- 슬롯에 아이템이 있을 때만
    if self.ItemId == "" then
        return
    end

    -- 슬롯의 아이템 제거
    local inventory = _UserService.LocalPlayer.SimpleInventory
    ---@type ItemStack
    local itemStack = inventory.ItemStacks[self.SlotIndex]
    local currItemCount = itemStack.Count

    inventory:RemoveItemAt(self.SlotIndex, currItemCount)
}
```
2. `SimpleInventory` 컴포넌트의 `RemoveItemAt()` 함수의 실행공간을 **server**로 임시 변경합니다.
3. `SimpleInventory` 컴포넌트의 `OnBeginPlay()` 함수의 `log_error("[SimpleInventory] 데이터 로딩 실패:" .. tostring(errorCode)) end` 아래에 중간 확인을 위해 임의의 데이터를 추가합니다.```
    self:AddItem("potion_red", 1)
    self:AddItem("potion_blue", 1)
    self:AddItem("potion_redpill", 1)
    self:AddItem("potion_bluepill", 1)
    self:AddItem("arrow", 1)
```
4. 시작을 눌러 인벤토리에서 아이템 슬롯을 클릭하면 아이템을 삭제할 수 있는지 확인합니다. 정상적으로 삭제되는 것을 확인했다면, 위에 작성한 중간 확인용 코드를 모두 삭제합니다.

Update 2025-11-17 PM 08:15


# 7. 상점 UI 만들기

# 상점 UI 만들기

인벤토리 프리셋을 활용해 상점 UI를 만들어 봅시다. ![ShopUI](https://mod-file.dn.nexoncdn.co.kr/bbs/169820059140328cb3fa93170433e835c486be9c66998.png)

1. **Preset List - UI - 인벤토리**를 선택해 DefaultGroup에 추가해 배치합니다.
2. 자동으로 inventory_1 UI엔티티에 추가된 UIInventory 컴포넌트를 **제거**합니다. ![RemoveUIInventory](https://mod-file.dn.nexoncdn.co.kr/bbs/170236046487131c5899e70634afd8c5755fb5c0e24df.png)
3. UIItemSlot 컴포넌트를 **삭제**합니다.
  > **Tip.** 인벤토리 프리셋을 UI 그룹에 추가하면, UIInventory, UIItemSlot 컴포넌트가 자동으로 생성됩니다.
4. 상점에서 필요하지 않은 메소 UI를 삭제합니다. **CoinPanel UI**엔티티와 하위 UI엔티티 **coin_count, coin_icon**을 삭제합니다.
5. **item_count** UI엔티티를 삭제합니다.
6. 추가된 기존 UI 엔티티 이름을 변경합니다. | 기존 이름 | 수정 이름 |
| --- | --- | | inventory_1 | Shop | | InventoryPanel | ShopPanel | | Inventory_ScrollView | Shop_ScrollView |
7. Shop_ScrollView의 ScrollLayoutGroupComponent **Type**과 **Spacing** 값을 변경합니다.
  - Type: Vertical
  - Spacing: 10
8. **item_slot** 하위에 **Create Entity as Child - CreateText** 2번, **CreateUISprite** 1번 선택해 생성합니다. 상품의 이름과 가격을 확인할 수 있도록 적절한 위치에 배치하고 이름을 변경합니다.
  - item_name 상품의 이름이 표시됩니다.
  - item_price: 상품의 가격이 표시됩니다.
  - item_price_icon: 메소 아이콘이 표시됩니다.
    - ImageRUID: 1aadfa1e39c3c4e4ea0339287bca2961 ![itemSlot](https://mod-file.dn.nexoncdn.co.kr/bbs/1698197645889deb92ab5cdc440a0a762951aa069cac7.png)
9. **ShopPanel - Title** UI엔티티의 TextComponent의 **Text** 값을 **상점**으로 변경합니다.

# 구매 팝업 UI 만들기

1. **Preset List - UI - 대화창**을 선택해 **DefaultGroup - Shop**에 배치합니다. 상위 UI엔티티 이름을 **BuyPopup**으로 변경합니다.
2. **BuyPopup** 하위 엔티티 중 **btn_end, btn_complete, btn_next, btn_prev UI**엔티티를 삭제합니다.
3. **txt_script** UI엔티티의 Text 컴포넌트 내용을 변경합니다.
  - 구매할 개수를 입력하고 확인 버튼을 누르세요.
4. img_npc UI 엔티티의 이름을 **img_item**로 변경합니다. SpriteGUIRendererComponent의 **PreserveSprite**를 **None**으로 변경합니다.
5. BuyPopup 하위에 새로운 Input Text를 추가하고 **input_count**로 이름을 변경합니다. 확인창 중앙에 배치합니다. ![buypopup](https://mod-file.dn.nexoncdn.co.kr/bbs/16981916240759e7308847f334527a345c230dba6c1c6.png)

# 판매 팝업 UI 만들기

1. **Preset List - UI - 대화창**을 선택해 **DefaultGroup - Shop** 하위에 배치하고, 상위 UI엔티티 이름을 **SellPopup**으로 변경합니다.
2. **SellPopup** UI엔티티의 하위 엔티티 중 **btn_end, btn_complete, btn_next, btn_prev** UI엔티티를 삭제합니다.
3. **txt_script** UI엔티티의 Text 컴포넌트 내용을 변경합니다.
  - 판매할 개수를 입력하고 확인 버튼을 누르세요.
4. img_npc UI 엔티티의 이름을 **img_item**로 변경합니다. SpriteGUIRendererComponent의 **PreserveSprite**를 **None**으로 변경합니다.
5. SellPopup 하위에 새로운 Input Text를 추가하고 **input_count**로 이름을 변경합니다. 확인창 중앙에 배치합니다. ![sellpopup](https://mod-file.dn.nexoncdn.co.kr/bbs/16981916536246decd0ab507b4334b555707cc6ea9990.png)

> **더 알아보기** UI는 순서에 영향을 받으므로 팝업 UI는 상점, 인벤토리 UI보다 앞에 배치되어야 합니다.

Update 2025-11-17 PM 08:15


# 8. 상점 로직 만들기Ⅰ

# 상점 로직 작성

1. **Workspace - MyDesk - Create Scripts - Create Logic**을 선택해 새로운 `Shop` 로직을 생성합니다.
2. `Buy()`함수를 생성해 itemId에 해당하는 상품을 itemCount만큼 구매하고, 메소를 차감하도록 작성합니다.```
Method:
[server]
void Buy (string itemId, integer itemCount)
{
    -- itemId에 해당하는 상품을 itemCount만큼 구매하고 메소를 차감합니다.

    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[Shop] (Buy) 아이템 Id 오류: " .. itemId)
    	return
    end

    local totalPrice = itemInfo.Price * itemCount

    local customerUserId = senderUserId
    local user = _UserService:GetUserEntityByUserId(customerUserId)
    local inventory = user.SimpleInventory
    local currMeso = inventory.Meso

    if inventory:HasSpaceFor(itemId, itemCount) == false then
    	log_error("[Shop] (Buy) 인벤토리 공간이 부족합니다.")
    	return
    end

    if currMeso < totalPrice then
    	log ("[Shop] (Buy) 메소가 부족합니다.")
    	return
    end

    inventory:SetMeso(currMeso - totalPrice)
    inventory:AddItem(itemId, itemCount)
}
```
3. `Sell()` 함수를 추가하고 매개변수 **inventorySlotIndex, itemCount**를 추가합니다. inventorySlotIndex에 있는 인벤토리 아이템을 itemCount만큼 판매하고 메소를 획득하도록 작성합니다. 이때 판매 가격은 구매 가격의 절반이 되도록 함께 작성합니다.```
[server]
void Sell (integer inventorySlotIndex integer itemCount)
{
    -- inventorySlotIndex에 있는 인벤토리 아이템을 itemCount만큼 판매하고 메소를 획득합니다.
    -- 구매 가격의 절반 가격으로 판매합니다.

    local customerUserId = senderUserId
    local user = _UserService:GetUserEntityByUserId(customerUserId)
    local inventory = user.SimpleInventory

    ---@type ItemStack
    local itemStack = inventory.ItemStacks[inventorySlotIndex]

    if itemStack == nil then
    	log_error("[Shop] (Sell) 아이템이 유효하지 않습니다.")
    	return
    end

    if itemStack.Count < itemCount then
    	log_error("[Shop] (Sell) 아이템 개수가 부족합니다.")
    	return
    end

    ---@type ItemInfo
    local itemInfo = _Data.ItemTable[itemStack.ItemId]
    local totalPrice = math.floor(itemInfo.Price * 0.5) * itemCount
    local currMeso = inventory.Meso

    inventory:SetMeso(currMeso + totalPrice)
    inventory:RemoveItemAt(inventorySlotIndex, itemCount)
}
```

Update 2025-11-17 PM 08:15


# 9. 상점 로직 만들기Ⅱ

# UIShop

1. 새로운 `UIShop` 컴포넌트를 생성합니다. **ui - DefaultGroup - Shop**에 컴포넌트를 추가합니다. ![UIShop](https://mod-file.dn.nexoncdn.co.kr/bbs/16986412576855dfd79bc352a407f9341732f6bdfd735.png)
2. 새로운 **itemUI, scrollView, ShopBtnPath, SyncTable** 프로퍼티를 추가합니다.```
Property:
[None]
Entity itemUI = nil
[None]
Entity scrollView = nil
[None]
string ShopBtnPath = "/ui/DefaultGroup/RPGButtons/btn_shop"
[None]
SyncTable<string, Entity> SlotItems
```
3. `OnBeginPlay()` 함수를 추가합니다.```
[client only]
void OnBeginPlay()
{
    self.itemUI =_EntityService:GetEntityByPath(self.Entity.Path .. "/ShopPanel/Shop_ScrollView/item_slot")
    self.itemUI:SetEnable(false)
    self.scrollView = _EntityService:GetEntityByPath(self.Entity.Path .. "/ShopPanel/Shop_ScrollView")

    -- UI Preset/Buttons 추가
    local inventoryButton = _EntityService:GetEntityByPath(self.ShopBtnPath)
    if inventoryButton ~= nil then
    	local openFunc = function()
    		self.Entity.Enable = true
    	end
    	if inventoryButton.ButtonComponent == nil then
    		inventoryButton:AddComponent("MOD.Core.ButtonComponent")
    	end
    	inventoryButton:ConnectEvent(ButtonClickEvent, openFunc)
    end

    -- 닫기 버튼
    local closeButton = _EntityService:GetEntityByPath(self.Entity.Path .. "/ShopPanel/CloseButton")
    local closeFunc = function()
    	self.Entity.Enable = false
    end

    closeButton:ConnectEvent(ButtonClickEvent, closeFunc)

}
```
4. `InitializeItemList()` 함수를 추가합니다.```
[client only]
void InitializeItemList()
{
    -- 상품 리스트에 아이템을 인덱스 순서로 배치합니다.

    local itemTable = _Data.ItemTable
    local itemCount = _Data.ItemTableRowCount

    -- 아이템 개수만큼 빈 슬롯 준비 
    local shopItemSlots = {}
    for i = 1, itemCount do
    	shopItemSlots[i] = _SpawnService:SpawnByEntity(self.itemUI, "Item", Vector3.zero, self.scrollView) 
    end

    -- 슬롯에 아이템을 인덱스 순서로 배치
    for k, v in pairs(itemTable) do
    	---@type ItemInfo
    	local itemInfo = v
    	shopItemSlots[itemInfo.Index].UIShopItemSlot:SetData(itemInfo.Id, itemInfo.Price)
    end
}
```
5. `InitializeItemList()`를 호출할 수 있도록 `OnBeginPlay()` 함수 가장 아래에 코드를 추가합니다.```
-- 상품 리스트 초기화
self:InitializeItemList()
```

# UIShopItemSlot

1. UIShopItemSlot 컴포넌트를 생성하고, **ui - DefaultGroup - Shop - ShopPanel - Shop_ScrollView - Item_Slot**에 추가합니다. ![UIShopItemSlot](https://mod-file.dn.nexoncdn.co.kr/bbs/170228214334842cb5138c86042afba807a937e704e97.png)
2. **ItemId** 프로퍼티를 추가합니다.```
Property:
[None]
string ItemId = ""
```
3. `SetData()` 함수를 생성하고, **itemId, itemPrice** 매개변수를 추가합니다. UI에서 데이터 값이 보이도록 작성합니다.```
void SetData (string itemId, integer itemPrice)
{
    ---@type ItemInfo
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[UIShopItemSlot] (SetData) 아이템 Id 오류")
    	return 
    end

    local imageEntity = self.Entity:GetChildByName("img_slot")
    local nameEntity = self.Entity:GetChildByName("item_name")
    local priceEntity = self.Entity:GetChildByName("item_price")

    imageEntity.SpriteGUIRendererComponent.ImageRUID = itemInfo.IconRUID
    nameEntity.TextComponent.Text = itemInfo.Name
    priceEntity.TextComponent.Text = tostring(itemPrice) .. " 메소"

    self.ItemId = itemId
}
```
4. Event Handler에 **ButtonClickEvent**를 추가합니다. 상품을 선택하면 구매 팝업 UI가 나타나도록 작성합니다.```
[self]
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- Parameters
    local Entity = event.Entity
    --------------------------------------------------------

    local popup = _EntityService:GetEntityByPath("/ui/DefaultGroup/Shop/BuyPopup")
    popup.UIBuyPopup:SetData(self.ItemId)
    popup:SetEnable(true)
}
```

# UIBuyPopup

상점 UI에서 선택한 아이템의 정보를 표시합니다. 구매할 개수를 입력할 수 있습니다. 확인 버튼을 누르면 구매를 진행합니다.

1. `UIBuyPopup` 컴포넌트를 생성하고, BuyPopup UI엔티티에 추가합니다. ![UIBuyPopup](https://mod-file.dn.nexoncdn.co.kr/bbs/1698200292074300de1b22d3640dea82d2f4d987fbd48.png)
2. 새로운 프로퍼티를 추가합니다.```
Property:
[None]
string ItemId = ""
```
3. `OnBeginPlay` 함수를 추가합니다. 닫기 버튼을 눌러 UI를 닫을 수 있도록 작성합니다.```
[client only]
void OnBeginPlay()
{
    self.Entity:SetEnable(false)

    -- 닫기 버튼
    local closeButton = self.Entity:GetChildByName("btn_close")
    local closeFunc = function()
    	self.Entity.Enable = false
    end

    closeButton:ConnectEvent(ButtonClickEvent, closeFunc)
}
```
4. `SetData()` 함수를 추가합니다. string 타입의 매개변수 **itemId**를 추가합니다. 상점 UI에서 아이템 정보가 나타날 수 있도록 작성합니다.```
void SetData (string itemId)
{
    ---@type ItemInfo
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[UIBuyPopup] (SetData) 아이템 Id 오류: " .. itemId)
    	return
    end

    local imageEntity = self.Entity:GetChildByName("img_item")
    local nameEntity = self.Entity:GetChildByName("txt_name")
    local inputEntity = self.Entity:GetChildByName("input_count")

    imageEntity.SpriteGUIRendererComponent.ImageRUID = itemInfo.IconRUID
    nameEntity.TextComponent.Text = itemInfo.Name
    inputEntity.TextInputComponent.Text = "1"

    self.ItemId = itemId
}
```
5. Event Handler에 **ButtonClickEvent**를 추가합니다. 확인 버튼을 눌러 구매를 진행할 수 있도록, **Btn_accept** 버튼을 연결합니다. ![butAcceptBtn](https://mod-file.dn.nexoncdn.co.kr/bbs/16981925049545f96382626bc43ca9fc2e918fbf6a6fa.png)```
Event Handler:
[entity: btn_accept(/ui/DefaultGroup/Shop/BuyPopup/btn_accept)
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------

    -- 입력 받은 아이템 개수만큼 구매 진행
    local inputEntity = self.Entity:GetChildByName("input_count")
    local count = tonumber(inputEntity.TextInputComponent.Text)
    _Shop:Buy(self.ItemId, count)
    self.Entity:SetEnable(false)
}
```

# UIInventoryItemSlot 수정

`UIInventoryItemSlot` 컴포넌트에서 상품을 선택하면 판매 팝업이 나타나도록 만들어봅시다.

1. Event Handler에 **ButtonClickEvent**를 추가합니다. 판매 팝업이 활성화되도록 아래와 같이 작성합니다.```
[self]
HandleButtonClickEvent (ButtonClickEvent event)
{
    -- 슬롯에 아이템이 있을 때만
    if self.ItemId == "" then
        return
    end

    -- 판매 팝업 활성화
    local popup = _EntityService:GetEntityByPath("/ui/DefaultGroup/Shop/SellPopup")
    popup.UISellPopup:SetData(self.SlotIndex, self.ItemId, self.ItemCount)
    popup:SetEnable(true)
}
```

# UISellPopup

인벤토리에서 아이템을 눌러 판매할 아이템의 개수를 입력하고, 확인 버튼을 눌러 판매할 수 있도록 작성합니다.

1. `UISellPopup` 컴포넌트를 생성하고, SellPopup에 추가합니다. ![UISellPopup](https://mod-file.dn.nexoncdn.co.kr/bbs/1698200337212469b767d86644664a1fbebe99f4ce845.png)
2. integer 타입의 **InventorySlotIndex** 프로퍼티를 추가합니다.```
Property:
[None]
integer InventorySlotIndex = 0
```
3. **OnBeginPlay** 함수를 추가하고, 닫기 버튼을 ButtonClickEvent와 연결하도록 아래와 같이 작성합니다.```
[client only]
void OnBeginPlay ()
{
    self.Entity:SetEnable(false)

    -- 닫기 버튼
    local closeButton = self.Entity:GetChildByName("btn_close")
    local closeFunc = function()
    	self.Entity.Enable = false
    end

    closeButton:ConnectEvent(ButtonClickEvent, closeFunc)
}
```
4. `SetData()` 함수를 추가합니다. **inventorySlotIndex, itemId, itemCount** 매개변수를 추가합니다.```
void SetData (integer inventorySlotIndex, string itemId, integer itemCount)
{
    ---@type ItemInfo
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[UISellPopup] (SetData) 아이템 Id 오류: " .. itemId)
    	return
    end

    local imageEntity = self.Entity:GetChildByName("img_item")
    local nameEntity = self.Entity:GetChildByName("txt_name")
    local inputEntity = self.Entity:GetChildByName("input_count")
    imageEntity.SpriteGUIRendererComponent.ImageRUID = itemInfo.IconRUID
    nameEntity.TextComponent.Text = itemInfo.Name
    inputEntity.TextInputComponent.Text = tostring(itemCount)

    self.InventorySlotIndex = inventorySlotIndex
}
```
5. Event Handler에 **ButtonClickEvent**를 추가합니다. 확인 버튼을 눌러 판매를 진행할 수 있도록, **Btn_accept** 버튼을 연결합니다. ![SellAcceptBtn](https://mod-file.dn.nexoncdn.co.kr/bbs/16981942263688bea85845a3c403685ec856093dd836f.png) ```
[entity: btn_accept(/ui/DefaultGroup/Shop/SellPopup/btn_accept)
HandleButtonClickEvent (ButtonClickEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: ButtonComponent
    -- Space: Client
    ---------------------------------------------------------

    -- Parameters
    local Entity = event.Entity
    ---------------------------------------------------------

    -- 입력 받은 개수만큼 판매 진행
    local inputEntity = self.Entity:GetChildByName("input_count")
    local count = tonumber(inputEntity.TextInputComponent.Text)
    _Shop:Sell(self.InventorySlotIndex, count)
    self.Entity:SetEnable(false)
}
```

Update 2025-11-17 PM 08:15


# 카드와 UI 만들기

![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EA%B6%8C%EC%9E%A5%EB%8C%80%EC%83%81&amp;message=Lv.3&amp;color=orange)![custom](https://img.shields.io/static/v1?label=%ED%95%99%EC%8A%B5%EC%98%88%EC%83%81%EC%8B%9C%EA%B0%84&amp;message=30%EB%B6%84&amp;color=green)

리메이크한 월드에는 제작에 필요한 UI, 리소스, 그리고 비어 있는 컴포넌트 등이 있습니다. 단계 별로 하나씩 채워나가며 함께 게임을 완성해봅시다.

# CardPairGameUI 활성화

![1](https://mod-file.dn.nexoncdn.co.kr/bbs/1670403831746fd0717f80a5345a9a5e90b947c4bdbc5.png)

월드에 유저가 입장하면 **CardPairGameUI**가 **Enable**로 변경되도록 만들어 봅시다. 월드 전체에 적용되는 규칙이나 로직을 만들 때는 Logic을 사용합니다. **CardPairGameLogic** 로직에는 짝 맞추기에 기본적으로 필요한 UI를 켜거나 끄기, 카드 입력 등 전반적인 규칙을 작성할 것입니다.

우선 월드에 입장한 유저에게 게임 UI가 나타나도록 만들어봅시다. 아래 스크립트를 작성하기 전에는 UI 그룹에 게임판이 있음에도 해당 UI가 켜지지 않습니다. UI를 나타내기 위해선 Enable 프로퍼티를 True로 만들야 합니다.

```
Property:
[None]
Entity CardPairGameUI = /ui/CardPairGameUI

Method:
[client only]
void StartGame()
{
    self.CardPairGameUI.Enable = true
}

[client only]
void OnBeginPlay()
{
    self:StartGame()
}
```

# 카드 만들기

UI 보여주기에 성공했으니 이번에는 카드를 만들어 볼까요? 우리는 여러 장의 카드를 동시에 화면에 띄워야 합니다. 이럴 때는 필요한 만큼의 카드 엔티티를 미리 만드는 것보다는 틀을 만들어 한 번에 생성하는 것이 좋습니다. 동일한 프로퍼티를 가진 엔티티를 여러 번 사용한다면 모델을 사용하면 됩니다. 모델은 어떤 엔티티의 컴포넌트와 프로퍼티 정보를 가지고 있는 판본입니다. 모델에서 스트라이트를 지정해 동일한 행동을 하는 몬스터를 만든다거나, 같은 오브젝트를 배치하는 식으로 사용하기도 합니다. 하지만 우리는 모델을 만들어 월드에 배치하지 않고, 월드가 실행되면 특정 로직에 따라 UI에 소환되도록 만들어봅시다. 모델에 대한 자세한 내용은 [모델의 활용](/docs/?postId=461)를 참고하세요.

이제, 우리가 먼저 해야 할 일이 무엇인지 알겠지요? 카드 모델을 만들어 봅시다!

#### Model_Card 크기 확인하기

1. **Workspace - MyDesk - Models - Model_Card**를 선택합니다.
2. 모델의 기본 이미지를 설정합니다. **SpriteGUIRendererComponent**의 **ImageRUID**에 흰색 이미지를 사용하거나, 아래 투명 RUID를 사용합니다.

- 투명 RUID: 98c34caab88ee34459cb3e5807ac4219

#### 카드 데이터 셋 만들기

**Workspace - MyDesk - DataSets - CardSet**을 선택합니다. 이 데이터 셋은 위에서 만든 **Model_Card**에 여러 이미지를 불러오기 위해 사용합니다. 이미 29개의 SpriteRUID가 저장되어 있습니다. 총 30개가 필요하므로 마지막 하나는 직접 찾아 보도록 하겠습니다.

1. **Resource Storage** 열고, **MSW 리소스**를 선택합니다.
2. **Sprite - Item**에서 사용할 네모 모양 스프라이트를 찾습니다.
3. **Copy RUID**를 선택합니다. ![3](https://mod-file.dn.nexoncdn.co.kr/bbs/16741102359233fd9bb514f9c44e98afb390641862f36.png)
4. **CardSet**에 복사한 RUID를 붙여 넣습니다. ![4](https://mod-file.dn.nexoncdn.co.kr/bbs/16704113017760020d152c0be407a86c703472bcfe157.png)

> **Tip** 한 화면에서 두개의 창을 동시에 보고 싶을 경우에는 CardSet 패널의 위치를 조정할 수 있습니다.
> **Tip** 구글 스프레드 시트나 엑셀 프로그램 등을 활용해 DataSet을 만든 후 CardSet에 불러올 수 있습니다. [데이터 편집](/docs/?postId=69) 가이드를 참고하세요.

# 카드판 만들기

이제 카드를 화면에 불러낼 차례입니다. 카드를 불러내기 위해선 **/ui/CardPairGameUI/UI_Board/UI_Blocks/UI_Block_Group**를 활용합니다. ![5](https://mod-file.dn.nexoncdn.co.kr/bbs/16704128182139ae9ca7ae6324a899544f763688b7506.png) **UI_Block_Group**은 [ScrollLayoutGroupComponent](/apiReference?postId=382)를 활용했습니다. **ScollLayoutGroupComponent**는 여러 개의 엔티티를 펼쳐야할 때 사용합니다. 주로 상점이나, 인벤토리처럼 한 눈에 봐야하는 이미지가 많은 UI를 제작할 때 유용하게 사용합니다. 자식 UI Entity들의 크기와 배치 간격 등을 일괄적으로 적용할 수 있습니다. **UI_Block_Group**을 Hierarchy에서 찾아 프로퍼티 에디터를 열어 프로퍼티 값을 확인합니다. 값이 아래와 동일하게 적용된 것을 확인했다면, 이제 카드를 소환하는 스크립트를 작성해봅시다.

![6](https://mod-file.dn.nexoncdn.co.kr/bbs/1674110690186be01644f71954e2e8184dad5dbd2d07b.png)

| 프로퍼티 | 값 | 설명 |
| --- | --- | --- |
| Padding | top:15, right, left, bottom:0 | 상단의 여유 공간을 15로 설정합니다. |
| CellSize | 90, 90 | 펼쳐질 카드의 크기를 90, 90 크기로 설정합니다. |
| Constraint | FixedColumnCount | ScorollLayoutGroupComponent의 설정합니다. FixedColumnCount로 설정했기 때문에 ConstraintCount에 입력한 개수가 보드판에 적용됩니다. |
| ConstraintCount | 6 | 가로에 보일 자식 UI Entity 개수를 6개로 고정합니다. |
| Spacing | 95, 50 | 카드 사이의 간격을 설정합니다. |

# Model_Card 불러오기

**Model_Card**를 UI_Block_Group에 불러오는 스크립트를 만들어봅시다.

#### CardBoard 컴포넌트

1. **CardBoard** 컴포넌트를 **CardPairGameUI** 그룹에 추가합니다. ![7](https://mod-file.dn.nexoncdn.co.kr/bbs/1674170611269041acb09868d4821a7cb09b910b252e6.png)
2. **CardBoard** 컴포넌트를 선택해 스크립트 에디터를 엽니다.
3. **CardSpawnRoot** 프로퍼티를 추가하고, 반환 타입을 Entity로 변경합니다. ![12](https://mod-file.dn.nexoncdn.co.kr/bbs/1671521982130c05a89c1ff844e5a87c22611a8bd4d0f.png)
4. 엔티티는 **UI_Block_Group**으로 지정합니다. ![11](https://mod-file.dn.nexoncdn.co.kr/bbs/1671522029484e4d94cd892d540c28d9c500c497b2e79.png)```
Property:
[None]
Entity CardSpawnRoot = /ui/CardParirGameUi/UI_Board/UI_Blocks/UI_Block_Group
```
5. Function에서 `CreateCardEntities`함수를 찾습니다. 이 함수는 Model_Card를 소환해 배치하는 역할을 합니다.
6. **Workspace - MyDesk - Models - Model_Card**를 선택하고 콘텍스트 메뉴를 열어 **Copy Entry ID**를 선택합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1671518293286d5743eb04f424a0d9bdb4405962b6230.png)
7. 복사한 모델 ID은 `CreateCardEntities` 함수에서 사용합니다. 아래와 같이 local cardModelId에 복사한 Entry ID를 할당합니다.```
local cardModelId = "Model_Card Entry ID"
```
8. `CreateCardEntities` 함수에서 `SpawnService:SpawnByModelId()`를 사용해 카드 모델을 불러올 위치를 정합니다. 차례대로 모델ID, 이름, 불러올 위치, 불러올 위치의 기준이 되는 parent를 입력해야 합니다. [SpawnService](/apiReference/Services/SpawnService)를 참고하세요.```
Method:
[client only]
void CreateCardEntities()
{
    local cardModelId = "Model_Card EntryID"

    local card = _SpawnService:SpawnByModelId(cardModelId, "Card", Vector3(0,0,0), self.CardSpawnRoot)
    }
```
9. Function에서 새로운 `SetCards` 함수를 찾습니다. 이 함수는 앞으로 카드 배치, 섞기 역할을 담당합니다. 앞에서 만든 `CreateCardEntities` 함수를 호출합니다.```
Method:
[client only]
void SetCards()
{
    self:CreateCardEntities()
}
```

#### CardPairGameLogic 로직

1. **WorkSpace - Logics - CardPairGameLogic** 로직을 선택해 스크립트 에디터 창을 엽니다. `SetCards`를 실행시킬 수 있도록 `StartGame()`에 아래 내용을 추가 작성합니다.```
local cardboard = self.CardPairGameUI.CardBoard
cardboard:SetCards()
```
2. 시작을 눌러 카드 하나가 화면에 나타나는지 확인합니다. ![8](https://mod-file.dn.nexoncdn.co.kr/bbs/1671415272545b3de4b80996643dd8ffa241a870dfaee.png)

# 전체 스크립트

#### CardPairGameLogic

```
Property:
[None]
Entity CardPairGameUI = /ui/CardPairGameUI

Method:
[client only]
void StartGame()
{
    self.CardPairGameUI.Enable = true
    
    local cardboard = self.CardPairGameUI.CardBoard
    cardboard:SetCards()
}

[client only]
void OnBeginPlay()
{
    self:StartGame()
}
```

#### CardBoard

```
Property:
[None]
Entity CardSpawnRoot = /ui/CardParirGameUi/UI_Board/UI_Blocks/UI_Block_Group

Method:
[client only]
void CreateCardEntities()
{
    local cardModelId = "Model_Card EntiryID"
    
    local card = _SpawnService:SpawnByModelId(cardModelId, "Card", Vector3(0,0,0), self.CardSpawnRoot)
}

[client only]
void SetCards()
{
    self:CreateCardEntities()
}
```

Update 2025-11-20 PM 02:03

